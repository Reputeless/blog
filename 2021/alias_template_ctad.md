# ［C++］`std::array`のエイリアステンプレートとCTAD

twitterに密かに置いていた質問箱に次のような質問をいただきました。

```cpp
```

ようするに、`std::array`のテンプレートパラメータの一部だけを束縛したエイリアステンプレートでCTADを期待すると、謎のコンパイルエラーに悩まされています。

エイリアステンプレートのCTADが絡み非常に複雑な問題であり、簡易に回答できなさそうなのでこの記事を書きました。

### エイリアステンプレートのCTADの仕組み

エイリアステンプレートのCTADは、元の型の推論補助からエイリアステンプレートの推論補助を導出し、それを利用することで行われます。

以下では、導出したいエイリアステンプレートの推論補助を`A`、元の型に存在する推論補助を`B`と表します。

1. エイリアステンプレートから推論補助`A`の結果（右辺）を取得し、`A`のテンプレートパラメータを推論する。
      - 推論できないコンテキストが存在しうるため、この時に全てのテンプレートパラメータを推論する必要はない
2. 1で暫定的に得られた`A`の内容を、元の推論補助`B`にフィードバックして置き換える
      - 1で全てのパラメータの推論が出来ていない可能性があるので、ここで得られた推論補助はエイリアステンプレートと`B`それぞれからのテンプレートパラメータを含む可能性がある
3. 結果の型（1で得られた`A`の右辺）からエイリアスを推定し、2で得られた推論補助を書き換えることで、エイリアステンプレートに対する推論補助`A`を生成する
      - 結果の型からエイリアスを推定するか、またどのように推定するかは実際の引数型に依存するため、追加の制約が必要となる場合がある
4. このように導出された`A`は、オーバーロード解決時に導出されたことによる優先順位を与える

次のような型で動作例を見てみます。

```cpp
template<typename A, typename B>
struct pair {
  A a;
  B b;

  my_pair(T arg1, U arg2)
    : a(std::move(arg1)), b(std::move(arg2))
  {}
};

// これは明示的に書かなくても自動で導出される
template<typename A, typename B>
pair(A, B) -> pair<A, B>;

// 今回の例の対象エイリアステンプレート
template<typename T>
using P = pair<int , T>;

int main() {
  P p = {1, 2}; // ok、CTADがエイリアステンプレートに対して行われる
}
```

このコードで、`P`に対する推論補助がどのように導出されるかを先ほどの手順に沿って見ていきます。

#### 1. エイリアステンプレートから推論補助`A`の結果（右辺）を取得し、`A`のテンプレートパラメータを推論する。

#### 2. 1で暫定的に得られた`A`の内容を、元の推論補助`B`にフィードバックして置き換える

#### 3. 結果の型（1で得られた`A`の右辺）からエイリアスを推定し、2で得られた推論補助を書き換えることで、エイリアステンプレートに対する推論補助`A`を生成する



正直4の意味と有効性は理解出来ていないし今回は関係ないはずなのでそこには触れません・・・

### `std::array`のエイリアステンプレートに対するCTADがうまく動かない理由

### 参考文献

- [P1021R4 Filling holes in Class Template Argument Deduction](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1021r4.html)
- [P1814R0 Wording for Class Template Argument Deduction for Alias Templates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1814r0.html)
- [CTAD for alias templates algorithm examples](https://htmlpreview.github.io/?https://github.com/mspertus/CTAD_POST_CPP17/master/CTAD_alias_examples.html)