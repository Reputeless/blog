# ［C++］コンセプトの無言のお願い事

[http://eel.is/c++draft/concepts.equality]
主にここに書いてあることを訳しただけの記事です。

### 等しさの保持（*equality preservation*）

ある式が等しい入力に対して等しい出力を返すとき、その式は **等しさを保持（*equality-preserving*）** しています。式とはわかりやすいところでは関数であり、演算子のことです。ある式を`f()`とすると`a == b`ならば`f(a) == f(b)`となり、かつ常にこれが成り立つ時、`f()`は等しさを保持する式ということです。

この場合の入力とは、その式に直接与えられた引数全ての集合のことであり、引数とは1つの式のことです。正確には以下のものだけを含む一番大きな部分式のことです。

- id-expression（一次式）
- `std::move(), std::forward(), std::declval()`の呼び出し

例えば、`f(std::move(a), std::declval<T>(), c)`みたいなコードでは、まずこの全体が1つの式です。この式の部分式とは`std::move(a), a, std::declval<T>(), c`で、上記2つだけを含む最大の部分式=入力は、`std::move(a), std::declval<T>(), c`の3つです。  
別の例では、`a = std::move(b)`と言う式の入力は`a, std::move(b)`の2つです。

式は最終的に結果となる1つの値になるので、等しさを保持する式の入力（の式）というのはつまりある1つの引数値と言う事です。

そして、出力とは式の結果（上記の`f()`ならその戻り値）および、その式の実行によって変更された引数の集合です（変更されなかった引数は含まれない）。

等しさを保持する式の入力と出力はこれら以外にあってはいけません。

#### 安定（*stable*）

等しさを保持する式はさらに安定であることが要求されます。

あるオブジェクトを入力（引数）にとるある式の2回の評価において、そのオブジェクトの明示的な変更が介在しない限り等しい出力が得られる時、その式は **安定（*stable*）** な式です。

つまり、等しさを保持し安定である式は内部や外部の状態に依存してはならず、直接の引数以外に対して副作用を持ってはならないと言う事です。

そして、標準ライブラリにおけるコンセプト定義内の全ての制約式は、特に注釈がない限り等しさを保持し安定でなければなりません。これは、そのコンセプトを満たそうとする場合にユーザーコードに対しても要求されます。

#### 定義域（*domain*）

等しさを保持する式はその入力となりうる全ての式について有効である必要はありません。例えば、整数に対する`a / b`と言う式は明らかに等しさを保持していますが、`b == 0`の時この式は有効ではありません。  
しかし、この様な入力を取り得たとしても、このことはその式が等しさを保持することに影響を与えません。

ある等しさを保持する式の入力の全体から、この様な有効ではない入力を除いた集合をその式の **定義域（*domain*）** と呼びます。

この用語はコンセプトの意味論的な制約条件に出現することがあります（例えば、[std::
equality_comparable_with](https://cpprefjp.github.io/reference/concepts/equality_comparable.html)など）。
 

### 制約式の引数に対しての制約

### 暗黙的な式のバリエーション（*implicit expression variations*）

### コンセプトのモデルとなるために

### 参考文献

- [18.2 Equality preservation [concepts.equality]](http://eel.is/c++draft/concepts.equality)
- [`<concepts>` - cpprefjp](https://cpprefjp.github.io/reference/concepts.html)
- [P2102R0 Make “implicit expression variations” more explicit (Wording for US185)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2102r0.html)
