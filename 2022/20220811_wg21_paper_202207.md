# ［C++］WG21月次提案文書を眺める（2022年07月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2022-07](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/#mailing2022-07)

全部で47本あります。

[:contents]

### [P0009R18 MDSPAN](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0009r18.html)

多次元配列に対する`std::span`である、`mdspan`の提案。

以前の記事を参照

- [P0009R12 MDSPAN - WG21月次提案文書を眺める（2021年05月）](https://onihusube.hatenablog.com/entry/2021/06/13/165215#P0009R12-MDSPAN)
- [P0009R13 MDSPAN - WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P0009R13-MDSPAN)
- [P0009R14 MDSPAN - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P0009R14-MDSPAN)
- [P0009R15 MDSPAN - WG21月次提案文書を眺める（2022年02月）](https://onihusube.hatenablog.com/entry/2022/03/19/224729#P0009R15-MDSPAN)
- [P0009R16 MDSPAN - WG21月次提案文書を眺める（2022年03月）](https://onihusube.hatenablog.com/entry/2022/04/02/175835#P0009R16-MDSPAN)
- [P0009R17 MDSPAN - WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P0009R17-MDSPAN)

このリビジョンでの変更は、LWGのフィードバックを受けての文言調整のみです。

この提案は今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P0009 進行状況](https://github.com/cplusplus/papers/issues/96)

### [P1018R17 C++ Language Evolution status 🦠 pandemic edition 🦠 2022/06–2022/07](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1018r17.html)

2022年6月から7月にかけてのEWG活動報告書。

投票にかけられた提案は以下のものです

- [P2513R2 char8_t Compatibility and Portability Fixes](https://wg21.link/P2513R2)
- [P1854R3 Conversion to literal encoding should not lead to loss of meaning](https://wg21.link/P1854R3)

そのほかにも、いくつかのコア言語IssueがCWGに転送されています。

### [P1083R6 Move `resource_adaptor` from Library TS to the C++ WP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1083r6.pdf)

`pmr::resource_adaptor`をLibrary Foundermental TSからワーキングドラフトへ移動する提案。

以前の記事を参照

- [P1083R4 Move `resource_adaptor` from Library TS to the C++ WP - WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P1083R4-Move-resource_adaptor-from-Library-TS-to-the-C-WP)
- [P1083R5 Move `resource_adaptor` from Library TS to the C++ WP - WG21月次提案文書を眺める（2022年03月）](https://onihusube.hatenablog.com/entry/2022/04/02/175835#P1083R5-Move-resource_adaptor-from-Library-TS-to-the-C-WP)

このリビジョンでの変更は

- `max_align_v`（最大アライメントサイズを表す定数）を`inline constexpr`変数として定義
- `aligned_raw_storage`の入れ子型`::type`を削除
- `aligned_raw_storage`は`std::aligned_storage`の完全な代替ではないことを明確化
- この提案には必須ではなかったため、`aligned_object_storage`を削除
- C++26ターゲットへ変更

などです。

- [P1083 進行状況](https://github.com/cplusplus/papers/issues/33)

### [P1255R8 A view of 0 or 1 elements: views::maybe](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1255r8.pdf)

`std::optional`やポインタ等のmaybeモナドな対象を、その状態によって要素数0か1のシーケンスに変換するRangeアダプタ`views::maybe`の提案。

以前の記事を参照

- [P1255R6 : A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2020年04月）](https://onihusube.hatenablog.com/entry/2020/05/01/194425#P1255R6--A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R7 : A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P1255R7-A-view-of-0-or-1-elements-viewsmaybe)

このリビジョンでの変更はタイポ修正や見た目の調整のみです。

- [P1255 進行状況](https://github.com/cplusplus/papers/issues/60)

### [P1642R11 Freestanding Library: Easy [utilities], [ranges], and [iterators]](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1642r11.html)

[[utility]](https://timsong-cpp.github.io/cppwp/n4861/#utilities)、`<ranges>`、`<iterator>`から一部のものをフリースタンディングライブラリに追加する提案。

前回の記事を参照

- [P1642R3 Freestanding Library: Easy [utilities], [ranges], and [iterators] - ［C++］WG21月次提案文書を眺める（2020年6月）](https://onihusube.hatenablog.com/entry/2020/07/05/003248#P1642R3--Freestanding-Library-Easy-utilities-ranges-and-iterators)
- [P1642R4 Freestanding Library: Easy [utilities], [ranges], and [iterators] - ［C++］WG21月次提案文書を眺める（2020年7月）](https://onihusube.hatenablog.com/entry/2020/08/12/014639#P1642R4--Freestanding-Library-Easy-utilities-ranges-and-iterators)
- [P1642R5 Freestanding Library: Easy [utilities], [ranges], and [iterators] - ［C++］WG21月次提案文書を眺める（2020年12月）](https://onihusube.hatenablog.com/entry/2021/01/17/005823#P1642R5-Freestanding-Library-Easy-utilities-ranges-and-iterators)
- [P1642R6 Freestanding Library: Easy [utilities], [ranges], and [iterators] - ［C++］WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P1642R6-Freestanding-Library-Easy-utilities-ranges-and-iterators)
- [P1642R7 Freestanding Library: Easy [utilities], [ranges], and [iterators] - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P1642R7-Freestanding-Library-Easy-utilities-ranges-and-iterators)
- [P1642R8 Freestanding Library: Easy [utilities], [ranges], and [iterators] - ［C++］WG21月次提案文書を眺める（2022年04月）](https://onihusube.hatenablog.com/entry/2022/05/08/195618#P1642R8-Freestanding-Library-Easy-utilities-ranges-and-iterators)
- [P1642R9 Freestanding Library: Easy [utilities], [ranges], and [iterators] - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P1642R9-Freestanding-Library-Easy-utilities-ranges-and-iterators)
- [P1642R10 Freestanding Library: Easy [utilities], [ranges], and [iterators] - ［C++］WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1642R10-Freestanding-Library-Easy-utilities-ranges-and-iterators)

このリビジョンでの変更は、提案する文言の調整のみです。

この提案は今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P1642 進行状況](https://github.com/cplusplus/papers/issues/429)


### [P1684R3 `mdarray`: An Owning Multidimensional Array Analog of mdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1684r3.html)

多次元配列クラス`mdarray`の提案。

- [P1684R1 mdarray: An Owning Multidimensional Array Analog of mdspan - ［C++］WG21月次提案文書を眺める（2022年03月）](https://onihusube.hatenablog.com/entry/2022/04/02/175835#P1684R1-mdarray-An-Owning-Multidimensional-Array-Analog-of-mdspan)
- [P1684R2   mdarray: An Owning Multidimensional Array Analog of mdspan - ［C++］WG21月次提案文書を眺める（2022年04月）](https://onihusube.hatenablog.com/entry/2022/05/08/195618#P1684R2-mdarray-An-Owning-Multidimensional-Array-Analog-of-mdspan)

このリビジョンでの変更は

- `std::mdspan`に適用された提案をこちらにも適用した
    - [P2554](https://wg21.link/P2554), [P2553](https://wg21.link/P2553), [P2599](https://wg21.link/P2599), [P2406](https://wg21.link/P2406)
- *size constructible container*という要件を新設
    - 整数（もしくは`range/initilizer_list`）からの構築によって、構築後のサイズを指定できるコンテナ
- `std::mdspan`からの構築のための推論補助を追加
- `range/initilizer_list`からのコンストラクタを削除
- 文言の解説を更新

などです。

- [P1684 進行状況](https://github.com/cplusplus/papers/issues/461)

### [P1899R3 `stride_view`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1899r3.html)

範囲を等間隔の要素からなる範囲に変換するRangeアダプタ`stride_view`の提案。

以前の記事を参照

- [P1899R1 `stride_view` - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P1899R1-stride_view)
- [P1899R2 `stride_view` - ［C++］WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P1899R2-stride_view)

このリビジョンでの変更は、LWGのフィードバックを受けての文言の修正と、`stride_view`のデフォルトコンストラクタを削除した事です。

この提案は今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P1899 進行状況](https://github.com/cplusplus/papers/issues/647)

### [P1967R8 `#embed` - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1967r8.html)

コンパイル時（プリプロセス時）にバイナリデータをインクルードするためのプリプロセッシングディレクティブ`#embed`の提案。

以前の記事を参照

- [P1967R3 `#embed` - a simple, scannable preprocessor-based resource acquisition method - ［C++］WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P1967R3-embed---a-simple-scannable-preprocessor-based-resource-acquisition-method)
- [P1967R4 `#embed` - a simple, scannable preprocessor-based resource acquisition method - ［C++］WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P1967R4-embed---a-simple-scannable-preprocessor-based-resource-acquisition-method)
- [P1967R5 `#embed` - a simple, scannable preprocessor-based resource acquisition method - ［C++］WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2022/05/08/195618#P1967R5-embed---a-simple-scannable-preprocessor-based-resource-acquisition-method)
- [P1967R6 `#embed` - a simple, scannable preprocessor-based resource acquisition method - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P1967R6-embed---a-simple-scannable-preprocessor-based-resource-acquisition-method)
- [P1967R7 `#embed` - a simple, scannable preprocessor-based resource acquisition method - ［C++］WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1967R7-embed---a-simple-scannable-preprocessor-based-resource-acquisition-method)

このリビジョンでの変更は

- C++の提案から`limit/suffix/prefix`に対する`__`を削除
- 2022/6月のミーティングの議論とその反応を追記
- `limit(0)`を使用した`if_empty`の例を追加
- ファイルが空であることを検知する二つの方法（`__has_embed`と`suffix/prefix/if_empty`）の違いについての説明の追加

などです。

この提案のC言語向けの部分はC23入りしましたが、C++ではまだEWGで議論中であるためもう少し時間がかかりそうです。

- [finally. `#embed` | The Pasture](https://thephd.dev/finally-embed-in-c23)
- [次期C標準 (C23) の内容が固まったらしい - Zenn](https://zenn.dev/mod_poppo/articles/next-c-language)
- [P1967 進行状況](https://github.com/cplusplus/papers/issues/700)

### [P2047R3 An allocator-aware optional type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2047r3.html)

*Allocator Aware*な`std::optional`である、`std::pmr::optional`を追加する提案。

- [P2047R1 An allocator-aware optional type - ［C++］WG21月次提案文書を眺める（2021年02月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P2047R1-An-allocator-aware-optional-type)
- [P2047R2 An allocator-aware optional type - ［C++］WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2047R2-An-allocator-aware-optional-type)

このリビジョンでの変更は、提案する文言の改善と、`pmr::basic_optional`（アロケータの一般化）の方向性についての説明を拡充したことです。

この提案ではまだ`pmr::basic_optional`を含んではいませんが、LEWGのレビューではその方向性を採用することで合意されているようです。

- [P2047 進行状況](https://github.com/cplusplus/papers/issues/777)

### [P2079R3 System execution context](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2079r3.html)

ハードウェアの提供するコア数（スレッド数）に合わせた固定サイズのスレッドプールを提供する*Scheduler*の提案。

- [P2079R1 Parallel Executor - ［C++］WG21月次提案文書を眺める（2020年8月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P1899R1-stride_view)
- [P2079R2 System execution context - ［C++］WG21月次提案文書を眺める（2022年1月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2079R2-System-execution-context)

このリビジョンでの変更は

- `execute_all`と`execute_chunk`を削除
    - 処理をメインスレッドでそのまま実行することができるようにするために、コンパイル時のカスタマイズを許可するようにするように文言を調整
    - （この2つの関数はそれを妨げていた）
- カスタマイズのためのアプローチと、実行コンテキストを実装定義とする範囲についての議論の追加
- `system_context`クラスの設計についての議論の追加
- 処理の優先度に関する設計の議論を追加

などです。

- [P2079 進行状況](https://github.com/cplusplus/papers/issues/806)

### [P2165R4 Compatibility between `tuple`, `pair` and `tuple-like` objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)

`std::pair`と2要素`std::tuple`及び`tuple-like`な型の間の非互換を減らし比較や代入をできるようにする提案。

前回の記事を参照

- [P2165R0 Compatibility between tuple and tuple-like objects - ［C++］WG21月次提案文書を眺める（2020年05月）](https://onihusube.hatenablog.com/entry/2020/06/01/001003#P2165R0--Comparing-pair-and-tuples)
- [P2165R1 Compatibility between tuple and tuple-like objects - ［C++］WG21月次提案文書を眺める（2020年07月）](https://onihusube.hatenablog.com/entry/2020/08/12/014639#P2165R1--Compatibility-between-tuple-and-tuple-like-objects)
- [P2165R2 Compatibility between tuple and tuple-like objects - ［C++］WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P2165R2-Compatibility-between-tuple-pair-and-tuple-like-objects)
- [P2165R3 Compatibility between tuple and tuple-like objects - ［C++］WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2165R3-Compatibility-between-tuple-pair-and-tuple-like-objects)

このリビジョンでの変更はLWGのレビューからのフィードバックを受けての修正がメインです。変更は1.5ページ分あるので転載はしませんが、大きな設計の変更はないはずです。

この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2165 進行状況](https://github.com/cplusplus/papers/issues/876)
- 
### [P2248R5 Enabling list-initialization for algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2248r5.html)

値を指定するタイプの標準アルゴリズムにおいて、その際の型指定を省略できるようにする提案。

以前の記事を参照

- [P2248R0 Enabling list-initialization for algorithms - ［C++］WG21月次提案文書を眺める（2020年11月）](https://onihusube.hatenablog.com/entry/2020/12/06/015108#P2248R0-Enabling-list-initialization-for-algorithms)
- [P2248R1 Enabling list-initialization for algorithms - ［C++］WG21月次提案文書を眺める（2020年12月）](https://onihusube.hatenablog.com/entry/2021/01/17/005823#P2248R1-Enabling-list-initialization-for-algorithms)
- [P2248R2 Enabling list-initialization for algorithms - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2248R2-Enabling-list-initialization-for-algorithms)
- [P2248R3 Enabling list-initialization for algorithms - ［C++］WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2248R3-Enabling-list-initialization-for-algorithms)
- [P2248R4 Enabling list-initialization for algorithms - ［C++］WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2248R4-Enabling-list-initialization-for-algorithms)

このリビジョンでの変更は

- LEWGフィードバックを受けての修正
- `projected_value`を`projected_value_t`にリネーム
- `projected_value_t`と[P2609RO](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2609r0.html)との関連について追記
- `ranges::fold()`と`ranges::contains()`を含めた
- 実装経験にHPXライブラリを追記

- [P2248 進行状況](https://github.com/cplusplus/papers/issues/944)

### [P2295R6 Support for UTF-8 as a portable source file encoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2295r6.pdf)

C++コンパイラが少なくともUTF-8をサポートするようにする提案。

以前の記事を参照

- [P2295R0 Correct UTF-8 handling during phase 1 of translation - WG21月次提案文書を眺める（2021年02月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P2295R0-Correct-UTF-8-handling-during-phase-1-of-translation)
- [P2295R3 Support for UTF-8 as a portable source file encoding - WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P2295R3-Support-for-UTF-8-as-a-portable-source-file-encoding)
- [P2295R4 Support for UTF-8 as a portable source file encoding - WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P2295R4-Support-for-UTF-8-as-a-portable-source-file-encoding)
- [P2295R5 Support for UTF-8 as a portable source file encoding - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2295R5-Support-for-UTF-8-as-a-portable-source-file-encoding)

このリビジョンでの変更は、提案する文言の調整のみです。

この提案は今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2295 進行状況](https://github.com/cplusplus/papers/issues/985)

### [P2361R5 Unevaluated strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2361r5.pdf)

コンパイル時にのみ使用され、実行時まで残らない文字列リテラルについての扱いを明確化する提案。

以前の記事を参照

- [P2361R0 Unevaluated string literals - ［C++］WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P2361R0-Unevaluated-string-literals)
- [P2361R1 Unevaluated string literals - ［C++］WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P2361R1-Unevaluated-string-literals)
- [P2361R2 Unevaluated strings - ［C++］WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2361R2-Unevaluated-strings)
- [P2361R3 Unevaluated strings - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2361R3-Unevaluated-strings)
- [P2361R4 Unevaluated strings - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P2361R4-Unevaluated-strings)

このリビジョンでの変更は、`asm`宣言の文法を実態に合わせた*balanced-token-seq*を受け取るように変更したことなどです。

本来の`asm`宣言はそのオペランドに文字列リテラルのみを取っていたためこの提案の対象となっていましたが、実際の実装では文字列リテラル以上の構文を受理するものがあったため、それを許可するようにする変更がこの提案に含まれることになりました。この変更はこの提案の内容とは直接関係なく、要するにGCCのインラインアセンブラの記法を受け入れるようにするものです。

- [GCCのインラインアセンブラの書き方 for x86 - OSのようなもの](https://wocota.hatenadiary.org/entry/20090628/1246188338)
- [P2361 進行状況](https://github.com/cplusplus/papers/issues/1035)

### [P2374R4 `views::cartesian_product`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2374r4.html)

任意個数のシーケンスの直積を取って、その元のシーケンスを生成する`cartesian_product_view`の提案。

以前の記事を参照

- [P2374R1 views::cartesian_product - WG21月次提案文書を眺める（2021年05月）](https://onihusube.hatenablog.com/entry/2021/06/13/165215#P2374R1-viewscartesian_product)
- [P2374R3 views::cartesian_product - WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2374R3-viewscartesian_product)

このリビジョンでの変更は、LWGのレビューを受けての修正です。修正項目は多岐に渡りますが、大きな設計の変更はないはずです。

この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2374 進行状況](https://github.com/cplusplus/papers/issues/1044)

### [P2404R3 Move-only types for `equality_comparable_with`, `totally_ordered_with`, and `three_way_comparable_with`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2404r3.pdf)

各種異種比較を定義するコンセプトの`common_reference`要件を緩和する提案。

以前の記事を参照

- [P2404R0 Relaxing equality_comparable_with's and three_way_comparable_with's common reference requirements to - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2404R0-Relaxing-equality_comparable_withs-and-three_way_comparable_withs-common-reference-requirements-to)
- [P2404R2 Relaxing equality_comparable_with's and three_way_comparable_with's common reference requirements to - WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2404R2-Move-only-types-for-equality_comparable_with-totally_ordered_with-and-three_way_comparable_with)

このリビジョンでの変更は

- この提案の破壊的影響についてAnnex Cセクションを追加
- 文言の簡素化のため、3つのコンセプトの意味論要件のために新しいタイプの左辺値（*lvalues denoting distinct equal objects*）を導入
    - 型を維持してムーブすることができる左辺値
- `CONVERT_TO_LVALUE<C>(E)`を`COMMON`にリネーム。
    - 型情報を含み省略を避けることで、よりわかりやすくした
- 説明専用コンセプトの文言の調整
- 専用の機能テストマクロの追加

などです。


この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています。  

- [P2404 進行状況](https://github.com/cplusplus/papers/issues/1074)

### [P2417R2 A more constexpr bitset](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2417r2.pdf)

[`std::bitset`](https://cpprefjp.github.io/reference/bitset/bitset.html)を`constexpr`対応させる提案。

以前の記事を参照

- [P2408R0 Ranges views as inputs to non-Ranges algorithms - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2417R0-A-more-constexpr-bitset)
- [P2408R1 Ranges views as inputs to non-Ranges algorithms - WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2417R1-A-more-constexpr-bitset)

このリビジョンでの変更は、LWGのフィードバックを受けての文言修正のみです。

この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2417 進行状況](https://github.com/cplusplus/papers/issues/1087)

### [P2419R2 Clarify handling of encodings in localized formatting of chrono types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2419r2.html)

`<chrono>`のフォーマットにおいて、実行時ロケールが指定するエンコーディングとリテラルエンコーディングが異なる場合の振る舞いを規定する提案。

以前の記事を参照

- [P2419R0 Clarify handling of encodings in localized formatting of chrono types - WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2419R0-Clarify-handling-of-encodings-in-localized-formatting-of-chrono-types)
- [P2419R1 Clarify handling of encodings in localized formatting of chrono types - WG21月次提案文書を眺める（2021年09月）](https://onihusube.hatenablog.com/entry/2021/10/03/193523#P2419R1-Clarify-handling-of-encodings-in-localized-formatting-of-chrono-types)

このリビジョンでの変更は、LWGのフィードバックを受けての文言修正のみです。

この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2419 進行状況](https://github.com/cplusplus/papers/issues/1093)

### [P2460R2 Relax requirements on wchar_t to match existing practices](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2460r2.pdf)

`wchar_t`のエンコーディングについての実態になじまない制約を取り除く提案。

- [P2460R0 Relax requirements on `wchar_t` to match existing practices - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2460R0-Relax-requirements-on-wchar_t-to-match-existing-practices)
- [P2460R1 Relax requirements on `wchar_t` to match existing practices - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P2460R1-Relax-requirements-on-wchar_t-to-match-existing-practices)

このリビジョンでの変更は、提案する文言の調整のみです。

この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2460 進行状況](https://github.com/cplusplus/papers/issues/1122)

### [P2474R2 `views::repeat`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2474r2.html)

指定された値の繰り返しによる範囲を生成するRangeファクトリである、`views::repeat`の提案。

以前の記事を参照

- [P2474R0 `views::repeat` - WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2474R0-viewsrepeat)
- [P2474R1 `views::repeat` - WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2474R1-viewsrepeat)

このリビジョンでの変更は

- タイポやフォーマットの修正
- `iterator{...}`を`iterator(...)`に置き換え（丸かっこ初期化を使うようにした）
- `iterator`の入れ子型`reference`を削除
- プライベートメンバ`W*, Bound`の初期化をコンストラクタからデフォルトメンバ初期化子に移動し、説明専用とした
- `iterator`の`_value`を`nullptr`に初期化する際、デフォルト初期化するようにした
- `iterator`の`deference_type`を定義
- `repeat_view`とそのイテレータのコンストラクタ、およびイテレータを変更しうる一部の操作に、`bound`が空でないとう事前条件を追加
- `repeat_view`の代わりに`views::repeat`を使用することで、`repeat_view`の`views::take, views::drop`特殊化の使用を簡素化
- `default_sentinel_t`を取るオーバーロードを`noexcept`にした

などです。

この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2474 進行状況](https://github.com/cplusplus/papers/issues/1155)

### [P2481R1 Forwarding reference to specific type/template](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2481r1.html)

テンプレートパラメータ指定時に`const`と値カテゴリを推論可能にする構文の必要性について説明した文書。

- [P2481R0 Forwarding reference to specific type/template - WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2481R0-Forwarding-reference-to-specific-typetemplate)

このリビジョンでの変更は、Circleのアプローチについて追記した事です。

Circleとは、C++の構文を拡張してメタプログラミングのために便利な構文を追加したある種のプログラミング言語（とそのコンパイラ）です。

Circleでは、この提案の解決したい問題について次のような構文を追加しています。

```cpp
template<typename T, typename... Args>
void f(T&& y : std::tuple<Args...>);
```

これは通常のテンプレートと同様に任意の型を`const`と参照修飾まで含めて推論しつつその素の型を`:`の後にある型に制限する構文です。

これはこの提案の案の1つである`Q`修飾子による指定と推論とほぼ同じことをしています。

<table>
<tr>
<th>`Q`修飾子</th>
<th>Circle</th>
</tr>
<tr>
<td valign="top">

```cpp
template <typename... Ts>
struct tuple {
  template <typename... Us, qualifiers Q>
    requires sizeof...(Us) == sizeof...(Ts)
          && (constructible_from<Ts, Q<Us>> && ...)
  tuple(Q<tuple<Us...>> rhs);
};
```

</td>
<td valign="top">

```cpp
template <typename... Ts>
struct tuple {
  template <typename... Us, typename Rhs>
    requires sizeof...(Us) == sizeof...(Ts)
          && (constructible_from<Ts, copy_cvref_t<Rhs, Us>> && ...)
  tuple(Rhs&& rhs : tuple<Us...>);
};
```

</pre>
</td>
</tr>
</table>

<table>
<tr>
<th>`Q`修飾子</th>
<th>Circle</th>
</tr>
<tr>
<td valign="top">

```cpp
template <typename D>
struct view_interface {
  template <qualifiers Q>
    requires forward_range<Q<D>>
  constexpr bool empty(this Q<D>& self)
  {
    return ranges::begin(self) == ranges::end(self);
  }
};
```

</td>
<td valign="top">

```cpp
template <typename D>
struct view_interface {
  template <class Self>
    requires forward_range<Self>
  constexpr bool empty(this Self& self : D)
  {
    return ranges::begin(self) == ranges::end(self);
  }
};
```

</pre>
</td>
</tr>
</table>

`Q`修飾子と比較して、Circleのアプローチでは推論された修飾子の伝播に追加の作業が必要となりますが、それはかなり軽微です。

このアプローチの欠点は、`Q`同様に構文と振る舞いが奇妙であることと、将来的にC++の宣言構文を改善しようとしたときにこれが導入されているとそれを妨げてしまう点です。

この文書はまだ提案に至っておらず、引き続き構文候補を募集しています。

- [P2481 進行状況](https://github.com/cplusplus/papers/issues/1137)

### [P2494R2 Relaxing range adaptors to allow for move only types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2494r2.html)

何かを保持する必要があるタイプの`view`型について、保持するものの型に対する要件を`copy_constructible`から`move_constructible`に弱める提案。

以前の記事を参照

- [P2494R0 Relaxing range adaptors to allow for move only types - WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2494R0-Relaxing-range-adaptors-to-allow-for-move-only-types)
- [P2494R1 Relaxing range adaptors to allow for move only types - WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2494R1-Relaxing-range-adaptors-to-allow-for-move-only-types)

このリビジョンでの変更はよくわかりません、多分文言の軽微な修正のみです。

この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2474 進行状況](https://github.com/cplusplus/papers/issues/1156)

### [P2513R4 `char8_t` Compatibility and Portability Fix](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2513r4.html)

`char8_t`の非互換性を緩和する提案。

以前の記事を参照

- [P2513R0 `char8_t` Compatibility and Portability Fixes - WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2513R0-char8_t-Compatibility-and-Portability-Fixes)
- [P2513R1 `char8_t` Compatibility and Portability Fixes - WG21月次提案文書を眺める（2022年02月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2513R0-char8_t-Compatibility-and-Portability-Fixes)
- [P2513R2 `char8_t` Compatibility and Portability Fixes - WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P2513R2-char8_t-Compatibility-and-Portability-Fix)
- [P2513R3 `char8_t` Compatibility and Portability Fixes - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P2513R3-char8_t-Compatibility-and-Portability-Fix)

このリビジョンでの変更はよくわかりません。

この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています（正確にはC++20へのDR）。

- [P2513 進行状況](https://github.com/cplusplus/papers/issues/1171)

### [P2547R1 Language support for customisable functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2547r1.html)

カスタマイゼーションポイントの言語サポートの提案。

以前の記事を参照

- [P2547R0 Language support for customisable functions - WG21月次提案文書を眺める（2022年02月）](https://onihusube.hatenablog.com/entry/2022/03/19/224729#P2547R0-Language-support-for-customisable-functions)

このリビジョンでの変更は

- `virtual`と`= 0;`の代わりにコンテキスト依存のキーワード`customisable`を使用するようにした
- デフォルトの実装は`customisable`関数の宣言と同時に定義できなくなった
    - 関数仮引数の処理とテンプレート実引数の処理は互いにかなり異なり、同居させると混乱を招くため
- オーバーライドできない関数に注釈をつけるための`final`のサポート
- カスタマイズ可能な関数のオーバーロード解決を変更して、*Customisable Function Prototype*（CFP）自体の名前空間及び関連エンティティを常に考慮するようにした
    - これによって、ジェネリックなオーバーライド（特定の型ではなくコンセプトに対するカスタマイズ）を確実に見つかる場所で定義可能となる
    - また、テンプレートな`customisable`関数のオーバーライドを、CFOへの明示的な型のテンプレート実引数の名前空間で発見できる
- テンプレートな`customisable`関数とジェネリックな`customisable`関数の例を追加
- 用語の一貫性の向上
    - CPOの代わりにカスタマイズ可能な関数（*customisable functions*）とCFOを使用する


このリビジョンによる変更によって、以前の例は次のように変更されます

```cpp
namespace std::execution {
  // execution::connect CFPの宣言
  template<sender S, receiver R>
  operation_state auto connect(S s, R r) customisable;
}
```

```cpp
namespace std::ranges {
  // std::ranges::contains CFPの宣言
  template<input_range R, typename Value>
    requires equality_comparable_with<range_reference_t<R>, Value>
  bool contains(R range, Value v) customisable;

  // std::ranges::contains CFPのデフォルト実装
  template<input_range R, typename Value>
    requires equality_comparable_with<range_reference_t<R>, Value>
  bool contains(R&& range, const Value& v) default {
    for (const auto& x : range) {
      if (x == v) return true;
    }
    return false;
  }
}
```

```cpp
namespace std {
  template<class Key, class Compare, class Allocator>
  class set {
  
  // ...

  private:
  
    // std::ranges::contains CFPのHidden friendsによるカスタマイズ
    template<typename V>
      requires requires(const set& s, const V& v) { s.contains(v); }
    friend bool ranges::contains(const set& s, const V& v) override {
      return s.contains(v);
    }
  };
}
```

```cpp
namespace std {
  template<class Key, class Hash, class KeyEq, class Allocator>
  class unordered_set { ... };

  // std::ranges::contains CFPのクラス定義外でのカスタマイズ
  template<class Key, class Hash, class Eq, class Allocator, class Value>
    requires(const unordered_set<Key,Hash,Eq, Allocator>& s, const Value& v) {
      s.contains(v);
    }
  bool ranges::contains(const unordered_set<Key,Hash,Eq,Allocator>& s,
                        const Value& v) override {
    return s.contains(v);
  }
}
```

`final`の使用例

```cpp
namespace std {
  // 型指定get()
  template<typename T, typename Obj>
  auto get(Obj&& obj) customisable; // (1)

  // インデックス指定get()
  template<size_t N, typename Obj>
  auto get(Obj&& obj) customisable; // (2)

  // インデックスを引数によって指定する非テンプレートのget()
  template<size_t N, typename Obj>
    requires (Obj&& obj) {
      get<N>(std::forward<Obj>(obj));
    }
  auto get(Obj&& obj, std::integral_constant<size_t, N>) final -> decltype(auto) {
    return get<N>(std::forward<Obj>(obj));
  }
}

struct my_tuple {
  int x;
  float y;

  // (1)をカスタマイズ
  friend int&   std::get<int>(my_tuple& self) noexcept override { return self.x; }
  friend float& std::get<float>(my_tuple& self) noexcept override { return self.y; }

  // (2)をカスタマイズ
  friend int&   std::get<0>(my_tuple& self) noexcept override { return self.x; }
  friend float& std::get<1>(my_tuple& self) noexcept override { return self.y; }
};
```

上記例の使用例

```cpp
void example() {
  my_tuple t = {42, 0.0f};
  
  int& x1 = std::get<0>(t);
  float& y1 = std::get<1>(t);

  int& x2 = std::get<int>(t);
  float& y2 = std::get<float>(t);
  
  int& x3 = std::get(t, std::integral_constant<std::size_t, 0>{});
  float& y3 = std::get(t, std::integral_constant<std::size_t, 1>{});
}
```

CFOの明示的な引数の推論例（上記の`get`を使用している）

```cpp
template<typename T, std::size_t N>
struct array {
  T data[N];
  
  // 関数テンプレートの仮引数からCFOの明示的なテンプレート引数（インデックスN）を推定する
  template<std::size_t Idx>
    requires (Idx < N)
  friend T& std::get<Idx>(array& self) noexcept override { 
    return self.data[Idx];
  }
};

template<typename First, typename Second>
struct pair {
  First first;
  Second second;
  
  // クラステンプレートの仮引数からCFOの明示的なテンプレート引数（型T）を推定する
  friend First& std::get<First>(pair& self) noexcept override
        requires (!std::same_as<First, Second>)
  {
    return self.first;
  }

  // ...
};
```

- [P2547 進行状況](https://github.com/cplusplus/papers/issues/1208)

### [P2548R0 `copyable_function`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2548r0.pdf)

`std::move_only_function`に対して、コピー可能な*Callable*ラッパである`copyable_function`の提案。

C++23で導入された`std::move_only_function`は、その関数シグネチャに`const`/参照修飾と`noexcept`を指定することができ、呼び出し時に自信の`const`性と値カテゴリを保持する*Callable*オブジェクトまで伝播させたうえで呼び出しを行うことができます。これによって、`std::move_only_function`オブジェクトの`const`有無と右辺値であるかの状態と、保持する*Callbale*オブジェクトの呼び出し環境を一致させることができます。

一方`std::function`にはそのようなサポートはなく、そのために`const`修飾のミスマッチバグ等の設計上の問題がいくつか指摘されていました。

- `const`修飾を正しく扱えない
- ムーブのみ可能な（コピーできない）*Callable*オブジェクトを保持できない
- 左辺値から呼び出す*Callable*オブジェクトしか保持できない（参照修飾を正しく扱えない）

`std::move_only_function`は`std::fucntion`の持つこれらの問題と軽微ないくつかの問題（RTTIへの依存、呼び出し時の空チェック）を解決するために導入されましたが、名前が示すとおりに`std::move_only_function`のオブジェクトはムーブしかできません（ムーブしかできない*Callable*だけを保持可能なわけではありません）。

コピー可能な`std::move_only_function`が欲しい場合は`std::function`を使用するしかないのですが、`std::function`には上記のような問題があります。また、後方互換のためには、`std::function`を`std::move_only_function`のような設計に変更することもできません。

この提案は、コピー可能かつ現在の`std::function`の問題を解決した、`std::move_only_function`のコピー可能なバージョンである`std::copyable_function`を標準ライブラリに追加する提案です。

`std::move_only_function`が保持する*Callable*は`copyable`であっても単に`movable`でしかなくても大丈夫ですが、`std::copyable_function`は`copyable`な*Callable*しか保持できません。それ以外のところでは、`std::move_only_function`にコピーコンストラクタとコピー代入演算子を追加しただけです。

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
auto lambda{[&]() /*const*/ { … }};

function<void(void)> func{lambda};  // ✔
const auto & ref{func};

func(); // ✔
ref();  // ✔
```

</td>
<td valign="top">

```cpp
auto lambda{[&]() /*const*/ { … }};

copyable_function<void(void)> func0{lambda};    // ✔
const auto & ref0{func0};

func0();  // ✔
ref0();   // ❌ operator() is NOT const! 

copyable_function<void(void) const> func1{lambda};  // ✔
const auto & ref1{func1};

func1();  // ✔
ref1();   // ✔ operator() is const! 
```

</pre>
</td>
</tr>
</table>

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
auto lambda{[&]() mutable { … }};

function<void(void)> func{lambda};  // ✔
const auto & ref{func};

func(); // ✔
ref();  // ⁉✔ operator() is const! 
        //     this is the infamous constness-bug
```

</td>
<td valign="top">

```cpp
auto lambda{[&]() mutable { … }};

copyable_function<void(void)> func{lambda}; // ✔
const auto & ref{func};

func(); // ✔
ref();  // ❌ operator() is NOT const! 

copyable_function<void(void) const> tmp{lambda};  // ❌
```

</pre>
</td>
</tr>
</table>

- [N4159 `std::functionand` Beyond](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4159.pdf)
- [MFHava/P2548 - Github](https://github.com/MFHava/P2548)
- [P2548 進行状況](https://github.com/cplusplus/papers/issues/1275)

### [P2549R1 `std::unexpected` should have `error()` as member accessor](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2549r1.html)

`std::unexpected`のエラー値取得関数を`error()`という名前にする提案。

以前の記事を参照

- [P2549R0 `std::unexpected` should have `error()` as member accessor - WG21月次提案文書を眺める（2022年02月）](https://onihusube.hatenablog.com/entry/2022/03/19/224729#P2549R0-stdunexpected-should-have-error-as-member-accessor)

このリビジョンでの変更は、ベースとなる`std::expected`提案及びワーキングドラフトの更新、LEWGでの投票結果の追記、寄せられたフィードバックの反映、などです。

この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています（正確にはC++20へのDR）。

- [P2549 進行状況](https://github.com/cplusplus/papers/issues/1209)

### [P2561R0 `operator??`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2561r0.html)

`std::expected`などを返す関数において、エラーの伝播を自動化させる演算子`??`の提案。

例外を投げうる関数を扱う関数が自身も例外を投げうる場合、例外を伝播させるための構文的なコストはゼロです。

```cpp
auto foo(int i) noexcept(false) -> int; // might throw an E
auto bar(int i) noexcept(false) -> int; // might throw an E

auto strcat(int i) noexcept(false) -> std::string {
  int f = foo(i);
  int b = bar(i);

  return std::format("{}{}", f, b);
}

// あるいはインライン化してこう書ける
auto strcat(int i) noexcept(false) -> std::string {
  return std::format("{}{}", foo(i), bar(i));
}
```

例外をハンドルせずに伝播させるためには、追加で何かを書く必要はありません。

ただし、例外にはその他多くの問題があるためあまり好まれず、その代替手段の一つとしてC++23からは`std::expected<T, E>`が使用できます。

```cpp
auto foo(int i) -> std::expected<int, E>;
auto bar(int i) -> std::expected<int, E>;

auto strcat(int i) -> std::expected<std::string, E> {
  auto f = foo(i);
  if (not f) {
    return std::unexpected(f.error());
  }

  auto b = bar(i);
  if (not b) {
    return std::unexpected(b.error());
  }

  return std::format("{}{}", *f, *b);
}
```

こちらの場合、エラーをハンドルせず伝播させる場合でも、そのためのかなり冗長なコードを追加しなければならず、値の取り出しにおいても`*`を使用しなければなりません。また、その際に考慮すべきことがいくつも潜んでいます（適切なムーブなど）。

そのため、`std::expected`に似た機能を提供するライブラリでは、このような処理をマクロによってラップする機能を提供しています。

```cpp
auto strcat(int i) -> std::expected<std::string, E> {
  SOMETHING_TRY(int f, foo(i));
  SOMETHING_TRY(int b, bar(i));
  return std::format("{}{}", f, b);
}
```

この場合は例外を使用するコードにかなり近くなりますが、マクロを使用していることから`f, b`の宣言を省いてインライン化することができません。これもまたマクロを工夫することで解決できますが、それは特定のコンパイラ拡張に頼っていたり適切にムーブされないなど効率的とは言えないものです。

コルーチンを用いて近しいシンタックスシュガーを再現することもできます。

```cpp
auto strcat(int i) -> std::expected<std::string, E> {
  int f = co_await foo(i);
  int b = co_await bar(i);
  co_return std::format("{}{}", f, b);

  // ... or
  co_return std::format("{}{}", co_await foo(i), co_await bar(i));
}
```

しかし、現在のところコルーチンは動的なメモリ確保を必ずしも回避できないため、これもまた効率的なコードではありません。

結局のところ、現在のC++における`std::expected`のエラー伝播手法としては、マクロによるものがベストとなります。

別の言語、例えばRustでは、`std::expected`に対応する`result`型がエラー伝播によく使用されています。Rustでは、先程のサンプルコードは例えば次のように書けます。

<table>
<tr>
<th>Rust</th>
<th>C++</th>
</tr>
<tr>
<td valign="top">

```cpp
fn strcat(i: i32) -> Result<String, E> {
  let f = match foo(i) {
      Ok(i) => i,
      Err(e) => return Err(e),
  };

  let b = match bar(i) {
      Ok(i) => i,
      Err(e) => return Err(e),
  }

  Ok(format!("{}{}", f, b))
}
```

</td>
<td valign="top">

```cpp
auto strcat(int i) -> std::expected<std::string, E> {
  auto f = foo(i);
  if (not f) {
      return std::unexpected(f.error());
  }

  auto b = bar(i);
  if (not b) {
      return std::unexpected(b.error());
  }

  return std::format("{}{}", *f, *b);
}
```

</pre>
</td>
</tr>
</table>

パターンマッチングの利用によって中間変数が必要ないなど、これだけでもRustの方が良い書き方ができますが、Rustにおいてのベストな書き方はこれではありません。

<table>
<tr>
<th>Rust</th>
<th>C++(例外)</th>
</tr>
<tr>
<td valign="top">

```cpp
fn strcat(i: i32) -> Result<String, E> {
  let f = foo(i)?;
  let b = bar(i)?;
  Ok(format!("{}{}", f, b))

  // ... or simply ...
  Ok(format!("{}{}", foo(i)?, bar(i)?))
}
```

</td>
<td valign="top">

```cpp
auto strcat(int i) -> std::string {
  int f = foo(i);
  int b = bar(i);
  return std::format("{}{}", f, b);

  // ... or simply ...
  return std::format("{}{}", foo(i), bar(i));
}
```

</pre>
</td>
</tr>
</table>

この場合、1文字（`?`）の構文上のオーバーヘッドによって、C++の例外を用いたコードとほぼ同等の半自動エラー伝播処理を記述できています。1文字とはいえオーバーヘッドではありますが、`std::expected`を使用するコードにおけるマクロに比べたらこのオーバーヘッドは無視できるでしょう。

理想的にはこれをC++に導入したいのですが、条件演算子`?:`と曖昧になる可能性があるためこの`?`を単項後置演算子として単純に導入できません。

```cpp
// ?:と?がある場合、次のコードは
auto res = a ? * b ? * c : d;

// 以下の2つのパース先がある
auto res1 = a ? (*(b?) * c) : d;
auto res2 = ((a?) * b) ? (*c) : d;
```

そのため、この提案では1文字増やした`??`演算子を`std::expected`等のためのエラー伝播半自動化構文として導入することを提案しています。

この演算子は上で示したRustの`?`に対応するもので、コンパイル時には範囲`for`のように展開されます。

<table>
<tr>
<th>展開前</th>
<th>展開後</th>
</tr>
<tr>
<td valign="top">

```cpp
auto strcat(int i) -> std::expected<std::string, E>{


  int f = foo(i)??;









  int b = bar(i)??;








  return std::format("{}{}", f, b);
}
```

</td>
<td valign="top">

```cpp
auto strcat(int i) -> std::expected<std::string, E> {
  using _Return = std::try_traits<
      std::expected<std::string, E>>;

  auto&& __f = foo(i);
  using _TraitsF = std::try_traits<
      std::remove_cvref_t<decltype(__f)>>;
  if (not _TraitsF::is_ok(__f)) {
      return _Return::from_error(
          _TraitsF::extract_error(FWD(__f)));
  }
  int f = _TraitsF::extract_value(FWD(__f));

  auto&& __b = bar(i);
  using _TraitsB = std::try_traits<
      std::remove_cvref_t<decltype(__b)>>;
  if (not _TraitsB::is_ok(__b)) {
      return _Return::from_error(
          _TraitsB::extract_error(FWD(__b)));
  }
  int b = _TraitsB::extract_value(FWD(__b));

  return std::format("{}{}", f, b);
}
```

</pre>
</td>
</tr>
</table>

展開に当たっては、対象のオブジェクトからエラー状態と中身の値を取り出す必要があり、また、それらの値から戻り値をどう構築するかを指定する必要があります。それを担っているのが`std::try_traits`という型特性で、次の静的メンバ関数を持っています

- `is_ok` : オブジェクトのエラー状態を取得する
- `extract_value/extract_error` : 正常値/エラー値を取得する
- `from_value/from_error` : 正常値/エラー値からその型のオブジェクトを構築する

これは、`std::expected`のような型に対して簡単にアダプトできます。

```cpp
// std::optionalでの例
template <class T>
struct try_traits<optional<T>> {
  using value_type = T;
  using error_type = nullopt_t;

  auto is_ok(optional<T> const& o) -> bool {
    return o.has_value();
  }

  // extractors
  auto extract_value(auto&& o) -> auto&& {
    return *FWD(o);
  }
  auto extract_error(auto&&) -> error_type {
    return nullopt;
  }

  // factories
  auto from_value(auto&& v) -> optional<T> {
    return optional<T>(in_place, FWD(v));
  }
  auto from_error(nullopt_t) -> optional<T> {
    return {};
  }
};

// std::expectedでの例
template <class T, class E>
struct try_traits<expected<T, E>> {
  using value_type = T;
  using error_type = E;

  auto is_ok(expected<T, E> const& e) -> bool {
    return e.has_value();
  }

  // extractors
  auto extract_value(auto&& e) -> auto&& {
    return *FWD(e);
  }
  auto extract_error(auto&& e) -> auto&& {
    return FWD(e).error();
  }

  // factories
  auto from_value(auto&& v) -> expected<T, E> {
    return expected<T, E>(in_place, FWD(v));
  }
  auto from_error(auto&& e) -> expected<T, E> {
    return expected<T, E>(unexpect, FWD(e));
  }
};
```

また、この提案の`try_traits`はC#等のnull条件演算子`?.`のような演算子のために必要なものをすべて提供します。

```cpp
auto f(int) -> std::expected<std::string, E>;

// 将来の可能性？
auto x = f(42)?.size();
```

- [P2561 進行状況](https://github.com/cplusplus/papers/issues/1276)

### [P2579R0 Mitigation strategies for P2036 “Changing scope for lambda trailing-return-type”](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2579r0.pdf)

P2036R3による後方非互換性を緩和する提案。

P2036R3（ラムダ式の後置戻り値型がキャプチャする変数のスコープの変更）はC++23のWDに導入されており、以前のバージョンに対するDRとして採択されています。P2036については以前の記事を参照。

- [P2036R1 Changing scope for lambda trailing-return-type - WG21月次提案文書を眺める（2021年01月）](https://onihusube.hatenablog.com/entry/2021/02/11/153333#P2036R1-Changing-scope-for-lambda-trailing-return-type)

この提案の検討段階では、この変更によって影響を受けるコードはほぼ無いだろうと思われていました。しかし、clangで実装されたところclangそのもの（llvm/libstdc++）のコードを壊している事が判明しました。それは次のようなコードです

```cpp
// なんかイテレータ範囲のendの値
auto local_end = ...;

[local_end](decltype(local_end) it) { return it != local_end; };
//          ^^^^^^^^^^^^^^^^^^^
```

後置戻り値型指定ではなく引数型でキャプチャした変数を参照しているコードが存在しており、P2036R3ではこれはill-formedとしています。なぜなら、ここではまだ`mutable`が見えていないため、`decltype((x))`の型を正しく求める事ができないためです。しかし、以前はこの`x`は外の変数をキャプチャしていたため問題にならず、少なくともコードを書いた人間の意図通りには動いていました。

このようなコードは[CWG2569](https://cplusplus.github.io/CWG/issues/2569.html)として報告され、これを先行実装することで解決されました。ここでは、`mutable`が現れる（場所に到達する）前にキャプチャ変数が`decltype`などで使用される場合、`decltype(x)`は許可するものの`decltype((x))`は許可しないようにすることで`mutable`の影響を受けないようにしつつ既存のコードが壊れないようにしています。

しかしその後、次のような別のコードが壊れている事が報告されました

```cpp
template <typename It, typename MapFn>
auto MapJoin(It first, It last, MapFn map_fn) {
  return std::accumulate(first, last, map_fn(*first),
                         // a new diagnostic: error: captured variable 'first' cannot appear here
                         [=](typename std::result_of<MapFn(decltype(*first))>::type result) { });
}

void foo() {
  int x = [x](int y[sizeof x]) { return sizeof x; }(0);
}
```

これらのコード破壊が報告された結果clangではP2036の実装を一旦停止したためこれ以上の破損例を収集できませんでしたが、実装された場合より多くのコードを壊すことになる事が予想されます。結果として、clangの実装者（筆者の方）はP2036R3は実装不可能であると考えているようです。

これらのコードに共通することは、C++11時点でジェネリックラムダが導入されていなかったことによる代替手段であるように思われます。従って、現在ジェネリックラムダを使用するコードをC++11で書こうとした場合にP2036に違反するコードになる可能があり、コーナーケースであると切って捨てられるほどおかしなコードであるわけではありません。

この提案は、P2036R3の変更を修正してその悪影響を緩和しようとするものです。ここでは、5つのソリューションが提示されています。

1. CWG2569の修正
2. `mutable`が現れた場合、ラムダ式の引数宣言内でキャプチャを参照するコードをill-formedにする
3. パース時に`mutable`キーワードを先読みする
4. キャプチャされた変数を参照するものの、常に`mutable`有無を考慮しない

EWGでは5番目の解決策が選択され、この提案はそのための文言を含んでいます。

それぞれのデメリットの概要は次のようになっています

1. CWG2569の修正
      - ラムダの変数宣言部で一部の用法（`decltype(x)`など）だけを許可するようにする 
      - 許可されるかが式に左右されるため理解しづらい（`decltype(*x)`はngなど）
      - 前述の通り、これだけでは破損するコードがまだある
2. `mutable`が現れる前は、ラムダの外側の変数をキャプチャする
      - つまりC++20以前（現在）の挙動
      - `decltype(expr)`の結果が`mutable`の前後で異なることはラムダ式本体開始（`{`）の前後で異なることよりも良いとは言えない
3. `mutable`が現れた場合、ラムダ式の引数宣言内でキャプチャを参照するコードをill-formedにする
      - 破損は減少するが完全ではない
      - 後から見つかる`mutable`によってエラー有無が変わるのは奇妙
4. パース時に`mutable`キーワードを先読みする
      - 完璧では無いものの、最善の解決策
      - 実装の負担が大きい
      - 後から見つかる`mutable`によって構文の意味が変わるのは奇妙
5. キャプチャされた変数を参照するものの、常に`mutable`有無を考慮しない
      - `decltype((x))`の振る舞いが関数引数部分の終端の前後で変化する可能性がある

なお、この場合、キャプチャされた変数`x`を参照する`decltype((x))`は`x`が`const`でない限り非`const`となります。すなわち、デフォルトで`mutable`があるかのように扱います。

```cpp
void f() {
  float x, &r = x;

  [=](decltype((x)) y) {
    decltype((x)) z = x;
  };  // ok、yの型はfloat&, zの型はconst float&

  [=] {
    []<decltype(x) P>;      // ok
    [](decltype((x)) y){};  // ok、yの型はfloat const&（囲むラムダがコピーキャプチャしたxを参照している）
    [x=1](decltype((x)) y){
      decltype((x)) z = x;
    };  // ok, yの型はint&, zの型はconst int&
  };
}
```

この提案は、CWG Issueと関連する提案でもあることからすでにCWGのレビューをパスしており、次の全体会議で投票にかけられる事が決まっています。

- [P2598R0 “Changing scope for lambda trailing-return-type” (P2036) should not be a DR - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P2598R0-Changing-scope-for-lambda-trailing-return-type-P2036-should-not-be-a-DR)
- [CWG Issue 2569. Use of `decltype(capture)` in a lambda's parameter-declaration-clause](https://cplusplus.github.io/CWG/issues/2569.html)
- [P2579 進行状況](https://github.com/cplusplus/papers/issues/1274)

### [P2585R1 Improving default container formatting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2585r1.html)

`std::format`のコンテナに対するフォーマットを改善する提案。

以前の記事を参照

- [P2585R0 Improving default container formatting - WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P2585R0-Improving-default-container-formatting)

このリビジョンでの変更は、`range_format_kind`を`range_format`にリネームしたことなどです。

この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2585 進行状況](https://github.com/cplusplus/papers/issues/1244)

### [P2587R1 `to_string` or not `to_string`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2587r1.html)

`std::to_string`の浮動小数点数出力を修正する提案。

以前の記事を参照

- [P2587R0 `to_string` or not `to_string` - WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P2585R0-Improving-default-container-formatting)

このリビジョンでの変更は、Annex Cセクションを追加したこと、機能テストマクロを追加したこと、`to_wstring`にも同じ変更を適用するようにしたこと、などです。

- [P2587 進行状況](https://github.com/cplusplus/papers/issues/1245)

### [P2590R2 Explicit lifetime management](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2590r2.pdf)

メモリ領域上にあるトリビアルな型のオブジェクトの生存期間を開始させるライブラリ機能の提案。

以前の記事を参照

- [P2590R0 Explicit lifetime management - WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P2590R0-Explicit-lifetime-management)
- [P2590R1 Explicit lifetime management - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P2590R1-Explicit-lifetime-management)

このリビジョンでの変更は、`const/const volatile`オーバーロードを追加したこと、`noexcept`を付加したこと、アライメントに関する事前条件を追加したこと、提案する文言の調整や修正、などです。

この提案は、今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2590 進行状況](https://github.com/cplusplus/papers/issues/1248)

### [P2592R1 Hashing support for std::chrono value classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2592r1.html)

[`<chrono>`](https://cpprefjp.github.io/reference/chrono.html)の時間や日付を表す型に対してハッシュサポートを追加する提案。

以前の記事を参照

- [P2592R0 Hashing support for std::chrono value classes - WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P2592R0-Hashing-support-for-stdchrono-value-classes)


このリビジョンでの変更は、LWGからのフィードバックの反映、カレンダー型の特殊化について構築のされ方によっては未規定の値を取る可能性がある事を追記、Heterogeneous Overloadのサポート（していない）についての追記、などです。

この提案はC++26を目指して現在LEWGでレビュー中です。

- [P2592 進行状況](https://github.com/cplusplus/papers/issues/1250)

### [P2601R1 Make redundant empty angle brackets optional](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2601r1.html)

クラステンプレート使用時に、不要な`<>`を省略可能にする提案。

以前の記事を参照

- [P2601R0 To make redundant empty angle brackets optional for class template argument lists - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P2601R0-To-make-redundant-empty-angle-brackets-optional-for-class-template-argument-lists)

このリビジョンでの変更は

- クラステンプレートと変数テンプレートの両方を対象とすることを明確にした
- デフォルトテンプレート引数と推定された引数の区別を明確にするために説明と文言を修正
- 空の`<>`を省略しても意味がない例とその有無が重要な例を追記

などです。

このリビジョンで追加された例

```cpp
template <class T = int>
struct C { C(T); };

std::vector<C> v ;  // C<int>
struct S { C c; };  // C<int>
struct D : C {};    // C<int>
void foo(C c);      // C<int>

C x = 1.0;    // C<double>
C<> y = 1.0;  // C<int>, intへの暗黙変換
```

- [P2601 進行状況](https://github.com/cplusplus/papers/issues/1265)

### [P2602R1 Poison Pills are Too Toxic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2602r1.html)

標準ライブラリから、Poison Pillと呼ばれるオーバーロードを削除する提案。

以前の記事を参照

- [P2602R0 Poison Pills are Too Toxic - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P2602R0-Poison-Pills-are-Too-Toxic)

このリビジョンでの変更は、機能テストマクロを追加したこと、比較系のCPO（`<compare>`にある`strong_order`など）を含めたことです。

この変更はどうやらC++20へのDRとされそうです（まだなってない）。

- [P2602 進行状況](https://github.com/cplusplus/papers/issues/1266)

### [P2609R1 Relaxing Ranges Just A Smidge](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2609r1.html)

射影（プロジェクション）を取るアルゴリズムについて、その制約を緩和する提案。

以前の記事を参照

- [P2602R0 Poison Pills are Too Toxic - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P2602R0-Poison-Pills-are-Too-Toxic)

このリビジョンでの変更は、`indirect_value_t`を説明専用にしたこと、[P2248R4](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2248r4.html)への影響について追記したこと、`__cpp_lib_ranges`の値を上げるようにしたこと、などです。 


- [P2609 進行状況](https://github.com/cplusplus/papers/issues/1271)

### [P2610R0 2022-07 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2610r0.html)

2022年の5月に予定されている、LEWGでの全体投票の予定表。

次の提案が、LWGに進むための投票にかけられます。

- C++23
    - [P0429R9 flat_map](https://wg21.link/P0429R9)
    - [P1222R4 flat_set](https://wg21.link/P1222R4)
    - [P0792R10 function_ref](https://wg21.link/P0792R10)
    - [P2505R4 Monadic Functions For expected](https://wg21.link/P2505R4)
    - [P2585R0 Improving Default Container Formatting](https://wg21.link/P2585R0)
    - [P2446R2 views::as_rvalue](https://wg21.link/P2446R2)
    - [P2278R4 cbegin Should Always Return A Constant Iterator](https://wg21.link/P2278R4)
    - [P2248R5 Enabling List-Initialization For Algorithms](https://wg21.link/P2248R5)
    - [P2539R1 Should The Output Of print To A Terminal Be Synchronized With The Underlying Stream?](https://wg21.link/P2539R1)
    - [P2510R3 Formatting Pointers](https://wg21.link/P2510R3)
    - [P2551R2 Clarify Intent Of Individually Specializable Numeric Traits](https://wg21.link/P2551R2)
    - [P2599R2 index_type & size_type In mdspan](https://wg21.link/P2599R2)
    - [P2604R0 mdspan: Rename pointer, data, And contiguous](https://wg21.link/P2604R0)
    - [P2613R1 Add The Missing empty To mdspan](https://wg21.link/P2613R1)
- C++26
    - [P2338R2 Freestanding Library: Character Primitives And The C Library](https://wg21.link/P2338R2)
    - [P2407R1 Freestanding Library: Partial Classes](https://wg21.link/P2407R1)
    - [P2562R1 constexpr Stable Sorting](https://wg21.link/P2562R1)
    - [P2283R2 constexpr Specialized Memory Algorithms](https://wg21.link/P2283R2)
    - [P2542R2 views::concat](https://wg21.link/P2542R2)
    - [P2609R1 Relaxing Ranges Just A Smidge](https://wg21.link/P2609R1)

### [P2613R1 Add the missing `empty` to `mdspan`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2613r1.html)

`std::mdspan`に`empty()`メンバ関数を追加する提案。

以前の記事を参照

- [P2613R0 Add the missing `empty` to `mdspan`](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P2613R0-Add-the-missing-empty-to-mdspan)


このリビジョンでの変更は、LWGのフィードバックを受けての文言調整のみです。

この提案は今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2613 進行状況](https://github.com/cplusplus/papers/issues/1272)

### [P2614R0 Deprecate `numeric_limits::has_denorm`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2614r0.pdf)

`std::numeric_limits::has_denorm`関連の定数を非推奨化する提案。

[`std::numeric_limits::has_denorm`](https://cpprefjp.github.io/reference/limits/numeric_limits/has_denorm.html)はその環境で、浮動小数点数型`T`が非正規化数をサポートしているかを調べるものです。これはコンパイル時定数であり、浮動小数点数型`T`非正規化数をサポートしている/いない/わからない、をコンパイル時に取得するものです。

IEE754準拠の浮動小数点数型であっても、ハードウェアによっては非正規化数をサポートしていない場合がありその場合はソフトウェアエミュレーションによってサポートされている場合があります。この場合、同じ系統のハードウェアであっても将来のバージョンでサポートされる可能性があり、この時にABI破壊を回避しようと思うと`std::denorm_indeterminate`を常に使用せざるを得なくなります。また、ハードウェアサポートがある場合でも、実行時のフラグ切り替えによって非正規化数をゼロにフラッシュするように設定する事が可能であり、`std::numeric_limits::has_denorm`は必ずしもコンパイル時に確定するプロパティでは無い面があります。

`std::numeric_limits::has_denorm_loss`は非正規化数が作成され（計算に使用され）る場合に起こる精度の低下をどのように検出できるかを取得するものです。非正規化数が使用されたことによって精度が低下した時にそれを検出する次の2つの方法がIEEE754標準で指定されていました

1. 非正規化損失（Denormalization loss）
2. 不正確な結果（Inexact result）

実際には1つ目の実装は存在しなかったため、現在のIEE754からは削除されており、2つ目の実装だけが存在しています。`std::numeric_limits::has_denorm_loss`はこの2つのどちらがその環境の浮動小数点数型で実装されているかを示すものでしたが、このような理由によりもはや意味がありません。また、この値は実装によってなぜか異なっています（MSVCだけが浮動小数点数型に対して`true`を返す）。

これらの理由から、`std::numeric_limits::has_denorm`と`std::numeric_limits::has_denorm_loss`は有用なものではなく、最悪勘違いして使用される危険性があるため、非推奨化しようとする提案です。ただし、削除してしまうと互換性の問題を引き起こすため、非推奨に止めようとしています。

- [`std::numeric_limits<T>::has_denorm_loss` - cppreference](https://en.cppreference.com/w/cpp/types/numeric_limits/has_denorm_loss)
- [P2614 進行状況](https://github.com/cplusplus/papers/issues/1278)

### [P2615R0 Meaningful exports](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2615r0.html)

無意味な`export`を行えないようにする提案。

現在の`export`宣言にまつわる規定の解釈の一つとして、次のような宣言が許可されているように見えます。

```cpp
// これは何？
template export void f();
export template void f();

// 本体の関数テンプレートがexportされているならこちらには不要
export template<> void g(int);
template<> export void g(int);

// プライマリテンプレートがexportされていれば不要
export template<class T> struct trait<T*>;
```

この問題はコア言語のissueとして提起され、この提案はその解決のための文言変更を含んだものです。

ただし、この後でも`export {...}`の中でこれらの宣言が現れたとしてもエラーにならないようにされています。`export`ブロック内では利便性向上のために、本来`export`できない宣言が含まれていても単に無視されるようにされる（ようにする傾向にある）ためです。

- [CWG Issue 2443. Meaningless template exports](https://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2443)
- [P2615 進行状況](https://github.com/cplusplus/papers/issues/1236)

### [P2616R0 Making `std::atomic` notification/wait operations usable in more situations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2616r0.html)

`std::atomic`の[`notify_one()`](https://cpprefjp.github.io/reference/atomic/atomic/notify_one.html)と[`wait()`](https://cpprefjp.github.io/reference/atomic/atomic/wait.html)操作を使いづらくしている問題を解消する提案。

`std::atomic`の`notify_one()/wait()`操作はC++23で追加され、`std::atomic`オブジェクトを介したスレッド間の同期プリミティブとして利用できます。

ただ、待機しているスレッドを起床させる`notify_one()`操作と`std::atomic`オブジェクトの出力（`.store()`）が分かれていることによって、 これを利用した同期プリミティブの移植可能な実装を妨げています。

例えば、`std::atomic`の`notify_one()/wait()`のよくある使用法では、`std::atomic`オブジェクトへ値を出力してから`notify_one()`を呼ぶという手順がとられます。この場合に、待機するスレッドが`wait()`からの復帰時に同期に使用していた`std::atomic`オブジェクトをすぐに破棄する場合に問題が起こります。

待機するスレッドで`wait()`が呼ばれる前に（正確には、その呼び出しで値のチェックが行われる前に）、通知スレッド（`notify_one()`を呼ぶスレッド）で`std::atomic`オブジェクトへの値の出力が行われていた場合、待機スレッドの`wait()`はすぐにリターンし使用していた`std::atomic`オブジェクトの破棄が行われます。すると、通知スレッドではそのように破棄されてしまった`std::atomic`オブジェクトに対して`notify_one()`を呼ぶ可能性があり、これはいうまでもなく未定義動作です。

```cpp
#include <atomic>
#include <thread>

int main() {
  {
    // 同期用アトミックオブジェクト
    std::atomic<bool> sync = false;

    std::thread{[&sync]{
      // 値をtrueに更新してから
      sync.store(true);   // #1
      // 待機スレッドを起床させる
      sync.notify_one();  // #2
    }}.detach();

    // 値が更新（trueになる）されるまで待機
    sync.wait(false); // #3
    // 終わったら即リターン、syncは破棄される
  } // #4
}
```

`.wait()`では引数に渡された値と現在の値を比較して、等しい場合にブロッキングし、等しく無い場合はすぐリターンします。この例では処理が`#1 -> #3 -> #4 -> #2`の順番で起こる可能性があり、起こった場合に未定義動作となります。

この例は恣意的に見えますが、例えば`std::atomic`を用いて`std::binary_semaphore`が実装されていた場合、このことは表面化しませんが同様の問題を潜在的に引き起こします。

```cpp
#include <semaphore>
#include <thread>

int main() {
  {
    // binary_semaphoreがstd::atomicを用いて実装されていたとすると・・・
    std::binary_semaphore sync;

    std::thread{[&sync]{
      sync.release();
    }}.detach();

    sync.acquire();
  }
}
```

このコードだと先ほどよりも問題が見えにくくなっています。`std::atomic`と`notify_one()/wait()`を用いて他の同期プリミティブを実装する場合はこの問題を避けるための工夫が必要になり、それらのワークアラウンドはパフォーマンスを損ねたり移植性が無かったりと問題があります。

実は標準ライブラリの主要3実装（GCC/clang/MSVC）における`std::binary_semaphore`（`std::counting_semaphore`）はまさに`std::atomic`を利用して実装されています。ただし、そこでは`std::atomic`オブジェクトのアドレスのみを使用して値にアクセスしないため、上記のようなライフタイムにまつわる問題は起こりません。ただしこれは、この3つの実装がプラットフォームの対応する操作に関する追加の知識を仮定できるために可能になっているだけで、その他の標準ライブラリ実装がこの方法を取るかどうかはわからず、ユーザーは同様の仮定のもとで`std::atomic`を使用して`std::binary_semaphore`のようなものを安全かつ移植可能に実装することはできません。

この提案はこの問題の解決を図るもので、次の2つの解決策を提示しています。

1. 名前空間スコープの[`std::atomic_notify_one()`](https://cpprefjp.github.io/reference/atomic/atomic_notify_one.html)/[`std::atomic_notify_all()`](https://cpprefjp.github.io/reference/atomic/atomic_notify_all.html)の規定を変更して、生存期間が終了している`std::atomic`オブジェクトへのポインタを渡されるようにする。
    - 渡されたポインタにはアクセスしないことを保証する
2. `std::atomic`オブジェクトの`.store()`を呼び出す可能性がある関数ごとに、通知操作を融合したオーバーロードを追加する。
    - `std::memory_notification`列挙体を追加して、それを引数に取るようにする

1つ目の方法では、最初のサンプルコードは次のように書き換えられます

```cpp
#include <atomic>
#include <thread>

int main() {
  {
    // 同期用アトミックオブジェクト
    std::atomic<bool> sync = false;

    std::thread{[&sync]{
      // 破棄される前にアドレスを取得
      auto* pa = &sync;
      // 値をtrueに更新
      sync.store(true);
      // 通知
      std::atomic_notify_one(pa);
    }}.detach();

    // 値が更新（trueになる）されるまで待機
    sync.wait(false);
  }
```

この時、ポインタ`pa`を`pa`の参照先オブジェクトが破棄された後で使用することが有効であるかには議論があり、Pointer lifetime-end zapという問題として知られています（詳細は以前の記事参照）

- [P1726R4 : Pointer lifetime-end zap - WG21月次提案文書を眺める（2020年07月）](https://onihusube.hatenablog.com/entry/2020/08/12/014639#P1726R4--Pointer-lifetime-end-zap)
- [P2414R0 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2414R0-Pointer-lifetime-end-zap-proposed-solutions)

したがって、この解決策を適用するためにはコア言語にこれらの提案による解決が導入される必要があります。

2つ目の方法では、次のような列挙体とその定数を標準ライブラリに追加し、`.store()`などの値を変更する関数にこれを受け取るオーバーロードを追加します。

```cpp
namespace std {
  enum class memory_notification : unspecified {
    notify_none = unspecified,
    notify_one = unspecified,
    notify_all = unspecified
  };
  inline constexpr auto memory_notify_none = memory_notification::notify_none;
  inline constexpr auto memory_notify_one = memory_notification::notify_one;
  inline constexpr auto memory_notify_all = memory_notification::notify_all;
}
```

この方法では、最初のコードは次のようになります

```cpp
#include <atomic>
#include <thread>

int main() {
  {
    // 同期用アトミックオブジェクト
    std::atomic<bool> sync = false;

    std::thread{[&sync]{
      // 値をtrueに更新して通知
      sync.store(true, std::memory_notify_one);
    }}.detach();

    // 値が更新（trueになる）されるまで待機
    sync.wait(false);
  }
}
```

実際の実装では`std::atomic`オブジェクトのアドレスを取ってからストア操作と通知操作を行う（1のような方法）が取られる可能性がありますが、それは実装定義の振る舞いとして（現在の`std::counting_semaphore`の実装のように）動作が保証されるため、ユーザーコードで同じことをした場合の未定義動作を回避することができます。

- [P2616 進行状況](https://github.com/cplusplus/papers/issues/1279)

### [P2617R0 Responses to NB comments on DTS 12907 "Extensions to C++ for Transactional Memory Version 2"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2617r0.html)

[Transactional Memory TS2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4906.pdf)に寄せられたNBコメントを受けての修正を反映する提案。

6つのNB（*national body*）コメント（WG21の各国毎のサブグループからのレビュー結果みたいなもの）が寄せられ、その指摘に対処するための文言変更が含まれています。どうやら全てカナダの委員会メンバからのものです。

この提案は既に2022年7月の全体会議で承認されたようです。

- [N4906 Transactional Memory TS2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4906.pdf)
- [P2617 進行状況](https://github.com/cplusplus/papers/issues/1280)

### [P2618R0 C++ Standard Library Issues to be moved in Virtual Plenary, Jul. 2022](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2618r0.html)

今回（2022/07）の会議で採択された標準ライブラリについてのIssue報告とその解決。

1. [3564. `transform_view::iterator<true>::value_type` and `iterator_category` should use `const F&`](https://wg21.cmeerw.net/lwg/issue3564)
2. [3617. `function/packaged_task` deduction guides and deducing this](https://wg21.cmeerw.net/lwg/issue3617)
3. [3656. Inconsistent bit operations returning a count](https://wg21.cmeerw.net/lwg/issue3656)
4. [3659. Consider ATOMIC_FLAG_INIT undeprecation](https://wg21.cmeerw.net/lwg/issue3659)
5. [3670. Cpp17InputIterators don't have integer-class difference types](https://wg21.cmeerw.net/lwg/issue3670)
6. [3671. `atomic_fetch_xor` missing from stdatomic.h](https://wg21.cmeerw.net/lwg/issue3671)
7. [3672. `common_iterator::operator->()` should return by value](https://wg21.cmeerw.net/lwg/issue3672)
8. [3683. `operator==` for `polymorphic_allocator` cannot deduce template argument in common cases](https://wg21.cmeerw.net/lwg/issue3683)
9. [3687. `expected<cv void, E>` move constructor should move](https://wg21.cmeerw.net/lwg/issue3687)
10. [3692. `zip_view::iterator`'s `operator<=>` is overconstrained](https://wg21.cmeerw.net/lwg/issue3692)
11. [3701. Make `formatter<remove_cvref_t<const charT[N]>, charT>` requirement explicit](https://wg21.cmeerw.net/lwg/issue3701)
12. [3702. Should `zip_transform_view::iterator` remove `operator<`?](https://wg21.cmeerw.net/lwg/issue3702)
13. [3703. Missing requirements for `expected<T, E>` requires `is_void<T>`](https://wg21.cmeerw.net/lwg/issue3703)
14. [3704. LWG 2059 added overloads that might be ill-formed for sets](https://wg21.cmeerw.net/lwg/issue3704)
15. [3705. Hashability shouldn't depend on `basic_string`'s allocator](https://wg21.cmeerw.net/lwg/issue3705)
16. [3707. `chunk_view::outer-iterator::value_type::size` should return unsigned type](https://wg21.cmeerw.net/lwg/issue3707)
17. [3708. `take_while_view::sentinel`'s conversion constructor should move](https://wg21.cmeerw.net/lwg/issue3708)
18. [3709. LWG-3703 was underly ambitious](https://wg21.cmeerw.net/lwg/issue3709)
19. [3710. The end of `chunk_view` for input ranges can be `const`](https://wg21.cmeerw.net/lwg/issue3710)
20. [3711. Missing preconditions for `slide_view` constructor](https://wg21.cmeerw.net/lwg/issue3711)
21. [3712. `chunk_view` and `slide_view` should not be `default_initializable`](https://wg21.cmeerw.net/lwg/issue3712)
22. [3713. Sorted with respect to comparator (only)](https://wg21.cmeerw.net/lwg/issue3713)
23. [3715. `view_interface::empty` is overconstrained](https://wg21.cmeerw.net/lwg/issue3715)
24. [3719. Directory iterators should be usable with default sentinel](https://wg21.cmeerw.net/lwg/issue3719)
25. [3721. Allow an arg-id with a value of zero for width in std-format-spec](https://wg21.cmeerw.net/lwg/issue3721)
26. [3724. decay-copy should be constrained](https://wg21.cmeerw.net/lwg/issue3724)

### [P2620R0 Lifting artificial restriction on universal character names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2620r0.pdf)

ユニコード文字名によって指定するユニバーサルキャラクタ名（名前付文字エスケープ）を識別子に使用した時の制限を解除する提案。

名前付文字エスケープ（*Named character escape*）はC++23で導入されたもので、`U'\N{LATIN CAPITAL LETTER A WITH MACRON}'`のようにユニバーサルキャラクタ名を指定するものです。詳細は以前の記事を参照

- [P2071R1 Named universal character escapes - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P2071R1-Named-universal-character-escapes)

この提案の指摘している問題とは次のようなものです

```cpp
int main() {
  auto \N{LATIN CAPITAL LETTER I} = 42; // ng、Iはユニバーサルキャラクタ名で指定できない
  auto \N{LATIN CAPITAL LETTER I WITH DOT ABOVE} = 42 ; // ok
}
```

`LATIN CAPITAL LETTER I`とは`I`（`U+0049`）の文字（アルファベットのI）であり、これは基本文字集合に含まれる文字であるためユニバーサルキャラクタ名によって指定できません。`LATIN CAPITAL LETTER I WITH DOT ABOVE`はIの上にドットがついている文字`İ`（`U+0130`）で、これは基本文字集合に含まれ無いためユニバーサルキャラクタ名によって指定することができます。

これらのことは、文字/文字列リテラル内では区別されないため問題になりませんが、識別子で使用された時だけこのような違いが生じます。この提案は、この制限を取り払おうとするものです。

- [P2620 進行状況](https://github.com/cplusplus/papers/issues/1282)

### [P2621R0 UB? In my Lexer?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2621r0.pdf)

字句解析するだけで未定義動作を引き起こすものについて、未定義ではなくする提案。

この提案によれば、次のようなコードは規格的には未定義動作となるようです

```cpp
int \\ // UB : 複数行にわたるユニバーサル文字名
u\
0\
3\
9\
1 = 0;

#define CONCAT(x, y) x ## y
int CONCAT(\, u0393) = 0; // UB: マクロ展開によって形成されるユニバーサル文字名

// UB: 閉じていない文字列リテラル
const char * foo = "
```

この提案は、これらの未定義動作を実際の実装に合わせる形で振る舞いを定義しようとするものです。

|UB|GCC|clang|EDG|MSVC|
|---|---|---|---|---|
|複数行UCN|Supported|Supported|Error|Supported|
|`##`によるUCNの形成|Supported|Supported|Supported|Supported|
|閉じていない文字（列）リテラル|ill-formed|ill-formed|ill-formed|ill-formed|

これらのことを踏まえて、この提案は3つのUBを次のようにしようとしています

|UB|提案|
|---|---|
|複数行UCN|Well-formed|
|`##`によるUCNの形成|Well-formed|
|閉じていない文字（列）リテラル|ill-formed|

従って、MSVCの複数行UCN実装だけがこの提案の影響を受けます。しかし、現在はエラーになっているのでその影響は破壊的なものではありません。

- [P2621 進行状況](https://github.com/cplusplus/papers/issues/1283)

### [P2622R0 Core Language Working Group "ready" Issues for the July, 2022 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2622r0.html)

今回（2022/07）の会議で採択されたコア言語についてのIssue報告とその解決。

1. [2355. Deducing noexcept-specifiers](https://wg21.cmeerw.net/cwg/issue2355)
2. [2405. Additional type-dependent expressions](https://wg21.cmeerw.net/cwg/issue2405)
3. [2507. Default arguments for operator[]](https://wg21.cmeerw.net/cwg/issue2507)
4. [2534. Value category of pseudo-destructor expression](https://wg21.cmeerw.net/cwg/issue2534)
5. [2535. Type punning in class member access](https://wg21.cmeerw.net/cwg/issue2535)
6. [2540. Unspecified interpretation of numeric-escape-sequence](https://wg21.cmeerw.net/cwg/issue2540)
7. [2571. Evaluation order for subscripting](https://wg21.cmeerw.net/cwg/issue2571)
8. [2582. Differing member lookup from nested classes](https://wg21.cmeerw.net/cwg/issue2582)
9. [2585. Name lookup for coroutine allocation](https://wg21.cmeerw.net/cwg/issue2585)
10. [2586. Explicit object parameter for assignment and comparison](https://wg21.cmeerw.net/cwg/issue2586)
11. [2594. Disallowing a global function template main](https://wg21.cmeerw.net/cwg/issue2594)
12. [2597. Replaceable allocation and deallocation functions in the global module](https://wg21.cmeerw.net/cwg/issue2597)
13. [2606. static_cast from "pointer to void" does not handle similar types](https://wg21.cmeerw.net/cwg/issue2606)
14. [2608. Omitting an empty template argument list](https://wg21.cmeerw.net/cwg/issue2608)

### [P2623R0 implicit constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2623r0.html)

一時オブジェクトへの参照によるダングリング発生を削減する提案。

一時オブジェクトへの参照によってダングリング参照が発生するのは主に次の2つの場合です

1. 関数から返された参照
2. 関数から返された、値のセマンティクスを持たないオブジェクト（`std::string_view`など）

例えば2つ目の場合だと、次のようなコードで簡単にダングリング参照を生成できます

```cpp
using namespace std::string_literals;

int main () {
  std::string_view sv = "hello world"s; // この行以降svはダングリング参照となる、その使用はUB
}
```

`"hello world"s`はユーザー定義リテラル`s`によって`std::string`の一時オブジェクトを生成します。それを`std::string_view`でバインドすると、すぐにその一時オブジェクトの寿命が尽きてダングリングとなります。

この提案の目的は、このコードがUB（ダングリング参照）にならないようにすることです。この例では、定数式`"hello world"s`が通常の文字列リテラルと同様に静的記憶域期間（*static storage duration*）を持つようにする（暗黙的な定数初期化を行う）ことで、ダングリング参照の生成を防止しようとしています。

また、`std::string_view`によるダングリングは次のように間接的に発生する場合もあります

```cpp
std::string operator+(std::string_view s1, std::string_view s2) {
  return std::string{s1} + std::string{s2};
}

auto f() {
  std::string_view sv = "hi";
  sv = sv + sv; // svはダングリング
  ...
}
```

`sv + sv`の結果は`std::string`の一時オブジェクトであり、その寿命はその式の終わり（`;`）までです。

この提案では、この場合にこの式の結果生成される一時オブジェクトの生存期間をその式ではなく囲むブロックのスコープとバインドさせることで、このようなダングリングを防止しようとしています。

もちろん、この場合でもこの参照（`sv`）をこのブロックの外に持ち出してしまえばダングリング参照となりますがそれは現在でも同じことで、この提案の目的はダングリング参照の発生を抑制することにあり、完全に失くすことを目指してはいません。

1つ目の場合（関数の参照戻り値）では、次のような場合にダングリング参照を生成できます

```cpp
struct X { int a, b; };

const int& f(const X& x) { return x.a; }  // 引数のメンバへの参照を返す

int main() {
  const int& a = f({4, 2}); // 一時オブジェクトを引数で与える
                            // aはダングリング参照、UB
}
```

この時でも、`{4, 2}`の一時オブジェクトの生存期間が囲むブロックのスコープに紐づいていれば、ダングリング参照は生成されません。

`std::string`では、この例とよく似たことを簡単に起こすことができます。

```cpp
char& c = std::string{"hello my pretty long string"}[0];
c = 'x'; // cはダングリング参照、UB
std::cout << "c: " << c << '\n'; // cはダングリング参照、UB
```

この時でも一時オブジェクトの生存期間がその式ではなく囲むブロックに紐づいていればダングリングを回避できます。ここで、このような一時オブジェクトの寿命にまつわる問題を回避するために一時オブジェクトを変数に受けてみると現在の一時オブジェクトの生存期間のルールがプログラマの期待と一致していないことが垣間見えます。

```cpp
auto anonymous = std::string{"hello my pretty long string"};
char& c = anonymous[0];
c = 'x'; // ok、cはダングリングではない
std::cout << "c: " << c << '\n'; // ok、cはダングリングではない
```

これはプログラマから見ればほぼ同じコードですが、このように一時オブジェクトに名前づけをするだけでダングリング参照の生成を回避できます。しかしこれは、一時オブジェクトの生存期間を囲むブロックに紐づけるという操作を手動でやっているだけです。

このようなことが意図せず発生しうるものとして範囲`for`がよく知られています。

```cpp
for (auto x : reversed(make_vector())) { ... }
```

`make_vector()`が`std::vector`の右辺値を返し、`reversed()`が[`std::ranges::owning_view`](https://cpprefjp.github.io/reference/ranges/owning_view.html)のような一時オブジェクトの生存期間延長のためのケアをしない場合、この範囲`for`全体はダングリングした範囲をイテレートします。

例えば、範囲`for`は次のように展開されています

```cpp
{// containing block
  auto&& rg = reversed(make_vector());  // この行でmake_vector()の戻り値の寿命が尽きる
  auto pos = rg.begin();
  auto end = rg.end();
  for ( ; pos != end; ++pos ) {
    auto x = *pos;
    ...
  }
}
```

この時でも、一時オブジェクトの生存期間が囲むブロックに紐づいていれば、このようなUBを回避できます。そのことは、一時オブジェクトに明示的に名前を与えてみるとわかります

```cpp
{// containing block
  auto anonymous1 = make_vector();
  auto anonymous2 = reversed(anonymous1);
  auto pos = anonymous2.begin();
  auto end = anonymous2.end();
  for ( ; pos != end; ++pos ) {
    auto x = *pos;
    ...
  }
}
```

この提案の主張することは、プログラマから見れば一時オブジェクトとは名前のない変数であるということです。その観点から、一時オブジェクトの寿命を通常の変数のようにすればダングリング参照の発生を減らすだけでなく、ダングリングする可能性のある関数戻り値を受けるための余計な変数の名前づけを削減することもできます。これによって、一時オブジェクトに注意して関数戻り値を命名するのではなく、一時オブジェクトのまま使用することを奨励することすらできるようになります。

より詳細には、この提案ではこれらの一時オブジェクトのうち、暗黙的な定数初期化が可能な場合（`constexpr`コンストラクタを持つ型の`const`参照）にはコンパイル時に定数初期化して静的記憶域期間を与えることで一時オブジェクトではなくし、そのような定数初期化ができない一時オブジェクトについてはその寿命を囲むブロックスコープにまで延長（通常の名前付き変数と同様に）することで、ダングリング参照の発生を防止しようとしています。

```cpp
// std::mapからキーに対応する値を取得する、なければ指定したデフォルトを返す
const V& findOrDefault(const std::map<K,V>& m, const K& key, const V& defvalue);

void f() {
  std::map<std::string, std::string> myMap;
  const std::string& s = findOrDefault(myMap, key, "none"); // "none"はstd::stringの一時オブジェクト
  // 現在はsはダングリング参照
  // この提案後は定数初期化されたグローバルな"none"（std::stringオブジェクト）を指す
}

std::string make_str(); // 非constexpr関数

void g() {
  std::map<std::string, std::string> myMap;
  const std::string& s = findOrDefault(myMap, key, make_str());  // 実行時文字列で使用した場合
  // 現在はsはダングリング参照
  // この提案後はmake_str()の戻り値の一時オブジェクトの寿命は囲むスコープに拡張されるため、ダングリングではなくなる
}
```

一時オブジェクトの生存期間を囲むブロックに拡張するのは、現在のC++でも制限的ながら起こっており、このことは全く新しいことではありません。

```cpp
template<typename T> using id = T;

int i = 1;
int&& a = id<int[3]>{1, 2, 3}[i]; // 配列の一時オブジェクトの寿命はaの寿命と同期する
const int& b = static_cast<const int&>(0); // intの一時オブジェクトの寿命はbの寿命と同期する
int&& c = cond ? id<int[3]>{1, 2, 3}[i] : static_cast<int&&>(0);  // 条件演算子の両方のオペランドの一時オブジェクトの寿命はcの寿命と同期する
```

この提案の内容は以前の[P0936R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0936r0.pdf)を引き継ぐものです。そちらでは追加の注釈によって引数や戻り値の生存期間の延長（この提案の一時オブジェクトの自動変数化）を行なっていましたが、この提案ではそれと同じことを暗黙的に行います。この提案はそこに一時オブジェクトの暗黙的定数初期化を追加することでP0936を補強するとともに、P0936の内容だけでは適切な対策とならないものについてより安全にしようとするものです。

- [P0936R0 Bind Returned/Initialized Objects to the Lifetime of Parameters, Rev0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0936r0.pdf)
- [P2623 進行状況](https://github.com/cplusplus/papers/issues/1285)

### [P2624R0 Make operations on bools more portable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2624r0.html)

`bool`型に関する標準の矛盾を正す提案。

標準では、`bool`型について次のように指定しています

- 実装定義の符号なし整数型と同じオブジェクト表現、値表現、アライメントを持つ
- `bool`型の値は`true`と`false`

型`T`のオブジェクト表現とは`T`のオブジェクトを`unsigned char[N]`で参照した時のバイト列のことで、`T`の値表現とは`T`の値を保持するビット列のことです。

`bool`の値は2つしか取れないとする場合、少なくとも256の異なる値を取れる符号なし整数型と同じ値表現として実装することはできません。この矛盾によって、`bool`型のどのような実装も標準に適合することはできておらず、さまざまな方法で標準の規定を近似しています。

- clang : 1バイトオブジェクト中の1ビットのビットフィールドであるかのように実装
    - 下位1ビットのみが値に関与し、残りはパディングビット
    - 2つの値のみを取れるという規定を満たすものの、ベースとなる符号なし整数型と同じ値表現を持たない
- GCC/MSVC : `enum bool : unsigned char { false, true };`のような型として実装
    - 符号なし整数型と同じ値表現を持つものの、異なる256の値を持つことができる

この違いによって、微妙な振る舞いの違いを観測することができます。

```cpp
// clangは常に 0 or 1のどちらかを返す
// msvc & gccは 0, 1, -1のどれかを返す
int test1(bool b) { 
  switch(b) {
    case false: return 0;
    case true: return 1;
    default: return -1;
  }
}
 
// clang & msvcは常に 1を返す
// gccは 1か2のどちらかを返す
int test2(bool b) {
  int n = 0;

  if (b) n++;
  if (!b) n++;
  
  return n;
}
 
// clangは常に 0 or 2のどちらかを返す
// msvc & gccは 0~510の間の任意の値を返す
int test3(bool b) { return b + b; }
 
// clang & msvcは常に 0 or 1のどちらかを返す
// gccは 0~255の間の任意の値を返す
int test4(bool b) { return b || b; }
```

この提案の目的は、これらのことを正すことで`bool`を含む式が数学的論理と一致した予測可能で意外性のない結果を返すようにし、`bool`型の変数を安全かつポータブルに使用可能とすることです。

この提案の内容にclangは既に準拠していますがGCC/MSVCはそうではなく、GCC/MSVCの現在の挙動に依存しているコードは動作が変更されることになります。

- [`std::has_unique_object_representations` - cpprefjp](https://cpprefjp.github.io/reference/type_traits/has_unique_object_representations.html)
- [P2624 進行状況](https://github.com/cplusplus/papers/issues/1286)
