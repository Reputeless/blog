# ［C++］WG21月次提案文書を眺める（2023年08月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-09](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-09)

全部で40本あります。

もくじ

[:contents]

### [P0843R9 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0843r9.html)
### [P1068R9 Vector API for random number generation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1068r9.pdf)
### [P1255R10 A view of 0 or 1 elements: views::maybe](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1255r10.pdf)
### [P2264R5 Make assert() macro user friendly for C and C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2264r5.html)
### [P2542R4 views::concat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2542r4.html)
### [P2542R5 views::concat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2542r5.html)
### [P2686R2 constexpr structured bindings and references to constexpr variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2686r2.pdf)
### [P2748R2 Disallow Binding a Returned Glvalue to a Temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2748r2.html)
### [P2755R0 A Bold Plan for a Complete Contracts Facility](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2755r0.pdf)

C++の契約プログラミング機能について、将来的な完成形のための計画を練る提案。

現在、C++26に向けて契約プログラミング機能を導入すべく作業が続けられていますが、それは本来の契約プログラミング機能の合意がとれたサブセットです。本来想定される契約プログラミング機能はより広いものですが、そこにはまだ合意がとれていないものや議論が紛糾しているもの、実装経験が乏しいものなどが含まれており、それらを全て導入しようとすればさらに長い時間が必要となります。

この提案は、そのような最終的なC++契約プログラミング機能がどのようなニーズの元に構成され、何を備えているべきかを説明し、提案するものです。必然的に、C++26に導入されようとしている機能を超えた部分についての提案になっています。

1章を除いた残りの部分は

- 2章 : 契約機能のC++におけるユースケースについての説明
- 3章 : 提案する個々の機能についての解説や提案
- 4章 : 3章を踏まえた、より大規模で現実的なサンプルの提示
- 5章 : 最終的に対処する必要がある、言語と契約機能についての他の（3章に含まれない）側面についての議論

のような構成となっています。

- [P2958 進行状況](https://github.com/cplusplus/papers/issues/1630)

### [P2760R0 A Plan for C++26 Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2760r0.html)

C++26に向けての、`<ranges>`ライブラリ関連作業の予定表。

C++23では`<ranges>`ライブラリ関連作業のまとめを[P2214](https://wg21.link/p2214r2)で行っていました。最終的に、そこで提案されていた優先度1のほとんどのものと優先度2の一部のものをC++23に導入することができました。

この提案は、C++26でも同様に作業を優先付けして分類し、追加の考慮が必要なものについてまとめておくためのものです。

この提案で優先度1とされているものは次のものです

- Rangeアダプタ
    - `views::concat`
    - `take/drop`のファミリ
      - `views::drop_last`と`views::take_last`
      - `views::drop_last_while`と`views::take_last_while`
      - `views::drop_exactly`と`views::take_exactly`
      - `views::slice`
    - 単純な合成アダプタ
      - `views::transform_join`
      - `views::replace`と`views::replace_if`
      - `views::remove`と`views::remove_if`
      - `views::upto`
    - `views::as_input`
    - `views::cache_last`
    - `views::chunk_on`
    - `views::cycle`
    - `views::delimit`と`views::c_str`
    - より複雑な状況における、より多くのアダプタの`borrowed_range`対応
    - ジェネレータ
      - `views::scan`
      - `views::generate`と`views::generate_n`
- Rangeアルゴリズム
    - `ranges::reduce`
    - `ranges::sum`
    - `ranges::product`

他にも優先度2と3の分類がありますが、C++26に向けてはこの優先度1のものについての作業を優先的に行う予定です。

- [P2760 進行状況](https://github.com/cplusplus/papers/issues/1635)

### [P2762R1 Sender/Receiver Interface For Networking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2762r1.pdf)
### [P2833R2 Freestanding Library: inout expected span](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2833r2.html)
### [P2846R1 size_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2846r1.pdf)
### [P2865R3 Remove Deprecated Array Comparisons from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2865r3.pdf)
### [P2866R1 Remove Deprecated Volatile Features From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2866r1.pdf)
### [P2867R1 Remove Deprecated strstreams From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2867r1.html)
### [P2868R2 Remove Deprecated `std::allocator` Typedef From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2868r2.pdf)
### [P2869R2 Remove Deprecated `shared_ptr` Atomic Access APIs From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2869r2.pdf)
### [P2870R2 Remove `basic_string::reserve()` From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2870r2.pdf)
### [P2871R2 Remove Deprecated Unicode Conversion Facets From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2871r2.pdf)
### [P2872R2 Remove `wstring_convert` From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2872r2.pdf)
### [P2875R2 Undeprecate `polymorphic_allocator::destroy` For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2875r2.pdf)
### [P2885R2 Requirements for a Contracts syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2885r2.pdf)
### [P2909R1 Fix formatting of code units as integers (Dude, where's my char?)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2909r1.html)
### [P2909R2 Fix formatting of code units as integers (Dude, where's my char?)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2909r2.html)
### [P2932R0 A Principled Approach to Open Design Questions for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2932r0.pdf)

契約機能に関する未解決の問題についての設計原則に基づく解決策の提案。

C++26に向けて契約プログラミング機能を導入するべく、SG21での作業は順調に進行しています。今年に入ってから、主に契約注釈の意味論についての議論が交わされ、合意の下でいくつかの提案がMVPにマージされました。

- [P2751R1 Evaluation of Checked Contract-Checking Annotations](https://wg21.link/P2751R1) : 契約条件式で許可されるものと、その評価結果がどう解釈されるかの規定
- [P2811R7 Contract-Violation Handlers](https://wg21.link/P2811R7) : 実行時に契約違反に対する処理をカスタマイズすることのできる、リンク時に置換可能な契約違反ハンドラの追加
- [P2834R1 Semantic Stability Across Contract-Checking Build Modes](https://wg21.link/P2834R1) : 関数の事前条件・事後条件は`noexcept`（指定/演算子）に影響を及ぼさない
- [P2877R0 Contract Build Modes, Semantics, and Implementation Strategies](https://wg21.link/P2877R0) : 契約注釈のセマンティクス（無視される、評価される、など）の選択を実装定義とし、特にその選択は評価ごとに異なる可能性があり、そのため契約注釈の意味論は契約注釈のコンパイル時の特性ではない、とした。これによって、ビルドモードの概念は削除された。

MVP仕様（P2521R4）に対してこれらをマージすれば、C++の言語機能としての契約プログラミング機能がすぐにでも得られますが、いくつかのエッジケースや設計ポイントにはまだ対処すべき問題が残っています。

契約プログラミングに関する議論が紆余曲折を経ていることもあって、C++における契約プログラミング機能の設計に関するドキュメントは存在していません。この提案は、C++26の契約プログラミング機能のための残りの作業の完遂のために、C++における契約プログラミング機能の設計意図を体系化する基本原則をまとめ、それらをもとに現在残っているいくつかの問題への回答を示すものです。

提案されている原則とは次の4つです

1. 契約注釈は平易な言語（非プログラミング言語）による契約をチェックする
    - 関数の宣言に付加された契約注釈は、それが評価されたときにその関数の平易な言語による契約の違反を特定しなければならない
2. プログラムのセマンティクスは（実装によって）選択された契約注釈のセマンティクスから独立している
    - 契約注釈のセマンティクスは、それがなされている地点を取り巻く近接した部分のコンパイル時のセマンティクスに影響を与えてはならない
3. 無視される契約述語（つまり、条件が評価されない場合）はゼロオーバーヘッドである
    - 無視される契約注釈付近のコードの動作は、その注釈がコメントアウトされているかのようになる
    - ただし、無視される場合でも構文チェックは継続される（エンティティがODR-usedであるかは変わらない）
4. 未定義動作はill-formed（コンパイルエラー）とする
    - 現在の契約機能ではサポートされていないユースケースに対応するために、未定義（安全でない）や実装定義（ポータブルでない）ではなく、未解決の振る舞いをill-formedとすることで拡張性を柔軟に保つことを好む

これらの原則をベースとして、

1. トリビアルな特殊メンバ関数と契約
    - 契約注釈は関数のトリビアル性に影響を与えない
    - そのような契約注釈は評価されない可能性がある
2. 暗黙のラムダキャプチャ
    1. ラムダ式における契約注釈を許可する
    2. 契約注釈中のODR-usedは暗黙的にキャプチャしない
        - 契約注釈（`assert`を含む）はラムダ式がキャプチャしていないものをキャプチャしない
        - それがなされている場合はill-formed
3. 定数式における契約チェック
    1. コンパイル時の契約違反は診断を発行する
        - 契約違反プロセスがコンパイル時に評価されると（*observe*もしくは*enforce*セマンティクスでコンパイル時に評価される場合に契約違反が発生すると）診断が発行される
          - *enforce*セマンティクスによって評価されている場合、プログラムはill-formed
    2. セマンティクスはコンパイル時に選択される可能性がある
        - 契約注釈を評価する際の実装定義の評価セマンティクスの選択は、コア定数式の一部として評価される可能性がある
        - つまり、契約注釈の評価の一部としてそのセマンティクスを選択しても、それを含む式はコア定数式ではなくならない
    3. コンパイル時に契約条件が評価される場合に、定数式で実行不可能な式を使用するのはill-formed
        - コア定数式として有効な式において、コア定数式として有効ではない契約条件を評価すると診断が発行される
          - *enforce*セマンティクスによって評価されている場合、プログラムはill-formed
    4. コンパイル時定数ではないものの、定数式として有効な初期化子内の契約注釈は、実行時に評価される
        - 潜在的なコンパイル時定数である非コンパイル時定数変数の初期化式が、その全ての契約注釈が*ignore*セマンティクスで評価されたときにコア定数式とならない場合、その初期化式はコア定数式ではない
        - 従って、異なるセマンティクスを持つ可能性のある契約条件を使用してその式を再度定数評価しようとすることは行われない
    5. 定数式における契約注釈の評価について、まとめ
        - 式が定数式として有効であるかを判断するときは、まず*ignore*セマンティクスで契約注釈とその式を評価することで、式が定数式として有効であるかを調べる
          - 式は定数式として有効である、もしくは、定数式として有効ではないが*manifestly constant-evaluated*なコンテキストにある場合
            - 実装定義の方法で選択されたセマンティクスに基づいて、契約注釈を評価しながら式を再評価する
              - *observe*セマンティクスの元で契約違反が発生した場合、診断を発行し実行（コンパイル）を継続
              - *enforce*セマンティクスの元で契約違反が発生した場合、プログラムはill-formed、診断を発行する
              - 式が定数式で実行できない場合、プログラムはill-formed
          - それ以外の場合、式は定数式ではない 
4. 仮想関数 : 次のどちらか
    1. 契約注釈は継承されない
        - 宣言に事前条件・事後条件を持たない仮想関数は、事前条件・事後条件を持たない
        - オーバーライドされる関数の契約条件を継承しない
    2. 仮想関数には契約注釈を行えない
        - 事前条件・事後条件を`virtual`とマークされた関数もしくはそれをオーバライドする関数に行うのはill-formed
5. コルーチン
    - コルーチンには契約注釈を行えない
      - コルーチンである関数に事前条件・事後条件を指定することはill-formed
      - コルーチン本体内での`assert`は許可
6. 最初の宣言の契約
    1. 契約注釈は最初の宣言でのみ行える
        - 関数の宣言がその最初の宣言ではない場合、事前条件・事後条件を持つことはできない
    2. 関数の契約注釈のリストは一貫している必要がある
        - ある関数について、全ての翻訳単位における最初の宣言における契約注釈リストは同じである必要がある。ただし、診断は不要

この提案が採択されることで、P2896R0で収集されている全ての未解決の問題は解決されます。そして、それによって（構文の選択は必要ですが）契約機能の提案はC++言語に統合するための準備ができている状態になります。

- [P2896R0 Outstanding design questions for the Contracts MVP - WG21月次提案文書を眺める（2023年08月）](https://onihusube.hatenablog.com/entry/2023/10/14/223052#P2896R0-Outstanding-design-questions-for-the-Contracts-MVP)
- [P2932 進行状況](https://github.com/cplusplus/papers/issues/1636)

### [P2935R1 An Attribute-Like Syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2935r1.pdf)
### [P2935R2 An Attribute-Like Syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2935r2.pdf)
### [P2944R2 Comparisons for reference_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2944r2.html)
### [P2951R3 Shadowing is good for safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2951r3.html)
### [P2955R1 Safer Range Access](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2955r1.html)
### [P2961R0 A natural syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2961r0.pdf)
### [P2963R0 Ordering of constraints involving fold expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2963r0.pdf)
### [P2966R0 Making C++ Better for Game Developers -- Progress Report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2966r0.pdf)
### [P2966R1 Making C++ Better for Game Developers -- Progress Report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2966r1.pdf)
### [P2968R0 Make std.ignore a first-class object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2968r0.html)
### [P2971R0 Implication for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2971r0.pdf)
### [P2972R0 2023-09 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2972r0.html)
### [P2973R0 Erroneous behaviour for missing return from assignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2973r0.html)
### [P2976R0 Freestanding Library: algorithm, numeric, and random](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2976r0.html)