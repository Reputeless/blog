# ［C++］WG21月次提案文書を眺める（2023年08月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-10)

全部で80本あります。

もくじ

[:contents]

### [N4961 2024-03 Tokyo meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4961.pdf)

2024年3月末に東京で行われるWG21全体会議の案内。

### [N4962 WG21 agenda: 6-11 November 2023, Kona, HI](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4962.html)

2023年11月にハワイのコナで行われるWG21全体会議のアジェンダ。

### [N4963 2023 WG21 admin telecon meetings, rev. 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4963.pdf)

11月の全体会議に先立って行われる、WG21管理者ミーティングの案内。

### [N4964 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4964.pdf)

C++26のワーキングドラフト第2弾

### [N4965 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4965.html)

↑の変更点をまとめた文書。

新規に採択された提案はなく、編集上の変更のみです。また、C++23 DISに対するNBコメントの対応についても記されています。

### [P0447R23 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0447r23.html)
### [P0876R14 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0876r14.pdf)
### [P0952R1 A new specification for `std::generate_canonical`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0952r1.html)

`std::generate_canonical`の仕様を改善する提案。

[`std::generate_canonical`](https://cpprefjp.github.io/reference/random/generate_canonical.html)の現在の規定は、浮動小数点数の仕様を無視しているため誤って制約されています。それによって実質的に正しい実装が不可能になっています。この提案では主に2つの問題について指摘しています。

この関数の動作は次の3つの要件に従うはずです

1. 結果は`[0, 1)`に入らなければならない
2. アルゴリズムは正確に指定されており、使用する`URBG`は指定された引数に対して特定の固定回数だけ呼び出される必要がある
3. 結果は一様分布となる

1つ目の問題は、これらの要件を満たしながらの実装が不可能である点です。現在の規定は、要件2を満たすように正確に数式によって指定されており、結果である`S/Rk`は数学的には1未満の値を返します。しかし、浮動小数点数によってこの式が実行される場合、丸めによってこの結果は正確に`1`になる場合があります。このことは、`generate_canonical`から取得した`x`に対して`(1.0 - x)`で除算している場合にバグを引き起こします。

すなわち、現在の規定では要件2を満たそうとすると、要件1に違反します。結果が`1`になってしまった場合に結果を修正しようとすれば要件3に違反します。要件1と3を満たすようにすると、結果が`1`となる場合にアルゴリズムを再実行する必要があり、それは要件2に違反します。

2つ目の問題は、除算と浮動小数点丸め（最近接偶数丸め）が組み合わさることで出力が均一とならない場合があることです。例えば、`0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5`という値に対して丸めを行うことを考える場合、最下位ビットを切り捨てれば`0, 0, 1, 1, 2, 2, 3, 3`となりこれは一様ですが、浮動小数点数において一般的な最近接偶数丸めを行うと`0, 0, 1, 2, 2, 2, 3, 4`となり偶数と奇数のバランスに偏りが生じる他、0にもバイアスが生じています。

これと同じことが`std::generate_canonical`の計算の過程で発生し、最下位ビットあるいはその周辺の数ビットにおいて結果のバイアスが生じることで最終的な結果の均一性が失われます（この辺りの説明はこの記事を書いている人が理解できていないので、提案の方を参照されるといいと思います・・・）。

この提案は、この2つの問題を`std::generate_canonical`のインターフェースを変更することなく解決するために、アルゴリズムや計算量についての規定を変更することで改善しようとするものです。

この提案は一部の引数の解釈やアルゴリズムそのものを変更することによって、non-trivial divisionを使用せず再近接偶数丸めの問題を回避しようとしています。そのため、副作用や計算量が変化し、また、同じ入力から生成される乱数列も変更前と異なることになります。そのため、それらに依存する既存のコードの動作は実行時に壊れます。

ただし、この提案では`std::generate_canonical`の結果が区間`[0, 1)`内で`RealType`の表現可能な全ての値が含むようにすることは、定義が困難かつ実装が複雑化するとして行っていません。

- [`std::generate_canonical` - cpprefjp](https://cpprefjp.github.io/reference/random/generate_canonical.html)
- [`[0.0, 1.0)` の乱数を得るための“本当の”方法](https://speakerdeck.com/hole/rand01)
- [単精度浮動小数点数 - FC2](https://ieyasu03.web.fc2.com/Computer/CUDA/04_float.html)
- [P0952 進行状況](https://github.com/cplusplus/papers/issues/574)

### [P1144R9 std::is_trivially_relocatable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1144r9.html)
### [P1729R3 Text Parsing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1729r3.html)
### [P1928R7 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r7.pdf)
### [P2019R4 Thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2019r4.pdf)
### [P2075R3 Philox as an extension of the C++ RNG engines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2075r3.pdf)
### [P2267R0 Library Evolution Policies](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2267r0.html)

C++標準ライブラリ設計のためのポリシーについて検討する提案。

ここでのポリシーとは、C++標準ライブラリの将来のユーティリティの提案者が従うべき技術ルールもしくは技術ガイドラインのことです。

この提案では、ポリシーの利点と欠点とを勘案しながら、LEWGのレビューを通過した提案全てに適用されるものとしてのポリシーを設定し、それを常設文書（SD-9）として設定することを提案しています。ただし、提案しているのはポリシーの確立と文書化のプロセスのみで、ポリシーそのものは例示するに留めています。

ポリシーを設定することの利点と欠点としては次のようなものが挙げられています

- 利点
    1. ポリシーによって、標準ライブラリの様々な部分の動作におけるユーザーの期待に対して統一性を持たすことができる
    2. ポリシーによって、提案の著者とレビューする委員会の両方の時間が節約される
    3. ポリシーは共有された知識ベースから作成される必要がある（それによって、それら知識の断片化や解釈の不一致を最小限に抑えることができる）
    4. ポリシーによって、標準化プロセスを新規参入者にとって優しいものにすることができる
- 欠点
    1. ポリシーは、委員会内で少数派領域の代表の意見を押し退けてしまう可能性がある
    2. 提案された一部のユーティリティに対しては、ポリシーによって誤った技術的解決策を強制してしまう可能性がある

欠点でも触れられているように、単一の原則が全てに適合することはなく、あるポリシーについてライブラリ全体の合意に達することには困難が伴います。この提案では、設定されたポリシーは常に強制されるものではなく、ポリシーに違反していることを明示しその理由について説明されていれば、ポリシーを常に守る必要はない、という運用にすることを提案しています。

小さなポリシー1つをとってもライブラリ全体での合意を得るには時間がかかりますが、そのような議論を提案ごとではなくポリシーを確立する1度だけ行っておくことで、長期的には時間の節約になり他の利点を得ることもできる、としています。

- [P2267 進行状況](https://github.com/cplusplus/papers/issues/1646)

### [P2447R5 std::span over an initializer list](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2447r5.html)
### [P2500R2 C++ parallel algorithms and P2300](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2500r2.html)
### [P2542R6 views::concat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2542r6.html)
### [P2642R4 Padded mdspan layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2642r4.html)
### [P2663R4 Proposal to support interleaved complex values in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2663r4.html)
### [P2664R4 Proposal to extend std::simd with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2664r4.html)
### [P2717R3 Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2717r3.html)
### [P2762R2 Sender/Receiver Interface For Networking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2762r2.pdf)
### [P2774R1 Concurrent object pool (was: Scoped thread-local storage)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2774r1.pdf)
### [P2786R3 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2786r3.pdf)
### [P2800R0 Dependency flag soup needs some fiber](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2800r0.html)

依存ライブラリとしてモジュールを使用する際に、必要となる情報について説明する文書。

この文書では、あらゆるプロジェクトにおいて共通する、そのプロジェクトを有意義に活用するために必要な一連の手順があり、その手順のために必要な各種情報（コンパイラ/リンカオプション、動的ローダーの環境変数、プラグインローディング環境変数などを通じて伝達される傾向にあるあらゆるもの）のことをプロジェクトの使用要件（*usage requirement*）と呼んでいます。この使用要件を発見することはビルドシステムの仕事の中核をなしています。

また、その使用要件を収集するための（ツールチェーンに依存する）方法のことをフラグスープ（*flag soup*）と呼んでいます。

この文書は、現在のフラグスープに代わるより構造化された使用要件の伝達手段の必要性を説くものです。

文書の意図は、モジュールを使用するクライアントはクライアントによって異なる使用要件を持ち、同じプロジェクト内でさえも同じモジュールに対して翻訳単位ごとに異なるBMIを取得する可能性があり、現在のフラグスープではその用途のために十分でないことを示すことにあります。また、そのような使用要件をより完全に伝達することができるようにすることで、BMIを再利用しやすくなるメリットもあります。

### [P2809R2 Trivial infinite loops are not Undefined Behavior](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2809r2.html)
### [P2841R1 Concept Template Parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2841r1.pdf)
### [P2845R3 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2845r3.html)
### [P2845R3 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2845r4.html)
### [P2862R1 text_encoding::name() should never return null values](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2862r1.html)
### [P2863R2 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2863r2.html)
### [P2885R3 Requirements for a Contracts syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2885r3.pdf)
### [P2893R1 Variadic Friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2893r1.pdf)
### [P2897R1 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2897r1.html)
### [P2900R0 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2900r0.pdf)

↓

### [P2900R1 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2900r1.pdf)

C++ 契約プログラミング機能の提案。

C++20で一度標準入りしてから撤回され、MVPという最小仕様を確立すべくSG21で議論を重ねられてきました。この提案はC++26に向けて現時点でのContracts MVP仕様をまとめ、それを正式な契約プログラミング機能としてC++26に導入するためのものです。

この提案は大きく設計と文言のセクションに分かれており、設計セクションではMVPの契約機能の構文と意味論について説明され、文言セクションでは設計セクションで説明された機能をC++言語で有効化するための標準のための文言の変更が記載されています（現時点では文言は未整備ですが）。設計セクションを読むことでC++26契約プログラミング機能がどういうものかを把握することができるでしょう。

ただし、現在のところ構文がまだ決まっておらず、いくつか小さめの未解決の問題が残されているため、まだ完全なものではありません。

- [P2900 進行状況](https://github.com/cplusplus/papers/issues/1648)

### [P2911R1 Python Bindings with Value-Based Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2911r1.pdf)
### [P2927R0 Observing exceptions stored in exception_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2927r0.html)

`std::exception_ptr`を再スローせずに例外オブジェクトの取得を試みる関数の提案。

`std::exception_ptr`は例外オブジェクトを型消去して可搬にすることができるラッパー型であり、例外オブジェクトを取り扱いやすくすることに貢献します。しかし、`std::exception_ptr`はかなり制限されたAPIしか持たず、現在参照している例外オブジェクトの型の情報などを取得することができません。

それによって、他のエラー伝達手段と比較してエラーを処理するための方法が制限されます。例えば、`std::optional/std::expected`のようなモナディックインターフェースを実装しようと思うと、`std::exception_ptr`の参照する例外オブジェクトを一旦再スローし、ハンドルされない場合はキャッチして再び`std::exception_ptr`に格納しなおすようなことをしなければならず、これはとても重い処理になります。

この提案はそのために、再スローをすることなく`std::exception_ptr`の例外オブジェクトを取得するためのAPIを追加しようとするものです。

この提案では、`try_cast<T>()`という関数を提案しています。これは、`std::any_cast`や`std::get_if`などとよく似たAPIで、`std::exception_ptr`を引数で渡して`T`に想定する型を指定し、`std::exception_ptr`の参照する例外オブジェクトの型が`T`（もしくはその曖昧でない基底クラスが`T`）である場合に例外オブジェクトへのポインタを返し、そうでない場合は`nullptr`を返します。

```cpp
template <typename T>
const std::remove_cvref_t<T>* 
  try_cast(const std::exception_ptr& e) noexcept;
```

提案文書より、サンプル

```cpp
struct Foo {
  virtual ~Foo() {}
  int i = 1;
};

struct Bar : Foo, std::logic_error {
  Bar() : std::logic_error("This is Bar exception") {}
  int j = 2;
};

struct Baz : Bar {};


int main() {
  const auto exp = std::make_exception_ptr(Baz());

  if (auto* x = try_cast<Baz>(exp)) {
    printf("got '%s' i: %d j: %d\n", typeid(*x).name(), x->i, x->j); 
  }
  if (auto* x = try_cast<Bar>(exp)) {
    printf("got '%s' i: %d j: %d\n", typeid(*x).name(), x->i, x->j);
  }
  if (auto* x = try_cast<Foo>(exp)) {
    printf("got '%s' i: %d\n", typeid(*x).name(), x->i);
  }
}
```

この出力は、例えば次のようになります

```
got '3Baz' what:'This is Bar exception' i: 1 j: 2
got '3Baz' what:'This is Bar exception' i: 1 j: 2
got '3Baz' i: 1
```

`try_cast<T>(exptr)`は、`exptr`の中身を再スローした時に`catch`節に記述してマッチングする型が`T`に指定された場合に例外オブジェクトへのポインタを`const T*`として返し、マッチングしない場合は`nullptr`を返します。

このような機能の実装のためには例外機構に手を加える必要がありそうですが、GCC/MSVC（libstdc++/MSVC STL）は非公開ながらそのような機能を持っており、それぞれの実装者も実装可能であると言っているようです。さらに、metaのfollyというライブラリではこれとよく似た機能がポータブルに実装されており、metaの様々なサービス内部で使用されているようです。

このような機能はまた、将来的にパターンマッチング機能において`std::exception_ptr`のパターンマッチングを可能にすることもできます。

- [［C++］ 例外送出からキャッチまでのあいだ - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2023/05/21/204050)
- [P2927 進行状況](https://github.com/cplusplus/papers/issues/1649)

### [P2932R1 A Principled Approach to Open Design Questions for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2932r1.pdf)
### [P2935R3 An Attribute-Like Syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2935r3.pdf)
### [P2959R0 Container Relocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2959r0.html)

ブロックベースコンテナ（特に`std::vector`）の再配置時の動作を修正する提案。

標準ライブラリのコンテナは主にノードベースコンテナ（`std::list, std::map`など）とブロックベースコンテナ（`std::vector, std::deque`など）の2つに大別することができます。

コンテナが管理する個別のオブジェクトの事を要素（*element*）と呼び、その要素の状態の事を値（*value*）と呼ぶとするとき、要素と値の区別は理論的なもので、この違いが実際のコードで現れることはほとんどありません。

しかし、ノードベースコンテナとブロックベースコンテナの間でこの違いが顕在化する場合があります。

```cpp
using element = std::tuple<int &>;

static_assert(std::is_move_assignable_v<int &>);
static_assert(std::is_move_assignable_v<element>);

template<typename C>
void test() {
  int a = 1;
  int b = 2;
  int c = 3;

  C x;
  x.emplace_back(a);
  x.emplace_back(b);
  x.emplace_back(c);

  std::cout << "a:\t" << a << "\n"                            // 1
            << "b:\t" << b << "\n"                            // 2
            << "c:\t" << c << "\n";                           // 3


  auto const mid = std::next(x.begin());

  std::cout << "x[0]:\t" << std::get<0>(x.front()) << "\n"    // 1
            << "x[1]:\t" << std::get<0>(*mid)      << "\n"    // 2
            << "x[2]:\t" << std::get<0>(x.back())  << "\n";   // 3

  x.erase(mid);

  std::cout << "x[0]:\t" << std::get<0>(x.front()) << "\n"    // 1
            << "x[1]:\t" << std::get<0>(x.back())  << "\n";   // 3

  b = 4;
  c = 5;

  std::cout << "x[0]:\t" << std::get<0>(x.front()) << "\n"    // 1
            << "x[1]:\t" << std::get<0>(x.back())  << "\n";   // 5 or 4
}

int main() {
  test<std::vector<element>>();
  std::cout << "----------------\n";
  test<std::list<element>>();
}
```

- [Wandbox](https://wandbox.org/permlink/X8tx00vk4E3yMeR8)

この実行結果は次のようになります

```
a:	1
b:	2
c:	3
x[0]:	1
x[1]:	2
x[2]:	3
x[0]:	1
x[1]:	3
x[0]:	1
x[1]:	4
----------------
a:	1
b:	2
c:	3
x[0]:	1
x[1]:	2
x[2]:	3
x[0]:	1
x[1]:	3
x[0]:	1
x[1]:	5
```

一番最後の`x[1]`の出力結果だけが異なっています。

`std::tuple<int&>`の構築時は、メンバの参照がコンストラクタ引数のオブジェクトへ束縛されますが、代入時はメンバの参照の切り替えではなくメンバ参照の参照先のオブジェクトへの代入が行われます。

`std::vector`の要素が削除される時、特に中間位置にある要素が削除されるとき、現在のブロック全体を確保しなおすのではなく、削除された位置よりも後ろの要素を前にずらすようにして再配置が行われます。この時、各要素が破棄されてから再構築されるのではなく、ムーブ代入によって要素の移動が起こります。そのため、`x.erase(mid)`では`b`への参照をメンバに持つ`tuple`要素を削除しますが、そこにはすぐ後ろの`c`への参照をメンバに持つ`tuple`が代入されます。それによって、`b = c`のような値の移動が起こり、`vector`から削除されるのは`b`の参照ではなく`c`の参照です。そのため、その後`b = 4`をすると`vector`の2番目の要素からもそれが観測できます。

`std::list`（他ノードベースコンテナ）の場合は単に1つのノードが削除されリンクが修正されるだけなので、このような要素の再利用は起きず、結果は意図通りになります。

このことはまた、`std::vector`そのものの状態によっても挙動に差異が生まれる場合があります。

```cpp
int main() {
  int a = 1;
  int b = 2;

  using element = std::tuple<int &>;
  std::vector<element> v;
  v.reserve(4);
  assert(4 == v.capacity());

  // aの参照で埋める
  auto fill = [&](int & i ) {
    v.clear();
    for (int j = 0; j != 4; ++j) {
      v.emplace_back(i);
    }
  };

  // 真ん中にbの参照を挿入
  auto inject = [&](int & i) { v.emplace(v.begin() + 2, i); };

  // 値と参照先変数名を出力
  auto report = [&] {
    for (auto& j : v) {
      std::cout << std::get<0>(j);
    }

    for (auto& j : v) {
      if (&a == &std::get<0>(j)) {
        std::cout << 'a';
      }
      else if (&b == &std::get<0>(j)) {
        std::cout << 'b';
      }
      else {
        std::cout << '?';
      }
    }

    std::cout << '\n';
  };

  for (int dummy : {1, 2}) {
    fill(a);
    inject(b);
    report();
  }
}
```

- [Wandbox](https://wandbox.org/permlink/IgSef3zD2mLvy2mv)

```
11211aabaa
22222aaaaa
```

`std::vector`のキャパシティの状態によってこの挙動の差異が生じており、キャパシティが丁度4つ分の場合は`inject()`においてブロック再確保が発生し全ての要素は再構築されますが、キャパシティが充足している場合は再確保が発生せず、挿入は再代入によって行われます。

これらの振る舞いは現在の規格の規定に則ったもので、現時点でもこの仕様によって引き起こされる懸念がいくつかありますが、トリビアルリロケーションを考慮するとそれらの懸念はより大きいものになり得ます。そして、この懸念はコンテナの要素型とコンテナのアロケータ型の2つの異なる原因から生じています。

1. ムーブ構築ではなくムーブ代入による要素の置換
    - 要素型のムーブ代入によって、破棄とムーブ構築とは異なる状態が生成される場合、ブロックベースコンテナはノードベースコンテナとは異なる振る舞いをする
2. アロケータは要素の同一性を考慮する必要がある
    - ムーブ代入によって内部再配置が行われる場合に、構築された要素のID（アドレス）が重要である場合、アロケータの`.destroy()`の期待に反する可能性がある
3. 強い例外安全保障が破られる可能性がある
    - アロケータの`construct()`がカスタマイズされている場合、構築時に要素型のコンストラクタ以外から例外が投げられないことを仮定できない
    - 現在のブロックベースコンテナに対する強い例外安全保障は要素型のムーブコンストラクタのみを考慮しており、アロケータを考慮していない
4. トリビアルリロケーションのサポートにおいて問題が起こりうる
    - アロケータが`construct()`を提供する場合、（3と同様の理由により）要素型のトリビアルリロケーション可能性の情報を利用できない
5. 再配置は標準ライブラリの未初期化アルゴリズムと同様にオブジェクトを作成する
    - `<memory>`に現在の`uninitialized_*`系アルゴリズムに対応する、ムーブ構築を基本とし利用可能な場合はリロケーションを利用して最適化する汎用の関数を追加する必要がある

この提案はこれらの懸念に対処するために次のような変更を標準ライブラリに加えることを提案しています

1. ムーブ構築/代入が一貫しない振る舞いをする型のために、新しい型特性を追加する
2. アロケータが独自の実装を提供せず1の特性が`false`となる場合に、現在の動作をデフォルトとする内部再配置（置換）をサポートするための非静的メンバ関数を`std::allocator_traits`に追加する

1つめの新しい型特性は`std::container_replace_with_assignment<T>`というもので、これは`T`のムーブ代入と破棄+ムーブ構築が異なる振る舞いをする（上記の`std::tuple<int&>`のように）ことを通知するものです。

```cpp
namespace std {
  template <class T>
  struct container_replace_with_assignment : is_move_assignable<T>::type {};

  template <class T>
  constexpr bool container_replace_with_assignment_v = container_replace_with_assignment{};
}
```

下位互換性のために、ムーブ代入が可能な型では`true`となるのがデフォルトとされます。意図的に`false`とするには部分特殊化を定義します

```cpp
namespace std {
  template <class ...TYPES>
  struct container_replace_with_assignment<tuple<TYPES...>>
    : conjunction<container_replace_with_assignment<tuple<TYPES>>...>::type
  {};
}
```

2つめの関数は`std::allocator_traits::relocate()`という関数で、これは主にコンテナ内で再配置が起こる場合に再配置の方法をカスタマイズするものです。次のような動作をします

1. アロケータ型が`relocate()`メンバ関数を定義する場合、それを呼び出す
2. アロケータ型が少なくとも1つの`construct()/destroy()`を定義している場合、再配置対象の右辺値を渡してそれらを利用する
3. 要素型がトリビアルコピー可能ならば、`memmove`を利用する
    - トリビアルなリロケーションが導入された場合、それで置き換えられる
4. それ以外の場合、ムーブ代入/構築によって再配置
    - `std::container_replace_with_assignment<T>`が`true`ならばムーブ代入によって再配置（現在の動作）
    - `std::container_replace_with_assignment<T>`が`false`ならば破棄とムーブ構築によって再配置

コードで書くと、次のようになります

```cpp
if constexpr (requires requires{ allocator::relocate(...); }) {
  // forward to allocator::relocate
} else if constexpr(requires requires{ allocator::construct(...); }) {
  // `allocator_traits::destroy(); allocator_traits::construct(rvalue)` each element
} else if constexpr (is_trivially_relocatable_v<T>) {
  // trivially relocate
} else if constexpr (container_replace_with_assignment_v<T>) {
  // move-assign elements
} else {
  // destroy-move-construct elements
}
```

現在動作しているコードは基本的に引き続いて4番目の動作を選択することで動作を維持します。3番目の動作はさらに、トリビアルコピー可能な型に対しての最適化を組み込んでいます。また、4番目の動作では同時に提案している`std::container_replace_with_assignment<T>`を使用してムーブ代入の使用が適切かどうかを判定し、不適切な場合は再配置先要素の破棄の後そこにムーブ構築することで再配置を行います。

これらの変更によって、後方互換性を維持しつつ現在の振る舞いを修正するとともに、将来的なトリビアルリロケーションを適切に有効化することができます。ただし、この提案は現在の実行時の動作を静かに変更する可能性があります。

- [P2959 進行状況](https://github.com/cplusplus/papers/issues/1650)

### [P2961R1 A natural syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2961r1.pdf)
### [P2962R0 Communicating the Baseline Compile Command for C++ Modules support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2962r0.pdf)

Baseline Compile Commandの説明と、それを伝達する方法についての提案。

ある翻訳単位におけるヘッダユニットのインポートは、その翻訳単位のプリプロセッサ状態の影響を受けず、ヘッダユニットはマクロをエクスポートするためヘッダユニットがインポートされるとその翻訳単位のプリプロセッサ状態は更新されます。一方で、ヘッダユニットはその翻訳単位に指定されているコンパイラオプション（コンパイラコマンド）は適用されなければなりません。

ただし、ヘッダユニットのインポートにおいてはその翻訳単位のプリプロセッサ状態を含めたローカルプリプロセッサ引数を適用しないようにする必要があります。この制約は、同じヘッダユニットを異なる翻訳単位でインポートした時でも、双方の翻訳単位において同じようにインポート可能なヘッダをパースするためのものです。特に、推移的なインポートが起こる場合に同じヘッダユニットの内容が異ならないようにするために求められることです。そのため、ローカルプリプロセッサ引数とはある翻訳単位に固有な、コンパイル中のプリプロセッサ状態に影響を与えうる引数のことです。

また、SG15における合意ではビルドシステム以外のものがコンパイルコマンドの構成を行うべきではないというものがあるため、ローカルプリプロセッサ引数の区別を行うのはビルドシステムであるとして、依存関係スキャンプロセス（これを行うのはコンパイラや静的解析ツールなど）にはその翻訳単位自身のコマンドライン引数と、インポートされた全てのヘッダユニットをコンパイルするために使用されるBaseline Compile Commandの2つの入力（コマンドライン引数）が必要となります。

この提案におけるBaseline Compile Commandは、次のような情報のことです

1. どのファイルがコンパイルされるか
2. どのような出力が生成されるべきか
3. ローカルプリプロセッサ引数を含まないコンパイルオプションの一部

ビルドシステムは、各翻訳単位をビルドするために必要なコンパイルコマンドを構成し、そこからBaseline Compile Commandを区別する役割を担います。したがって、ある翻訳単位におけるBaseline Compile Commandはそのコンパイルにおいて使用されるコンパイルオプションの一部分であり、それを区別する方法にはいくつか問題があります。

この提案では、コンパイルオプションからBaseline Compile Commandを独立させてファイルに保存し、依存関係スキャンプロセスへの入力にはコンパイルオプション及びBaseline Compile Commandを記録したファイルパスを渡すようにすることを提案しています。

提案より、LLVMのJSON Compilation Database（いわゆる`compile_commands.json`）をBaseline Compile Commandを含むように拡張する例

```json
{
    "directory": "/path/to/build/dir",
    "file": "/path/to/source/main_translation_unit.cpp",
    "arguments": [ "g++", "-o" ,"main_translation_unit.o",
                   "-DFOO=1", "-DBAR=2", "-I/one/path",
                   "-I/other/path" ],
    "output": "main_translation_unit.o",
    "baseline-arguments": ["g++", "-DFOO=1", "-I/one/path" ]
}
```

一番最後の`baseline-arguments`フィールドがBaseline Compile Commandです。

- [P2898R1 Build System Requirements for Importable Headers - WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P2898R1-Build-System-Requirements-for-Importable-Headers)
- [JSON Compilation Database Format Specification - Clang](https://clang.llvm.org/docs/JSONCompilationDatabase.html)
- [P2962 進行状況](https://github.com/cplusplus/papers/issues/1651)

### [P2967R0 Relocation Is A Library Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2967r0.pdf)

リロケーションサポートのためのライブラリ機能の提案。

この提案はP2786で提案されているトリビアルリロケーションをサポートするための、追加のライブラリ機能を提案するものです。P2786では主にコア言語にトリビアルなリロケーション可能性の概念を提案し、それを検出して活用するために必要な最小限のライブラリ機能のみが提案されています。この提案は、標準ライブラリ全体でトリビアルリロケーションを活用するための機能、特にユーザーが自身のコードでリロケーションを活用するときに必要となる機能についてを提案するものです。

ここで提案されているライブラリ機能は2つだけで、まず1つは`std::relocate()`です

```cpp
namespace std {
  template <class T>
    requires (is_trivially_relocatable_v<T> || is_nothrow_move_constructible_v) && !is_const_v<T>
  constexpr T* relocate(T* begin, T* end, T* new_location);
}
```

これは`[begin, end)`の領域にある`T`のオブジェクトを`new_location`の領域へリロケーションするものです。その際、トリビアルではないリロケーションも含めてあらゆる手段でリロケーションを行おうとします。

この関数は次のようなコードと等価な振る舞いをします

```cpp
if constexpr (is_trivially_relocatable_v<T>) {
  // Tがトリビアルリロケーション可能ならそうする
  return std::trivially_relocate(begin, end, new_location);
} else if (less{}(end, new_location) || less{}(new_location + begin - end, begin)) {
  // 未初期化アルゴリズムを使用して、ムーブ&破棄によってリロケーション（領域にオーバーラップがない場合
  std::uninitialized_move(begin, end, new_location);
  std::destroy(begin, end);

  return new_location;
} else if (std::less{}(begin, new_location)) {
  // ↓こんな感じの領域の重なり方をしている場合の処理
  // |begin ...       ... end|
  //                  |nee_location...        ...|

  // 要素ごとにムーブ&破棄によってリロケーション（後から
  while (T* dest = new_location + begin - end; dest != new_location) {
    ::new (--dest) T(std::move(*--end));
    std::destroy_at(end);
  }

  return dest;
} else {
  // ↓こんな感じの領域の重なり方をしている場合の処理
  //                |begin ...       ... end|
  // |nee_location...        ...|

  // 要素ごとにムーブ&破棄によってリロケーション（前から
  while (begin != end) {
    ::new (new_location++) T(std::move(*begin++));
    std::destroy_at(begin);
  }

  return new_location;
}
```

複雑な分岐はほとんど、リロケーション元と宛先の領域がオーバーラップしている場合にも正しく動作させるためのものです。

この関数は効率的なリロケーションのために`T`のムーブコンストラクタが例外を投げないことを求めています。それを満たさない型での使用やイテレータ範囲によって同等のことを行うために、2つ目の機能である`std::uninitialized_move_and_destroy()`が用意されています。

```cpp
namespace std::ranges {
  // イテレータ版
  template<forward_iterator I, sentinel_for<I> S1,
           nothrow-forward-iterator O, nothrow-sentinel-for <O> S2>
    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
  uninitialized_move_and_destroy_result<I, O>
    uninitialized_move_and_destroy(I ifirst, S1 ilast, O ofirst, S2 olast);

  // range版
  template<forward_range IR, nothrow-forward-range OR>
    requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
  uninitialized_move_and_destroy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
    uninitialized_move_and_destroy(IR&& in_range, OR&& out_range); 
}
```

ここでは代表としてRangeアルゴリズムのものを抜粋しましたが、非Rangeのものや並行アルゴリズム、`_n`付きのものも提案されています。

これらのアルゴリズムは未初期化領域`[ofirst, olast)`（`out_range`）に対して`[ifirst, ilast)`（`in_range`）の領域のオブジェクトを、ムーブ&破棄によってリロケーションするものです。

これも含めた未初期化メモリに対するアルゴリズム全体の指定として、例外がスローされた場合は出力領域は未初期化状態にリセットされます。また、既存の未初期化メモリに対するアルゴリズムと同様に、事前条件で入出力領域がオーバーラップしていないことを求めており、`std::relocate()`とは異なりオーバーラップ領域には使用できません。

- [P2786R0 Trivial relocatability options - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2786R0-Trivial-relocatability-options)
- [P2967 進行状況](https://github.com/cplusplus/papers/issues/1652)

### [P2971R1 Implication for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2971r1.pdf)
### [P2978R0 A New Approach For Compiling C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2978r0.html)

ビルドシステムとコンパイラが相互にやり取りをするためのAPIの提案。

現在のC++のコンパイルは、人間かビルドシステムがコンパイラの実行ファイルを呼び出すことで行われています。提案によれば、ビルドシステムがコンパイラの機能を実行ファイルではなく共有ライブラリ経由で使用するようにすることで25~40%のコンパイル速度向上が見込めるとのことです。

速度が向上する理由は次の2点です

1. ビルドシステムはAPIを利用してコンパイラが読み込んだファイルを知ることができる。その情報を利用すれば、複数のファイルのコンパイルで同じキャッシュファイルを使用可能になる
2. モジュールのビルドにおいては、本ビルドの前にモジュール間の依存関係を調べる必要がある。その役割は基本的にコンパイラが担っているが、APIを使用することでビルドシステムがその解決を行うことができ、依存関係スキャンを行う必要がなくなる

ビルドシステムがコンパイラの持つ情報を得ようとすると一々コンパイラを呼び出す必要があり、それはオーバーヘッドが大きいため現在は避けられているか時間がかかっています。API経由でコンパイラの個別機能を使用することでビルドシステムの任意のタイミングでその情報を得られるようになり、そのコストはおそらくコンパイラを呼び出すオーバーヘッドよりもかなり小さくなると思われます。

この提案ではWindows11上のMSVCを使用したSFLMおよびLLVMのコンパイル時間の分析を行うことでその効果を見積もっており、25~40%のコンパイル速度向上が見込めるとしています。主に、翻訳単位それぞれでの依存関係スキャンをスキップできることと、コンパイル全体で読み取る必要のあるファイル数を削減すること、立ち上げるべきプロセス数の削減によって高速化されるようです。

提案しているAPIは次のようなものです。これはおそらくC++標準ではなくSG15（Tooling Study Group）で議論中のEcosystem International Standardに対して適用されるものだと思われます。

```cpp
namespace buildsystem {

  struct string {
    const char *ptr;
    unsigned long size;
  };

  // Those char pointers that are pointing to the path are platform dependent i.e. whcar_t* in-case of Windows
  struct compile_output {
    // completed == false : コンパイラ状態へのポインタ
    // それ以外の場合 : nullptr
    void *compiler_state;

    // completed == true : コンパイラの出力メッセージ
    // それ以外の場合 : nullptr
    string stdout;
    string stderr;

    // completed == true : コンパイラが待機しているモジュール名orヘッダユニットのビルド済モジュールorヘッダユニット名（すなわち依存関係の情報）
    // それ以外の場合 : エクスポートされたモジュールがある場合その論理名
    string wait_string_or_logical_name;

    // インクルードされているヘッダの数と名前（パス）
    unsigned long header_includes_count;
    string *header_includes;

    // コンパイル成果物のファイル名、パス、数
    string *output_files;
    string *output_files_paths;
    unsigned short output_files_count;

    // コンパイラがモジュールの入力を待っている場合true
    bool waiting_on_module;

    // コンパイルが完了していれば（エラーでも）true
    bool completed;

    // completed == trueの場合、コンパイルエラーが起きていればtrue、成功していればfalse
    bool error_occurred;
  };

  compile_output new_compile(string compile_command, string (*get_file_contents)(string file_path));
  compile_output resume_compile(void *compiler_state, string bmi_file);
  string get_object_file(string bmi_file);

} // namespace buildsystem
```

このようなAPIをコンパイラ共有ライブラリが提供し、ビルドシステムはこのAPIを介してコンパイラとコンパイルを制御します。

`new_compile()`にコンパイラオプションを引数として渡してコンパイルを開始します（このオプションには依存関係の情報は含まれていません）。その後、コンパイル実行中にモジュールのインポートに遭遇した場合、戻り値の`wait_string_or_logical_name`にその依存関係の名前を指定し`waiting_on_module`を`true`に設定してこの関数はリターンします。また、コンパイル実行中にヘッダユニットのインポートに遭遇した場合、`wait_string_or_logical_name`にそのヘッダユニットのパスを指定し`waiting_on_module`を`false`に設定してリターンします。

ビルドシステムは一連のビルドの間で得られた`compiler_state`を保存しておき、必要なファイルが既にビルドされているか、ビルドする必要があるか、ビルド中であるかを管理します。あるビルドが待機しているファイルが利用可能になると、その`compiler_state`と新たに利用可能になったモジュール（ヘッダユニット）のBMIを渡して`resume_compile()`を呼び出すことでコンパイルを再開します。

ビルドが完了すると、コンパイラは`compile_output`オブジェクトの`completed`を`true`に設定し、`output_files`と`output_files_paths`に成果物の名前とパスを設定してリターンします。

ある`compiler_state`に対して依存関係が解消されコンパイルが完了するまで`resume_compile()`は繰り返し呼び出され、それらのビルドは複数並行で行われます。

このAPIの実行モデルでは、コンパイラは依存関係スキャンを行わず依存関係（モジュール関連）にぶつかるとそこでコンパイルを一時停止しビルドシステムに制御を返します。ビルドシステムはプロジェクト内の全てのモジュール/ヘッダユニットについて並行的に`new_compile()`を走らせ、その成果物をもって`resume_compile()`を呼び出すことで依存関係を自動的に解決しながらビルドを完了します。

この提案は、API定義を通してそのようなモジュールのビルドモデルを定義しようとしてもいます。

- [HassanSajjad-302/solution5 - Github](https://github.com/HassanSajjad-302/solution5)
- [P2978 進行状況](https://github.com/cplusplus/papers/issues/1653)

### [P2979R0 The Need for Design Policies in WG21](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2979r0.pdf)

LEWG/EWGでの機能設計のための設計ポリシーを整備する提案。

WG21に参加する人々は、C++標準を可能な限り最高のものにする目標を共有していますが、誰もが同じ原則に基づいて設計を選択するわけではありません。そのため、関連するすべての原則が先に合意されない限り設計に関する議論を行き詰まってしまう可能性があります。一見の一致を見た場合でも、投票の後で1つ以上の重要な設計原則について十分な情報が共有されていなかったことが後で反目する場合があります。

この提案では、原則に基づいた設計を採用し、WG21の議論プロセスにおいて、現在のように初めに関連する問題について議論した後に解決策の一つに投票するのではなく、原則に基づいた設計のプロトコルに従ってまず関連する設計原則を明確にした上で優先順位を付けるようにすることを提案しています。

また、そのような設計原則に基づいた決定を文書化して共有することで、別の議論における同様の決定の際に再検討を避け将来の議論を合理化できます。

現在では、そのような設計原則やそれに基づく過去の決定などの情報は属人化しており、その人がたまたまその議論において欠けていることで以前の議論や決定が継承されず、設計に矛盾が生じることが少なからずあったようです。提案では、クラスのデフォルト特殊メンバ関数に対する`noexcept`指定のバージョン間での振る舞いの不一致や、LEWGにおけるラコスルールの軽視の例をあげています。

この提案はそのようなポリシーの概要を説明するもので、具体的な提案は個別の2つの提案で行おうとしています

1. 議論のある設計の決定を仲裁するための原則に基づいたアプローチ (P3004)
2. 確立された設計ポリシーを文書化してアクセスするための体系的なメカニズム（P3005）

なお、これらの提案はまだ公開されていません。

- [P2979 進行状況](https://github.com/cplusplus/papers/issues/1654)

### [P2980R0 A motivation, scope, and plan for a physical quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2980r0.html)

物理量と単位を扱うライブラリ機能の導入について説明する提案。

この提案では、物理量と単位を扱うライブラリを導入する理由やモチベーションを説明し、設計目標や現時点での例を示すものです。

モチベーションとしては次のようなものが挙げられています

- 安全性
    - 単位を間違えた計算がコンパイルエラーとなる
    - 物理量とその単位を扱うライブラリは多くの機械の制御コードの安全性を向上させる
- 語彙型となること
    - ベンダーがそれぞれ独自実装をしなくてよくなる
- 認証されたライブラリ
    - MISRA等の安全性基準に従ったソフトウェア開発においてはOSSを使用できない場合が多い
    - 標準ライブラリとして提供されていることでより安全なコードを記述できるようになる
- 独自実装は複雑で難しい
- 拡張性
    - 非SI単位などに対応するために単位の追加を容易にする
- 幅広いドメインで使用可能（されている）

提案より、サンプルコード

```cpp
// mp-unitsというライブラリで試験実装が行われている
#include <mp-units/systems/si/si.h>

using namespace mp_units;
using namespace mp_units::si::unit_symbols;

// 単純な数値計算
static_assert(10 * km / 2 == 5 * km);

// 単位変換
static_assert(1 * h == 3600 * s);
static_assert(1 * km + 1 * m == 1001 * m);

// 組立量
static_assert(1 * km / (1 * s) == 1000 * m / s);
static_assert(2 * km / h * (2 * h) == 4 * km);
static_assert(2 * km / (2 * km / h) == 1 * h);

static_assert(2 * m * (3 * m) == 6 * m2);

static_assert(10 * km / (5 * km) == 2 * one);

static_assert(1000 / (1 * s) == 1 * kHz);
```

```cpp
#include <mp-units/format.h>
#include <mp-units/ostream.h>
#include <mp-units/systems/international/international.h>
#include <mp-units/systems/isq/isq.h>
#include <mp-units/systems/si/si.h>
#include <iostream>

using namespace mp_units;

constexpr QuantityOf<isq::speed> auto avg_speed(QuantityOf<isq::length> auto d,
                                                QuantityOf<isq::time> auto t)
{
  return d / t;
}

int main()
{
  using namespace mp_units::si::unit_symbols;
  using namespace mp_units::international::unit_symbols;

  constexpr quantity v1 = 110 * km / h;
  constexpr quantity v2 = 70 * mph;
  constexpr quantity v3 = avg_speed(220. * km, 2 * h);
  constexpr quantity v4 = avg_speed(isq::distance(140. * mi), 2 * isq::duration[h]);
  constexpr quantity v5 = v3.in(m / s);
  constexpr quantity v6 = value_cast<m / s>(v4);
  constexpr quantity v7 = value_cast<int>(v6);

  std::cout << v1 << '\n';                // 110 km/h
  std::cout << v2 << '\n';                // 70 mi/h
  std::println("{}", v3);                 // 110 km/h
  std::println("{:*^14}", v4);            // ***70 mi/h****
  std::println("{:%Q in %q}", v5);        // 30.5556 in m/s
  std::println("{0:%Q} in {0:%q}", v6);   // 31.2928 in m/s
  std::println("{:%Q}", v7);              // 31
}
```

この提案及び将来的に標準に導入しようとしているライブラリ機能は、[mp-units](https://github.com/mpusz/mp-units)というライブラリで試験実装が進められています。

提案ではこの機能をC++29に導入することを目指しており、そのための機能ごとのカテゴライズやその中での優先順位付けを行っています。掲載されている予定表によれば、C++26サイクル中にLEWGのレビューを完了し、C++29サイクル中でLWGの承認を取り付け、標準に導入するような予定を組んでいるようです（詳細な予定表が提案にはあります）。ただし、まだ確度の高いものではなく、計画をLEWGに承認してもらってスムーズに進めようとしています。

- [mpusz/mp-units - Github](https://github.com/mpusz/mp-units)
- [P2980 進行状況](https://github.com/cplusplus/papers/issues/1655)

### [P2981R0 Improving our safety with a physical quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2981r0.html)
### [P2982R0 std::quantity as a numeric type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2982r0.html)
### [P2984R0 Reconsider Redeclaring static constexpr Data Members](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2984r0.html)
### [P2985R0 A type trait for detecting virtual base classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2985r0.html)
### [P2986R0 Generic Function Pointer](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2986r0.html)
### [P2988R0 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2988r0.html)
### [P2989R0 A Simple Approach to Universal Template Parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2989r0.pdf)
### [P2990R0 C++ Modules Roadmap](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2990r0.html)
### [P2991R0 Stop Forcing std::move to Pessimize](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2991r0.html)
### [P2992R0 Attribute [[discard]] and attributes on expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2992r0.html)
### [P2994R0 On the Naming of Packs](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2994r0.html)
### [P2995R0 SG16: Unicode meeting summaries 2023-05-24 through 2023-09-27](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2995r0.html)
### [P2996R0 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r0.html)
### [P2997R0 Removing the common reference requirement from the indirectly invocable concepts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2997r0.html)
### [P2999R0 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r0.html)
### [P3001R0 std::hive and containers like it are not a good fit for the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3001r0.html)
### [P3002R0 Guidelines for allocators in new library classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3002r0.pdf)
### [P3003R0 The design of a library of number concepts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3003r0.pdf)
### [P3008R0 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3008r0.html)
### [P3009R0 Injected class name in the base specifier list](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3009r0.pdf)
### [P3010R0 Using Reflection to Replace a Metalanguage for Generating JS Bindings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3010r0.pdf)
### [P3011R0 Supporting document for Hive proposal #1: outreach for evidence of container-style use in industry](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3011r0.pdf)
### [P3012R0 Supporting document for Hive proposal #2: use of std::list in open source codebases](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3012r0.pdf)
### [P3014R0 Customizing std::expected's exception](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3014r0.html)
### [P3015R0 Rebuttal to Additional format specifiers for time_point](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3015r0.html)
### [P3016R0 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3016r0.html)
### [P3018R0 Low-Level Integer Arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3018r0.pdf)
### [P3019R0 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3019r0.pdf)
### [P3020R0 2023-09 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3020r0.html)
### [P3021R0 Unified function call syntax (UFCS)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3021r0.pdf)
### [P3022R0 A Boring Thread Attributes Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3022r0.html)
### [P3023R0 C++ Should Be C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3023r0.html)
