# ［C++］WG21月次提案文書を眺める（2024年01月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-02](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-02)

全部で112本あります。

もくじ

[:contents]

### [P0493R5 Atomic maximum/minimum](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
### [P0843R10 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0843r10.html)
### [P0876R15 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0876r15.pdf)
### [P1061R7 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1061r7.html)
### [P1144R10 std::is_trivially_relocatable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1144r10.html)
### [P1729R4 Text Parsing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1729r4.html)
### [P2047R7 An allocator-aware optional type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2047r7.html)
### [P2075R4 Philox as an extension of the C++ RNG engines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2075r4.pdf)
### [P2249R5 Mixed comparisons for smart pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2249r5.html)
### [P2249R6 Mixed comparisons for smart pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2249r6.html)
### [P2299R4 `mdspan`s of All Dynamic Extents](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2299r4.html)

これはどうやら間違って公開されたようで、内容はR3と同一です。

- [P2299R3 mdspans of All Dynamic Extents - WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P2299R3-mdspans-of-All-Dynamic-Extents)

### [P2389R0 `dextents` Index Type Parameter](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2389r0.html)

`std::dextents`から、整数型の指定を省略する提案。

`std::dextents`は`std::mdspan`のインデックス指定のためのもので、次元数だけを静的に指定しておいて、次元ごとの要素数は動的に指定するものです。

```cpp
import std;

// int型2x2行列
using imat22 = std::mdspan<int, std::extents<std::size_t, 2, 2>>;

// int型4x3行列
using imat43 = std::mdspan<int, std::extents<std::size_t, 4, 3>>;

// int型2次元行列
using imatnn = std::mdspan<int, std::dextents<std::size_t, 2>>;

int main() {
  int data[] = { ... };

  // 2x2行列
  imatnn mat22{data, 2, 2};
  // 4x3行列
  imatnn mat43{data, 4, 3};
}
```

すなわち、`dextents<size_t, 2>`は`extents<size_t, dynamic_extent, dynamic_extent>`の略記です。

当初の`mdspan`では`extents/dextents`の使用する整数型（インデックス型）は`std::size_t`で固定でしたが、P2533によってそれが変更可能となり、それに伴って`extents/dextents`はテンプレートパラメータリストの最初で使用する整数型を受け取るようになりました。

特に`dextents`ではこれによって、本来できていた`dextents<2>`を`dextents<std::size_t, 2>`のように書かなければならなくなり、わずらわしさが増加しています。

インデックス型のカスタマイズは重要な機能ですが、多くのユーザーはその変更を考慮する必要が無いため、`dextents`はデフォルトで`std::size_t`を使用するようにしておこうとする提案です。

```cpp
// これを
using imatnn = std::mdspan<int, std::dextents<std::size_t, 2>>;

// こう書けるようにする
using imatnn = std::mdspan<int, std::dextents<2>>;
```

この実現方法としては、ソースの破壊的変更を受け入れて`std::dextents`のテンプレートパラメータを入れ替えることを提案しているようです。

```cpp
namespace std {
  // 現在の宣言
  template <typename IndexType, std::size_t Rank>
  using dextents = ...;
}
```

これは、現在`std::dextents<std::size_t, 2>`と書いているところを`std::dextents<2, std::size_t>`と書くようにしなければならなくなるので、破壊的変更となります。

LEWGのレビューでは、破壊的変更を回避して`std::dims`という新しいエイリアステンプレート？を追加してこの問題の解決とすることで合意が取れているようです。

```cpp
namespace std {

  template <typename IndexType, std::size_t Rank>
  using dextents = ...;

  // 追加
  template <std::size_t Rank, typename IndexType = std::size_t>
  using dims = dextents<IndexType, Rank>
}
```

- [`std::extents` - cpprefjp](https://cpprefjp.github.io/reference/mdspan/extents.html)
- [P3086 進行状況](https://github.com/cplusplus/papers/issues/1743)

### [P2422R0 Remove nodiscard annotations from the standard library specification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2422r0.html)

規格署における標準ライブラリの関数から、`[[nodiscard]]`を取り除く提案。

`operator new`等をはじめとして、現在の標準ライブラリの一部の関数にはその戻り値を捨てることが望ましくないことから`[[nodiscard]]`が付加されています。この提案は、標準ライブラリの規定としてそれを取り除くとともに、今後も追加しないことを提案するものです。

その理由としては

- その注釈を行うかどうかは、実装品質の問題
- 何も指定しないため、規格書にあるべきかは疑問
- 委員会の時間を消費することなく、一律的に利用可能にすることができる
- 一律的に利用可能にするためには、実装の分析と経験が必要
- この注釈を付加することが適切であるかの判断は場合によって困難であり、実装後の経験によって変更される可能性がある

としています。

`[[nodiscard]]`の注釈を付加することを決定するためには想像よりも多くの作業と時間を必要とする一方で、それによるメリットはあまり大きくなく、規格書に対してではなく各実装に対してその検討を促してほしい、という事のようです。

この提案では現在標準ライブラリの関数に付加されている`[[nodiscard]]`をすべて取り除くとと主に今後も付加しないことを基本とし、代わりに別の文書で`[[nodiscard]]`を付加することを推奨する標準ライブラリ中の関数をまとめておくことを提案しています。

- [P2422 進行状況](https://github.com/cplusplus/papers/issues/1744)

### [P2643R2 Improving C++ concurrency features](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2643r2.html)
### [P2686R3 constexpr structured bindings and references to constexpr variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2686r3.pdf)
### [P2688R1 Pattern Matching: `match` Expression](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2688r1.pdf)
### [P2721R0 Deprecating function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2721r0.pdf)
### [P2727R4 std::iterator_interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2727r4.html)
### [P2746R4 Deprecate and Replace Fenv Rounding Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2746r4.pdf)
### [P2758R2 Emitting messages at compile time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2758r2.html)
### [P2781R4 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2781r4.html)
### [P2786R4 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r4.pdf)
### [P2822R0 Providing user control of associated entities of class types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2822r0.pdf)

ADLにおいて考慮される関連名前空間を制御する言語機能提案。

ADLでは、非修飾名（名前空間指定なし）の関数呼び出しに際して、関数に渡されている引数の型の情報を用いてその関数を見つけようとします。

```cpp
template<typename T>
void adl_example(T a) {
  NS::f(a); // 修飾名呼び出し、ADLは行われない
  f(a);     // 非修飾名呼び出し、ADLが行われる
}
```

この例では、`adl_example()`内部から`f`という名前を探索する必要があり、`f(a)`の呼び出しでは非修飾名探索が行われます。ここで何も見つからない場合、次にADLによって引数`a`の型`T`の関連情報から`f`という推定関数名を探索します。

ADLは関数オーバーロードの探索のために必須であり、同時に関数によるカスタマイゼーションポイントを提供する役目も担っています。

この時、ADLによって探索が行われる場所のことを関連エンティティ（*associated entities*）と呼びます。これは、ADLによって関数呼び出しに渡されている引数型（クラス型）`T`に対して、次のもので構成される集合です

- `T`自身
- `T`の直接/間接の基底クラス
    - それらの関連エンティティは含まれない
- `T`がネストしたクラス型ならば、`T`を直接囲んでいるクラス型
    - 直接のもののみで、その外側のクラス型は含まれない
    - 囲んでいるクラス型の関連エンティティは含まれない
- `T`がクラステンプレートの特殊化であれば
    - そのテンプレート引数を`A`とすると、`A`の関連エンティティ
    - そのテンプレートテンプレート引数として使用されているテンプレート

ここでのエンティティとはほぼクラス型のことです。

これらの関連エンティティのそれぞれごとに、そのエンティティのフレンドとして宣言されたADL対象の名前を持つ関数を探索し、さらにエンティティの関連名前空間（そのエンティティを囲う最も内側の非インライン名前空間とそのエンティティを囲う最も内側のインライン名前空間の集合）でもADL対象の名前を持つ関数を探索します。

この時、関連エンティティ及び関連名前空間の定義が複雑かつ予測しづらいことによって予期しない関数が呼び出される場合があり、長年問題になってきました（C++ ADLとかでググれば事例をいくつも見つけられるでしょう）。特に、クラステンプレートのテンプレート引数が関連エンティティに含まれてしまうというのが驚きの呼び出しに繋がります。そのほかにも

- 関連エンティティが増加することによるコンパイル時間増大
- 同名の候補がいくつも見つかる場合にエラーメッセージが膨大になる
- 予期しないテンプレートのインスタンス化が起こる
    - 関連エンティティとして`T`の基底クラスを見に行くため、`T`がインスタンス化される

などの問題があります。これらの解決のための提案もいくつか出されたものの、後方互換の問題や実装経験の乏しさなどもあり、解決策は確立されませんでした。

この提案ではADLによる問題の解決のために、クラス型の宣言ごとに関連名前空間を明示的に指定できるオプトイン構文を用いることによって、ADLの関連エンティティを制御することができるようにしようとするものです。

提案しているのは、`namespace(...)`というものをクラス型宣言内でクラス名の後においておくものです。`...`にはADLの関連エンティティもしくは関連名前空間として含めたいものを指定し、空にすることもできます。

```cpp
// 関連エンティティは自身のみ
template<typename T>
class example namespace()
{ /* ... */ };

// some_containerの関連エンティティとして、要素型Tを追加
template<typename T, typename Alloc>
class some_container namespace(T)
{ /* ... */ };

// 関連エンティティのルールは現在と同様
class normal_adl
{};
```

`namespace(...)`に指定することのできるエンティティは型名とクラステンプレート名、および名前空間名の3つのみです。

あるクラス型`C`に対して、`namespace(Ts...)`によって指定された型/テンプレート名`Ts...`は`C`の関連エンティティの設定を上書きし、`C`および`Ts...`のみが関連エンティティとして扱われるようにします。ただし、何かを追加した時でも`namespace()`のように空として指定した時でも、それが指定されているクラス型`C`自身は常に関連エンティティであり続けます。

`namespace(...)`に名前空間名が指定されている場合、ADL探索対象の関連名前空間に指定した名前空間が追加されます。こちらは関連名前空間を上書きせず、関連名前空間は指定したものに加えて、通常通りに関連エンティティの関連名前空間が含まれます。

クラス宣言時に`namespace(...)`を指定しなければ、関連エンティティの設定を現在と同じになります。すなわち、既存のコードの動作を変更しません。

このように、関連エンティティの決定を上書きしなおかつ限定することによって、ADL時の探索対象を限定するとともに、基底クラスやテンプレートパラメータなどの含まれてほしくないものが自動で含まれてしまうのを防ぐことができます。これにより、関連エンティティの検出の手間が減るとともに関連エンティティの削減によってコンパイル負荷を減らすことができ、いたずらに同名候補が増えないことでエラーメッセージを削減でき、意図しないインスタンス化も回避することができます。

`namespace(...)`には型名など指定可能なものをリストとして複数指定することができます。

```cpp
// 複数の型を関連エンティティに追加
template<typename First, typename Second>
struct pair namespace(First, Second)
{ /* ... */ };

// Ts...に含まれる型だけを関連エンティティに追加（基底クラスは含まれない）
template<typename... Ts>
struct tuple namespace(Ts...) : detail::tuple_base<Ts...>
{ /* ... */ };
```

また、本来は関連エンティティとして扱われないような型を関連エンティティに含まれるようにすることもできます。

```cpp
namespace std {
  // NTTP Xの型を関連名前空間に追加する
  template<auto X>
  struct constexpr_v namespace(decltype(X)) {
    ...

    constexpr operator decltype(X) const { return X; }

    ...
  }
}

template<typename T>
void f(T t) {
  std::cout << t << '\n'; // ok

  auto cv = std::c_<T{...}>;

  std::cout << cv << '\n';  // ok、Tを関連エンティティとするADLでTの関数を検出し
                            //     暗黙変換によってTの関数が使用できる
}
```

提案中の`std::constexpr_v`では、ラップしているコンパイル時定数の型が関連エンティティに含まれないことから、ラップしているNTTP値のインターフェースを使用できない問題が指摘されています。これを回避するために、テンプレートパラメータを増やしてNTTP値の型を関連名前空間に入れようとしていますが、この提案ならよりスマートにそれを解決できます。

- [P2781R2 `std::constexpr_v` - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2781R2-stdconstexpr_v)

また、全く関係の無い型を指定することもできます。

```cpp
struct string_like namespace(std::string_view)
{
  
  ...

  operator std::string_view() const noexcept;
  
  ...
};

void f(string_like mystr, std::string_view strv) {
  std::cout << mystr; // ok、string_viewの<<がADLによって発見され暗黙変換によって使用される
  
  // mystrには比較演算子が定義されていないとしても
  bool b = strv == mystr; // ok、string_viewの==が使用される
}
```

この`string_like`は文字列を保持する簡単な型であるとして、現在は`string_like`の値に対するADLからでは`std::string_view`のために定義されている`std`の関数を発見することはできません。この提案の後、このように`std::string_view`を関連エンティティとして追加することで、ADLによってそれを発見し、暗黙変換によって利用することができます。

- [P2822 進行状況](https://github.com/cplusplus/papers/issues/1746)

### [P2835R3 Expose std::atomic_ref's object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2835r3.html)
### [P2845R6 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2845r6.html)
### [P2863R4 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2863r4.html)
### [P2875R3 Undeprecate `polymorphic_allocator::destroy` For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2875r3.pdf)
### [P2893R2 Variadic Friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2893r2.html)
### [P2900R5 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r5.pdf)
### [P2927R1 Observing exceptions stored in exception_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2927r1.html)
### [P2964R0 Allowing user-defined types in `std::simd`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2964r0.html)

現在の`std::simd<T>`の`T`は算術型や複素数型など標準にある数値型に限られています。この提案は、それを少し緩和してユーザー定義型（プログラム定義型）をSIMD要素として使用可能にする提案です。

用途としては、特定の型に保存された信号データや動画像データ、あるいは飽和整数型や固定小数点数型などの特殊な数値型を`std::simd`上で取り扱えるようにすることを目的としています。

この提案のアプローチは、カスタマイゼーションポイントを通して必要な場所に特別な動作を注入するものです。ただし、`std::simd`で使用可能な型としてはトリビアルコピー可能であることを要求しています。

この提案ではまず、`std::simd`のAPIのうち、ユーザー定義型で動作させるためにカスタムが必要なものとそうでないものなどを次の4つに分類します

1. Basic
    - 要素型を使用するために提供されなければならない関数
    - 四則演算など
2. Custom
    - 汎用的に実装できるが、より効率的な実装のためにカスタマイズを提供することもできる関数
    - 符号反転（0から引くというデフォルトを提供できるが、浮動小数点数型の符号ビット反転のように効率実装が可能）など
3. Copy
    - ビット列が何を表しているかを知らなくても、`std::simd`の値間で要素を移動することができる
    - トリビアルコピー可能を要求することで実現
4. Algorithm
    - 何らかの処理を実現するために他の関数（上記3つ）を利用するもの
    - 必要な関数をユーザー定義型が提供していない場合は使用できなくなる
    - アルゴリズムはカスタマイゼーションポイントを提供しない

この中で、カスタマイゼーションポイントの用意が必要なものは上2つのBasicとCustomに分類される関数です。`std::simd`については次の関数群が該当しています

1. Basic
    - 単項演算子
      - `operator~`
    - 二項演算子
      - `+,-,*,/,%,<<,>>,&,|,^`
    - 複合代入演算子
      - `+=,-=,*=,/=,%=&=,|=,^=,<<=, >>=`
    - 比較演算子
      - `operator==`
      - `<,<=,>, >=`
2. Custom
    - コンストラクタ
      - `basic_simd(basic_simd<U>)` : `T`と`U`が異なる場合変換のためのカスタマイゼーションポイントが必要
    - 単項演算子
      - `operator-`
      - `operator!`
    - 比較演算子
      - `operator!=`
    - フリー関数
      - `min`
      - `max`
      - `clamp`
      - 数学関数

この提案では、これらの関数に対してカスタマイゼーションポイントを用意しておくことでユーザー定義型でも`std::simd`が動作可能なようにしようとしています。カスタマイズが提供されていない場合、Basicな関数はコンパイルエラーとなり、Customな関数はデフォルトの実装が使用され実行されます。

上記関数群とは少し性質が異なりますが、そもそも`std::simd`でユーザー定義型を扱うためにはそのストレージをどう用意したらいいのかについての知識が必要となります。この提案では、`std::simd_custom_type_storage<T>`というクラステンプレートを用意して、これをユーザー定義型で特殊化したうえでその入れ子型でストレージ型を指定することを提案しています。

```cpp
namespace std {
  // stdで提供
  template<typename T>
  struct simd_custom_type_storage;
}

// ユーザー定義型に対しては特殊化して使用
template<>
struct std::simd_custom_type_storage<user-defined-type> {
  using value_type = /* some bit container */;
};
```

あるいは（もしくは追加で）、ユーザー定義型が直接これを提供するようにする方法も考えられます

```cpp
struct user-defined-type {
  using simd_storage_type = /* some container */;
};
```

この`simd_storage_type`はユーザー定義型（ここでの`user-defined-type`）と同じサイズであり、相互に`std::bit_cast`可能である必要があります。すなわち、`simd_storage_type`は`user-defined-type`の範囲となるものではなく、`user-defined-type`を表現できる何らかのストレージ型です（ユーザー定義型自身でもok）。例えば、8bit数値8個分のデータに対して64bit整数型を使用する、ようなことが可能です。

このストレージ型のカスタマイズは`std::simd`でユーザー定義型を利用可能にするための必須の操作です。

そのうえで、先程上げた各種単項/二項演算のカスタマイズは、演算子オーバーロードではなく特定の名前付き関数テンプレートのカスタマイズによって行われます。

```cpp
// std::simdに定義されている二項operator+オーバーロード
constexpr friend 
  basic_simd operator+(const basic_simd& lhs, const basic_simd& rhs)
    requires (details::simd_has_custom_binary_plus || details::element_has_plus)
{
    if constexpr (details::simd_has_custom_binary_plus)
      return simd_binary_op(lhs, rhs, std::plus<>{});    // ユーザー定義型を呼び出す
    else
        /* impl-defined */
}
```

`simd_binary_op()`は二項演算のカスタマイズを受ける統一的な名前の関数テンプレートです。このように二項演算でまとめてしまうことで、二項演算の種類ごとに別名のカスタマイゼーションポイントが生えてしまうことを抑止しています。二項演算の種類は第三引数に透過二項演算ファンクたオブジェクトを渡すことで識別します。

単項演算に対しても同様に、`simd_unary_op()`という名前のカスタマイゼーションポイントを提供できます（こちらはタグ型を用意する必要がありますが）。

シフト演算子に関しては対応する既存のファンクタ型が定義されておらず、何かしら対応が必要ですが、この提案（intel内部での実装）では専用のファンクタ型（`std::simd_shift_left<>`など）を追加することを採用しています。

残ったフリー関数については、ADLを利用した単純な関数オーバーロードによってカスタマイズすることを提案しています。

```cpp
template<typename Abi>
constexpr auto abs(const basic_simd<user-defined-type, Abi>& v) {
  return /* special-abs-impl */;
}
```

これは既存の`std::complex`等と共通することです。

この提案の内容はまだ、intelにおける社内実装における設計選択を説明する側面が強く、カスタマイゼーションポイントの提供方法あるいは提供する対象についてはは固まっていません。

- [P2422 進行状況](https://github.com/cplusplus/papers/issues/1748)

### [P2988R2 `std::optional<T&>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r2.pdf)
### [P2988R3 `std::optional<T&>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r3.pdf)
### [P2989R1 A Simple Approach to Universal Template Parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2989r1.pdf)
### [P2992R1 Attribute [[discard("reason")]]](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2992r1.html)
### [P2994R1 On the Naming of Packs](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2994r1.html)
### [P2996R2 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r2.html)
### [P3002R1 Policies for Using Allocators in New Library Classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3002r1.html)
### [P3004R0 Principled Design for WG21](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3004r0.pdf)

原則に基づいた設計のプロセスを紹介する文書。

標準化委員会での議論プロセスにおいて、事前に確認しておくべき設計原則の見落としや軽視による議論の手戻りなどの問題の発生を防止し、提案に関する作業のための時間を節約するために新しい提案が事前に確認しておくべきポリシーを文書としてまとめておこうとする活動が現在なされています。

この文書は、そのようなポリシーを含めて事前に定められた原則に従って提案の内容を評価し設計を進めていく作業プロセスを紹介するものです。

この提案は

- 4章 : 企業イベントにおける会場選択という作業を例にして、プロセスの使用方法を紹介する
- 5章 : 4で紹介したプロセスの詳細な手順の説明
- 6章 : 委員会においてそのプロセスを適用する例を紹介
- 7章 : プロセスに基づいて提案の作業を進めるために、WG21の標準化会議がどのように開催されるべきかについての説明
- 付録 : C++における実際の問題についてプロセスを適用する例をいくつか紹介

のような内容で構成されています。

- [P2267R0 Library Evolution Policies - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2267R0-Library-Evolution-Policies)
- [P2979R0 The Need for Design Policies in WG21 - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2979R0-The-Need-for-Design-Policies-in-WG21)

### [P3005R0 Memorializing Principled-Design Policies for WG21](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3005r0.pdf)

機能提案が満たすべきポリシーそのものについてのプロセスとフレームワークの提案。

P2979やP2267などによって、委員会での議論を効率化するためのポリシーを策定し文書化しておこうとする作業が行われています。この提案では、そうしたポリシーそのものの策定や修正、維持管理プロセスを提案するものです。

- [P2267R0 Library Evolution Policies - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2267R0-Library-Evolution-Policies)
- [P2979R0 The Need for Design Policies in WG21 - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2979R0-The-Need-for-Design-Policies-in-WG21)

### [P3008R1 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3008r1.html)
### [P3016R2 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3016r2.html)
### [P3019R4 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r4.html)
### [P3019R5 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r5.html)
### [P3019R6 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r6.html)
### [P3032R0 Less transient constexpr allocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3032r0.html)

定数式における動的メモリ確保の制限を少しだけ緩和する提案。

C++20では定数式における動的メモリ確保が許可されましたが、定数式中で確保されたメモリはその定数評価の範囲内で解放される必要があり、実行時に持ち越すことはできません。

この制限はコンパイル時に確保したメモリを実行時から参照することを防止するためのものですが、実際には実行時から参照される可能性が無いにも関わらずコンパイル時のメモリ確保が禁止される場合があります。

以下例ではP2996R1で提案中の静的リフレクションを使用しますが、リフレクションを使用することはこの提案の本質の部分とはほぼ関係がありません。意思っておくべきことは、式`E`に対して`^E`は`std::meta::info`型のオブジェクトを返すことと、`enumerators_of()`という関数が`std::meta::info`の`std::vector`を返すことです。

```cpp
namespace std::meta {
  using info = /* ... */;

  consteval vector<info> enumerators_of(info);
}
```

以下、例

```cpp
int main() {
  constexpr int r1 = enumerators_of(^E).size(); // ✅

  return r1;
}
```

`constexpr`変数`r1`の初期化式は定数式であり、`enumerators_of()`から返される`std::vector`はその評価内で破棄されるため、問題ありません。

```cpp
constexpr int f2() {
  return enumerators_of(^E).size(); // ❌
}

int main() {
  constexpr int r2 = f2();

  return r2;
}
```

`r2`の初期化に関しては`r1`と同様ですが、`f2()`は`constexpr`関数であり実行時からも呼ばれる可能性があるため、`consteval`関数呼び出し`enumerators_of(^E)`は即時関数コンテキストに無く、その実行のために新しい定数評価コンテキストを導入します。ただし、そのコンテキスの範囲は`enumerators_of(^E)`のみであり、`enumerators_of(^E).size()`ではなく、`enumerators_of(^E)`の戻り値はその定数評価コンテキストの外側で参照されるために生存するため、定数式で許可されません。

```cpp
consteval int f3() {
  return enumerators_of(^E).size(); // ✅
}

int main() {
  constexpr int r3 = f();
  return r3;
}
```

`f2()`に対して`f3()`は`consteval`関数であり、その本体内のすべてが即時関数コンテキスト内にあります。これによって、`enumerators_of(^E).size()`全体が定数式になり、そこで生成される一時`std::vector<info>`オブジェクトはその評価の内側で破棄されるため、問題なくなります。

```cpp
template<class E>
constexpr int f4() {
  return enumerators_of(^E).size(); // ✅
}

int main() {
  constexpr int r4 = f4<E>();
  return r4;
}
```

`f4()`が`constexpr`関数テンプレートであり、含まれる式`enumerators_of(^E).size()`が`consteval`関数を呼び出しているのに定数式ではない（`f2()`の時と同様の理由によって）ため、関数テンプレート`f4()`は即時関数（`consteval`関数）として扱われ、結果として`f3()`と同じ状態になるため問題ありません。

これは、`constexpr`関数テンプレート内に即時関数呼び出しが含まれている場合に`consteval`関数に直さなくてもそれを呼び出せるようにするために（そのような関数呼び出しは、場合によっては単なる`constexpr`関数呼び出しである可能性もあるため）、関数テンプレートがそのインスタンス化に際して適応的に即時関数に昇格される仕組みによって、`f2()`と異なった結果となります。

```cpp
consteval int f5() {
  constexpr auto es = enumerators_of(^E); // ❌
  return es.size();
}

int main() {
  constexpr int r5 = f();
  return r5;
}
```

`consteval`関数の中で`constexpr`変数を初期化しているため、`es`の初期化式は別の定数評価コンテキストを導入しています。このため、`es`初期化式の評価内で`enumerators_of(^E)`戻り値の`vector`は破棄されなければならないが、されていないため拒否されます。ただしこの場合、`consteval`関数`f5()`の呼び出し内部でコンパイル時`vector`が破棄されることは確実です。

リフレクションを使用していることを除いて、これら5つの例のうち問題の内3つはC++23でも有効です。残りの2つは現時点でも拒否されるものの、実際に実行時までコンパイル時`std::vector`が持ち越されることは無いため、本来問題ないはずの例です。

2つ目の例

```cpp
constexpr int f2() {
  return enumerators_of(^E).size(); // ❌
}
```

`enumerators_of(^E)`は即時関数コンテキストの外側で呼び出される即時関数であり、定数式ではない即時関数呼び出しとなるため、その呼び出しは即時関数呼び出しとして扱われます、しかしその戻り値から呼ばれる`.size()`は単なる`constexpr`関数（定数式）であるため、その即時関数呼び出しの一部ではありません。これによって`enumerators_of(^E).size()`はその評価に異なる2つのコンテキストを含んでしまい、そのコンテキスト間で`std::vector`を移行できないためエラーになります。

これを許可するには、単に`enumerators_of(^E).size()`全体を定数式として扱ってやればよく、`enumerators_of(^E)`の呼び出しが定数式になりうる最も近い囲み式（それを含む式）を定数式として扱うようなことをする必要があります。

5つ目の例

```cpp
consteval int f5() {
  constexpr auto es = enumerators_of(^E); // ❌
  return es.size();
}
```

では`enumerators_of(^E)`の戻り値`std::vector`がその評価を超えて生存することでエラーとなっています。しかし、ここではそれを囲む関数が`consteval`関数であるため、`es`は実行時に参照されることはありません。

これを許可するためには、定数評価内の動的メモリ確保はその評価内で解放される、もしくはその割り当てが即時関数コンテキスト内にある場合はそのコンテキストの終わりで解放する必要がある、のようにすればよさそうです。

まとめると、最初の5つの例のうち拒否される2つの例を許可するようにするには、2つの異なる変更が必要となります

1. 定数式にならない即時関数呼び出しが定数式になるように、それを含むより大きな式を定数式として扱う
2. 定数式における動的メモリ確保に関して、開放のタイミングが同じ評価内にある場合に加えて、同じ直接のコンテキスト内にある場合も許可する

しかし、この2つ目の変更についてはすぐに標準文言の変更を考えることができてその利益も大きいですが、1つ目の変更は文言が複雑になるとともに利益があまり大きくありません（関数を`consteval`にするか、`constexpr`変数の初期化式にすれば回避できるため）。

従って、この提案ではこの2つ目の変更のみを提案しています。

ここまでの例で使用されているように、この変更は静的リフレクションを使用するにあたって遭遇することになるであろう問題を取り除くものでもあります。

- [constexpr関数内でconsteval関数を呼び出せない問題を軽減 - cpprefjp](https://cpprefjp.github.io/lang/cpp23/consteval_needs_to_propagate_up.html)
- [P2564R0 consteval needs to propagate up - WG21月次提案文書を眺める（2023年03月）](https://onihusube.hatenablog.com/entry/2022/04/02/175835#P2564R0-consteval-needs-to-propagate-up)
- [可変サイズをもつコンテナのconstexpr化 - cpprefjp](https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html)
- [P3032 進行状況](https://github.com/cplusplus/papers/issues/1751)

### [P3045R0 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3045r0.html)

物理量と単位を扱うライブラリ機能の提案。

この提案は以前に個別に提出されていた関連提案を1つにまとめて、設計の詳細説明を追加したものです。

それぞれの提案については以前の記事を参照

- [P2980R0 A motivation, scope, and plan for a physical quantities and units library - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2980R0-A-motivation-scope-and-plan-for-a-physical-quantities-and-units-library)
- [P2980R0 A motivation, scope, and plan for a physical quantities and units library - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2980R0-A-motivation-scope-and-plan-for-a-physical-quantities-and-units-library)
- [P2982R0 `std::quantity` as a numeric type - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2982R0-stdquantity-as-a-numeric-type)

以降、物理量と単位のライブラリの標準化作業はこの提案で行われます。

- [P3045 進行状況](https://github.com/cplusplus/papers/issues/1752)

### [P3047R0 Remove deprecated namespace `relops` from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3047r0.html)

`std::relops`を削除する提案。

`std::relops`はクラス型に`< ==`の演算子を定義しておけば残りの比較演算子を自動で実装するものです。しかし、これは同等以上のものがC++20で一貫比較として言語機能に組み込まれたことで非推奨とされていました。

この提案は、これはC++26に向けて削除しようとするものです。

```cpp
#include <cassert>
#include <utility>

struct Test {
  int data = 0;

  friend bool operator==(Test a, Test b){return a.data == b.data;}
  friend bool operator <(Test a, Test b){return a.data <  b.data;}
};

int main() {
  Test x{};
  Test y{2};

  assert(x == x);
  assert(x != y);

  // std::rel_opsをusingする
  using namespace std::rel_ops;

  // rel_opsによって利用可能になる
  assert(x <  y);
  assert(x <= y);
  assert(x >= y);
  assert(x >  y);
}
```

現在はMSVCのみ`rel_ops`の使用に対して非推奨である警告を発するようです。

現在のこのようなコードは

1. `<utility>`ではなく`<compare>`をインクルード
2. `<`の代わりに`<=>`を定義する
    - 典型的な実装であれば`default`指定で良い
3. 利用側で、`std::rel_ops`の`using`を削除する

の3ステップで移行できます。

- [`std::rel_ops` - cpprefjp](https://cpprefjp.github.io/reference/utility/rel_ops.html)
- [P3047 進行状況](https://github.com/cplusplus/papers/issues/1753)

### [P3052R1 view_interface::at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3052r1.html)
### [P3055R1 Relax wording to permit relocation optimizations in the STL](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3055r1.html)
### [P3060R1 Add std::views::upto(n)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3060r1.html)
### [P3068R0 Allowing exception throwing in constant-evaluation.](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r0.pdf)

定数式において`throw`式による例外送出を許可する提案。

現在定数式においては例外送出が許可されていません。そのほかに定数式におけるエラー報告を行うメカニズムが用意されているわけでもないため、定数式におけるエラー処理は省略されるか、`optional`などを使用して侵入的にハンドリングされています。いずれにせよ、エラーを報告するメカニズムを欠いていることで、定数式におけるエラーメッセージ出力はコンパイラに頼るほかなく、ほとんどの場合わかりづらいメッセージが出力されます。

また、P2996で提案中の値ベース静的リフレクションにおいては、エンティティから反射して（`^`によって）取得した鏡像（`std::meta::info`値）に対して作用する`consteval`メタ関数が用意されており、入力が不正であることによってそれらの処理がエラーを返す場合のエラー報告メカニズムとして、例外が最もふさわしいものであることが示唆されています。

この提案は、これらの理由から定数式における例外の送出（`throw`式の評価）およびハンドリング（`try - catch`の実行）を許可するものです。

提案では、定数式における`throw`式の評価を許可し、1つの定数式の評価内において送出された例外がその評価内でキャッチされない場合にコンパイルエラーとするようにしています。

```cpp
constexpr auto just_error() {
  throw my_exception{"this is always an error"};
}

constexpr void foo() {
  try {
    auto v = just_error(); // ok、foo()が定数式で実行される場合、すぐにキャッチされるのでエラーにならない
  } catch (my_exception) { }

  try {
    constexpr auto v = just_error(); // ng、constexpr変数の初期化は別の定数評価コンテキストを構成するが、その評価内でキャッチされない
  } catch (my_exception) { }
}
```

また、この提案では例外を定数式で許可するような言語機能の変更のみを提案していて、`<stdexcept>`にあるような関連するライブラリ機能を定数式で使用可能にすることは提案していません。

- [P2996R1 Reflection for C++26 - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2996R1-Reflection-for-C26)
- [P3068 進行状況](https://github.com/cplusplus/papers/issues/1754)

### [P3072R1 Hassle-free thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3072r1.html)
### [P3073R0 Remove evaluation_undefined_behavior and will_continue from the Contracts MVP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3073r0.pdf)

Contracts MVPのライブラリ仕様から、`evaluation_undefined_behavior`と`will_continue()`を削除する提案。

契約違反時に呼ばれる違反ハンドラの引数には`std::contracts::contract_violation`という型のオブジェクトへの参照が渡され、ここには契約違反時の関連情報が保持されており、メンバ関数を通して取得することができます。

そのうちの1つ、`detection_mode()`は契約違反がどのように起きたか（契約条件が`false`を返した、例外が投げられたなど）を`std::contracts::detection_mode`列挙値によって返します。`std::contracts::detection_mode`の列挙値には未定義動作によって契約違反が発生した場合を意味する`evaluation_undefined_behavior`という値が定義されています。

もう1つ、`will_continue()`は違反ハンドラが正常にリターンした後に違反地点の直後からプログラムが続行されることが期待されているか（違反ハンドラの終了がプログラム終了を意味するか）を`bool`値で取得することができます。

しかし、この2つのものについてはその導入後に、その意味や正しい仕様、動機付けとなる使用例等について未解決の問題が多く報告されたようです。これを受けてこの提案は、この2つのものはC++26で契約を使用できるようにするために必須のものではなく、それらの疑問の解決のための時間を確保するために、C++26に向けての仕様から削除して将来の拡張にすることを提案するものです。

#### `evaluation_undefined_behavior`

`.detection_mode()`が`evaluation_undefined_behavior`を返す場合、契約条件式の評価に伴ってプログラムが未定義動作に陥ることが検出されたことを意味します。この導入の後で、この値の使用方法に関して、UBサニタイザーのようなツールがプログラムの任意の場所で検出した未定義動作について報告するために違反ハンドラを使用するのに活用できることが提案されました。すなわち、違反ハンドラは契約機能を超えて、外部ツールが検出した事項について報告する標準APIとして機能しうるということです。

SG21においてこのアイデアを議論する過程で、`evaluation_undefined_behavior`の意味するところについて疑義が上がり、次のようなことを意味しているかどうかについてコンセンサスがないことが確認されました

- 契約述語の式自体、またはその直接部分式の1つを評価すると未定義動作が発生する可能性がある
- 契約述語の評価中に式を評価すると、その評価中に呼び出される関数の本体内（別の翻訳単位にあるかもしれない）等も含めて、未定義動作が発生する可能性がある
- プログラムの実行中に任意の式を評価すると、契約機能が使用されているかどうかに関係なく未定義動作が発生する可能性がある

外部ツールが実行時にUBを検出する場合にそれを報告するための標準APIを用意するというアイデアについてはSG21でも好意的に受け止められており、そのアプローチが実行されると違反ハンドラによる契約違反処理、サニタイザーによるUBの実行時検出、erroneous behaviourの概念についてを統合したC++における未定義動作を軽減するための包括的な機能を提供することができるようになるかもしれません。

そのような方向性の検討は内部的に行われているようですが、現在のところどのようにそれを実現するかについてはまだほぼ決まっていません。そのための議論もオープンに行われている段階ではなく、今の段階でそれに関する機能を追加してしまうことはそのような将来的な機能の設計自由度を制限することになり、時期尚早であると思われます。

そのために契約違反ハンドラを利用すべきかどうかについてのコンセンサスはなく、利用した場合でも`.detection_mode()`とその列挙値を使用することが適切な設計なのかも不明です。仮にその方向のために`evaluation_undefined_behavior`を利用したとして、`.detection_mode()`がそれを返す場合に`contract_violation`の他のメンバ関数がどう振舞うべきか（他のメンバ関数は当然契約で使用されることを前提としている）に関しても不透明です。

さらには、`evaluation_undefined_behavior`の意味を定義するためには未定義動作の検出についてを扱う必要がありますが、それによって実装可能性の問題にぶつかっており、その正しい規定については現在合意できていないようです。例えば、実装はUB検出能力を提供するべきなのか、翻訳単位を超えた場合にどうするのか、UB検出機能はQoIの推奨程度のものなのかなど、どれを選択するのかとそれをどのように標準文言に落とし込むかについてコンセンサスが得られていないようです。

また、`evaluation_undefined_behavior`を実装及びサニタイザーも含めて何かしらのUB検出の詳細な報告メカニズムとして使用することには使用経験がありません。特に、どこで何が起きたかについての詳細な報告方法、コールバックにどのような引数を提供すべきかについては、現在のサニタイザー実装においても決定的なコンセンサスは見られません。

これらの理由によって、この提案では`evaluation_undefined_behavior`列挙値を削除してC++26には含めないようにし、これらの問題点を解決するための議論や検討、実装の時間を取るようにすることを提案しています。

#### `will_continue()`

`will_continue()`は元々、契約のセマンティクスが*ignore*と*enforce*だけだった時代に追加されたもので、*enforce*セマンティクスとその時点で標準に無かった*observe*セマンティクスを区別することを目的としていました。その後*observe*セマンティクスが正式に標準に追加されたことで冗長になったかに見えましたがユースケースがあるとして残されました。

そのユースケースには次のようなものがあげられています

- 非標準のセマンティクスの検出
    - 契約条件をチェックする非標準のセマンティクスで違反後終了するものを検出して、終了のための対応を行う
    - 違反ハンドラの終了後にプログラムが続行または終了することが何を意味するのか、違反ハンドラが正常終了して元の実行に戻った後が何を意味するのかを規定しなければならない
    - その規定をどう行うかについてのコンセンサスがない
- 未定義動作の実行時検出
    - 戻り値は*enforce*の場合に`false`、*observe*の場合に`true`となると思われるが、規定では後者の場合も`false`になりうる場合がある
    - 提供されている唯一の例は、契約チェック後のパスに未定義動作が含まれている場合にそれを検出することを意図したもの
    - `evaluation_undefined_behavior`と同じ問題がある他、こちらはより目的外利用であると思われる
- セマンティクスのクエリの短縮形
    - 前の2つの用途のいずれにも使用されていない場合、この関数は`semantic() == std::contracts::contract_semantic::observe`の短縮形となる
    - コンテナの`.empty()`が`.size() == 0`の短縮形であるのと同様に、このような仕様は非常に明快であり、この提案で挙げている他の問題に悩まされない
    - ただし、前の2つのような混乱の可能性を標準に追加することを正当化するほど有用であるとは思えない

これらのユースケースにはいずれも問題があるため、`will_continue()`を削除してC++26には含めないようにし、これらの問題点を解決するための議論や検討、実装の時間を取るようにすることを提案しています。

- [P2811R4 Contract Violation Handlers - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2811R4-Contract-Violation-Handlers)
- [P3073 進行状況](https://github.com/cplusplus/papers/issues/1755)

### [P3074R1 std::uninitialized<T>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3074r1.html)
### [P3074R2 std::uninitialized<T>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3074r2.html)
### [P3085R0 `noexcept` policy for SD-9 (throws nothing)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3085r0.html)

ライブラリ関数に`noexcept`を付加する条件についてのポリシーの提案。

標準化作業のためにポリシーを策定する動きを受けて、LEWG/LWGにおいて無条件`noexcept`の付加基準に関するポリシーを検討する提案です。

この提案では、現在の運用に則った次の基準を推奨するポリシーとしています

- LWGとLEWG双方が例外を投げないとして合意された関数についてのみ、無条件`noexcept`を指定する

そのうえで、Lakos Ruleに基づいた次のポリシーについても検討しています

- 事前条件を持つ関数は無条件`noexcept`指定するべきではない

まだどちらがポリシーとして合意されたわけではなく、この提案はこのどちらかをポリシーとして採用することを推奨するものです。

提案では、これに関する過去の議論や実装の状況、様々な論点や意見などを詳細に記録しています。

- [P3085 進行状況](https://github.com/cplusplus/papers/issues/1756)

### [P3088R0 Attributes for contract assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3088r0.pdf)

↓

### [P3088R1 Attributes for contract assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3088r1.pdf)

契約注釈に対して属性を指定できるようにする提案。

C++26に向けて提案中の契約構文は、現在のところ3種類の契約注釈のいずれも属性指定を行うことができません。属性の主な役割は実装に対して独自のコードアノテーションを追加する場所と機能を提供することにあり、契約注釈に対する属性でも有用である可能性があります。

そのようなユースケースとして、契約注釈に対するラベル付があります。契約注釈に対するラベルはC++20の契約仕様には含まれていましたが現時点のMVPには含まれておらず、C++29以降の機能拡張として議論していくことがほぼ確定しています。C++20時点では`audit`というラベルがチェックされないコードの仮定を表現するために提供されていました。

他にも、現在の契約注釈のセマンティクスは実装定義とされますが、それをラベルによって明示的に指定するような用途など、さまざまなラベルを考えることができます。

`audit`など基本的なラベル付けはおそらく将来のC++で提供されますが、C++26の契約注釈に対しても属性構文を指定して実装がラベルを先行提供することで将来のラベルの実装実験を行うことができます。この余白が提供されない場合、実装毎に異なるキーワードや独自の構文などによってそれが行われる可能性があり、移植性や将来の互換性を損ねる可能性があります。

この提案は、そのようなラベル属性を提案するものではなく、3種類の契約注釈に一貫した方法で属性を指定できるようにしておくことを提案するものです。

提案では、契約注釈構文内のキーワードとそれに続く開きかっこの間に属性指定を入れ込む構文を提案しています。

```cpp
bool binary_search(Range r, const T& value)
  pre [[vendor::audit]] (is_sorted(r));

void f() {
  int i = get_i();
  contract_assert [[vendor::assume]] (i > 0); // ...
}
```

属性がどの注釈に適用されているかが明白であり、他の場所（前、後、かっこの中）だと発生する問題が発生しないことからこの場所を選択しています。

また、`noexcept(contract_assert(false))`がどう振る舞うかについての議論を回避するために、現在のMVP仕様では`contract_assert()`は文(*statement*)とされています。これによって、他の文との属性指定方法が一貫しなくなるため、`contract_assert()`の場合にのみその先頭に対しても属性指定を許可することも提案しています。

ただし、文の先頭に対する属性指定はそのアサーション文（*assertion-statement*）に対する属性指定とされ、`contract_assert`の後に中置する属性指定は契約注釈に対する属性指定として区別されます。

```cpp
void f() {
  int i = get_i();

  // 契約注釈に対する属性指定
  contract_assert [[vendor::assume]] (i > 0);

  // アサーション文に対する属性指定
  [[likely]] contract_assert(i > 0);
}
```

この違いは、契約注釈に対する属性指定（中置）なのか、文に対する属性指定（先頭）なのかの違いです。

- [P3088 進行状況](https://github.com/cplusplus/papers/issues/1757)

### [P3090R0 `std::execution` Introduction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3090r0.pdf)

P2300のsender/receiverベース非同期処理ライブラリの紹介をする文書。

P2300のライブラリ機能がどういうもので何を目的としているかやその設計についてが簡単に紹介され、サンプルコードとともにその機能の解説が行われています。

### [P3091R0 Better lookups for `map` and `unordered_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3091r0.html)
### [P3092R0 Modules ABI requirement](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3092r0.html)
### [P3093R0 Attributes on expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3093r0.html)

式に対して属性を指定できるようにする提案。

現在のC++において、属性の指定は実際には文に対して行われており、式に対して属性を指定することができません

```cpp
// 全てNGな例

// 関数呼び出し式に対する属性指定
([[attr]] f(1, 2, 3));

// 関数引数の式に対する属性指定
process(([[lock]] g()), 42);

// カンマ式中の部分式に対する属性指定
for (int i = 0; i < N; ++i, ([[discard]] f()))
  doSomething(i);

// メンバ初期化子リスト内の初期化式に対する属性指定
struct S {
  S(int i)
      : m_i(([[debug_only(check(i))]] i)) {}

  int m_i;
};
```

この提案は、これらのような式に対する属性指定を許可しようとするものです。

この提案は`[[discard]]`属性を提案するP2922から分離されたもので、モチベーションはこの属性を関数呼び出しが可能な任意の場所に書けるようにすることにあります。

```cpp
// 戻り値を無視してほしくない関数
[[nodiscard]]
int f(int i);

// 文に対する属性指定、現在も可能
[[discard("f always succeeds for 42")]] f(42);

// 式に対する属性指定、この提案
for (int i = 0; i < N; ++i, ([[discard("f succeeds for inputs >= 0")]] f(i)))
  doSomething(i);
```

他にも、P2946の`[[throws_nothing]]`属性を同様に関数呼び出しに対して指定可能にすることにも使用可能です

```cpp
// 文に対する属性指定
[[throws_nothing]] f(42);

// 式に対する属性指定
struct S {
  S(int i)
    : m_i(([[throws_nothing]] f(i))) {}

  int m_i;
};
```

この場合、`f()`は狭い契約を持つ（何らかの事前条件を持つ）関数であり、通常無条件`noexcept`ではありません。しかし、呼び出し側でその事前条件を満たしていることを確認していることをこの属性の付加によってコンパイラに伝達することで、例外処理周りのコード生成をスキップすることができ、`noexcept`が指定されている場合の恩恵をアドホックに適用することができます。

属性が文にしか指定できないのは意図的なもののようで、属性を導入した提案（N2761）によれば式に対する何らかの属性指定にはキーワードを導入すべき、としています。しかし、キーワードの追加はとてもハードルが高く、属性のように無視できるという性質がありません。

提案では、C++の現行文法における式の最上位である*assignment-expression*に対して*attribute-specifier-seq*（属性文法）を適用可能にすると現在可能な文に対する属性指定と衝突するためそれは提案せず、代わりに*parenthesized expressions*（`()`に囲まれた式）の内側の*expression*に対して*attribute-specifier-seq*を指定可能にすることを提案しています。

```cpp
primary-expression:
    literal
    this
    ( attribute-specifier-seq(opt) expression )
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    id-expression
    lambda-expression
    fold-expression
    requires-expression
```

この上で、セマンティクスの指定を追加して、この属性指定がその隣にある括弧の中の*expression*に対して適用されるようにします。

```cpp
int a[10];

[[attr]] a[0] = x + y;      // 文に対する属性指定
([[attr]] a[1]) = x + y;    // 式`a[1]`に対する属性指定
a[2] = [[attr]] x + y;      // ill-formed
a[3] = ([[attr]] x) + y;    // 式`x`に対する属性指定
a[4] = ([[attr]] x + y);    // 式`x + y`に対する属性指定
a[4] = ([[attr]] (x + y));  // 同上
([[attr]] a[6] = x + y);    // 式`a[6] = x + y`に対する属性指定


// attr1はrequires式全体に適用される
// attr2は式`c.foo()`に適用される
// attr3は式`*c`に適用される
template <typename T>
concept C =
  ([[attr1]] requires (C c)
    {
        ([[attr2]] c.foo());
        { ([[attr3]] *c) } -> convertible_to<bool>;
    });


// attr1は文に対する属性指定
// attr2は式全体に適用される
// attr3はラムダ式の関数呼び出し演算子に適用される
// attr4はラムダ式の関数型に適用される
[[attr1]] ( [[attr2]] [] [[attr3]] () [[attr4]] {} () );
```

`()`が冗長に見えますが、`()`が必要である事によって属性がどの式に対して適用されているかが明確になるメリットもあります。

この新しい文法は、最初に示した例をすべて許可します

```cpp
// この提案後OKになる

// 関数呼び出し式に対する属性指定
([[attr]] f(1, 2, 3));

// 関数引数の式に対する属性指定
process(([[lock]] g()), 42);

// カンマ式中の部分式に対する属性指定
for (int i = 0; i < N; ++i, ([[discard]] f()))
  doSomething(i);

// メンバ初期化子リスト内の初期化式に対する属性指定
struct S {
  S(int i)
      : m_i(([[debug_only(check(i))]] i)) {}

  int m_i;
};
```

- [P2992R0 Attribute `[[discard]]` and attributes on expressions - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2992R0-Attribute-discard-and-attributes-on-expressions)
- [P3093 進行状況](https://github.com/cplusplus/papers/issues/1761)

### [P3094R0 std::basic_fixed_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3094r0.html)
### [P3095R0 ABI comparison with reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3095r0.pdf)
### [P3096R0 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3096r0.pdf)
### [P3101R0 Differentiating potentially throwing and nonthrowing violation handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3101r0.pdf)
### [P3102R0 Refining Contract Violation Detection Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3102r0.pdf)
### [P3103R0 More bitset operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3103r0.html)
### [P3104R0 Bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3104r0.html)
### [P3105R0 constexpr std::uncaught_exceptions()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3105r0.html)
### [P3106R0 Clarifying rules for brace elision in aggregate initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3106r0.html)
### [P3107R0 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r0.html)
### [P3109R0 A plan for std::execution for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3109r0.html)
### [P3110R0 Array element initialization via pattern expansion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3110r0.html)
### [P3112R0 Specify Constructor of std::nullopt_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3112r0.html)
### [P3113R0 Slides: Contract assertions, the noexcept operator, and deduced exception specifications](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3113r0.pdf)
### [P3114R0 noexcept(contract_assert(_)) -- slides](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3114r0.pdf)
### [P3115R0 Data Member, Variable and Alias Declarations Can Introduce A Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3115r0.pdf)
### [P3116R0 Policy for explicit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3116r0.html)
### [P3117R0 Extending Conditionally Borrowed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3117r0.html)
### [P3122R0 [[nodiscard]] should be Recommended Practice](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3122r0.html)
### [P3123R0 2024-02 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3123r0.html)
### [P3126R0 Graph Library: Overview](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3126r0.pdf)
### [P3127R0 Graph Library: Background and Terminology](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3127r0.pdf)
### [P3128R0 Graph Library: Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3128r0.pdf)
### [P3129R0 Graph Library: Views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3129r0.pdf)
### [P3130R0 Graph Library: Graph Container Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3130r0.pdf)
### [P3131R0 Graph Library: Graph Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3131r0.pdf)
### [P3133R0 Fast first-factor finding function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3133r0.html)
### [P3135R0 Hazard Pointer Extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3135r0.pdf)
### [P3136R0 Retiring niebloids](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3136r0.html)
### [P3137R0 views::to_input](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3137r0.html)
### [P3138R0 views::cache_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r0.html)
### [P3140R0 std::int_least128_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3140r0.html)
### [P3142R0 Printing Blank Lines with println](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3142r0.pdf)
### [P3143R0 An in-depth walk through of the example in P3090R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3143r0.pdf)
### [P3144R0 Deprecate Delete of Incomplete Class Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3144r0.pdf)
### [P3146R0 Clarifying std::variant converting construction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3146r0.html)
### [P3147R0 A Direction for Vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3147r0.pdf)
### [P3148R0 Formatting of chrono Time Values](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3148r0.pdf)
### [P3149R0 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r0.pdf)
### [P3150R0 SG14: Low Latency/Games/Embedded/Financial Trading virtual Meeting Minutes 2023/12/13-2024/2/14](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3150r0.pdf)
### [P3151R0 SG19: Machine Learning virtual Meeting Minutes to 2023/12/14-2024/02/8](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3151r0.pdf)
### [P3153R0 An allocator-aware variant type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3153r0.html)
### [P3154R0 Deprecating signed character types in iostreams](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3154r0.html)
### [P3155R0 noexcept policy for SD-9 (The Lakos Rule)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3155r0.pdf)
### [P3156R0 empty_checkable_range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3156r0.html)
### [P3157R0 Generative Extensions for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3157r0.pdf)
### [P3158R0 Headless Template Template Parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3158r0.html)
### [P3160R0 An allocator-aware `inplace_vector`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3160r0.html)
### [P3300R0 C++ Asynchronous Parallel Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3300r0.html)
