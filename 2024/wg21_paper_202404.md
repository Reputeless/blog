# ［C++］WG21月次提案文書を眺める（2024年04月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-04](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-04)

全部で173本あります。

もくじ

[:contents]

### [N4974 Wroclaw meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4974.pdf)

2024年11月にポーランドのWroclaw（ブロツワウ）で行われる全体会議のインフォメーション。

予定（2024年11月18日～23日）と場所、ホテルの案内などが記載されています。

### [N4975 2024 WG21 admin telecon meetings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4975.pdf)

2024年に行われる、WG21管理者ミーティングの予定表。

今年の残りは6/10と11/04に予定されています。

### [N4976 WG21 agenda: 18-23 March 2024, Tokyo, Japan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4976.html)

2024年3月に東京で行われた会議のアジェンダ。

### [N4978 WG21 2024-03 Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4978.pdf)

2024年3月4日に行われた、WG21管理者ミーティングの議事録。

前回（kona会議の前）からどのような活動があったかや、東京会議で何をするかなどの報告がなされています。

### [N4979 Hagenberg Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4979.pdf)

2025年1月にオーストリアのHagenberg（ハーゲンベルグ）で行われる全体会議のインフォメーション。

予定（2025年1月10日～15日）と場所、生き方や現地の観光案内などが記載されています。

### [N4980 WG21 2024-03 Tokyo Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4980.pdf)

2024年3月に東京で行われた全体会議の議事録。

最終日に行われた全体会議での各グループの作業報告と、全体投票の様子が記録されています。

### [N4981 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4981.pdf)

C++26のワーキングドラフト第4弾

### [N4982 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4982.html)

↑の変更点をまとめた文書。

### [P0260R8 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0260r8.html)
### [P0562R1 Initialization List Symmetry](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0562r1.pdf)

↓

### [P0562R2 Trailing Commas in Base-clauses and Ctor-initializers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0562r2.pdf)

コンストラクタ初期化子リストと基底クラスリストにおいて、末尾カンマを許容する提案。

カンマはC++の様々なところでエンティティの区切り文字として使用され、一部のコンテキストでは冗長な末尾のカンマが許容されます。

```cpp
enum class E {
  a,
  b,
  c,  // ok
};

int array[2] = { 
  0,
  1, // ok
};

std::vector<int> vec = {
  0,
  1, // ok
};

struct S {
  int a;
  int b;
};

S s = { 
  .a = 0,
  .b = 1,  // ok
};
```

このことは、単純なマクロの展開によってカンマ区切りリストを生成する際に便利であったり、単純なコード整形などによって見やすさや保守性の向上等のための助けとなります。

ただし、コンストラクタ初期化子リストでは末尾のカンマは許容されていません。

```cpp
class C {
  int a, b;
public:

  C(int n1, int n2)
    : a{n1},
      b{n2},  // ng
  {}
};
```

コンストラクタ初期化子リストの順番はクラスのメンバの宣言順と一致している必要があり、一致しない場合に時に微妙なバグを静かに埋め込むことになります。宣言順に一致させるために行の入れ替えをした後でカンマを消すというのはとても簡単な作業ではありますが、時に忘れがちで、コンパイルエラーを起こしてはじめて気づくこともあります。コンパイル時間が長い場合はその損失は大きなものになります。

また、そもそもその些細な作業の地味な面倒さから、並べ替えの必要性に気づいた人が作業をやらない誘因を与えています。

そのため、この提案ではコンストラクタ初期化子リストにおける末尾の不要なカンマを許容することを提案しています。

また、同様のメンテナンス性の問題と一貫性の向上のために、基底クラスリストにおいて同様に末尾カンマを許容するようにすることも提案しています。


<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
foo::foo(int x, int y, int z) :
  a(x),
  b(y),
  c(z)
{...}

class bar :
  public base,
  public mixin
{};
```

</td>
<td valign="top">

```cpp
foo::foo(int x, int y, int z) :
  a(x),
  b(y),
  c(z),
{...}

class bar :
  public base,
  public mixin,
{};
```

</td>
</tr>
</table>

この提案は内容が小さいこともありEWGのレビューをすでに終えてCWGでレビューされています。

- [P0562 進行状況](https://github.com/cplusplus/papers/issues/1818)

### [P0609R3 Attributes for Structured Bindings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0609r3.pdf)
### [P0843R11 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0843r11.html)
### [P0876R16 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0876r16.pdf)
### [P1061R8 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1061r8.html)
### [P1068R11 Vector API for random number generation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1068r11.pdf)
### [P1317R1 Remove return type deduction in `std::apply`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1317r1.pdf)

`std::apply`の戻り値型推論をやめる提案。

`std::apply`の宣言は次のようになっており、戻り値型は`decltype(auto)`によって推論されています。

```cpp
namespace std {
  template<class F, tuple-like Tuple>
  constexpr decltype(auto)
    apply(F&& f, Tuple&& t) noexcept(...);
}
```

これによって、`apply`の引数に呼び出し不可能なペアを渡すと`apply`内部においてエラーが起こることによって、SFINAEのような動作をしないという問題があります。

例えば次のようなコンセプトとその使用例において

```cpp
#include <tuple>

template<class Func, class Tuple>
concept applicable =
  requires(Func&& func, Tuple&& args) {
    std::apply(std::forward<Func>(func), std::forward<Tuple>(args));
  };

int main () {
  auto func = [](){};
  auto args = std::make_tuple(1);

  static_assert(!applicable<decltype(func), decltype(args)>); // static_assert()によらずにエラーが起こる
}
```

この`func`は引数無しのラムダ式なので`std::tuple<int>`では呼び出しできません。`applicable`コンセプトの意図としては制約を満たさずに`false`となることが期待されますが、実際には`apply`本体内でのハードエラーとなることによってコンセプトの定義内でのエラーとなってしまいます。

これは、`decltype(auto)`によって戻り型が推論されているためで、これによって関数のシグネチャの決定のために本体のインスタンス化が必要となり、呼び出しできない引数が渡っている場合にそのインスタンス化の途中でハードエラーを起こしています。

この問題を回避するため、この提案は`std::apply`の戻り値型を求めるために`decltype(auto)`ではなく別の型特性を使用することを提案しています。

この提案では、`std::apply`の戻り値型導出のために`std::apply_result_t`という型特性を使用することを提案しています。

```cpp
namespace std {
  template<class Fn, class Tuple>
  struct apply_result;

  template<class F, class Tuple>
  using apply_result_t = apply_result<F, Tuple>::type;

  // 新しいapplyの宣言
  template<class F, class Tuple>
  constexpr std::apply_result_t<F, Tuple> apply(F&& f, Tuple&& t);
}
```

この`std::apply_result_t`は呼び出し不可能な型のペアを受け取ると、巧妙な実装によってそれをハードエラーではなくSFINAE-friendlyなエラーとして報告するように実装されます（提案中に実装例があります）。

また特に触れられてはいないのですが、上記の`applicable`のようなコンセプトを同時に追加しようともしています。

- [c++ - decltype(auto) works with SFINAE in some cases? - Stack Overflow](https://stackoverflow.com/questions/51119523/decltypeauto-works-with-sfinae-in-some-cases)
- [P1317 進行状況](https://github.com/cplusplus/papers/issues/326)

### [P2034R3 Partially Mutable Lambda Captures](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2034r3.pdf)
### [P2075R5 Philox as an extension of the C++ RNG engines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2075r5.pdf)
### [P2127R0 Making C++ Software Allocator Aware](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2127r0.pdf)

Allocator AwareなC++コードのための解説書。

この文書は、Bloomberg社内の教育のために書かれた、C++コードでアロケータを受け取るクラスを記述するための知っておくべきことをまとめたものです。

LEWGにおけるポリシーの策定に当たってアロケータ関連のポリシーが提案されており、LEWGのメンバにとっても有用である可能性があるとして公開されたものです。

### [P2135R1 P2055R1: A Relaxed Guide to memory_order_relaxed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2135r1.pdf)
### [P2141R2 Aggregates are named tuples](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2141r2.html)
### [P2248R8 Enabling list-initialization for algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
### [P2300R8 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r8.html)
### [P2300R9 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r9.html)
### [P2355R2 Postfix fold expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2355r2.html)
### [P2389R1 `dextents` Index Type Parameter](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2389r1.html)
### [P2414R3 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2414r3.pdf)
### [P2542R8 views::concat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2542r8.html)
### [P2573R2 = delete("should have a reason");](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2573r2.html)
### [P2591R5 Concatenation of strings and string views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2591r5.html)
### [P2746R5 Deprecate and Replace Fenv Rounding Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2746r5.pdf)
### [P2747R2 constexpr placement new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2747r2.html)
### [P2748R5 Disallow Binding a Returned Glvalue to a Temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2748r5.html)
### [P2755R1 A Bold Plan for a Complete Contracts Facility](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2755r1.pdf)
### [P2786R5 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r5.pdf)
### [P2795R5 Erroneous behaviour for uninitialized reads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2795r5.html)
### [P2809R3 Trivial infinite loops are not Undefined Behavior](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2809r3.html)
### [P2810R4 is_debugger_present is_replaceable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2810r4.html)
### [P2825R1 Overload Resolution hook: declcall(unevaluated-postfix-expression)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2825r1.html)
### [P2825R2 Overload Resolution hook: declcall(unevaluated-postfix-expression)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2825r2.html)
### [P2826R2 Replacement functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2826r2.html)
### [P2830R2 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r2.html)
### [P2830R3 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r3.html)
### [P2841R2 Concept and variable-template template-parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2841r2.pdf)
### [P2845R7 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2845r7.html)
### [P2845R8 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2845r8.html)
### [P2855R1 Member customization points for Senders and Receivers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2855r1.html)
### [P2863R5 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2863r5.html)
### [P2866R2 Remove Deprecated Volatile Features From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2866r2.pdf)
### [P2867R2 Remove Deprecated strstreams From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2867r2.html)
### [P2869R4 Remove Deprecated `shared_ptr` Atomic Access APIs From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2869r4.pdf)
### [P2872R3 Remove `wstring_convert` From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2872r3.pdf)
### [P2873R1 Remove Deprecated locale category facets for Unicode from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2873r1.pdf)
### [P2875R4 Undeprecate `polymorphic_allocator::destroy` For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2875r4.pdf)
### [P2893R3 Variadic Friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2893r3.html)
### [P2900R6 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r6.pdf)
### [P2927R2 Observing exceptions stored in exception_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2927r2.html)
### [P2944R3 Comparisons for reference_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2944r3.html)
### [P2977R1 Build database files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2977r1.html)
### [P2988R4 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r4.pdf)
### [P2993R0 Constrained Numbers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2993r0.pdf)

制約付きの整数型を生成するライブラリ機能の提案。

2018年から2022年の5年間で整数オーバーフローに関連するCVEレコードが1515件あります。1996年6月4日のアリアン5G V88/501ロケットの打ち上げ失敗は整数オーバーフローのエラー処理のバグが原因となり、3億7000万ドルの以上の損害を出しました。2015年と2020年には、ボーイング787のシステム内の時間値の整数オーバフローに関連する2つの別々のバグにより、飛行システムがクラッシュしたり計器に誤った情報が表示されたりするインシデントがありました。

これらのような整数型のオーバフローとそれに伴う結果は、プログラムの機能やセキュリティ、安全性を損なう重大なバグの原因となります。実行時に整数オーバーフローを検出できた場合でも、エラー処理を正しく行わなければそれもバグの元となります。

整数型の実行時の演算に伴う問題としてはそのほかにも、アンダーフロー、ゼロ除算、少し毛色は異なりますが配列の範囲外アクセスなどがあります。

C++コアガイドラインをはじめとする、安全なC/C++プログラムのためのコーディングルールにおいても必ず整数型のオーバーフローに関する注意やルールが存在しています。しかし、そのようなルールが取り入れられている現場においても、整数型のオーバーフローをはじめとする数値演算におけるバグは依然として危険性の高い問題であり続けています。

数値を正しく扱うために、既存のC++言語標準及びライブラリ、ガイドライン、コーディングルールなどは十分ではありません。

この提案では、標準ライブラリに対して新しい制約付きの数値システムを提案するものです。このシステムは、基本的に制約をコンパイル時にチェックし、必要な場合にのみ実行時チェックを行うことで、実行時への影響を最小限に抑えつつ安全で使いやすい数値型を提供するものです。

この提案による機能は`constrained_number<C, T>`という型を中心にしています。テンプレートパラメータの`C`には制約を指定し、`T`には内部表現のための整数型を指定して使用します。

```cpp
// 64bit符号付整数型としての制約を満たす値でのみ初期化可能
constrained_integral<int64_t> foo = 42; // ok

// [0, 10]の区間の整数値のみ表現可能な整数型
// この場合、符号付き整数型の値で初期化できない
constrained_number<constrain_interval<0, 10>> bar = 4;  // ng
```

ここでの制約とはコンセプトとは関係ありません。詳細は後述しますが、これは構文的な制約だけではなく意味論的な制約も表現可能なDSLになっています。

整数定数によって`constrained_number`を初期化するには、`_cn`リテラルを使用します。

```cpp
// 定数値'4'は指定されている制約を満たす
constrained_number<constrain_interval<0, 10>> bar = 4_cn;   // ok

// 定数値'42'は制約を満たさない
bar = 42_cn;    // ng
```

このチェックはすべてコンパイル時に行われ、実行時のオーバーヘッドはありません。

異なる制約を持つ`constrained_number`値の間で代入や初期化は可能ですが、代入・初期化しようとしている値が制約を満たしているかどうかがコンパイル時にチェックされます

```cpp
// 制約を満たす値によって正しく初期化されているとして
constrained_number<constrain_interval<0, 100>> foo = ...;

// 'foo'には'bar'の制約を満たさない値が含まれうる
constrained_number<constrain_interval<0, 10>> bar = foo;    // ng

// 上記エラーが無く、制約を満たす値によって正しく初期化されているとして
bar = ...;

// `bar`の値は`foo`の制約を常に満たす
foo = bar;  // ok
```

とはいえ、実行時に決定される値によって初期化できなければ実用には耐えません。ただしその場合でも制約を満たすかどうかはチェックされなければなりません。`make_constrained()`を使用すると、実行時の値から実行時に制約を満たしているかをチェックして変換することができます。このとき、制約を満たさない場合は例外が送出されます。

```cpp
// 5の倍数であることを要求する制約
constexpr any_constraint auto multiple_of_five_c =
  constraint_of<int64_t> &&
  constrain_multiple<5>;

// 5の倍数値のみからなる整数型
using mult_of_five_t = constrained_number<multiple_of_five_c>;

// コンパイル時にチェックされ、実行時には何もしない
auto v1 = make_constrained<multiple_of_five_c>(1005_cn);    // ok

// 実行時にチェック、制約が満たされない場合は例外を投げる
mult_of_five_t v2 = make_constrained<multiple_of_five_c>(get_some_raw_int());   // ok

// コンパイルエラー
auto v3 = make_constrained<multiple_of_five_c>(12_cn);  // ng

// 実行時に例外が送出される
mult_of_five_t v4 = make_constrained<multiple_of_five_c>(12);   // ok
```

`make_constrained()`は引数値に対してコンパイル時の検証が行える場合（`_cn`リテラルの値など）はコンパイル時にチェックを完了しようとします。

`constrained_number`は他の整数型に暗黙変換されません。`constrained_number`の値から生の整数値を得るためには`static_cast`によって明示的にキャストします
```cpp
// 制約を満たす値によって正しく初期化されているとして
constrained_number<constrain_interval<0, 10>> foo = ...;

// 組み込み整数型に変換
auto raw_foo = static_cast<uint32_t>(foo);  // ok
```

`constrained_number<C, T>`に指定する制約`C`の指定は、簡易なDSLによって行います。ここまでに使用していますが、整数型のとり得る値を区間で制限するために`constrain_interval`が用意されています

```cpp
// [-100, 100]区間の値のみ保持可能
constrained_number<constrain_interval<-100, 100>> small_number{};

// ↑はこれと等価
constrained_number<constrain_interval<-100, 100>> small_number = 0_cn;

// 0を除きたい場合（[-100, 0) ∪ (0, 100]）
constrained_number<constrain_interval<-100, -1> || constrain_interval<1, 100>> small_nonzero_number = 1_cn;
```

これによって、このライブラリではゼロ除算をコンパイル時に防止することができます。

```cpp
// small_numberは0を保持しうる
auto result_1 = 10_cn / small_number;   // ng

// small_nonzero_numberは0を保持しない
auto result_2 = 10_cn / small_nonzero_number;   // ok
```

この制約の実体は変数テンプレートであり、`constrained_number`のテンプレートパラメータの外側で定義しておくこともできます。

```cpp
constexpr auto non_zero_req = constrain_interval<-100, -1> || constrain_interval<1, 100>;
constexpr auto small_num_req = constrain_interval<-100, 100>;

// <=演算子を⊆の意味で使用可能
static_assert(non_zero_req <= small_num_req);

constrained_number<non_zero_req> non_zero = 1_cn;

// この初期化が安全であることは、制約の<=によってコンパイル時にチェックされる
constrained_number<small_num_req> small_num = non_zero;
```

この制約は、演算によって更新されます。

```cpp
constexpr auto one_to_ten_req = constrain_interval<1, 10>;
constexpr auto non_zero_req = constrain_interval<-100, -1> || constrain_interval<1, 100>;

constrained_number<non_zero_req> a = 42_cn;
constrained_number<one_to_ten_req> b = 3_cn;

auto c = a * b; // ok

// 実行時の値は期待通りに更新される
assert(c == 126);

// 制約もまた、期待通りに更新される
static_assert(c.constraint == constrain_interval<-1000, -1> || constrain_interval<1, 1000>);
```

用意されている制約は次のものです

|名称|定義|API|備考|
|---|---|---|---|
|区間|`[a, b]`|`constrain_interval<a, b>`|閉区間|
|集合|`{a, b, ...}`|`constrain_set<a, b, ...>`|外延的な集合|
|マスク|`{x ∈ Z | 0 <= x <= 2^n && (x & ~V) == C}`|`constrain_mask<V, C>`|ビットマスクによる整数値の指定|
|剰余類|`{x ∈ Z | mod(x, a) == 0}`|`constrain_multiple<a>`|`a`の倍数からなる集合|
|Constraint of|`[min(T), max(T)]`|`constraint_of<T>`|整数表現の制約区間|
|空集合|∅|`constraint_empty `|表現可能な値なし|
|不正|⊥|`constraint_invalid`|他の方法では表現できない値が含まれていたであろう集合|

これらの制約は集合的に指定されており、集合の演算によって制約を合成したりすることができます。制約の定義のために使用可能な演算は、次のものです

![](./wg21_paper_202404/P2993R0_constraint_operation.png)

`constrained_number`を使用して、`[]`の引数値を制限する例

```cpp
template<class T, size_t Extent = dynamic_extent>
class span {
  ...

  constexpr reference at(constrained_number<constrain_interval<0, Extent - 1>> pos) noexcept const
    requires (Extent != dynamic_extent);

  constexpr reference operator[](constrained_number<constrain_interval<0, Extent - 1>> pos) noexcept const
    requires (Extent != dynamic_extent);
  
  ...
};
```

- [C++ における整数型の怪と "移植性のある" オーバーフローチェッカー (第1回 : 整数型の怪と対策の不足) - Qiita](https://qiita.com/a4lg/items/541c9d9dd5d874eeef2f)
- [P2993 進行状況](https://github.com/cplusplus/papers/issues/1817)

### [P2997R1 Removing the common reference requirement from the indirectly invocable concepts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2997r1.html)
### [P3008R2 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3008r2.html)
### [P3016R3 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3016r3.html)
### [P3019R7 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r7.html)
### [P3019R8 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r8.html)
### [P3029R1 Better mdspan's CTAD](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3029r1.html)
### [P3032R1 Less transient constexpr allocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3032r1.html)
### [P3032R2 Less transient constexpr allocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3032r2.html)
### [P3034R1 Module Declarations Shouldn't be Macros](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3034r1.html)
### [P3037R1 constexpr std::shared_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3037r1.pdf)
### [P3049R0 node-handles for lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3049r0.pdf)

リストに対してノードハンドルのサポートを追加する提案。

C++17では、連想コンテナに対してノードハンドルAPIが追加されました。ノードハンドルとはノードベースコンテナのある一要素の所有権を引き取るもので、ノードハンドルを介することで、互換性のあるコンテナ間でムーブすらすることなく要素を移動することができます。

```cpp
// cpprefjpのサンプルを微修正したもの

import std;

int main() {
  std::map<char, int> m1, m2;

  m1.insert(std::make_pair('a', 10));
  m1.insert(std::make_pair('b', 20));
  m1.insert(std::make_pair('c', 30));

  // m1の'c'をキーとするノードハンドルを取得
  std::map<char, int>::node_type node = m1.extract('c');

  // 取得したノードハンドルを別のmap'm2'へ挿入
  // この時、ノード（要素）はコピーもムーブもされていない
  m2.insert(std::move(node));

  std::println("{}\n{}", m1, m2);
}
```

出力例

```
{'a': 10, 'b': 20}
{'c': 30}
```

一方`std::list`及び`std::forward_list`もノードベースコンテナではありましたが、元々`splice`のAPIを備えていたこともあり、APIの一貫性以上の利点はないとしてリスト系コンテナに対してはノードハンドルAPIは追加されませんでした。

この提案は、APIの一貫性向上も含めてさらに追加の利点があるとして、`std::list`及び`std::forward_list`にノードハンドルAPIを追加することを提案するものです。

ここで提案されているAPIは、連想コンテナのAPI

```cpp
// ノードハンドルの型
using node_type = implementation defined specialization of node_handle;

// ノードハンドルの取り出しAPI
node_type extract(const_iterator pos);
node_type extract(const key_type& key);
template<typename Key> 
node_type extract(Key&& key);

// insert()の戻り値型
struct insert_return_type {
  iterator position; 
  bool inserted; 
  node_type node; 
};

// ノードハンドルの挿入API
insert_return_type insert(node_type && handle);
iterator insert(const_iterator pos, node_type && handle);
```

に対してこのサブセットとなるもので、次の2つの関数からなります

```cpp
// ノードハンドルの型
using node_type = implementation defined specialization of node_handle;

// ノードハンドルの取り出し
node_type extract(const_iterator pos);

// ノードハンドルの挿入
iterator insert(const_iterator pos, node_type && handle);

// forward_listのAPI
node_type extract_after(const_iterator pos); 
iterator insert_after(const_iterator pos, node_type && handle);
```

減った分のAPIは、連想コンテナに固有の事情に特化したものだけです。

リスト系コンテナへのノードハンドルAPI追加の利点として、この提案では`splice()`操作と比較してソースとターゲットをより適切に分離できる点を挙げています。

```cpp
// listでsplice()を使用する例

// valに指定した値に一致する値を持つリスト要素を移動する
template<typename T> 
void splice_if(list<T> & from, list<T> & to, T val) { 
  const auto it{ranges::find(from, val)};
 
  if (it != from.end()) {
    to.splice(to.begin(), from, it); 
  }
} 

// usage: 
list<int> l1 = …; // filled with random ints 

// splice()によって要素を移動させようとする場合
// 移動元と移動先コンテナがそろっている必要がある
list<int> l2 = …;

splice_if(l1, l2, 42);
```

```cpp
// この提案のノードハンドルAPIを使用する例

// valに指定した値に一致する値を持つリスト要素のノードハンドルを取得する
template<typename T> 
list<T>::node_type extract_if(list<T> & from, T val) { 
  const auto it{ranges::find(from, val)};

  if (it != from.end()) {
    return from.extract(it);
  }

  return {}; 
} 

//usage: 
list<int>& l1 = …; // filled with random ints 
auto nh{extract_if(l1, 42)};
// nh は転送先とは独立して取り廻すことができる

// これにより、要素取り出しと要素挿入が分離される
list<int>& l2 = …; 
if(nh) l2.insert(l2.end(), move(nh));
```

この提案の内容は既に、MSVC STLのフォークにて実装可能なことが確認されています。

- [`node_handle` - cpprefjp](https://cpprefjp.github.io/reference/node_handle/node_handle.html)
- [P3049 進行状況](https://github.com/cplusplus/papers/issues/1820)

### [P3050R1 Fix C++26 by optimizing linalg::conjugated for noncomplex value types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3050r1.html)
### [P3064R0 How to Avoid OOTA Without Really Trying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3064r0.pdf)
### [P3068R1 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r1.pdf)
### [P3072R2 Hassle-free thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3072r2.html)
### [P3074R3 trivial union (was std::uninitialized<T>)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3074r3.html)
### [P3085R1 `noexcept` policy for SD-9 (throws nothing)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3085r1.html)
### [P3086R1 Proxy: A Pointer-Semantics-Based Polymorphism Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3086r1.pdf)
### [P3086R2 Proxy: A Pointer-Semantics-Based Polymorphism Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3086r2.pdf)
### [P3091R1 Better lookups for `map` and `unordered_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3091r1.html)
### [P3094R1 std::basic_fixed_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3094r1.html)
### [P3097R0 Contracts for C++: Support for virtual functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3097r0.pdf)

契約プログラミング機能において、仮想関数に対する契約の指定をサポートする提案。

以前の契約プログラミング仕様においては仮想関数にも通常の関数と同様に契約注釈を行うことができました。ただし、派生先の契約注釈は派生元の契約を暗黙に継承し、明示的に指定する場合でも派生元の契約と同じにならなければならないとされていました。これは、Assertion Redeclaration ruleというルール（事前条件は同じかより弱いもの、事後条件は同じかより強いものでなければならない）に沿うものでしたが、派生先に明示的に指定された契約注釈が派生元と同じであることをどう表現するかや異なる場合にどうするかなどや、そのルールがC++の実際の仮想関数のユースケースを満たしていないということが問題となり、より議論を尽くすためにC++26に向けては仮想関数に対する契約注釈を目指さないことになりました。それを受けて、現在のContracts MVP仕様（P2900R5）では仮想関数に対する契約注釈の指定は禁止されています。

例えば、Assertion Redeclaration ruleに従わないような2つの呼び出し、事前条件をより強くする場合と事後条件をより弱くする場合の2つのケースにおいても、ユースケースが存在しています。

例えば次のような`Car`クラスを基底クラスとして

```cpp
struct Car {
  virtual void drive(float speedMph)
    pre (speedMph < 100) // don't go too fast!
};

void testCar(Car& car) {
  car.drive(90);  // OK
  car.drive(120); // bug: precondition violation
}
```

次のように`Car`クラスを派生させると、事前条件をより強くすることになります

```cpp
struct ElectricCar : Car {
  void drive(float speed_mph) override
    pre (is_charged);   // 事後条件が強くなっている

  void charge() { is_charged = true }

private:
  bool is_charged = false;
};


void testCar(Car& car);

int main() {
  ElectricCar myElectricCar;
  testCar(myElectricCar);
}

void testCar(Car& car) {
  car.drive(90); // 事前条件違反、charge()を呼んでいない
}
```

このように派生クラスで事前条件を強くしてしまうと、`ElectricCar`のインスタンスは一般的に`Car`のインスタンスとして使用することができなくなるため、正統的なオブジェクト指向設計に準拠していません。

それでもなあお、これが合理的である場合があります。使用準備が整った`ElectricCar`のインスタンスをより広いスコープで使用することで、より具体的な事前条件を非ローカルで保証することができます。

```cpp
int main() {
  ElectricCar myElectricCar;
  myElectricCar.charge();
  
  testCar(myElectricCar); // everything works now!
}
```

デフォルト構築された`ElectricCar`はそのまま`Car`の代わりに使用することはできませんが、`.charge()`を呼び出すことでその準備が整います。この場合、`ElectricCar::drive()`で強められている契約はこの追加のセットアップ手順を省略されないようにすることを表現するものとしてみることができます。このような設計は現実のC++アプリケーションで一般的です。

（提案には、他の3つの場合と多重継承の場合のユースケース例があります）

また、以前のMVP仕様（派生先に派生元と同じ契約を強制する）では、この例だけでなく、Assertion Redeclaration ruleに従うような継承を行っている場合を完全にサポートしきれてはいません。

この提案は、仮想関数に対する契約注釈は契約機能の普及のために必須であるとして、以前の問題を解決して仮想関数に対する契約注釈を個萎えるようにするための新しいソリューションを提案するものです。

この提案では仮想関数に対する契約注釈を許可しますが、派生先の関数は派生元の関数の契約を継承しません。派生元関数の契約は派生元の関数の契約から完全に独立しており、派生先の事前条件及び事後条件は拡大と縮小の両方が可能になります。

そして、仮想関数呼び出し時の契約チェックの評価は次のようになります

1. 派生元関数の事前条件が評価される
2. 派生先関数の事前条件が評価される
3. 派生先関数の本体が実行される
4. 派生先関数の事後条件が評価される
5. 派生元関数の事後条件が評価される

仮想関数が基底クラスのポインタ/参照を介して呼び出される場合、派生元の関数は静的に決定されておりその契約も呼び出す場所から見えています。一方、派生先の関数は動的に決定され動的にディスパッチされますが、ディスパッチされた先ではどの派生型の実装された関数が呼ばれているのか、およびその契約についてが分かっています。

そのため、仮想関数の呼び出しにおいては直接関与する2つの型（静的型と動的型）についての情報を利用することができ、それによって上記のような呼び出しシーケンスが可能になります。

例えば、静的型と動的型が一致する場合（派生クラスオブジェクトを派生クラスのポインタ/参照、あるいはオブジェクトから直接呼び出した場合）、その派生クラスにおいてなされている契約だけが評価されます。

提案より、深い継承の例

```cpp
struct X {
  virtual void f() pre(a) post(b);
};

struct Y : X {
  void f() override pre(c) post(d);
};

struct Z : Y {
  void f() override pre(e) post(f);
};

int main() {
  Z z;

  X& x = (X&)z;
  x.f(); // a -> eの順でチェックされ、z::f()が実行された後、f -> bの順でチェックされる
  
  Y& y = (Y&)z;
  y.f(); // c -> eの順でチェックされ、z::f()が実行された後、f -> dの順でチェックされる
}
```

多重継承の例

```cpp
struct X1 {
  virtual void f() pre(a1) post (b1);
};

struct X2 {
  virtual void f() pre(a2) post (b2);
};

struct Y : X1, X2 {
  void f() override pre(c) post (d);
};

int main() {
  Y y;

  X2& x2 = (X2&)y;
  x2.f(); // a2 -> cの順でチェックされ、Y::f()が実行された後、d -> b2の順でチェックされる
}
```

このように、仮想関数呼び出しにおいてはコード上から見えている直接の静的型における関数と実際に呼び出される動的型における関数だけが契約チェックに関与することになり、直感的になるとともに非常に教えやすくもなります。

この提案における仮想関数に対する契約注釈は、仮想関数が純粋であるかどうかによらず行うことができ、同じように動作します。

提案しているこの方法では、事前条件は派生先の物より強くすることができ、どちらの条件においても派生元の契約を無視するようにすることができます。そのため、Assertion Redeclaration ruleに従ったものではありません。これは、実際のC++における仮想関数の使用パターンとの互換性と一貫性を最大化しつつ、全体として最も幅広いユースケースを可能にしようとした結果です。この提案では、Assertion Redeclaration ruleに従わない契約と継承を許可する一方で、Assertion Redeclaration ruleに従った契約と継承も同時に許可しています。

この提案において重要なことは、呼び出し側（派生元）と呼び出し先（派生先）の関数の両方がその呼び出しに伴って契約をチェックする一方で、必要なところではその契約を変化させたり回避する柔軟性を提供している点です。

- [P3049 進行状況](https://github.com/cplusplus/papers/issues/1822)

### [P3103R1 More bitset operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3103r1.html)
### [P3104R1 Bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3104r1.html)
### [P3104R2 Bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3104r2.html)
### [P3105R1 constexpr std::uncaught_exceptions()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3105r1.html)
### [P3105R2 constexpr std::uncaught_exceptions()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3105r2.html)
### [P3106R1 Clarifying rules for brace elision in aggregate initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3106r1.html)
### [P3107R1 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r1.html)
### [P3107R2 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r2.html)
### [P3107R3 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r3.html)
### [P3107R4 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r4.html)
### [P3107R5 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r5.html)
### [P3119R0 Tokyo Technical Fixes to Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3119r0.pdf)

現在のContarcts仕様の小さな問題を解決する提案。

2023年3月に東京で行われたWG21全体ミーティングの中で、Contracts MVP（P2900R6）がEWGに転送され、最初のレビューが行われました。この提案は、その際に寄せられたごく小さい問題について報告し、その解決策を提案するものです。

報告されているのは次の3つの問題です。

**配列引数と事後条件**

事後条件から関数引数を参照する場合、その引数は`const`指定されている必要があります。ところが、（参照ではない）配列引数の場合は`decay`されることによってポインタによって宣言した場合と同等になりますが、その際にそのポインタそのものに`const`を付加することができません。

例えば、次の2つの宣言は等価となります。

```cpp
void f(const int a[]);
void f(int * const a);
```

2つ目の宣言を見ればわかるように、これはポインタ自体が`const`なのではなく、ポインタの指す先が`const`となる宣言です。2つ目の宣言の場合は`const`を追加することは容易ですが、1つ目の配列引数に対してそのポインタに`const`を付加することはできません。

これによって、そもそも事後条件からの関数引数を参照することを禁止している理由が再燃します

```cpp
void f(const int a[]) post( a[0] == 5 ) {
  static int x[1];
  a = x;    // ローカル静的配列へのポインタを代入（ポインタそのものはローカル変数なので関数の外には漏れていない）
  a[0] = 5; // 関数本体では事後条件は満たされている
}

void g() {
  int b[5] = {0,1,2,3,4,5};
  f(b);
  contract_assert(b[0] == 5); // これは決して満たされない（常に失敗）
}
```

**Cの可変長関数引数と事前/事後条件**

現在のMVPの規定では、Cの可変長引数を持つ関数に対して事前条件及び事後条件を指定した場合、それらの中からその可変長引数をどのように使用可能なのかについての指定がありません。一般に、`va_start()`から`va_end()`までの一連の流れは1つの関数内で完結している必要があり、現在の契約においては次の2点が問題となります

1. `va_start()`から`va_end()`の使用はある1つの述語内で完結しなければならない
    - Cの可変長引数から見ると、異なる契約述語は異なる関数
2. Cの可変長引数を`const`にする方法が無いため、事後条件はそれを参照できない

少なくとも事前条件から可変長引数を参照するには1つ目の問題を解消しなければなりませんが、それは性的に検証できることではないので、破られた場合に未定義動作とするしかありません。

**契約条件の評価回数の制限**

現在のMVPの仕様では、ある契約述語は違反の検出のために0回以上、違反の処理のために1回以上評価されうるとしていますが、最大何回評価するかについては制限がありません。これについて2つの問題点が指摘されました

1. 契約述語の評価を何度も繰り返した末にUBになるとしたら、その契約は常にUBになるとみなせる。
2. 実行時の計算量について厳密な制限を必要とするリアルタイムシステムでは、標準で1回の述語評価から生じる評価回数が制限されていない場合、契約を使用できない
    - 実際に実装がこれについて制限を設けたとしても、使用が無制限を許可する以上契約を使用しないようにする人が居るかもしれない

一方で、無制限の評価を許可する合理的な理由もあります

1. 異なる翻訳単位で定義されている関数では、関数呼び出しの両側でチェックを行う必要がある場合があるかもしれない
    - これによって、契約のチェックが全く行われないことを回避できる
    - このことは、各契約述語は少なくとも2回評価されることを要求している
2. 何回評価されるかが不定であることは、副作用が発生する正確な回数への依存を困難にするため、契約述語に副作用があることが推奨されていないことを明確にする
3. 破壊的な契約述語をテストするための特に徹底的な方法は、テスト中に繰り返して契約述語を評価することで結果が変わるかを観察すること
    - 任意の繰り返し回数を要求する適合コンパイラオプションはこれを検証するための優れたメカニズム


これらの3つの問題について、この提案では次のような解決を提案しています

1. 配列引数と事後条件 : 事後条件からの配列引数の参照は禁止（コンパイルエラーとする）
    - それを行いたい場合、等価なポインタによる宣言に書き換える
2. Cの可変長関数引数と事前/事後条件 : 契約述語での`va_start`の使用は禁止（コンパイルエラーとする）
3. 契約条件の評価回数の制限 : 評価回数の上限は実装定義
    - 標準としては具体的な数の指定を避ける

とてもマイナーな問題ではありますが、この解決によってContracts仕様はよりロバストになるはずです。

- [P3119 進行状況](https://github.com/cplusplus/papers/issues/1823)

### [P3122R1 [[nodiscard]] should be Recommended Practice](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3122r1.html)
### [P3135R1 Hazard Pointer Extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3135r1.pdf)
### [P3146R1 Clarifying std::variant converting construction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3146r1.html)
### [P3147R1 A Direction for Vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3147r1.pdf)
### [P3149R1 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r1.pdf)
### [P3149R2 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r2.pdf)
### [P3159R0 C++ Range Adaptors and Parallel Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3159r0.html)

Rangeアダプタを並列実行する際に必要となる最適化とその方針についての提案。

この提案は、P3300で提案されている並列Rangeアルゴリズムの実装に伴って発生する設計の選択肢について説明し、その選択を提案するものです。以下、ほぼ提案の翻訳

Rangeアダプタ/ファクトリは範囲の各要素の変換をローカルに（グローバルメモリを更新することなく）行うことができ、またコード上でもその変換を分かりやすく表現することができます。

ただし、Rangeアダプタ/ファクトリが生成する`view`は遅延評価を行い、範囲の要素に対して1つづつその変換処理を適用していきますが、並列化のためにはその変換処理を抽出してベースとなる範囲に対して一括適用（複数の操作を順番にやるのではなく、1度にすべての操作を適用する）する必要があります。

範囲を消費する並列Rangeアルゴリズムを実装するには、入力の範囲を適用されているアダプタと一番基底にある元の範囲/Rangeファクトリに再帰的に分解する最適化カーネルビルダーを構築する必要があります。ただし、このカーネルビルダーはライブラリ内部に閉じているもので、公開されるAPIには含める必要はありません。

このカーネルビルダーは、必要に応じて各アダプタとファクトリを並列処理に適した代替実装に置き換えたり、前処理パスを挿入したりします。

```cpp
// 最適化カーネルビルダーの簡単な例
auto optimize_range(range auto&& rng) {
  if constexpr(has_base(rng)) {
    // このアダプタを最適化するロジックにディスパッチする
    return optimize_range(rng.base());
  } else {
    return rng;
  }
}
```

Rangeアダプタ/ファクトリを標準ライブラリ由来のものだけを考慮することにすると、この最適化カーネルビルダーは次の事を行います

- 入力の範囲がRangeアダプタなのか、Rangeファクトリなのかを判断する
- 入力の範囲がどのRangeアダプタ/ファクトリから来たのかを特定する
- 入力の範囲から、基底となる範囲を取得する
- 各アダプタを最適化するロジックにディスパッチする

Rangeアダプタの最適化が必要な場合として、例えば次の場合があります

1. 自明ではない要素の削除
2. 自明ではない要素のグループ化

**自明ではない要素の削除**

`filter`や`take_while`などのアダプタは、事前に自明に計算できない方法で範囲の要素を削除（フィルタ）します。

並列アルゴリズムの実装では、N個の実行エージェントがM個の要素を処理するように、入力をスレッド間で事前に分散することができます。この分散時に範囲内のどの要素が削除されるのかを計算することができないため、各実行エージェントはM個の初期要素を受け取ってから遅れて各自で条件を満たす要素を削除することになります。

これらの非自明な削除を行うアダプタを並行的に使用するためには、削除対象の要素をそれとマークされた特定の値（*tombstone* : 墓石）に置き換える必要があります。墓石要素は範囲から削除する必要がある事を示す`std::optional`とよく似た要素です。

並列アルゴリズムが範囲を消費する場合、この墓石を取り除く必要があります。このためのもっとも簡単な方法は`copy_if`前処理パスを挿入することです。ただしこの処理を適用した範囲がメモリ上で実体化するのを回避するために、インプレースで行う必要があります。このような処理パスはストリーム圧縮（*stream compaction*）と呼ばれます。

```cpp
// このような処理は
for_each(rng | filter(f), g);

// このように最適化する必要がある
void kernel(range auto&& rng0) {
  // フィルタ要素の墓石への置き換えと、ストリーム圧縮
  rng1 = compact(rng0 | filter_tombstone(f));
  for_each_collective(rng1);
}
```

ストリーム圧縮は多くの場合、`scan`によって実装されます

```cpp
auto copy_if(range auto&& in, output_iterator auto out, auto pred) {
  vector<uint8_t> flags(size(in));

  transform(par, in, begin(flags), pred);

  vector<size_t> indices(size(in));

  exclusive_scan(par, flags, begin(indices), 0);

  for_each(par, zip(in, flags, indices),
    apply([&in] (auto e, auto flag, auto index]) {
      if (flag) out[index] = e;
    }));

  return subrange(begin(out), next(out, indices.back()));
}
```

墓石要素を取り除く別の方法は、後続のアダプタ等をすべてラップして墓石要素を無視するようにすることです。全てを単純にラップできる場合、ストリーム圧縮パスを挿入する必要が無くなります。

```cpp
// このような処理は
for_each(rng | filter(f), g);

// このように最適化（ストリーム圧縮を使用しない）
for_each(rng | transform([f] (auto x) {
                  if (!f(x)) return tombstone(x); else return nullopt;
               }),
         [g] (auto x) { if (x) g(*x); });


// このような処理は
reduce(rng | filter(f), g);

// このように最適化（ストリーム圧縮を使用しない）
reduce(rng | transform([f] (auto x) {
               if (!f(x)) return tombstone(x); else return nullopt;
             }),
       [g] (auto l, auto r) {
         if (l && r) return g(l, r);
         else if (l) return l;
         else if (r) return r;
         else        return {};
       });
```

ただし、このようなラッピングを常に可能ではありません。`adjacent`や`enumrate`をはじめとする一部のアダプタは要素の位置を認識します。これは、隣接する要素のアクセスするなど範囲内の要素の位置を考慮することを意味しており、墓石要素の存在はその位置ロジックを混乱させます。これを回避するためには、そもそも回避しようとしている遅延フィルタリングが必要となってしまいます。

このようなラッピングによって遅延的に墓石要素を取り除こうとする場合、最適化カーネルビルダーが範囲を再構築する際に、墓石が必要な範囲を見つけたらそれとマークし、墓石要素を無視できない範囲を見つけたらストリーム圧縮パスを挿入し墓石スキップが不要であるとマークする必要があります。

```cpp
// 墓石要素の要必要が入り乱れる例
sort(rng | filter(f) | transform(g) | adjacent<2> | filter(h) | transform(i));
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   XXXXXXXXXXX   ^^^^^^^^^^^^^^^^^^^^^^^^
  //           Tombstoned             Untombstoned         Tombstoned

// ↑を正しく処理する例
void kernel(range auto&& rng0) {
  rng1 = compact(rng0 | filter_tombstone(f) | transform_tombstone(g));
  rng2 = compact(rng1 | adjacent<2> | filter_tombstone(h) | transform_tombstone(i));
  sort_collective(rng2);
}
```

ラッピングによる遅延的な墓石要素の除去は、最適化カーネルビルダーの複雑さを増大させる代わりに、処理コストの高いストリーム圧縮パスを回避できるためパフォーマンスで有利になります。

C++26（予定）の並列Rangeアルゴリズムに向けては、簡素化のために、現時点ではこのラッピングによる遅延的な墓石要素の除去を行わず、墓石要素が必要となる範囲を見つけた場合はストリーム圧縮パスを挿入するようにすることを提案しています。

**自明な要素のグループ化と削除**

`drop. stride`などのRangeアダプタは事前に自明に予測可能な方法で要素を削除し、`chunk, adjacent`等のアダプタは事前に自明に計算可能な方法で要素をグループ化もしくは結合します。そのため、これらのアダプタを並列実行する場合、エージェントに分割して作業の分配を行う際にそのグルーピングを考慮することができます。

```cpp
// この様な処理は
for_each(rng | drop(X), f);

// このように最適化
auto start = begin(rng) + X;
auto end = end(rng);
for_each(start, end, f);
```

しかしこれらの入力アダプタが非自明な要素の削除もしくは非自明な要素のグループ化（`chunk_by, split`）を行うアダプタの適用を含んでいる場合、そのアダプタも非自明な要素削除を伴うアダプタとなるため、ストリーム圧縮パスを挿入する必要があります。

これらの、自明な要素のグループ化と削除を行うアダプタを処理するには2つのアプローチがあります

1. 常にストリーム圧縮パスを挿入し、作業の分散中にそれらを処理しない
    - 実装が単純
2. 以前に非自明な要素削除/グループ化のパスを含んでいる場合にのみストリーム圧縮パスを挿入し、それ以外の場合は作業分散中に処理する
    - 実装が複雑化するが、より効率的

この提案では、1のアプローチを提案しています。

- [P3300R0 C++ Asynchronous Parallel Algorithms - WG21月次提案文書を眺める 2024年02月](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3300R0-C-Asynchronous-Parallel-Algorithms)
- [P3119 進行状況](https://github.com/cplusplus/papers/issues/1824)

### [P3160R1 An allocator-aware `inplace_vector`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3160r1.html)
### [P3161R0 Unified integer overflow arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3161r0.html)

↓

### [P3161R1 Unified integer overflow arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3161r1.html)

オーバーフローを処理可能な整数演算の提案。

一部のアプリケーションでは、標準でサポートされている（あるいは今後されるであろう）整数値の最大幅を大きく超える値を扱わなければならない場合があります。また、そのような拡張幅を必要としない場合でも、整数演算の結果が有効かどうか（オーバーフローしていないかどうか）を知ることが重要な場合があります。前者の場合は多倍長整数型を使用することになりますが、その実装においては同様に整数演算の桁上がりを検知する必要があります。

それに対処するアルゴリズムは非常に単純で、ほとんどのCPUはそれをハンドルする命令をサポートしているものの、標準C++の範囲内でそれらの機構を利用可能な抽象化は存在していません。C++だけで同等の機能を実装するのはかなり難しく、その結果非常に非効率なコードになってしまいます。

C++23では整数型の飽和演算ライブラリが追加されましたが、これらはオーバーフローに対処する別のアプローチであり、オーバーフローを検知したい場合には向きません。

また、オーバーフローを検知可能な操作を行う関数があり、それがCPU命令を用いて効率的に実装されているとします。CPUは命令の実行のためあるいは結果の退避やレジスタ値の復帰のために特定のレジスタにオペランドをmovのような命令によって読み込みますが、一部のCPU（x86-64）では入力と出力のレジスタが一致していることから連続して同じ命令を同じ結果に対して適用していくような場合（多倍長整数の実装でよく現れるパターン）にmov命令の数を削減することができます。独立した計算を並べ替えたり可換なオペランドを入れ替えたりするオプティマイザはさらにmov命令を抑制可能になります。

このような最適化は個別の関数を実装するだけのライブラリ側では不可能であり、よりコンパイラに近いところで作業した場合に可能となります。このことは、このような操作が標準化されていることが重要であることを示唆しています。

この提案は、オーバーフローを検知することのできる整数型に対する操作を行うライブラリ機能を提案するものです。

提案より、整数型の演算のグループの要約表

|操作|現在の標準|飽和演算|オーバーフロー安全|Wide arithmetic|
|---|:-:|:-:|:-:|:-:|
|足し算|`+`|`add_sat()`|N/A|`add_carry()`|
|引き算|`-`|`sub_sat()`|N/A|`sub_borrow()`|
|掛け算|`*`|`mul_sat()`|N/A|`mul_wide()`|
|割り算, 剰余|`/, %, div()`|`div_sat()`*|`is_div_defined`|`div_wide(), is_div_wide_defined`|
|キャスト|`static_cast`|`saturate_cast`|`would_cast_modify`|N/A|

ここで提案されているのは、Wide arithmeticの列の関数群および`would_cast_modify`です。

`add_carry()`はキャリーありの加算を行います。

```cpp
template<class T>
constexpr add_carry_result<T> add_carry(T v1, T v2, bool carry) noexcept;
```

`result = v1 + v2 + (carry ? 1 : 0);`のような計算を行い、`result`の`T`と同じ幅の部分のビットによる`T`の値とオーバーフローが起きたかどうかの`bool`値を返します。

`sub_borrow()`はキャリーあり減算を行います。

```cpp
template<class T>
constexpr sub_borrow_result<T> sub_borrow(T v1, T v2, bool borrow) noexcept;
```

`result = v1 - v2 - (borrow ? 1 : 0);`のような計算を行い、`result`の`T`と同じ幅の部分のビットによる`T`の値とオーバーフローが起きたかどうかの`bool`値を返します。

`mul_wide()`はオーバーフローなしの乗算を行います。

```cpp
template<class T>
constexpr mul_wide_result<T> mul_wide(T v1, T v2) noexcept;
```

`result = v1 * v2;`のような計算を精度の制限が無いかのように行い、`T`の幅を`N`として、`result`の下位`N`ビットと上位`N`ビットの値をまとめて返します。`N`ビットの値同士の乗算の結果は`2N`ビットを超えないので、オーバーフローすることなく乗算を行い結果を得ることができます。

`div_wide()`は商と剰余の計算を同時に行います。

```cpp
template<class T>
constexpr div_result<T> div_wide(T dividend_high, T dividend_low, T divisor) noexcept;
```

これは、次のような計算を精度の制限が無いかのように行います

```cpp
dividend = (dividend_high << sizeof(T)*8) | dividend_low;
result_quo = dividend / divisor;
result_rem = dividend % divisor;
```

結果として、`T`の幅に切り詰めた`result_quo`の値と`result_rem`の値を返します。

この関数では、`divisor == 0`もしくは商の値`result_quo`がオーバーフローしている場合は未定義動作となります。これは`is_div_wide_defined()`によって調べることができます。

```cpp
template<class T>
constexpr bool is_div_wide_defined(T dividend_high, T dividend_low, T divisor) noexcept;
```

引数は`div_wide()`と同じで、`div_wide()`の結果が未定義にならない場合に`true`を返します。

`would_cast_modify()`は、キャストによって値が変化するかを調べるものです。

```cpp
template<class T, class U>
constexpr bool would_cast_modify(U) noexcept;
```

型`U`の入力値が型`T`で表現可能かを調べ、できる場合に`true`を返します。

また提案にはしていないものの、`std::div_sat()`の削除と`std::div`のシグネチャ修正も解決すべき問題として挙げています。

- [P3161 進行状況](https://github.com/cplusplus/papers/issues/1825)

### [P3162R0 LEWG [[nodiscard]] policy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3162r0.html)
### [P3164R0 Improving diagnostics for sender expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3164r0.html)

提案中のExecutorライブラリにおいて、`sender`チェーンのエラーを早期に報告するようにする提案。

P2300にて`sender/receiver`ベースのExecutorライブラリの提案が進行中です。`sender`はなにかの処理を表現する型のことを指しており、`sender`同士は`|`でチェーンすることで非同期処理グラフを構成することことができ、その結果もまた何らかの`sender`型となります。

処理グラフを構成している`sender`の型チェックのためには通常、その完了シグネチャ（成功・失敗・完了の3つのチャネルが何を返すかなどの情報）を計算する必要があり、一般に完了シグネチャを計算するためには`receiver`のもつ実行環境（*execution environment*）の情報が必要であるため、`sender`が`receiver`に接続されるまでは`sender`の表現している処理グラフの型チェックを行うことができません。

例えば、`read(get_stop_token)`のような`sender`は、`rcvr`というなにか`receiver`を接続し処理が開始されると、その内部で`rcvr`の環境から次のように`stop_token`を取得してそれを返そうとします

```cpp
auto st = get_stop_token(get_env(rcvr));  // stop_token取得
set_value(move(rcvr), move(st));          // このsenderの処理の結果としてそれを返す
```

`receiver`が与えられてその実行環境が存在している場合にのみ、この`sender`（`read(get_stop_token)`）はその完了方法を知ることができます。

`receiver`の実行環境の型は接続されて初めて分かり、これはその`sender`が構成された場所から遠く離れている場合があります。その`sender`がエラーとなりうる構成をされている場合、そのエラーはその`sender`が構成された場所から離れたところで起こることになります。

ところが、用意されている`sender`のほとんどは`receiver`の実行環境に依存せずにその処理を完了することができます。例えば次のような`sender`による処理があるとき

```cpp
just(42) | then([](int* p) { return *p; });
```

この`just(42)`は結果として`42`という整数値を生成しますが、その結果は他の何かに依存せずに決まります。そして、後続の`then`ではそこに指定されたラムダの引数型が前段の`just(42)`の結果を受けることができないことがすぐに（`receiver`の接続を待たずして）分かります。

このような依存なしの`sender`（non-dependent `sender`）の場合、その後続の`sender`においてはその結果と自身の入力の期待が一致するかをすぐにチェックすることができます。

P2300でもそのような依存なしの`sender`は区別されていますが、現在その特性を使用してはいません。

この提案は、依存なしの`sender`が接続された場合の型チェックを早期に（`receiver`接続前に）行うようにする提案です。ここで提案されているのは次のことです

- 依存なしの`sender`を実行環境無くても完了を知ることのできる`sender`として定義
- `awaitable`ヘルパコンセプトの定義を変更して、任意のコルーチンで（`promise`型を知らなくても）`awaitable`かどうかのを問い合わせられるようにする
    - 例えば、awaiterインターフェース(`await_ready`, `await_suspend`, `await_resume`)を定義していればどのコルーチンでも`awaitable`であり、依存なしの`sender`として機能するはず
- 環境引数なしで`get_completion_signatures()`を呼び出せるようにする
- `completion_signatures_of_t`エイリアステンプレートの定義を修正し、`sender`の非依存シグネチャを問い合わせられるようにする（存在する場合にのみ）
- `sender`アダプタアルゴリズムに対して、可能な限り依存なし`sender`の性質を維持するように要求する
- `sender`アダプタアルゴリズムの"Mandates"にて、依存なし`sender`が渡されて型チェックに失敗した場合にハードエラーを起こすように規定する

これによって、多くの`sender`に対して早期の型チェックが可能となり、P2300の提案するライブラリ機能のユーザーエクスペリエンスが向上します。

- [P3164 進行状況](https://github.com/cplusplus/papers/issues/1827)

### [P3165R0 Contracts on virtual functions for the Contracts MVP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3165r0.html)
### [P3166R0 Static Exception Specifications](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3166r0.html)
### [P3167R0 Attributes for the result name in a postcondition assertion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3167r0.html)
### [P3168R0 Give std::optional Range Support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3168r0.html)
### [P3168R1 Give std::optional Range Support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3168r1.html)
### [P3169R0 Inherited contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3169r0.pdf)
### [P3170R0 sinkable exception error message](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3170r0.html)

標準の例外クラスに対して、動的確保無しでエラーメッセージを設定可能にする提案。

`std::logic_error`と`std::runtime_error`をはじめとする標準の例外クラスは、構築時にエラーメッセージを指定することができます。しかし、このコンストラクタに`std::string`を渡す場合、それはコピーされて保持される可能性があります。

```cpp
std::string temp = to_string(pos, location);
// std::stringはコピーされる可能性がある
throw std::out_of_range(temp);
```

これは、これらの型のコンストラクタが`explicit T(const string& what_arg);`の様に宣言されているためです。

この提案は、右辺値の`std::string`を受け取るコンストラクタを追加することで、例外オブジェクト構築時の余計な`std::string`のコピー及び動的メモリ確保の発生を削減しようとするものです。

この提案では各例外クラスのコンストラクタに`T(string&& what_arg);`の様なコンストラクタを追加することで、エラーメッセージを指定する`std::string`をムーブできるようにするものです。

```cpp
std::string temp = to_string(pos, location);
throw std::out_of_range(std::move(temp));

// もしくは
throw std::out_of_range(to_string(pos, location));
```

これによって、例外を投げる処理がそれに伴って発生しうる動的メモリ確保をその制御下に置くことができるようになります。

この提案は、以前のP3056R0で提案されていたものの一部を分離したものです。

- [P3056R0 what ostream exception - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P3056R0-what-ostream-exception)
- [`<stdexcept>` - cpprefjp](https://cpprefjp.github.io/reference/stdexcept.html)
- [P3170 進行状況](https://github.com/cplusplus/papers/issues/1833)

### [P3171R0 Adding functionality to placeholder types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3171r0.html)
### [P3172R0 Using `this` in constructor preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3172r0.html)
### [P3173R0 P2900R6 may be minimimal, but it is not viable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3173r0.pdf)
### [P3174R0 SG16: Unicode meeting summaries 2023-10-11 through 2024-02-21](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3174r0.html)

2023年10月から2024年2月に行われたSG16のミーティングの議事録。

全部で7回のミーティングが開催されており、どの提案をレビューしてだれがどういう発言をしたのかが詳しく記されています。

### [P3175R0 Reconsidering the `std::execution::on` algorithm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3175r0.html)
### [P3176R0 The Oxford variadic comma](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3176r0.html)
### [P3177R0 const prvalues in the conditional operator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3177r0.html)
### [P3179R0 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3179r0.html)
### [P3180R0 C++ Standard Library Ready Issues to be moved in Tokyo, Mar. 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3180r0.html)
### [P3181R0 Atomic stores and object lifetimes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3181r0.pdf)
### [P3182R0 Add pop_value methods to container adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3182r0.html)
### [P3183R0 Contract testing support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3183r0.pdf)
### [P3187R1 remove ensure_started and start_detached from P2300](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3187r1.pdf)
### [P3188R0 Proxy: A Pointer-Semantics-Based Polymorphism Library - Presentation slides for P3086R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3188r0.pdf)
### [P3189R0 Slides for LEWG presentation of P2900R6: Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3189r0.pdf)
### [P3190R0 Slides for EWG presentation of D2900R7: Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3190r0.pdf)
### [P3191R0 Feedback on the scalability of contract violation handlers in P2900](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3191r0.pdf)
### [P3192R0 LEWGI/SG18 Presentation of P3104R1 Bit Permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3192r0.pdf)
### [P3194R0 LEWGI/SG18 Presentation of P3105R1 constexpr std::uncaught_exceptions()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3194r0.pdf)
### [P3196R0 Core Language Working Group "ready" Issues for the March, 2024 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3196r0.html)
### [P3197R0 A response to the Tokyo EWG polls on the Contracts MVP (P2900R6)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3197r0.pdf)
### [P3198R0 A takeaway from the Tokyo LEWG meeting on Contracts MVP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3198r0.html)
### [P3199R0 Choices for make_optional and value()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3199r0.html)
### [P3201R0 LEWG [[nodiscard]] policy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3201r0.html)
### [P3201R1 LEWG [[nodiscard]] policy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3201r1.html)
### [P3203R0 Implementation defined coroutine extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3203r0.html)
### [P3205R0 Throwing from a `noexcept` function should be a contract violation.](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3205r0.pdf)
### [P3207R0 More & like](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3207r0.html)
### [P3208R0 import std; and stream macros](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3208r0.pdf)
### [P3210R0 A Postcondition *is* a Pattern Match](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3210r0.html)
### [P3211R0 views::transform_join](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3211r0.html)
### [P3213R0 2024-04 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3213r0.html)
### [P3215R0 Slides: Thread Attributes as Designators (P3072R2 presentation)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3215r0.pdf)
### [P3216R0 views::slice](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3216r0.html)
### [P3217R0 Adjoints to "Enabling list-initialization for algorithms": find_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3217r0.html)
### [P3218R0 const references to constexpr variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3218r0.html)
### [P3220R0 views::delimit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3220r0.html)
### [P3221R0 Disable pointers to contracted functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3221r0.pdf)
### [P3222R0 Fix C++26 by adding transposed special cases for P2642 layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3222r0.html)
### [P3223R0 Making std::basic_istream::ignore less surprising](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3223r0.html)
### [P3224R0 Slides for P3087 - Make direct-initialization for enumeration types at least as permissive as direct](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3224r0.pdf)
### [P3225R0 Slides for P3140 std::int_least128_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3225r0.pdf)
### [P3226R0 Contracts for C++: Naming the "Louis semantic"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3226r0.pdf)
### [P3228R0 Contracts for C++: Revisiting contract check elision and duplication](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3228r0.pdf)
### [P3230R0 views::(take|drop)_exactly](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3230r0.html)
### [P3232R0 User-defined erroneous behaviour](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3232r0.html)
### [P3233R0 Issues with P2786 (Trivial Relocatability For C++26)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3233r0.html)
### [P3234R0 Utility to check if a pointer is in a given range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3234r0.html)
### [P3236R0 Please reject P2786 and adopt P1144](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3236r0.html)
### [P3237R0 Matrix Representation of Contract Semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3237r0.pdf)
### [P3240R0 Slides for EWGI presentation on allocators, Tokyo 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3240r0.pdf)
### [P3241R0 Slides for LEWG presentation on trivial relocation, April 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3241r0.pdf)
### [P3242R0 Copy and fill for mdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3242r0.html)
### [P3243R0 Give std::optional Range Support - Presentation, Tokyo 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3243r0.pdf)
### [P3244R0 [[nodiscard]] Policy - Presentation, Tokyo 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3244r0.pdf)
### [P3245R0 Allow `[[nodiscard]]` in type alias declarations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3245r0.html)
### [P3247R0 Deprecate the notion of trivial types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3247r0.html)
