# ［C++］モジュール 理論編

※この内容はC++20より有効なものです。C++20正式策定までの間に内容が変化する可能性があります。

より読みやすい解説がすでにあるのでそちらにも目を通されるといいと思われます。→ [モジュール - cpprefjp](https://cpprefjp.github.io/lang/cpp20/modules.html)

### モジュールのインターフェースと実装
あるファイルをモジュールである！と宣言するには、__モジュール宣言__ をファイル先頭で行います。モジュール宣言を行うことでそのファイルは1つの __モジュール単位__、かつ1つの翻訳単位となります（すなわち、モジュール単位＝翻訳単位）。

通常のC++コードがソースファイル（定義）とヘッダファイル（宣言）に分割できる様に、モジュールにおいても宣言と定義を別のファイル（別々のモジュール単位）に分けて実装する事ができます。その時、それらのモジュール単位はそれぞれ __モジュールインターフェース単位__ と __モジュール実装単位__ と呼ばれます。

以下、コメントでファイル名が書かれている部分は、そこから別のファイルにあるものとして書いていきます。

```cpp
///mymodule.cpp
//（プライマリー）モジュールインターフェース単位の宣言
export module MyModule;

//export宣言、宣言をモジュール外部で使用可能にする
export int f(int n);

///mymodule_impl.cpp
//モジュール実装単位の宣言
module MyModule;
//ここでは暗黙的にプライマリーモジュールインターフェース単位をimportしている
//import MyModule; のようには書けないため

int f(int n) {
  return n;
}

///main.cpp（非モジュール）
//モジュールMyModuleのインポート宣言、exportされているものを取り込む
import MyModule;

int main() {
  //使用可能
  int n = f(10);
}
```

このように、`export module`の形のモジュール宣言によってインターフェース単位を宣言し、このモジュール単位は __プライマリーモジュールインターフェース単位__ と呼ばれ、モジュールには必ず __唯一つだけ__ 含まれていなければなりません。

その名の通り、（モジュール）インターフェース単位にはモジュールのインターフェース、すなわち外部に公開する宣言を、実装単位にはそれら宣言の実装をそれぞれ書く、という事を想定しています。

どちらの宣言においても`module`の後に来るのがモジュール名で、（一部のキーワードを除いて）好きな名前を付けることができます。

モジュールインターフェースでは、モジュール外に提供したい宣言をエクスポート宣言（`export 宣言;`）によって外部へ公開します。  
そして、モジュールを利用する側（翻訳単位）ではインポート宣言（`import モジュール名;`）によってモジュールからエクスポートされている宣言を取り込みます。

モジュール実装単位とインターフェース単位は同じ名前を持つことができます。すると、実装単位においてインターフェース単位をインポートしようとすると自分自身をインポートすることになってしまいます。  
いかなるモジュールも自分自身をインポートすることはできません。そのため、モジュール実装単位は対応する（プライマリー）モジュールインターフェース単位を暗黙的にインポートします。

なお、ヘッダーやソースファイルがそうである様に、モジュールファイルの拡張子は規定されていません。コンパイラがそれと認識すれば、拡張子は自由です。

#### モジュールパーティション

そしてさらに、モジュールの内部のファイルを複数のファイルに分けて実装する事ができます。  
これは例えば、自作のライブラリを1つのモジュールとして提供したいが、その内部の実装においては整理のためにも複数のファイルに分けたい、という際に役立ちます。

その様にモジュール内部で分割したファイル（これもまたモジュール単位）は __モジュールパーテイション__ と呼ばれます。  
そして、モジュールパーティションもまたインターフェースと実装に分割する事ができ、分割後のモジュール単位はそれぞれ __モジュールインターフェースパーティション__、__モジュール実装パーティション__ と呼ばれ、それぞれモジュールインターフェース単位とモジュール実装単位でもあります。

```cpp
///mymodule_part.cpp
//モジュールインターフェースパーティションの宣言
export module MyModule:InterfacePart;
import :ImplPart;  //import宣言、モジュールパーティションMyModule:ImplPartでexportされているものを取り込む

export double g(double v) {
  return g_impl(v);  //パーティション:ImplPart内の関数を使用
}

///mymodule_part_impl.cpp
//モジュール実装パーティションの宣言
module MyModule:ImplPart;

double g_impl(double v) {
  return v + v;
}

///mymodule.cpp
//（プライマリー）モジュールインターフェース単位の宣言
export module MyModule;
export import :InterfacePart;  //インターフェースパーティション:InterfacePartの再エクスポート、必須

export int f(int n);

///mymodule_impl.cpp
//モジュール実装単位の宣言
module MyModule;

int f(int n) {
  return n;
}

///main.cpp
import MyModule; 

int main() {
  //共に使用可能
  int n = f(10);
  double v = g(1.0);
}
```

モジュールパーティションの宣言はモジュール宣言とほぼ同様で、モジュール名の後に`:パーティション名`を指定します。`:`がモジュールパーティションである証です。  
通常のモジュールインターフェース単位は実質プライマリーモジュールインターフェース単位の一つしか作ることができませんが、インターフェースパーティションはいくつでも作ることができます。

ただし、同じモジュール内で複数のモジュールパーティションが同じ名前を持つことは出来ません。従って、インターフェースパーティションと実装パーティションでは異なる名前を付ける必要があります（このため、実装パーティションは使用するインターフェースパーティションを明示的にインポートする必要があります）。

このようなモジュールのパーティションへの分割は、モジュールの外からは観測することができません。したがって、モジュールパーティションはモジュール外で`import`することは出来ません。  
そのため、モジュールインターフェースパーティション内のエクスポートしたい宣言は全て、プライマリーモジュールインターフェース単位から再エクスポートされなければなりません。  

また、モジュールパーティションをインポートするときは、（`:`も含めた）そのパーティション名だけを指定する必要があります。モジュール名は要らず、むしろコンパイルエラーになります。

上記の例では以下のように書いてはいけません。

```cpp
///mymodule_part.cpp
//モジュールインターフェースパーティションの宣言
export module MyModule:InterfacePart;
import MyModule:ImplPart;  //compile error!

///mymodule.cpp
//（プライマリー）モジュールインターフェース単位の宣言
export module MyModule;
export import MyModule:InterfacePart;  //モジュール名を指定してはいけない
```

モジュールパーティションを（同モジュール内で）インポートした際は通常のインポート宣言とは異なり、エクスポートしていない宣言も利用可能になります。

#### モジュール宣言、まとめ

ここまで4種類のモジュールが出てきましたが、モジュールはその種別にかかわらず1ファイル1モジュール（単位）であり、モジュール1つは1つの翻訳単位を成しています。  
そのような複数のモジュール単位は、そのモジュール名によって1つのモジュールとしてまとめて扱われます。  
なお、モジュール名は`:`の左側に来るもので、モジュールパーティション名（`:`の右側）はモジュール名ではありません。

#### インターフェースオンリーなモジュール

### 可視と到達可能（Visible and Reachable）

### `export`

### `import`


### モジュールにおけるテンプレートのインスタンス化

### ADLとモジュール

### `inline`変数・関数

### グローバルモジュールフラグメント

### Header Unit

### モジュール史（2004 - 2019）
- Moduleのあけぼの
  - [N1736: Modules in C++ (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1736.pdf)
  - [N1778: Modules in C++ (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1778.pdf)
  - [N1964: Modules in C++ (Revision 3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1964.pdf)
  - [N2073: Modules in C++ (Revision 4)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf)
  - [N2316: Modules in C++ (Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2316.pdf)
  - [N3347: Modules in C++ (Revision 6)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf)
- MSの隆盛
  - [N4047: A Module System for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4047.pdf)
  - [N4214: A Module System for C++ (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4214.pdf)
  - [N4465: A Module System for C++ (Revision 3)](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4465.pdf)
  - [P0142R0: A Module System for C++ (Revision 4)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0142r0.pdf)
- Moduleの挑戦とつまづき
  - [N4466: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4466.pdf)
  - [P0143R0: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0143r0.pdf)
  - [P0143R1: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0143r1.pdf)
- Module TSの時代
  - [N4592: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)
  - [N4610: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4610.pdf)
  - [N4637: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4637.pdf)
  - [N4681: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4681.pdf)
  - [N4720: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4720.pdf)
- googleの台頭（Atom Proposals）
  - [P0947R0: Another take on Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r0.html)
  - [P0947R1: Another take on Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r1.html)
  - [P0986R0: Comparison of Modules Proposals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0986r0.html)
- ひらけゆくModule
  - [P1103R0 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r0.pdf)
  - [P1103R1 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r1.pdf)
  - [P1103R2 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r2.pdf)
  - [P1103R3 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)

### 参考文献

- [P1103R3 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)
- [モジュール - cpprefjp](https://cpprefjp.github.io/lang/cpp20/modules.html)
- [C++ ModulesのHeader units - Qita](https://qiita.com/tetsurom/items/e25b2683cb7e7c0fa91c)
- [C++ Modulesの分割 - Qita](https://qiita.com/tetsurom/items/0de4795866b52f5bcf65)
- [C++ ModulesとDLLの関係 (MSVCの場合) - Qita](https://qiita.com/tetsurom/items/0f6aad21e06b043f42bd)
- [Understanding C++ Modules: Part 1: Hello Modules, and Module Units - vector<bool>{ true, true, false };](https://vector-of-bool.github.io/2019/03/10/modules-1.html)
- [Understanding C++ Modules: Part 2: export, import, visible, and reachable - vector<bool>{ true, true, false };](https://vector-of-bool.github.io/2019/03/31/modules-2.html)
- [C++20: Modules - MODERNES C++](https://www.modernescpp.com/index.php/c-20-modules)
- [C++20: More Details to Modules - MODERNES C++](https://www.modernescpp.com/index.php/c-20-more-details-to-modules)
- [C++ MODULES - HSAE - Wuhan · 张轶](http://purecpp.org/purecpp/static/717887c97bf947d68e67da309cdd0611.pdf)