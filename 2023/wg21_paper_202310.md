# ［C++］WG21月次提案文書を眺める（2023年08月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-10)

全部で80本あります。

もくじ

[:contents]

### [N4961 2024-03 Tokyo meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4961.pdf)

2024年3月末に東京で行われるWG21全体会議の案内。

### [N4962 WG21 agenda: 6-11 November 2023, Kona, HI](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4962.html)

2023年11月にハワイのコナで行われるWG21全体会議のアジェンダ。

### [N4963 2023 WG21 admin telecon meetings, rev. 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4963.pdf)

11月の全体会議に先立って行われる、WG21管理者ミーティングの案内。

### [N4964 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4964.pdf)

C++26のワーキングドラフト第2弾

### [N4965 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4965.html)

↑の変更点をまとめた文書。

新規に採択された提案はなく、編集上の変更のみです。また、C++23 DISに対するNBコメントの対応についても記されています。

### [P0447R23 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0447r23.html)
### [P0876R14 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0876r14.pdf)
### [P0952R1 A new specification for `std::generate_canonical`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0952r1.html)

`std::generate_canonical`の仕様を改善する提案。

[`std::generate_canonical`](https://cpprefjp.github.io/reference/random/generate_canonical.html)の現在の規定は、浮動小数点数の仕様を無視しているため誤って制約されています。それによって実質的に正しい実装が不可能になっています。この提案では主に2つの問題について指摘しています。

この関数の動作は次の3つの要件に従うはずです

1. 結果は`[0, 1)`に入らなければならない
2. アルゴリズムは正確に指定されており、使用する`URBG`は指定された引数に対して特定の固定回数だけ呼び出される必要がある
3. 結果は一様分布となる

1つ目の問題は、これらの要件を満たしながらの実装が不可能である点です。現在の規定は、要件2を満たすように正確に数式によって指定されており、結果である`S/Rk`は数学的には1未満の値を返します。しかし、浮動小数点数によってこの式が実行される場合、丸めによってこの結果は正確に`1`になる場合があります。このことは、`generate_canonical`から取得した`x`に対して`(1.0 - x)`で除算している場合にバグを引き起こします。

すなわち、現在の規定では要件2を満たそうとすると、要件1に違反します。結果が`1`になってしまった場合に結果を修正しようとすれば要件3に違反します。要件1と3を満たすようにすると、結果が`1`となる場合にアルゴリズムを再実行する必要があり、それは要件2に違反します。

2つ目の問題は、除算と浮動小数点丸め（最近接偶数丸め）が組み合わさることで出力が均一とならない場合があることです。例えば、`0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5`という値に対して丸めを行うことを考える場合、最下位ビットを切り捨てれば`0, 0, 1, 1, 2, 2, 3, 3`となりこれは一様ですが、浮動小数点数において一般的な最近接偶数丸めを行うと`0, 0, 1, 2, 2, 2, 3, 4`となり偶数と奇数のバランスに偏りが生じる他、0にもバイアスが生じています。

これと同じことが`std::generate_canonical`の計算の過程で発生し、最下位ビットあるいはその周辺の数ビットにおいて結果のバイアスが生じることで最終的な結果の均一性が失われます（この辺りの説明はこの記事を書いている人が理解できていないので、提案の方を参照されるといいと思います・・・）。

この提案は、この2つの問題を`std::generate_canonical`のインターフェースを変更することなく解決するために、アルゴリズムや計算量についての規定を変更することで改善しようとするものです。

この提案は一部の引数の解釈やアルゴリズムそのものを変更することによって、non-trivial divisionを使用せず再近接偶数丸めの問題を回避しようとしています。そのため、副作用や計算量が変化し、また、同じ入力から生成される乱数列も変更前と異なることになります。そのため、それらに依存する既存のコードの動作は実行時に壊れます。

ただし、この提案では`std::generate_canonical`の結果が区間`[0, 1)`内で`RealType`の表現可能な全ての値が含むようにすることは、定義が困難かつ実装が複雑化するとして行っていません。

- [`std::generate_canonical` - cpprefjp](https://cpprefjp.github.io/reference/random/generate_canonical.html)
- [`[0.0, 1.0)` の乱数を得るための“本当の”方法](https://speakerdeck.com/hole/rand01)
- [単精度浮動小数点数 - FC2](https://ieyasu03.web.fc2.com/Computer/CUDA/04_float.html)
- [P0952 進行状況](https://github.com/cplusplus/papers/issues/574)

### [P1144R9 std::is_trivially_relocatable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1144r9.html)
### [P1729R3 Text Parsing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1729r3.html)
### [P1928R7 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r7.pdf)
### [P2019R4 Thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2019r4.pdf)
### [P2075R3 Philox as an extension of the C++ RNG engines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2075r3.pdf)
### [P2267R0 Library Evolution Policies](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2267r0.html)

C++標準ライブラリ設計のためのポリシーについて検討する提案。

ここでのポリシーとは、C++標準ライブラリの将来のユーティリティの提案者が従うべき技術ルールもしくは技術ガイドラインのことです。

この提案では、ポリシーの利点と欠点とを勘案しながら、LEWGのレビューを通過した提案全てに適用されるものとしてのポリシーを設定し、それを常設文書（SD-9）として設定することを提案しています。ただし、提案しているのはポリシーの確立と文書化のプロセスのみで、ポリシーそのものは例示するに留めています。

ポリシーを設定することの利点と欠点としては次のようなものが挙げられています

- 利点
    1. ポリシーによって、標準ライブラリの様々な部分の動作におけるユーザーの期待に対して統一性を持たすことができる
    2. ポリシーによって、提案の著者とレビューする委員会の両方の時間が節約される
    3. ポリシーは共有された知識ベースから作成される必要がある（それによって、それら知識の断片化や解釈の不一致を最小限に抑えることができる）
    4. ポリシーによって、標準化プロセスを新規参入者にとって優しいものにすることができる
- 欠点
    1. ポリシーは、委員会内で少数派領域の代表の意見を押し退けてしまう可能性がある
    2. 提案された一部のユーティリティに対しては、ポリシーによって誤った技術的解決策を強制してしまう可能性がある

欠点でも触れられているように、単一の原則が全てに適合することはなく、あるポリシーについてライブラリ全体の合意に達することには困難が伴います。この提案では、設定されたポリシーは常に強制されるものではなく、ポリシーに違反していることを明示しその理由について説明されていれば、ポリシーを常に守る必要はない、という運用にすることを提案しています。

小さなポリシー1つをとってもライブラリ全体での合意を得るには時間がかかりますが、そのような議論を提案ごとではなくポリシーを確立する1度だけ行っておくことで、長期的には時間の節約になり他の利点を得ることもできる、としています。

- [P2267 進行状況](https://github.com/cplusplus/papers/issues/1646)

### [P2447R5 std::span over an initializer list](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2447r5.html)
### [P2500R2 C++ parallel algorithms and P2300](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2500r2.html)
### [P2542R6 views::concat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2542r6.html)
### [P2642R4 Padded mdspan layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2642r4.html)
### [P2663R4 Proposal to support interleaved complex values in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2663r4.html)
### [P2664R4 Proposal to extend std::simd with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2664r4.html)
### [P2717R3 Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2717r3.html)
### [P2762R2 Sender/Receiver Interface For Networking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2762r2.pdf)
### [P2774R1 Concurrent object pool (was: Scoped thread-local storage)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2774r1.pdf)
### [P2786R3 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2786r3.pdf)
### [P2800R0 Dependency flag soup needs some fiber](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2800r0.html)

依存ライブラリとしてモジュールを使用する際に、必要となる情報について説明する文書。

この文書では、あらゆるプロジェクトにおいて共通する、そのプロジェクトを有意義に活用するために必要な一連の手順があり、その手順のために必要な各種情報（コンパイラ/リンカオプション、動的ローダーの環境変数、プラグインローディング環境変数などを通じて伝達される傾向にあるあらゆるもの）のことをプロジェクトの使用要件（*usage requirement*）と呼んでいます。この使用要件を発見することはビルドシステムの仕事の中核をなしています。

また、その使用要件を収集するための（ツールチェーンに依存する）方法のことをフラグスープ（*flag soup*）と呼んでいます。

この文書は、現在のフラグスープに代わるより構造化された使用要件の伝達手段の必要性を説くものです。

文書の意図は、モジュールを使用するクライアントはクライアントによって異なる使用要件を持ち、同じプロジェクト内でさえも同じモジュールに対して翻訳単位ごとに異なるBMIを取得する可能性があり、現在のフラグスープではその用途のために十分でないことを示すことにあります。また、そのような使用要件をより完全に伝達することができるようにすることで、BMIを再利用しやすくなるメリットもあります。

### [P2809R2 Trivial infinite loops are not Undefined Behavior](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2809r2.html)
### [P2841R1 Concept Template Parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2841r1.pdf)
### [P2845R3 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2845r3.html)
### [P2845R3 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2845r4.html)
### [P2862R1 text_encoding::name() should never return null values](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2862r1.html)
### [P2863R2 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2863r2.html)
### [P2885R3 Requirements for a Contracts syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2885r3.pdf)
### [P2893R1 Variadic Friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2893r1.pdf)
### [P2897R1 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2897r1.html)
### [P2900R0 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2900r0.pdf)

↓

### [P2900R1 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2900r1.pdf)

C++ 契約プログラミング機能の提案。

C++20で一度標準入りしてから撤回され、MVPという最小仕様を確立すべくSG21で議論を重ねられてきました。この提案はC++26に向けて現時点でのContracts MVP仕様をまとめ、それを正式な契約プログラミング機能としてC++26に導入するためのものです。

この提案は大きく設計と文言のセクションに分かれており、設計セクションではMVPの契約機能の構文と意味論について説明され、文言セクションでは設計セクションで説明された機能をC++言語で有効化するための標準のための文言の変更が記載されています（現時点では文言は未整備ですが）。設計セクションを読むことでC++26契約プログラミング機能がどういうものかを把握することができるでしょう。

ただし、現在のところ構文がまだ決まっておらず、いくつか小さめの未解決の問題が残されているため、まだ完全なものではありません。

- [P2900 進行状況](https://github.com/cplusplus/papers/issues/1648)

### [P2911R1 Python Bindings with Value-Based Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2911r1.pdf)
### [P2927R0 Observing exceptions stored in exception_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2927r0.html)

`std::exception_ptr`を再スローせずに例外オブジェクトの取得を試みる関数の提案。

`std::exception_ptr`は例外オブジェクトを型消去して可搬にすることができるラッパー型であり、例外オブジェクトを取り扱いやすくすることに貢献します。しかし、`std::exception_ptr`はかなり制限されたAPIしか持たず、現在参照している例外オブジェクトの型の情報などを取得することができません。

それによって、他のエラー伝達手段と比較してエラーを処理するための方法が制限されます。例えば、`std::optional/std::expected`のようなモナディックインターフェースを実装しようと思うと、`std::exception_ptr`の参照する例外オブジェクトを一旦再スローし、ハンドルされない場合はキャッチして再び`std::exception_ptr`に格納しなおすようなことをしなければならず、これはとても重い処理になります。

この提案はそのために、再スローをすることなく`std::exception_ptr`の例外オブジェクトを取得するためのAPIを追加しようとするものです。

この提案では、`try_cast<T>()`という関数を提案しています。これは、`std::any_cast`や`std::get_if`などとよく似たAPIで、`std::exception_ptr`を引数で渡して`T`に想定する型を指定し、`std::exception_ptr`の参照する例外オブジェクトの型が`T`（もしくはその曖昧でない基底クラスが`T`）である場合に例外オブジェクトへのポインタを返し、そうでない場合は`nullptr`を返します。

```cpp
template <typename T>
const std::remove_cvref_t<T>* 
  try_cast(const std::exception_ptr& e) noexcept;
```

提案文書より、サンプル

```cpp
struct Foo {
  virtual ~Foo() {}
  int i = 1;
};

struct Bar : Foo, std::logic_error {
  Bar() : std::logic_error("This is Bar exception") {}
  int j = 2;
};

struct Baz : Bar {};


int main() {
  const auto exp = std::make_exception_ptr(Baz());

  if (auto* x = try_cast<Baz>(exp)) {
    printf("got '%s' i: %d j: %d\n", typeid(*x).name(), x->i, x->j); 
  }
  if (auto* x = try_cast<Bar>(exp)) {
    printf("got '%s' i: %d j: %d\n", typeid(*x).name(), x->i, x->j);
  }
  if (auto* x = try_cast<Foo>(exp)) {
    printf("got '%s' i: %d\n", typeid(*x).name(), x->i);
  }
}
```

この出力は、例えば次のようになります

```
got '3Baz' what:'This is Bar exception' i: 1 j: 2
got '3Baz' what:'This is Bar exception' i: 1 j: 2
got '3Baz' i: 1
```

`try_cast<T>(exptr)`は、`exptr`の中身を再スローした時に`catch`節に記述してマッチングする型が`T`に指定された場合に例外オブジェクトへのポインタを`const T*`として返し、マッチングしない場合は`nullptr`を返します。

このような機能の実装のためには例外機構に手を加える必要がありそうですが、GCC/MSVC（libstdc++/MSVC STL）は非公開ながらそのような機能を持っており、それぞれの実装者も実装可能であると言っているようです。さらに、metaのfollyというライブラリではこれとよく似た機能がポータブルに実装されており、metaの様々なサービス内部で使用されているようです。

このような機能はまた、将来的にパターンマッチング機能において`std::exception_ptr`のパターンマッチングを可能にすることもできます。

- [［C++］ 例外送出からキャッチまでのあいだ - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2023/05/21/204050)
- [P2927 進行状況](https://github.com/cplusplus/papers/issues/1649)

### [P2932R1 A Principled Approach to Open Design Questions for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2932r1.pdf)
### [P2935R3 An Attribute-Like Syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2935r3.pdf)
### [P2959R0 Container Relocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2959r0.html)

ブロックベースコンテナ（特に`std::vector`）の再配置時の動作を修正する提案。

標準ライブラリのコンテナは主にノードベースコンテナ（`std::list, std::map`など）とブロックベースコンテナ（`std::vector, std::deque`など）の2つに大別することができます。

コンテナが管理する個別のオブジェクトの事を要素（*element*）と呼び、その要素の状態の事を値（*value*）と呼ぶとするとき、要素と値の区別は理論的なもので、この違いが実際のコードで現れることはほとんどありません。

しかし、ノードベースコンテナとブロックベースコンテナの間でこの違いが顕在化する場合があります。

```cpp
using element = std::tuple<int &>;

static_assert(std::is_move_assignable_v<int &>);
static_assert(std::is_move_assignable_v<element>);

template<typename C>
void test() {
  int a = 1;
  int b = 2;
  int c = 3;

  C x;
  x.emplace_back(a);
  x.emplace_back(b);
  x.emplace_back(c);

  std::cout << "a:\t" << a << "\n"                            // 1
            << "b:\t" << b << "\n"                            // 2
            << "c:\t" << c << "\n";                           // 3


  auto const mid = std::next(x.begin());

  std::cout << "x[0]:\t" << std::get<0>(x.front()) << "\n"    // 1
            << "x[1]:\t" << std::get<0>(*mid)      << "\n"    // 2
            << "x[2]:\t" << std::get<0>(x.back())  << "\n";   // 3

  x.erase(mid);

  std::cout << "x[0]:\t" << std::get<0>(x.front()) << "\n"    // 1
            << "x[1]:\t" << std::get<0>(x.back())  << "\n";   // 3

  b = 4;
  c = 5;

  std::cout << "x[0]:\t" << std::get<0>(x.front()) << "\n"    // 1
            << "x[1]:\t" << std::get<0>(x.back())  << "\n";   // 5 or 4
}

int main() {
  test<std::vector<element>>();
  std::cout << "----------------\n";
  test<std::list<element>>();
}
```

- [Wandbox](https://wandbox.org/permlink/X8tx00vk4E3yMeR8)

この実行結果は次のようになります

```
a:	1
b:	2
c:	3
x[0]:	1
x[1]:	2
x[2]:	3
x[0]:	1
x[1]:	3
x[0]:	1
x[1]:	4
----------------
a:	1
b:	2
c:	3
x[0]:	1
x[1]:	2
x[2]:	3
x[0]:	1
x[1]:	3
x[0]:	1
x[1]:	5
```

一番最後の`x[1]`の出力結果だけが異なっています。

`std::tuple<int&>`の構築時は、メンバの参照がコンストラクタ引数のオブジェクトへ束縛されますが、代入時はメンバの参照の切り替えではなくメンバ参照の参照先のオブジェクトへの代入が行われます。

`std::vector`の要素が削除される時、特に中間位置にある要素が削除されるとき、現在のブロック全体を確保しなおすのではなく、削除された位置よりも後ろの要素を前にずらすようにして再配置が行われます。この時、各要素が破棄されてから再構築されるのではなく、ムーブ代入によって要素の移動が起こります。そのため、`x.erase(mid)`では`b`への参照をメンバに持つ`tuple`要素を削除しますが、そこにはすぐ後ろの`c`への参照をメンバに持つ`tuple`が代入されます。それによって、`b = c`のような値の移動が起こり、`vector`から削除されるのは`b`の参照ではなく`c`の参照です。そのため、その後`b = 4`をすると`vector`の2番目の要素からもそれが観測できます。

`std::list`（他ノードベースコンテナ）の場合は単に1つのノードが削除されリンクが修正されるだけなので、このような要素の再利用は起きず、結果は意図通りになります。

このことはまた、`std::vector`そのものの状態によっても挙動に差異が生まれる場合があります。

```cpp
int main() {
  int a = 1;
  int b = 2;

  using element = std::tuple<int &>;
  std::vector<element> v;
  v.reserve(4);
  assert(4 == v.capacity());

  // aの参照で埋める
  auto fill = [&](int & i ) {
    v.clear();
    for (int j = 0; j != 4; ++j) {
      v.emplace_back(i);
    }
  };

  // 真ん中にbの参照を挿入
  auto inject = [&](int & i) { v.emplace(v.begin() + 2, i); };

  // 値と参照先変数名を出力
  auto report = [&] {
    for (auto& j : v) {
      std::cout << std::get<0>(j);
    }

    for (auto& j : v) {
      if (&a == &std::get<0>(j)) {
        std::cout << 'a';
      }
      else if (&b == &std::get<0>(j)) {
        std::cout << 'b';
      }
      else {
        std::cout << '?';
      }
    }

    std::cout << '\n';
  };

  for (int dummy : {1, 2}) {
    fill(a);
    inject(b);
    report();
  }
}
```

- [Wandbox](https://wandbox.org/permlink/IgSef3zD2mLvy2mv)

```
11211aabaa
22222aaaaa
```

`std::vector`のキャパシティの状態によってこの挙動の差異が生じており、キャパシティが丁度4つ分の場合は`inject()`においてブロック再確保が発生し全ての要素は再構築されますが、キャパシティが充足している場合は再確保が発生せず、挿入は再代入によって行われます。

これらの振る舞いは現在の規格の規定に則ったもので、現時点でもこの仕様によって引き起こされる懸念がいくつかありますが、トリビアルリロケーションを考慮するとそれらの懸念はより大きいものになり得ます。そして、この懸念はコンテナの要素型とコンテナのアロケータ型の2つの異なる原因から生じています。

1. ムーブ構築ではなくムーブ代入による要素の置換
    - 要素型のムーブ代入によって、破棄とムーブ構築とは異なる状態が生成される場合、ブロックベースコンテナはノードベースコンテナとは異なる振る舞いをする
2. アロケータは要素の同一性を考慮する必要がある
    - ムーブ代入によって内部再配置が行われる場合に、構築された要素のID（アドレス）が重要である場合、アロケータの`.destroy()`の期待に反する可能性がある
3. 強い例外安全保障が破られる可能性がある
    - アロケータの`construct()`がカスタマイズされている場合、構築時に要素型のコンストラクタ以外から例外が投げられないことを仮定できない
    - 現在のブロックベースコンテナに対する強い例外安全保障は要素型のムーブコンストラクタのみを考慮しており、アロケータを考慮していない
4. トリビアルリロケーションのサポートにおいて問題が起こりうる
    - アロケータが`construct()`を提供する場合、（3と同様の理由により）要素型のトリビアルリロケーション可能性の情報を利用できない
5. 再配置は標準ライブラリの未初期化アルゴリズムと同様にオブジェクトを作成する
    - `<memory>`に現在の`uninitialized_*`系アルゴリズムに対応する、ムーブ構築を基本とし利用可能な場合はリロケーションを利用して最適化する汎用の関数を追加する必要がある

この提案はこれらの懸念に対処するために次のような変更を標準ライブラリに加えることを提案しています

1. ムーブ構築/代入が一貫しない振る舞いをする型のために、新しい型特性を追加する
2. アロケータが独自の実装を提供せず1の特性が`false`となる場合に、現在の動作をデフォルトとする内部再配置（置換）をサポートするための非静的メンバ関数を`std::allocator_traits`に追加する

1つめの新しい型特性は`std::container_replace_with_assignment<T>`というもので、これは`T`のムーブ代入と破棄+ムーブ構築が異なる振る舞いをする（上記の`std::tuple<int&>`のように）ことを通知するものです。

```cpp
namespace std {
  template <class T>
  struct container_replace_with_assignment : is_move_assignable<T>::type {};

  template <class T>
  constexpr bool container_replace_with_assignment_v = container_replace_with_assignment{};
}
```

下位互換性のために、ムーブ代入が可能な型では`true`となるのがデフォルトとされます。意図的に`false`とするには部分特殊化を定義します

```cpp
namespace std {
  template <class ...TYPES>
  struct container_replace_with_assignment<tuple<TYPES...>>
    : conjunction<container_replace_with_assignment<tuple<TYPES>>...>::type
  {};
}
```

2つめの関数は`std::allocator_traits::relocate()`という関数で、これは主にコンテナ内で再配置が起こる場合に再配置の方法をカスタマイズするものです。次のような動作をします

1. アロケータ型が`relocate()`メンバ関数を定義する場合、それを呼び出す
2. アロケータ型が少なくとも1つの`construct()/destroy()`を定義している場合、再配置対象の右辺値を渡してそれらを利用する
3. 要素型がトリビアルコピー可能ならば、`memmove`を利用する
    - トリビアルなリロケーションが導入された場合、それで置き換えられる
4. それ以外の場合、ムーブ代入/構築によって再配置
    - `std::container_replace_with_assignment<T>`が`true`ならばムーブ代入によって再配置（現在の動作）
    - `std::container_replace_with_assignment<T>`が`false`ならば破棄とムーブ構築によって再配置

コードで書くと、次のようになります

```cpp
if constexpr (requires requires{ allocator::relocate(...); }) {
  // forward to allocator::relocate
} else if constexpr(requires requires{ allocator::construct(...); }) {
  // `allocator_traits::destroy(); allocator_traits::construct(rvalue)` each element
} else if constexpr (is_trivially_relocatable_v<T>) {
  // trivially relocate
} else if constexpr (container_replace_with_assignment_v<T>) {
  // move-assign elements
} else {
  // destroy-move-construct elements
}
```

現在動作しているコードは基本的に引き続いて4番目の動作を選択することで動作を維持します。3番目の動作はさらに、トリビアルコピー可能な型に対しての最適化を組み込んでいます。また、4番目の動作では同時に提案している`std::container_replace_with_assignment<T>`を使用してムーブ代入の使用が適切かどうかを判定し、不適切な場合は再配置先要素の破棄の後そこにムーブ構築することで再配置を行います。

これらの変更によって、後方互換性を維持しつつ現在の振る舞いを修正するとともに、将来的なトリビアルリロケーションを適切に有効化することができます。ただし、この提案は現在の実行時の動作を静かに変更する可能性があります。

- [P2959 進行状況](https://github.com/cplusplus/papers/issues/1650)

### [P2961R1 A natural syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2961r1.pdf)
### [P2962R0 Communicating the Baseline Compile Command for C++ Modules support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2962r0.pdf)

Baseline Compile Commandの説明と、それを伝達する方法についての提案。

ある翻訳単位におけるヘッダユニットのインポートは、その翻訳単位のプリプロセッサ状態の影響を受けず、ヘッダユニットはマクロをエクスポートするためヘッダユニットがインポートされるとその翻訳単位のプリプロセッサ状態は更新されます。一方で、ヘッダユニットはその翻訳単位に指定されているコンパイラオプション（コンパイラコマンド）は適用されなければなりません。

ただし、ヘッダユニットのインポートにおいてはその翻訳単位のプリプロセッサ状態を含めたローカルプリプロセッサ引数を適用しないようにする必要があります。この制約は、同じヘッダユニットを異なる翻訳単位でインポートした時でも、双方の翻訳単位において同じようにインポート可能なヘッダをパースするためのものです。特に、推移的なインポートが起こる場合に同じヘッダユニットの内容が異ならないようにするために求められることです。そのため、ローカルプリプロセッサ引数とはある翻訳単位に固有な、コンパイル中のプリプロセッサ状態に影響を与えうる引数のことです。

また、SG15における合意ではビルドシステム以外のものがコンパイルコマンドの構成を行うべきではないというものがあるため、ローカルプリプロセッサ引数の区別を行うのはビルドシステムであるとして、依存関係スキャンプロセス（これを行うのはコンパイラや静的解析ツールなど）にはその翻訳単位自身のコマンドライン引数と、インポートされた全てのヘッダユニットをコンパイルするために使用されるBaseline Compile Commandの2つの入力（コマンドライン引数）が必要となります。

この提案におけるBaseline Compile Commandは、次のような情報のことです

1. どのファイルがコンパイルされるか
2. どのような出力が生成されるべきか
3. ローカルプリプロセッサ引数を含まないコンパイルオプションの一部

ビルドシステムは、各翻訳単位をビルドするために必要なコンパイルコマンドを構成し、そこからBaseline Compile Commandを区別する役割を担います。したがって、ある翻訳単位におけるBaseline Compile Commandはそのコンパイルにおいて使用されるコンパイルオプションの一部分であり、それを区別する方法にはいくつか問題があります。

この提案では、コンパイルオプションからBaseline Compile Commandを独立させてファイルに保存し、依存関係スキャンプロセスへの入力にはコンパイルオプション及びBaseline Compile Commandを記録したファイルパスを渡すようにすることを提案しています。

提案より、LLVMのJSON Compilation Database（いわゆる`compile_commands.json`）をBaseline Compile Commandを含むように拡張する例

```json
{
    "directory": "/path/to/build/dir",
    "file": "/path/to/source/main_translation_unit.cpp",
    "arguments": [ "g++", "-o" ,"main_translation_unit.o",
                   "-DFOO=1", "-DBAR=2", "-I/one/path",
                   "-I/other/path" ],
    "output": "main_translation_unit.o",
    "baseline-arguments": ["g++", "-DFOO=1", "-I/one/path" ]
}
```

一番最後の`baseline-arguments`フィールドがBaseline Compile Commandです。

- [P2898R1 Build System Requirements for Importable Headers - WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P2898R1-Build-System-Requirements-for-Importable-Headers)
- [JSON Compilation Database Format Specification - Clang](https://clang.llvm.org/docs/JSONCompilationDatabase.html)
- [P2962 進行状況](https://github.com/cplusplus/papers/issues/1651)

### [P2967R0 Relocation Is A Library Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2967r0.pdf)

リロケーションサポートのためのライブラリ機能の提案。

この提案はP2786で提案されているトリビアルリロケーションをサポートするための、追加のライブラリ機能を提案するものです。P2786では主にコア言語にトリビアルなリロケーション可能性の概念を提案し、それを検出して活用するために必要な最小限のライブラリ機能のみが提案されています。この提案は、標準ライブラリ全体でトリビアルリロケーションを活用するための機能、特にユーザーが自身のコードでリロケーションを活用するときに必要となる機能についてを提案するものです。

ここで提案されているライブラリ機能は2つだけで、まず1つは`std::relocate()`です

```cpp
namespace std {
  template <class T>
    requires (is_trivially_relocatable_v<T> || is_nothrow_move_constructible_v) && !is_const_v<T>
  constexpr T* relocate(T* begin, T* end, T* new_location);
}
```

これは`[begin, end)`の領域にある`T`のオブジェクトを`new_location`の領域へリロケーションするものです。その際、トリビアルではないリロケーションも含めてあらゆる手段でリロケーションを行おうとします。

この関数は次のようなコードと等価な振る舞いをします

```cpp
if constexpr (is_trivially_relocatable_v<T>) {
  // Tがトリビアルリロケーション可能ならそうする
  return std::trivially_relocate(begin, end, new_location);
} else if (less{}(end, new_location) || less{}(new_location + begin - end, begin)) {
  // 未初期化アルゴリズムを使用して、ムーブ&破棄によってリロケーション（領域にオーバーラップがない場合
  std::uninitialized_move(begin, end, new_location);
  std::destroy(begin, end);

  return new_location;
} else if (std::less{}(begin, new_location)) {
  // ↓こんな感じの領域の重なり方をしている場合の処理
  // |begin ...       ... end|
  //                  |nee_location...        ...|

  // 要素ごとにムーブ&破棄によってリロケーション（後から
  while (T* dest = new_location + begin - end; dest != new_location) {
    ::new (--dest) T(std::move(*--end));
    std::destroy_at(end);
  }

  return dest;
} else {
  // ↓こんな感じの領域の重なり方をしている場合の処理
  //                |begin ...       ... end|
  // |nee_location...        ...|

  // 要素ごとにムーブ&破棄によってリロケーション（前から
  while (begin != end) {
    ::new (new_location++) T(std::move(*begin++));
    std::destroy_at(begin);
  }

  return new_location;
}
```

複雑な分岐はほとんど、リロケーション元と宛先の領域がオーバーラップしている場合にも正しく動作させるためのものです。

この関数は効率的なリロケーションのために`T`のムーブコンストラクタが例外を投げないことを求めています。それを満たさない型での使用やイテレータ範囲によって同等のことを行うために、2つ目の機能である`std::uninitialized_move_and_destroy()`が用意されています。

```cpp
namespace std::ranges {
  // イテレータ版
  template<forward_iterator I, sentinel_for<I> S1,
           nothrow-forward-iterator O, nothrow-sentinel-for <O> S2>
    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
  uninitialized_move_and_destroy_result<I, O>
    uninitialized_move_and_destroy(I ifirst, S1 ilast, O ofirst, S2 olast);

  // range版
  template<forward_range IR, nothrow-forward-range OR>
    requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
  uninitialized_move_and_destroy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
    uninitialized_move_and_destroy(IR&& in_range, OR&& out_range); 
}
```

ここでは代表としてRangeアルゴリズムのものを抜粋しましたが、非Rangeのものや並行アルゴリズム、`_n`付きのものも提案されています。

これらのアルゴリズムは未初期化領域`[ofirst, olast)`（`out_range`）に対して`[ifirst, ilast)`（`in_range`）の領域のオブジェクトを、ムーブ&破棄によってリロケーションするものです。

これも含めた未初期化メモリに対するアルゴリズム全体の指定として、例外がスローされた場合は出力領域は未初期化状態にリセットされます。また、既存の未初期化メモリに対するアルゴリズムと同様に、事前条件で入出力領域がオーバーラップしていないことを求めており、`std::relocate()`とは異なりオーバーラップ領域には使用できません。

- [P2786R0 Trivial relocatability options - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2786R0-Trivial-relocatability-options)
- [P2967 進行状況](https://github.com/cplusplus/papers/issues/1652)

### [P2971R1 Implication for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2971r1.pdf)
### [P2978R0 A New Approach For Compiling C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2978r0.html)

ビルドシステムとコンパイラが相互にやり取りをするためのAPIの提案。

現在のC++のコンパイルは、人間かビルドシステムがコンパイラの実行ファイルを呼び出すことで行われています。提案によれば、ビルドシステムがコンパイラの機能を実行ファイルではなく共有ライブラリ経由で使用するようにすることで25~40%のコンパイル速度向上が見込めるとのことです。

速度が向上する理由は次の2点です

1. ビルドシステムはAPIを利用してコンパイラが読み込んだファイルを知ることができる。その情報を利用すれば、複数のファイルのコンパイルで同じキャッシュファイルを使用可能になる
2. モジュールのビルドにおいては、本ビルドの前にモジュール間の依存関係を調べる必要がある。その役割は基本的にコンパイラが担っているが、APIを使用することでビルドシステムがその解決を行うことができ、依存関係スキャンを行う必要がなくなる

ビルドシステムがコンパイラの持つ情報を得ようとすると一々コンパイラを呼び出す必要があり、それはオーバーヘッドが大きいため現在は避けられているか時間がかかっています。API経由でコンパイラの個別機能を使用することでビルドシステムの任意のタイミングでその情報を得られるようになり、そのコストはおそらくコンパイラを呼び出すオーバーヘッドよりもかなり小さくなると思われます。

この提案ではWindows11上のMSVCを使用したSFLMおよびLLVMのコンパイル時間の分析を行うことでその効果を見積もっており、25~40%のコンパイル速度向上が見込めるとしています。主に、翻訳単位それぞれでの依存関係スキャンをスキップできることと、コンパイル全体で読み取る必要のあるファイル数を削減すること、立ち上げるべきプロセス数の削減によって高速化されるようです。

提案しているAPIは次のようなものです。これはおそらくC++標準ではなくSG15（Tooling Study Group）で議論中のEcosystem International Standardに対して適用されるものだと思われます。

```cpp
namespace buildsystem {

  struct string {
    const char *ptr;
    unsigned long size;
  };

  // Those char pointers that are pointing to the path are platform dependent i.e. whcar_t* in-case of Windows
  struct compile_output {
    // completed == false : コンパイラ状態へのポインタ
    // それ以外の場合 : nullptr
    void *compiler_state;

    // completed == true : コンパイラの出力メッセージ
    // それ以外の場合 : nullptr
    string stdout;
    string stderr;

    // completed == true : コンパイラが待機しているモジュール名orヘッダユニットのビルド済モジュールorヘッダユニット名（すなわち依存関係の情報）
    // それ以外の場合 : エクスポートされたモジュールがある場合その論理名
    string wait_string_or_logical_name;

    // インクルードされているヘッダの数と名前（パス）
    unsigned long header_includes_count;
    string *header_includes;

    // コンパイル成果物のファイル名、パス、数
    string *output_files;
    string *output_files_paths;
    unsigned short output_files_count;

    // コンパイラがモジュールの入力を待っている場合true
    bool waiting_on_module;

    // コンパイルが完了していれば（エラーでも）true
    bool completed;

    // completed == trueの場合、コンパイルエラーが起きていればtrue、成功していればfalse
    bool error_occurred;
  };

  compile_output new_compile(string compile_command, string (*get_file_contents)(string file_path));
  compile_output resume_compile(void *compiler_state, string bmi_file);
  string get_object_file(string bmi_file);

} // namespace buildsystem
```

このようなAPIをコンパイラ共有ライブラリが提供し、ビルドシステムはこのAPIを介してコンパイラとコンパイルを制御します。

`new_compile()`にコンパイラオプションを引数として渡してコンパイルを開始します（このオプションには依存関係の情報は含まれていません）。その後、コンパイル実行中にモジュールのインポートに遭遇した場合、戻り値の`wait_string_or_logical_name`にその依存関係の名前を指定し`waiting_on_module`を`true`に設定してこの関数はリターンします。また、コンパイル実行中にヘッダユニットのインポートに遭遇した場合、`wait_string_or_logical_name`にそのヘッダユニットのパスを指定し`waiting_on_module`を`false`に設定してリターンします。

ビルドシステムは一連のビルドの間で得られた`compiler_state`を保存しておき、必要なファイルが既にビルドされているか、ビルドする必要があるか、ビルド中であるかを管理します。あるビルドが待機しているファイルが利用可能になると、その`compiler_state`と新たに利用可能になったモジュール（ヘッダユニット）のBMIを渡して`resume_compile()`を呼び出すことでコンパイルを再開します。

ビルドが完了すると、コンパイラは`compile_output`オブジェクトの`completed`を`true`に設定し、`output_files`と`output_files_paths`に成果物の名前とパスを設定してリターンします。

ある`compiler_state`に対して依存関係が解消されコンパイルが完了するまで`resume_compile()`は繰り返し呼び出され、それらのビルドは複数並行で行われます。

このAPIの実行モデルでは、コンパイラは依存関係スキャンを行わず依存関係（モジュール関連）にぶつかるとそこでコンパイルを一時停止しビルドシステムに制御を返します。ビルドシステムはプロジェクト内の全てのモジュール/ヘッダユニットについて並行的に`new_compile()`を走らせ、その成果物をもって`resume_compile()`を呼び出すことで依存関係を自動的に解決しながらビルドを完了します。

この提案は、API定義を通してそのようなモジュールのビルドモデルを定義しようとしてもいます。

- [HassanSajjad-302/solution5 - Github](https://github.com/HassanSajjad-302/solution5)
- [P2978 進行状況](https://github.com/cplusplus/papers/issues/1653)

### [P2979R0 The Need for Design Policies in WG21](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2979r0.pdf)

LEWG/EWGでの機能設計のための設計ポリシーを整備する提案。

WG21に参加する人々は、C++標準を可能な限り最高のものにする目標を共有していますが、誰もが同じ原則に基づいて設計を選択するわけではありません。そのため、関連するすべての原則が先に合意されない限り設計に関する議論を行き詰まってしまう可能性があります。一見の一致を見た場合でも、投票の後で1つ以上の重要な設計原則について十分な情報が共有されていなかったことが後で反目する場合があります。

この提案では、原則に基づいた設計を採用し、WG21の議論プロセスにおいて、現在のように初めに関連する問題について議論した後に解決策の一つに投票するのではなく、原則に基づいた設計のプロトコルに従ってまず関連する設計原則を明確にした上で優先順位を付けるようにすることを提案しています。

また、そのような設計原則に基づいた決定を文書化して共有することで、別の議論における同様の決定の際に再検討を避け将来の議論を合理化できます。

現在では、そのような設計原則やそれに基づく過去の決定などの情報は属人化しており、その人がたまたまその議論において欠けていることで以前の議論や決定が継承されず、設計に矛盾が生じることが少なからずあったようです。提案では、クラスのデフォルト特殊メンバ関数に対する`noexcept`指定のバージョン間での振る舞いの不一致や、LEWGにおけるラコスルールの軽視の例をあげています。

この提案はそのようなポリシーの概要を説明するもので、具体的な提案は個別の2つの提案で行おうとしています

1. 議論のある設計の決定を仲裁するための原則に基づいたアプローチ (P3004)
2. 確立された設計ポリシーを文書化してアクセスするための体系的なメカニズム（P3005）

なお、これらの提案はまだ公開されていません。

- [P2979 進行状況](https://github.com/cplusplus/papers/issues/1654)

### [P2980R0 A motivation, scope, and plan for a physical quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2980r0.html)

物理量と単位を扱うライブラリ機能の導入について説明する提案。

この提案では、物理量と単位を扱うライブラリを導入する理由やモチベーションを説明し、設計目標や現時点での例を示すものです。

モチベーションとしては次のようなものが挙げられています

- 安全性
    - 単位を間違えた計算がコンパイルエラーとなる
    - 物理量とその単位を扱うライブラリは多くの機械の制御コードの安全性を向上させる
- 語彙型となること
    - ベンダーがそれぞれ独自実装をしなくてよくなる
- 認証されたライブラリ
    - MISRA等の安全性基準に従ったソフトウェア開発においてはOSSを使用できない場合が多い
    - 標準ライブラリとして提供されていることでより安全なコードを記述できるようになる
- 独自実装は複雑で難しい
- 拡張性
    - 非SI単位などに対応するために単位の追加を容易にする
- 幅広いドメインで使用可能（されている）

提案より、サンプルコード

```cpp
// mp-unitsというライブラリで試験実装が行われている
#include <mp-units/systems/si/si.h>

using namespace mp_units;
using namespace mp_units::si::unit_symbols;

// 単純な数値計算
static_assert(10 * km / 2 == 5 * km);

// 単位変換
static_assert(1 * h == 3600 * s);
static_assert(1 * km + 1 * m == 1001 * m);

// 組立量
static_assert(1 * km / (1 * s) == 1000 * m / s);
static_assert(2 * km / h * (2 * h) == 4 * km);
static_assert(2 * km / (2 * km / h) == 1 * h);

static_assert(2 * m * (3 * m) == 6 * m2);

static_assert(10 * km / (5 * km) == 2 * one);

static_assert(1000 / (1 * s) == 1 * kHz);
```

```cpp
#include <mp-units/format.h>
#include <mp-units/ostream.h>
#include <mp-units/systems/international/international.h>
#include <mp-units/systems/isq/isq.h>
#include <mp-units/systems/si/si.h>
#include <iostream>

using namespace mp_units;

constexpr QuantityOf<isq::speed> auto avg_speed(QuantityOf<isq::length> auto d,
                                                QuantityOf<isq::time> auto t)
{
  return d / t;
}

int main()
{
  using namespace mp_units::si::unit_symbols;
  using namespace mp_units::international::unit_symbols;

  constexpr quantity v1 = 110 * km / h;
  constexpr quantity v2 = 70 * mph;
  constexpr quantity v3 = avg_speed(220. * km, 2 * h);
  constexpr quantity v4 = avg_speed(isq::distance(140. * mi), 2 * isq::duration[h]);
  constexpr quantity v5 = v3.in(m / s);
  constexpr quantity v6 = value_cast<m / s>(v4);
  constexpr quantity v7 = value_cast<int>(v6);

  std::cout << v1 << '\n';                // 110 km/h
  std::cout << v2 << '\n';                // 70 mi/h
  std::println("{}", v3);                 // 110 km/h
  std::println("{:*^14}", v4);            // ***70 mi/h****
  std::println("{:%Q in %q}", v5);        // 30.5556 in m/s
  std::println("{0:%Q} in {0:%q}", v6);   // 31.2928 in m/s
  std::println("{:%Q}", v7);              // 31
}
```

この提案及び将来的に標準に導入しようとしているライブラリ機能は、[mp-units](https://github.com/mpusz/mp-units)というライブラリで試験実装が進められています。

提案ではこの機能をC++29に導入することを目指しており、そのための機能ごとのカテゴライズやその中での優先順位付けを行っています。掲載されている予定表によれば、C++26サイクル中にLEWGのレビューを完了し、C++29サイクル中でLWGの承認を取り付け、標準に導入するような予定を組んでいるようです（詳細な予定表が提案にはあります）。ただし、まだ確度の高いものではなく、計画をLEWGに承認してもらってスムーズに進めようとしています。

- [mpusz/mp-units - Github](https://github.com/mpusz/mp-units)
- [P2980 進行状況](https://github.com/cplusplus/papers/issues/1655)

### [P2981R0 Improving our safety with a physical quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2981r0.html)

↑の物理量と単位を扱うライブラリ機能について、コンパイル時の安全性に関する側面を解説する文書。

この文書では主に、P2980のライブラリ（以下単位ライブラリと呼びます）がC++コードの安全性向上に役立つことを解説しており、単位ライブラリの必要性や使用可能な産業領域等を説き、単位付きの量の取り扱いを間違ったことで起きた事故を紹介し、現在よく見られる単位付きの量を使用している危ういコード例について紹介したうえで、単位ライブラリがそれらの問題をどう解決できるかを示しています。

単位ライブラリによる安全性は主に、算術演算コードにおいてその値の単位をコンパイル時にチェックすることで間違った計算を防止するものです。それをベースに、ダングリング参照に対する配慮や、同じ単位を持つ異なる種類の量のサポートなどの安全性への配慮が行われています。

### [P2982R0 `std::quantity` as a numeric type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2982r0.html)
### [P2984R0 Reconsider Redeclaring `static constexpr` Data Members](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2984r0.html)

`static constexpr`メンバ変数のクラス外定義の非推奨の扱いを検討する提案。

C++11で`static constexpr`メンバ変数が宣言できるようになりましたが、その定義が必要となる場合は通常の静的メンバ変数と同様にクラス外に定義を置く必要がありました。これはC++17のインライン変数の導入時に`static constexpr`メンバ変数は暗黙`inline`とされるようになったことでクラス外での定義が不要になりました。それとともに、クラス外の定義は不要な再宣言となり非推奨とされました。

```cpp
struct A {
  static constexpr int n = 5;  // 定義（C++14までは宣言）
};

constexpr int A::n;            // 冗長な再宣言（C++14までは定義）
```

`__cpp_inline_variables`機能テストマクロを用いてクラス外定義の存在を切り替えることでこのようなコードはバージョン間でポータブルにすることができます。とはいえ、C++14以前にこの書き方をされている既存のコードはおそらくたくさんあり、必ずしも全てがそのような対応を行えるわけではないかもしれません。

現在の主要なコンパイラ（フロントエンド）は、C++17以降のモードにおいてもこれらの冗長な再宣言（以前の定義）に対して非推奨である旨の警告を発しません。

C++26に向けて現在非推奨とされているものを整理し可能なら削除しようとする取り組み（P2863）のEWGにおけるレビューにおいてこの問題も議論され、そこでは現状維持（非推奨のまま）とする方向性のようですが、さらにこれの非推奨化を解除する方向性について提案が望まれたようで、この提案はそれを受けてのものです。

この提案では、その歴史的経緯や現状を説明するとともに、現状維持・非推奨解除・削除のいずれかを選択することを促しています。

その後のEWGのレビューでは、C++26サイクルでは現状維持とすることになったようです。

- [P2863R0 Review Annex D for C++26  - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2863R0-Review-Annex-D-for-C26)
- [P2984 進行状況](https://github.com/cplusplus/papers/issues/1658)

### [P2985R0 A type trait for detecting virtual base classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2985r0.html)

あるクラスが他のクラスの仮想基底になっているかを判定する型特性の提案。

このような判定はクラス型のポインタの変換を行う場所において必要となり、特にスマートポインタの変換コンストラクタにおいて必要となります。

ポインタ`derived* d`を`base*`に変換するには、`base`が`derived`の仮想基底クラスであるかどうかによって実装が分岐します

1. `base`が`derived`の仮想基底クラスではない場合
    - `d`が`nullptr`かをチェックする
      - `nullptr`ではない場合、`d`にコンパイル時にわかっている定数オフセットを加算する
      - `nullptr`の場合、`nullptr`を返す
2. `base`が`derived`の仮想基底クラスである場合
    - `d`が`nullptr`かをチェックする
      - `nullptr`ではない場合、`d`の参照する領域の仮想テーブルを検査して適切なポインタ値を得る
        - 実際の仕組みはABIに依存する

この処理はユーザーが実装するものではなく、コンパイラが挿入する変換処理です。

2で`d`が`nullptr`ではない場合に問題なのは、仮想テーブルにアクセスしてポインタ値を得るのが1の場合に比べてコストがかかることと、`d`の参照先が既に破棄されている場合に未定義動作となることです。

`weak_ptr`の変換コンストラクタを実装することを例として考えてみます。

`weak_ptr`のクラス構造は簡単には次のようになっています

```cpp
template <typename T>
class weak_ptr {
  control_block *m_cb;
  T *m_data;
};
```

この場合に`weak_ptr<Y*>`から`weak_ptr<T*>`へムーブしつつ変換するコンストラクタを考えると、単純には次のようになります

```cpp
template <typename Y>
  requires std::is_convertible_v<Y*, T*>
weak_ptr(weak_ptr<Y> &&other)
  : m_cb(std::exchange(other.m_cb, nullptr)),
    m_data(std::exchange(other.m_data, nullptr)) // <-- danger
  {}
```

この実装には

- `T`が`Y`の仮想基底であり
- `other.m_data`の参照するオブジェクトが既に破棄されている場合

に前述の理由により、`d`の領域の仮想テーブルにアクセスしようとして未定義動作となります。

正しい実装は、きちんと`other`の領域が有効であるかを調べる必要があります

```cpp
template <typename Y> 
  requires std::is_convertible_v<Y*, T*>
weak_ptr(weak_ptr<Y> &&other)
  : m_cb(other.m_cb),
    m_data(other.lock().get())
  {
     other.m_cb = nullptr; other.m_data = nullptr;
  }
```

ただ、これは今度は`T`が`Y`の仮想基底ではないほとんどのケースで非効率となります。

この実装を正しくかつ効率的に行うには`T`が`Y`の仮想基底であるかどうかによって実装を分岐する必要があります。

```cpp
// 非仮想基底の場合の単純な実装
template <typename Y> 
  requires (std::is_convertible_v<Y*, T*> && !std::is_virtual_base_of_v<T, Y>)
weak_ptr(weak_ptr<Y> &&other)
  : m_cb(std::exchange(other.m_cb, nullptr)),
    m_data(std::exchange(other.m_data, nullptr)) 
    {}
    
// 仮想基底の場合の安全だが重い実装
template <typename Y> 
  requires (std::is_convertible_v<Y*, T*> && std::is_virtual_base_of_v<T, Y>)
weak_ptr(weak_ptr<Y> &&other)
  : m_cb(other.m_cb),
    m_data(other.lock().get())
  {
     other.m_cb = nullptr; other.m_data = nullptr;
  }
```

同様の問題は`observer_ptr`というスマートポインタ（標準にはない）の変換コンストラクタにおいても発生し得ます。

この提案は、主にスマートポインタの安全な実装のために、この例の`is_virtual_base_of`型特性を標準ライブラリに導入しようとするものです。

```cpp
namespace std {

  // 追加するis_virtual_base_ofの宣言例
  template<class Base, class Derived>
  struct is_virtual_base_of;

  template<class Base, class Derived>
  constexpr bool is_virtual_base_of_v = is_virtual_base_of<Base, Derived>::value;
}
```

- [P2985 進行状況](https://github.com/cplusplus/papers/issues/1659)

### [P2986R0 Generic Function Pointer](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2986r0.html)

定数式でも使用可能な関数ポインタ専用の型消去型を追加する提案。

現在利用可能な関数ポインタの型消去機能（`std::function`等）は全て、定数式で使用可能ではありません。これは`std::function`等の実装の都合上、構築も呼び出しも定数式で行えないためです。

例えば、C++26で導入される予定の`std::function_ref`のCallableを保存するストレージの実装を見てみると

```cpp
struct _function_ref_base {
  union storage {
    void *p_ = nullptr;
    void const *cp_;
    void (*fp_)();

    constexpr storage() noexcept = default;

    // 関数オブジェクトを受け取るコンストラクタ
    template<class T>
      requires std::is_object_v<T>
    constexpr explicit storage(T *p) noexcept
      : p_(p)
    {}

    // 関数オブジェクトをconstで受け取るコンストラクタ
    template<class T>
      requires std::is_object_v<T>
    constexpr explicit storage(T const *p) noexcept
      : cp_(p)
    {}

    // 関数ポインタを受け取るコンストラクタ
    template<class T>
      requires std::is_function_v<T>
    constexpr explicit storage(T *p) noexcept
      : fp_(reinterpret_cast<decltype(fp_)>(p)) // 👈 reinterpret_castは定数式で実行不可
    {}
  };

  template<class T>
  constexpr static auto get(storage obj) {
    if constexpr (std::is_const_v<T>) {
      // C++26ではvoid*からのキャストは定数式で可能（本来の型が合っていれば）
      return static_cast<T*>(obj.cp_);
    } else if constexpr (std::is_object_v<T>) {
      // C++26ではvoid*からのキャストは定数式で可能（本来の型が合っていれば）
      return static_cast<T*>(obj.p_);
    } else {
      return reinterpret_cast<T*>(obj.fp_); // 👈 reinterpret_castは定数式で実行不可
    }
  }
};
```

`std::function_ref`は構築後に保持するCallableを切り替える必要がないためそのストレージの実装はかなり単純になります。そのため、`constexpr`対応も可能なように思えます。

しかし実際には、関数ポインタが`void*`に変換できないため関数ポインタの保存においては特別扱いが必要となります。すると、`void(*)()`というポインタ型で型消去することになりますが、関数ポインタのこのキャストには`reinterpret_cast`が必要となり、それは定数式で実行できません。これに引っ張られる形で、`std::function_ref`は構築も呼び出しも定数式では行えません。

C++26時点でも、これを解決するソリューションは存在していません。この提案はこの解決のために、定数式で使用可能な関数ポインタ型専用の型消去ポインタ型を用意しようとするものです。

提案されているのは`std::function_ptr_t`という名前のものです。これは言語組み込みの型で、この型の値は任意の関数ポインタ型を代入することができます。そして、この型の操作は全て定数式で行うことができます。

```cpp
constexpr int f() {
  return 42;
}

int main() {
  // nullptrを代入可能
  constexpr std::function_ptr_t fp1 = nullptr;

  // 任意の関数ポインタをそのまま受け入れられる
  constexpr std::function_ptr_t fp2 = f;

  // static_castを用いて関数ポインタを復帰できる
  // これは型が合っていれば定数式で行える
  constexpr auto p_f = static_cast<int(*)()>(fp2);
  static_assert( p_f == f );
  static_assert( p_f() == 42 );

  // 直接の呼び出しやデリファレンスはできない
  fp_f(); // ng
  *fp_f;  // ng
}
```

例えば`std::function_ref`においては、この`std::function_ptr_t`を使用して関数ポインタを保存する部分を書き換えることで`reinterpret_cast`を使用する必要がなくなり、構築も呼び出しも定数式で行えます。

EWGIによるレビューでは、この問題はキャストの仕様調整によって解決することが望ましいという方向性のようで、この提案の方向性は支持を得られていないようです。

- [P2986 進行状況](https://github.com/cplusplus/papers/issues/1660)

### [P2988R0 `std::optional<T&>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2988r0.html)
### [P2989R0 A Simple Approach to Universal Template Parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2989r0.pdf)

より限定されたユニバーサルテンプレートパラメータの提案。

ユニバーサルテンプレートパラメータは型・非型・テンプレートを統一的に受けることのできるテンプレートパラメータのことで、P1985で提案されました。P1985の提案は言語のあらゆるコンテキストでユニバーサルテンプレートパラメータを使用可能にしようとするもので、仕様と実装に追加する複雑さが大きくなりメリットが相対的に小さくなっていました。

この提案はそれを改善しつつほぼ同じ機能を追加しようとするもので、のP1985との違いは、ユニバーサルテンプレートパラメータの構文として`universal template`を選択し、その導入を純粋にテンプレートパラメータとしての使用のみに限定したことです。

- ユニバーサルテンプレートパラメータは関数・クラス・変数テンプレートのテンプレートヘッド（`template<...>`の中）でのみ宣言できる
- ユニバサールテンプレートパラメータ名はテンプレート引数としてのみ使用できる
- ユニバーサルテンプレートパラメータはパックを取れる
- ユニバーサルテンプレートパラメータのデフォルト引数は設定できない
- ユニバーサルテンプレートパラメータを処理するには、別のテンプレートに転送するか、部分特殊化によって行う

提案しているユニバーサルテンプレートパラメータ（UTP）によるライブラリ機能とその実装例

```cpp
// UTPが型名かを判定
template <universal template T>
inline constexpr bool is_typename_v = false;

template <typename U>
inline constexpr bool is_typename_v<U> = true;

// UTPがNTTPかを判定
template <universal template U>
inline constexpr bool is_nttp_v = false;

template <auto U>
inline constexpr bool is_nttp_v<U> = true;

// UTPがテンプレートかを判定
template <universal template U>
inline constexpr bool is_template_v = false;

template <template<universal template....> universal template U>
constexpr bool is_template_v<U> = true;

// UTPが型テンプレートかを判定
template <universal template U>
inline constexpr bool is_type_template_v = false;

template <template<universal template....> typename U>
inline constexpr bool is_type_template_v<U> = true;

// UTPが変数テンプレートかを判定
template <universal template U>
inline constexpr bool is_var_template_v = false;

template <template<universal template....> auto U>
inline constexpr bool is_var_template_v<U> = true;

// UTPがコンセプトかを判定
template <universal template U>
inline constexpr bool is_concept_v = false;

template <template<universal template....> concept U>
inline constexpr bool is_concept_v<U> = true;
```

これを利用した`is_specialization_of`の実装例

```cpp
template<universal template T, universal template Primary>
  requires is_var_template_v<Primary> || requires is_type_template_v<Primary>
inline constexpr bool is_specialization_of_v = false;

// 型についてのテンプレート特殊化を検出
template<
  template<universal template...> typename Primary,
  universal template... Args
>
inline constexpr bool is_specialization_of_v<Primary<Args...>, Primary> = true;

// NTTPについてのテンプレート特殊化を検出
template<
  template<universal template...> auto Primary,
  universal template... Args
>
inline constexpr bool is_specialization_of_v<Primary<Args...>, Primary> = true;
```

P2098R1で提案されていたもの（汎用性が低いとしてリジェクト）とは異なり、この実装の場合はクラステンプレートと変数テンプレートの特殊化をチェックすることができ、さらに特殊化しているものが型でない場合についてもチェックすることができます。

この提案のユニバーサルテンプレートパラメータは他のテンプレートに渡す以外は何もできないため、このように最終的には部分特殊化によって処理することになるでしょう。そのため、P1985R3の例のいくつかは実装に工夫が必要となります。

```cpp
// メタ関数FにArgsを適用したい、P1985の実装
template<universal template F, universal template... Args>
using apply = F<Args...>; // これはできない、エイリアスでUTPを使用できない

// メタ関数FにArgsを適用したい、この提案における実装
template<template <universal template...> typename F, universal template... Args>
struct apply {
  using type = F<Args...>;  // ここではFは型テンプレートパラメータなので普通に使える
};
```

ただし、この提案ではコンセプトのテンプレートパラメータでUTPを使用可能にすることは提案していないため（コンセプトは部分特殊化できないため）、コンセプトでは使用できません。

```cpp
// これはできない・・・
template <typename R, template<universal template....> concept C>
concept range_of =
  ranges::input_range<R> &&
  C<remove_cvref_t<ranges::range_reference_t<R>>>;
```

- [P1985R1 Universal template parameters - WG21月次提案文書を眺める（2020年5月）](https://onihusube.hatenablog.com/entry/2020/06/01/001003#P1985R1--Universal-template-parameters)
- [P1985R3 Universal template parameters - WG21月次提案文書を眺める（2022年9月）](https://onihusube.hatenablog.com/entry/2022/10/09/021557#P1985R3-Universal-template-parameters)
- [P2989 進行状況](https://github.com/cplusplus/papers/issues/1662)

### [P2990R0 C++ Modules Roadmap](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2990r0.pdf)

モジュールのエコシステムのために必要な作業についての提案。

この提案は、モジュールを実際に利用可能にするために必要なツールのサポートのために現在欠けているものを特定し、SG15（tooling study group）においてそのために必要な作業とその優先度を提案するものです。

提案では、現状のエコシステム（コンパイラやビルドシステム、静的解析ツールなど）におけるモジュールのサポート状況を紹介し、それらツールがモジュールを相互に運用するために欠けているものについて説明したうえで、それを解消するために必要な作業について優先度を付けて提示しています。

提案されているのは次のようなロードマップです

1. 単一のプロジェクトにおいてモジュールを利用可能にする
    1. モジュールインターフェースの複数回のコンパイル
        - 1つのモジュールインターフェースが異なる翻訳単位において異なるビルドオプションを用いてコンパイルされることがよくある
        - あるモジュールインターフェースが何回コンパイルされるのかを特定することに関して、ビルドシステムとコンパイラ間の相互運用性の疑問に答える必要がある
    2. 静的解析ツールのビルドシステム外部におけるサポート
        - IDEにおけるコード補完など、静的解析ツールはビルドシステムと深く統合することなく動作することが求められる
        - ビルドシステムはそれらツールが動作するのに十分な情報を提供する必要がある
2. 事前ビルドライブラリにおけるモジュールの利用
    1. 事前ビルドライブラリでのモジュールのメタデータ
        - ライブラリが提供するモジュールのメタデータのスキーマの決定が必要
    2. 標準ライブラリモジュールのメタデータ
        - コンパイラが提供するそれの相互運用性の確保
3. インポート可能なヘッダ
    1. インポート可能ヘッダの識別
        - ビルドシステムやパッケージマネージャーがプロジェクト内でインポート可能なヘッダを見つける時の問題について、ツールの実装者との協力が必要
    2. 依存関係スキャンとプリプロセッサ状態
        - 依存関係スキャン実行時のインポートメカニズムのエミュレーションの要件について未解決の問題が残っている

この提案は、SG15における行動喚起を促す事と同時に、ツール開発者がモジュールサポートのための投資を行っても安全であることを示す目的があります。

SG15ではこのロードマップに沿った作業を行っていくことに合意が取れており、Githubのcplusplus/modules-ecosystem-trで作業を行っていくことにしたようです。

- [cplusplus/modules-ecosystem-tr: The ISO C++ Modules Ecosystem Technical Report (METeR)](https://github.com/cplusplus/modules-ecosystem-tr)
- [P2989 進行状況](https://github.com/cplusplus/papers/issues/1662)

### [P2991R0 Stop Forcing `std::move` to Pessimize](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2991r0.html)

`std::move()`がNRVOを阻害しないようにする提案。

C++の学習においては、新しいオブジェクトを構築するときにそのオブジェクトが別の左辺値オブジェクトから構築され、構築元のオブジェクトが以降使用されないような場合に`std::move()`を使用して新しいオブジェクトを構築するように教えられます。しかし、`return`文においてローカル変数を返そうとするときには逆に`std::move()`を使用すべきではないとも教わります。その理由は`return`文における`std::move()`がNRVOを妨げるためですが、このことは一貫しておらず、`return`文における例外の理由についても非常に複雑なものがあります。

```cpp
std::vector<std::string> readStrings(int numStrings) {
  std::vector<std::string> result;
  std::string string;

  while (numStrings--) {
    std::cin >> string;
    // ここではmove()がいる
    result.push_back(std::move(string));
  }

  // ここではmove()がいらない
  return result;
}
```

例えばこのコードにおいては、ローカルの`string`及び`result`は他のオブジェクトの初期化に使われた後で再び参照されることがなくコピーが重いクラスであるため、他のオブジェクトの初期化時にはムーブすることが適切です。しかし、プログラマが明示的に`std::move()`によってムーブする必要があるのはループ中の`string`に対してのみです。

全てのC++バージョンにおいてNRVOは許可されており（必須ではない）、NRVOが行われる場合ムーブすらも省略され`result`は最初から呼び出し側の変数であったかのように使用されます。NRVOが行われない場合でも、暗黙ムーブによって`return`文における変数名を指定する式は値カテゴリが*xvalue*となるため、`result`は自動でムーブされます。

`return std::move(result)`と書くことはむしろ有害であり、NRVOを確実に行われなくします。これはNRVOの対象となるものがローカル変数の変数名を指定する式のみであるためであり、`std::move()`を追加すると変数名を指定する式ではなくなるためNRVOの対象でもなくなるためです。

このことによって、C++初学者には`std::move()`を使用する時のルールと、`std::move()`を使用してはならない時のルールの2つを教えなければならなくなります。しかも、後者のルールに違反するとパフォーマンス上のペナルティとして帰ってきます。

この提案は、`return`文における`std::move()`を特別扱いすることで`std::move()`がNRVOを妨げることがないようにして、`std::move()`に関しては`std::move()`を使用する時のルールのみを教えれば済むようにしようとするものです。

そのために現在の規定で、`return`文のオペランドとして*NRVO eligible*とされている式`E`について、次の形式に当てはまる場合の式も*NRVO eligible*であるというように判定を行うことを提案しています

- `F`が名前解決の後で`std::move()`になる場合の式`F(E)`
- `T`が戻り値型への右辺値参照となる場合の式`static_cast<T>(E)`
- `T`が戻り値型への右辺値参照となる場合の式`(T)E`
- `T`が戻り値型への右辺値参照となる場合の式`T(E)`

さらに、コンパイラが以前の言語バージョンでもこの動作を実行できるように、このことを以前の言語バージョンに対するDRとすることも提案しています。

- [P2991 進行状況](https://github.com/cplusplus/papers/issues/1664)

### [P2992R0 Attribute `[[discard]]` and attributes on expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2992r0.html)

式の結果を破棄することを明示する`[[discard]]`属性の提案。

`[[nodiscard]]`属性を付加された関数の戻り値を消費しない場合、警告が発せられます。これは基本的にはとても便利なのですが、場合によっては`[[nodiscard]]`な関数の戻り値を使用せずに破棄したい場合もあります。例えば

- テスト
    - スモークテストにおいて広い契約を持つ関数がクラッシュしないことを確かめたい場合など
    - この場合に戻り値に興味はなく、警告は必要ない
- 部分的なドメイン
    - 例えば、エラーコードを返す`[[nodiscard]]`な関数がある特定の引数を渡された場合に決して失敗しないことがわかっている場合にユーザーがそれを確認して呼び出してる時
    - この場合、戻り値を消費する必要はなく、安全に破棄できる
- 古い関数
    - 当初は成否を戻り値で返していた関数が後のバージョンで決して失敗しないようになったものの、API/ABI保護のために戻り値型を維持し続けている場合
    - この場合、戻り値は意味がないため安全に破棄できる

などの場合があります。

そのような場合に警告を抑制しつつ戻り値を破棄するのに使用可能な方法は主に次の2つがあります

1. `void`キャスト
2. `std::ignore`

```cpp
[[nodiscard]]
int f();

int main() {
  f();  // 警告される

  // 1. voidキャスト
  (void)f();  // 警告されない
  void(f());  // 警告されない

  // 2. ignore
  std::ignore = f();  // 警告されない
}
```

しかしこれらの方法には欠点があります

1. `void`キャスト
    - キャスト式の濫用であり、警告を抑制するために言語の難解なルールを使用しているだけ
    - 初心者への教育が困難
    - コードベースで検索（grepなど）できない
    - `void`キャストを`[[maybe_unused]]`として使用している場合がある
    - 破棄の根拠はコメントとしてのみ提供できるため、コードベースにそのような根拠を義務付けるルールを強制するのが困難
2. `std::ignore`
    - 右辺が`void`式の場合にコンパイルエラーになるため、ジェネリックコードで使用しづらい
    - C互換性がない
    - `std::ignore`はライブラリソリューションであり、言語の問題の解決には言語によるソリューションの方が適している
    - `void`キャストと比べて冗長
    - 破棄の根拠はコメントとしてのみ提供できる

この提案は、これらの欠点を解決する言語機能による戻り値の明示的破棄のソリューションとして、`[[discard]]`属性を提案するものです。

```cpp
[[nodiscard]]
int f();

int main() {
  [[discard]] f();  // 警告されない
  [[discard("just testing")]] f();  // 警告されない
}
```

これには次のような利点があります

- `[[discard]]`は使用法と構文において`[[nodiscard]]`と対称になっている
    - `[[nodiscard]]`は呼び出し元において無視して欲しくない関数/型宣言に置かれ、`[[discard]]`は呼び出し側において結果を明示的に破棄したい式に置かれる
- 理由を書いておくことができる
    - これはコンパイラからは使用されないが、ユーザーや周辺ツールにとって有用となる
- `void`式でも使用可能
- 警告抑制のために標準ライブラリのものを持って来なくてもいい
- Cとの互換性を図ることができる
- `void`キャストと比べて適度に冗長

この提案ではこの属性を式に対する属性指定として提案しています。現在のC++では式に対する属性指定を行うことができず、現在の文法も文に対する属性指定は可能でも式に対する属性指定には問題があります。

現在の式（*expression*）の文法定義は次のようになっています

```
expression:
    assignment-expression
    expression , assignment-expression
```

ここに属性指定を単純に追加すると次のようになるでしょう

```
expression:
    attribute-specifier-seq(opt) assignment-expression
    expression , assignment-expression
```

しかし、これは既存の文（*statement*）の文法と衝突します

```
statement:
    attribute-specifier-seq(opt) expression-statement

expression-statement:
    expression(opt) ;
```

従って、現在の文法のもとでは提案している式に対する属性は実際には文に対するものになっています。

```cpp
[[discard]] f();  // 文に対する属性指定
```

ただし、このような単純な関数呼び出し式のみを含む文に対する`[[discard]]`属性の適用はこの属性の最も一般的な使い方であり、式文（*expression-statement*）に対して属性適用が行われていればこの提案の目的には十分です。

その場合に問題となるのは、組み込みカンマ演算子を使用した場合です。

```cpp
[[discard]] a(), b(), c();  // 全ての関数の戻り値破棄警告が抑制されてしまう
```

個別の式に対して属性指定が必要となるのはこのように組み込みカンマ演算子を使用した場合のみであり、これを追求するのは完全性を追求する二次的な目標ではあります。

この提案ではそれでもあえて式に対する属性指定を提案しており、そのアプローチとして2つのものを提案しています。

1つ目のアプローチは式の右側に属性を指定するものです。

```
expression:
    assignment-expression attribute-specifier-seq(opt)
    expression , assignment-expression
```

```cpp
[[discard]] f();  // 警告されない（文に対する属性）
f() [[discard]];  // 警告されない（式に対する属性）

[[discard]] a(), b();  // 警告されない（文に対する属性）
a(), b() [[discard]];  // 警告されない（式全体に対する属性）
a() [[discard]], b();  // a()は警告されないが、b()は警告されうる

int x = (a() [[discard]], b()); // 警告されない、a()は抑制され、b()は破棄されていない

struct S {
  S(int i) 
    : m_i((check(i) [[discard]], i))   // 警告されない
  {}

  int m_i;
};
```

このアプローチにはいくつか問題があります

- 配列の`new`式との競合
    - `auto ptr = (new T[123] [[someattribute]]);`が現在合法なコード
- 変換関数を指定する式における競合
    - `struct S { operator int() const; };`がある時
    - `auto ptr = (&S::operator int [[attribute]]);`が現在合法なコード

このアプローチを採用する場合、この既存のコードとの衝突の影響を評価した上でどうするかを決定する必要があります。

2つ目のアプローチはかっこで括った上で式の左側に属性を指定するものです。

```
primary-expression:
    literal
    this
    ( attribute-specifier-seqopt expression )
    id-expression
    lambda-expression
    fold-expression
    requires-expression
```

```cpp
[[discard]] f();   // 警告されない（文に対する属性）
([[discard]] f()); // 警告されない（式に対する属性）
f() [[discard]];   // ill-formed

[[discard]] a(), b();     // 警告されない（文に対する属性）
([[discard]] a(), b());   // 警告されない（式全体に対する属性）
([[discard]] a()), b();   // a()は警告されないが、b()は警告されうる

int x = ([[discard]] a(), b()); // 警告されない、a()は抑制され、b()は破棄されていない
int y = ([[discard]] a()), b(); // 警告されない、a()は抑制され、b()は破棄されていない

struct S {
  S(int i) 
    : m_i(([[discard]] check(i)), i)  // 警告されない
  {}

  int m_i;
};
```

こちらのアプローチでは対象の式を一々かっこで括る必要があるものの、式の左側という自然な位置に属性を導入でき、かっこで括ることによってどの式に属性を指定しているのかが明確になります。

この提案ではこれらのアプローチをのどちらを選択するかの決定をEWG/EWGIに委ねています。

EWGIの投票では、この提案の`[[discard]]`属性については好まれたものの、個別の式に対する属性指定にはコンセンサスが得られませんでした。おそらく、式文に対する属性としての`[[discard]]`としてEWGに転送されています。

- [P2992 進行状況](https://github.com/cplusplus/papers/issues/1665)

### [P2994R0 On the Naming of Packs](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2994r0.html)

パラメータパックそのものを指定する構文を検討する提案。

C++11で導入された可変長テンプレートとパラメータパックはとても便利な機能ですが、基本的にパックそのものにできることは展開のみです。C++17で畳み込み式が追加されましたが、パックそのものに対する操作はまだ導入されておらず、いくつかの提案が進行中です。

そのような機能の難しい点は、パック自体に操作を適用する構文とパックを展開してその要素に操作を適用する構文を区別するようにしなければならない点です。例えばインデックスアクセスの場合、パックの最初の要素にアクセスするのに`pack[0]`のような構文を選択できません。なぜなら、`f(pack + pack[0]...)`は現在有効な式であり、これはパック最初の要素をパック内の全ての要素に加算するという意味にはならないためです。

このため、パックそのものに操作を適用する機能についての提案は、それぞれの機能のために個別の提案を選択します。

|機能|単一要素|パック|
|---|---|---|
|インデックスアクセス|`elem[0]`|`pack...[0]`|
|展開ステートメント|`template for(auto x : elem)`|次のうちのどれか</br>`template for(auto x : {pack...})`</br>`template for...(auto x : pack)`</br>`for...(auto x : pack)`|
|リフレクション|`^elem`|なし|
|スプライス|`[: elem :]`|`... [: pack :] ...`|

`elem`は何か単一の値（非パック）、`pack`は関数引数パックです。

パラメータパックに対する構文は単一要素に対するものと異なっているだけでなく、パラメータパックそのものに対する操作の間でも異なっています。ここには直交性がなく、パックに対して操作を適用したい場合に`...`をどこに置くのかは場合により変化します。

ここで問題にしているのは個別の機能そのものについてではなく、それらの間でパックそのものを指定する構文に一貫性がないことです。

この提案は、パラメータパックそのものを指定する構文をまず考案し各操作ではそれをベースとした構文を採用するようにすることで、パックそのものに対する操作ごとに個別の構文を導入するのを回避し、直交性と一貫性を回復しようとするものです。

ただし、パックそのものを指定する構文は捻り出す必要もなく現在すでに存在しています。それは、パラメータパックの（関数引数パックの）宣言やラムダ式の初期化キャプチャで現れる`...pack`という構文です。この提案はこれをそのまま採用し、各機能に展開していくことを提案しています。先ほどの表に当てはめると次のようになります

|機能|単一要素|パック|この提案|
|---|---|---|---|
|インデックスアクセス|`elem[0]`|`pack...[0]`|`...pack[0]`|
|展開ステートメント|`template for(auto x : elem)`|次のうちのどれか</br>`template for(auto x : {pack...})`</br>`template for...(auto x : pack)`</br>`for...(auto x : pack)`|`template for(auto x : ...pack)`|
|リフレクション|`^elem`|なし|`^...pack`|
|スプライス|`[: elem :]`|`... [: pack :] ...`|`[: ...pack :] ...`|

この提案による構文では、単一要素の構文において`elem`を`...pack`で置き換えた形になっており、パックに対する各種操作の間でも一貫しています。

個別の機能の個別の提案を見ると、一番左の列の構文よりも中列の構文を好む人はいるかもしれませんが、パック操作の全体を俯瞰したときにはこの構文による一貫性と直交性がその小さな好みを上回るだろうとしています。

この提案による構文には1つ空白地帯があります。

```cpp
// この提案が採用されたとして
template <typename... Ts>
void foo(Ts... pack) {
  // パックの最初の要素を取得
  auto first = ...pack[0];

  // パックの各要素をイテレートする
  template for (auto elem : ... pack) { }

  // では、これはどういう意味？
  auto wat = ...pack;
}
```

ここを突き詰めると言語タプルのような用法が開かれる可能性もありますが、この提案ではそれは将来の発明に期待するとしてとりあえずは禁止（ill-formed）としておくことを提案しています。

- [P2994 進行状況](https://github.com/cplusplus/papers/issues/1666)

### [P2995R0 SG16: Unicode meeting summaries 2023-05-24 through 2023-09-27](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2995r0.html)
### [P2996R0 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r0.html)
### [P2997R0 Removing the common reference requirement from the indirectly invocable concepts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2997r0.html)
### [P2999R0 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r0.html)
### [P3001R0 `std::hive` and containers like it are not a good fit for the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3001r0.html)

`std::hive`は標準ライブラリのコンテナとしてふさわしくないとする提案。

まず、標準ライブラリの要素は理想的には次のいずれかに該当するものです

- コンパイラサポートが必要な型や関数
    - 標準ライブラリはコンパイラと一緒に出荷されるため、コンパイラサポートの必要な物を配置できる唯一の場所
- コアな語彙型
    - `std::optional, std::span, std::string_view`などの語彙型は汎用性と表現力に優れ、C++プログラミングの基礎部品となる
    - 語彙型を標準化しない場合、同じ目的に対応する独自実装がライブラリ毎に定義され、それの間の相互変換のために余計なオーバーヘッドがかかる
- クロスプラットフォームの抽象
    - 標準ライブラリはプラットフォームの専門家によって実装されており、ほとんどのプラットフォームはI/Oやメモリ割り当て、スレッドなどの機能を提供する
    - これを標準化することで、ユーザーはクロスプラットフォームで統一的にそれを利用でき、実装者はプラットフォームの専門知識を活かしてそれを実装できる
- 基礎的なアルゴリズムとデータ構造
    - コンテナ（動的配列やキュー、スタックなど）とアルゴリズム（ソートや検索など）はほとんどすべてのプログラミングタスクの基礎であり、必須の機能である
    - 頻繁に必要となるこれらのものを標準化することで、ユーザーはそれを再実装する必要がなくなる
    - またこれらの機能は、広く理解できるセマンティクスと安定した実装を備えてもいる
    - これらのエンティティは、エンティティを再発明することなく作業を完了するために重要であるという点で、語彙型とは異なる
        - 語彙型は規則を確立するために重要であり、異なるコード間の相互運用に利用される

これに該当しないものが標準ライブラリとしてふさわしくないわけではありませんが、該当しないものを標準化するにはそれなりの根拠が必要となります。

賛否はあれど、C++標準ライブラリは安定したABIとAPIを維持しており、そこからの逸脱はユーザーに大きな混乱をもたらします。`std::vector<bool>`のように明らかに失敗とみなされる機能であっても非推奨や削除されることは稀であり、残り続けます。そのため、標準化委員会はインターフェースが確立されていない限りライブラリ機能を標準化することはできず、一度標準化されるとライブラリのAPIとABIは事実上凍結されます。それによって、実装も変更できなくなる場合があります。

標準化された機能はすべてのプラットフォーム間で移植可能である必要があり、その実装や品質はプラットフォームによって異なります。そのため、すべてのプラットフォームで利用できるわけではないAPIや、パフォーマンスなどの特定の実装特性に依存したAPIの標準化には注意が必要です。

そして、標準化委員会の時間は限られており、ある機能の議論に時間をかけるということは別の提案の議論の時間が取られるということを意味しています。

`std::hive`は高性能コンテナに該当するタイプのコンテナであり、実行時の動作やメモリ使用量などの点で既存の標準コンテナに対して優位性を持つコンテナです。このようなコンテナには次のような特徴があります

- 時間・空間計算量で他の実装よりも優れている
- 関連するベンチマークで他の実装よりも明確に優れた実行時の速度やメモリ使用量が計測される
- 語彙型である必要はない
    - APIの特定の部分にカスタムの特化型を使用することはパフォーマンス上のメリットがある
- 積極的にメンテナンスされている
    - CPUは進化し続けており、より優れたアルゴリズムがすぐに利用可能になる
    - 高性能コンテナがそうあり続けるためには、これらの変化に適用し改善し続けなければならない

この性質はその実装が安定しておらず、プログラミングにおいて必須というわけでもないことを示しています。さらに、高性能コンテナはコンパイラのサポートやOSのAPIのサポートを必要とせず、語彙型でもないため、最初に挙げた標準ライブラリ要素のカテゴリのいずれにも該当しないことになります。

むしろ、高性能コンテナを標準化した場合の欠点を上げることができます

- 安定性の要件は高性能コンテナの進化を妨げる
    - メンバ変数の追加などはABI破壊であり、内部実装のほとんどはAPIの要件を介して公開されている
- 標準化のためには委員会の多大な時間を必要とする
    - 標準化に時間を食っている間に想定する実装が時代遅れになっていたとしても、ABIの問題から更新できない
- 標準ライブラリはインターフェースのみを標準化しており、実装は標準化していない
    - 実装は複数の標準ライブラリベンダによって行われ、そのパフォーマンスはプラットフォームごとに異なる可能性がある
    - 標準ライブラリ機能を使用する場合、パフォーマンスの保証はない

それでも高性能コンテナを実装することの利点はせいぜい、外部ライブラリに依存せずにそのコンテナを利用できるようになるくらいのものです。

ここまでの高性能コンテナの批判は一般的な話ですが、`std::hive`は高性能コンテナなのですべて該当します。

提案者によって提供されているリファレンス実装は堅牢であるようで、有用性は疑うべくもありません。しかし、委員会が標準化するのはリファレンス実装ではなくインターフェースであり、それは標準ライブラリ実装者が独自のトレードオフを行うのに十分な余地を残すのと同時に、後の最適化によって重大な変更が発生する可能性があるほど具体的です。わざわざ`std::hive`を使用するほど性能にこだわるのに、標準ライブラリの実装品質や外部ライブラリの保証に無頓着であるということは考えられません。

これらのマイナス面を無視したとして、`std::hive`を導入するメリットを考えてみます。

前述のように、最初に挙げた要素にはいずれも該当していません。残るは標準ライブラリに載せることでサードパーティライブラリを入手するためのメカニズムをセットアップする必要がなくなるため使いやすくなるという利便性の向上です。しかし、現在使用したい人はリファレンス実装ないし同等の特性を持つ代替実装をなんとかして使用していると考えられ、現在それを使用していないプロジェクトで使用されるようになるかは疑問があります。

この提案は、ここまで述べたように、`std::hive`を標準化するメリットはほぼなく`std::hive`そのものの利点も保証されない可能性があるため、C++26の限られた時間サイクルを割いてまで`std::hive`を標準化するべきではない、とするものです。

この提案を受けてのLEWGにおける投票では、`std::hive`の標準化作業を続けることに合意されています。

- [P3001 進行状況](https://github.com/cplusplus/papers/issues/1685)

### [P3002R0 Guidelines for allocators in new library classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3002r0.pdf)
### [P3003R0 The design of a library of number concepts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3003r0.pdf)

数値コンセプトの設計についての文書。

この文書のいう数値コンセプトとは、数学的な意味での数というものをC++コンセプトで定式化しようとするものです。主に、`<numeric>`にあるもののコンセプト対応や将来の物理量と単位を扱うライブラリにおいて使用することを意図しています。

まず全ての数値コンセプトはオプトインが必要で、そのためのいくつかの型特性が用意されます

- `number`コンセプトを有効化するための`enable_number`、`enable_complex_number`
- 特定の数値を示す`number_zero`、`number_one`
    - 例えば、`number_zero_v<T>`のようにして`number`型`T`の零元を取得する
- 数値に関連した型を取得する`number_difference_t`、`vector_scalar_t`
    - `number_difference_t<T>`は`T`の差の結果型
    - `vector_scalar_t<T>`はベクトル空間`T`のスカラ型

これによって、一番基本的な`number`コンセプトが次のように定義されます

```cpp
template<typename T>
concept number = enable_number_v<T> && std::regular<T>;

template<typename T, typename U>
concept common_number_with =
  number<T> && number<U> && std::common_with<T, U> && number<std::common_type_t<T, U>>;
```

`common_number_with`は2つの`number`型を関連づけるためのコンセプトです。

他の数値コンセプトはこの`number`コンセプトをベースとして組み立てられます。例えば

```cpp
// 順序付け可能な数
template<typename T>
concept ordered_number = number<T> && std::totally_ordered<T>;

// 数直線
template<class T>
concept number_line =
  ordered_number<T> &&
  requires(T& v) {
    number_one_v<number_difference_t<T>>;
    { ++v } -> std::same_as<T&>;
    { --v } -> std::same_as<T&>;
    { v++ } -> std::same_as<T>;
    { v-- } -> std::same_as<T>;
  };
```

また、基本的な数値演算に関するコンセプトも用意されています。例えば加算の場合

```cpp
template<class T, class U> concept addition-with =
  number<T> &&
  number<U> &&
  requires(const T& c, const U& d) {
    { c + d } -> common_number_with<T>;
    { d + c } -> common_number_with<T>;
  };

template<class T, class U> concept compound-addition-with =
  addition-with<T, U> &&
  requires(T& l, const U& d) {
    { l += d } -> std::same_as<T&>;
  };
```

これらは今の所説明専用として定義されています。

最後に、これらによって代数的構造を表すコンセプトが定義されます。例えば

```cpp
template<typename T, typename U>
concept point_space_for =
  subtraction-with<T, U> && // TとUの値t, uに対して、t - uが可能
  negative<U> &&            // Uは負の数を含む
  common_number_with<number_difference_t<T>, U>;

template<typename T, typename U>
concept compound_point_space_for = point_space_for<T, U> && compound-subtraction-with<T, U>;

// 点付き空間
template<typename T>
concept point_space = compound_point_space_for<T, number_difference_t<T>>;

// ベクトル空間
template<typename T>
concept vector_space = 
  point_space<T> && 
  compound-scales-with<T, vector_scalar_t<T>>;  // vector_scalar_t<T>はベクトル空間Tにおいてスカラ型としての性質を満たすこと
```

この文書による数値コンセプトの設計はまだ完全ではなく経験も不足しているため、この文書は現状報告であり、将来の標準数値コンセプトの実現のための1つの足がかりとして提出されたものです。

- [P3003 進行状況](https://github.com/cplusplus/papers/issues/1686)

### [P3008R0 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3008r0.html)

浮動小数点数型の`std::atomic`における`fetch_max()/fetch_min()`の問題を解消する提案。

P0493では`std::atomic`に対して指定した値との大小比較を条件として値の入れ替えを行う`fetch_max()/fetch_min()`を提案しており、これはC++26導入目前まで進んでいます。しかし、2023年6月の全体会議において、浮動小数点数型の場合の動作について問題が提起されたことで足踏みをしています。

`fetch_max()/fetch_min()`はその大小比較について`std::min/std::max`をベースとしていますが、その`std::min/std::max`が浮動小数点数型の特定の値の比較に対して望ましい結果（IEEE754に定義され、多くのハードウェア実装やCのライブラリ関数が返す結果）を返さないという問題がありました。

- 符号付の0
    - `-0 < +0`と判断するのか否か
- quiet NaN（qNaN）
    - 引数の片方がqNaNの場合、それを欠落したデータ（Missing Data）として扱うのか、エラーを伝播させるのか

|C|C++|signed 0|qNaN|
|---|---|---|---|
||`std::min/std::max`|同値|UB|
|`fmin/fmax`||同値、QoIとして`-0 < +0`|Missing Data|
|`fminimum/fmaximum`||`-0 < +0`|error|
|`fminimum_num/fmaximum_num`||`-0 < +0`|Missing Data|

C++の`std::min/std::max`の場合qNaNは事前条件違反で未定義動作となり、その場合全ての実装で第一引数を返すようです。

```cpp
// std::min/std::maxの動作例
min(qNaN, 2.f); // UB: qNaN
max(qNaN, 2.f); // UB: qNaN
min(2.f, qNaN); // UB: 2
max(2.f, qNaN); // UB: 2
min(-0.f, +0.f); // -0
max(-0.f, +0.f); // -0
min(+0.f, -0.f); // +0
max(+0.f, -0.f); // +0
```

この振る舞いは並行プログラミングにおいては問題となる可能性があり、異なるスレッドからの値の出力を待機してこのような比較を行う処理がある場合に、その処理結果はデータの到着順によって変化し、実行ごとに異なった結果になる（特に符号が異なる）可能性があります。

Cの`fmin/fmax`の場合、符号付0の扱いは`std::min/std::max`と同じですが、QoI（実装品質）として`-0 < +0`とすることが許可されています。また、aNaNは欠落したデータとしてもう片方の値を返します。

```c
// Cのfmin/fmaxの動作例
fmin(qNaN, 2.f); // 2
fmax(qNaN, 2.f); // 2
fmin(2.f, qNaN); // 2
fmax(2.f, qNaN); // 2
fmin(-0.f, +0.f); // -0 or +0
fmax(-0.f, +0.f); // -0 or +0
fmin(+0.f, -0.f); // -0 or +0
fmax(+0.f, -0.f); // -0 or +0

// Cのfminimum/fmaximumの動作例
fminimum(qNaN, 2.f); // qNaN
fmaximum(qNaN, 2.f); // qNaN
fminimum(2.f, qNaN); // qNaN
fmaximum(2.f, qNaN); // qNaN
fminimum(-0.f, +0.f); // -0
fmaximum(-0.f, +0.f); // +0
fminimum(+0.f, -0.f); // -0
fmaximum(+0.f, -0.f); // +0

// Cのfminimum_num/fmaximum_numの動作例
fminimum_num(qNaN, 2.f); // 2
fmaximum_num(qNaN, 2.f); // 2
fminimum_num(2.f, qNaN); // 2
fmaximum_num(2.f, qNaN); // 2
fminimum_num(-0.f, +0.f); // -0
fmaximum_num(-0.f, +0.f); // +0
fminimum_num(+0.f, -0.f); // -0
fmaximum_num(+0.f, -0.f); // +0
```

`fminimum/fmaximum`および`fminimum_num/fmaximum_num`はIEE754にある同名操作（頭のfを省いたもの）に対応する関数で、C23で追加されたものです。どちらの関数も`-0 < +0`となり、`fminimum/fmaximum`はqNaN入力に対してエラー伝播としてqNaN引数を返し、`fminimum_num/fmaximum_num`はqNaNを欠落したデータとして扱いもう片方の値を返します。

Cのこれらの関数はIEEE754の規定によく従った振る舞いとなります。

また、`std::min/std::max`は現在のGPUのISAにおける浮動小数点数比較命令の結果とも一貫していません

|ベンダ|ISA|命令|対応|signed 0|aNaN|
|---|---|---|---|---|---|
|AMD|CDNA2+|`MIN/MAX`|`minimum_num/maximum_num`|`-0 < +0`|Mssing Data|
|intel|Xe ISA|`AOP_FMIN/AOP_FMAX`|`minimum_num/maximum_num`|`-0 < +0`|Mssing Data|
|NVIDIA|PTX|`atom red`|`minimum_num/maximum_num`|`-0 < +0`|Mssing Data|
||SPIR V|`OpAtomicFMinEXT/OpAtomicFMaxEXT`|C `fmin/fmax`|同値、QoIとして`-0 < +0`|Mssing Data|

この結果を受けて、C++における浮動小数点数型の`std::atomic`の`fetch_max()/fetch_min()`の設計指針は2つあり、`std::min/std::max`と一貫させるかどうかです。両選択肢の比較は次のようになります

|カテゴリ|一貫させる|一貫させない|
|---|---|---|
|例|`x.fetch_min(y);`</br>`x.fetch_fminimum_num(y);`|`x.fetch_min(y, std::less{});`</br>`x.fetch_min(y);`|
|利点|セマンティクスの一致</br>一貫性|安全なセマンティクスがデフォルト</br>ハードウェア命令のデフォルト|
|欠点|`min`という一般的な名前がポータブルではない振舞いをする</br>一般的な名前の処理がパフォーマンス的に不利になる|同名関数との非一貫性</br>`atomic`に移行する際の微妙な挙動の違い|
|教育の必要性|間違った使用とパフォーマンス|浮動小数点数型の微妙な動作変更|
|デフォルト|安定性|正しさとパフォーマンス|
|オプトイン|正しさとパフォーマンス|安定性|

この提案では、浮動小数点数型の`std::atomic`の`fetch_max()/fetch_min()`は`std::min/std::max`とは異なるセマンティクスを提供することを提案しています。また、既存のAPIとの非一貫性を和らげるために、C23の`fminimum/fmaximum`および`fminimum_num/fmaximum_num`を`<cmath>`に追加し`std`名前空間で利用できるようにすることも提案しています。

- [P0493R1 : Atomic maximum/minimum - WG21月次提案文書を眺める（2020年05月）](https://onihusube.hatenablog.com/entry/2020/06/01/001003#P0493R1--Atomic-maximumminimum)
- [P3008 進行状況](https://github.com/cplusplus/papers/issues/1672)

### [P3009R0 Injected class name in the base specifier list](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3009r0.pdf)

クラステンプレート内での特殊化名を指すクラス名を基底クラスリストでも使用可能にする提案。

クラステンプレート内部において、そのクラスの名前は現在のクラステンプレートの特殊化名を指しています。これは、クラスの内部でのみ使用可能であり、特に基底クラス指定の場所では使用できません。

```cpp
template<typename D>
class crtp_base {...};

template<typename T, typename U, typename V = int>
class sample
  : crtp_base<sample>       // ng、sampleはテンプレート名
  , crtp_base<sample<T, U>> // ok、これでクラス名、ただしVはデフォルト
  , crtp_base<sample<T, U, V>> // ok、全てのテンプレートパラメータの指定を反映している
{
  // このクラス内部でのsampleの名前は、sample<T, U>としたのと同じになる
  sample* p;  // ok

  void f() {
    const sample& r = *this;  // ok
  }

  // ここでも使用可能
  friend bool operator==(sample, sample) = default; // ok
};
```

このような名前のことを規格用語では*injected-class-name*（注入されたクラス名）と言います。

基底クラスで注入されたクラス名が使用できないことにより、主にCRTPパターンの記述時にその記述が冗長かつ複雑になります。この例のように短いテンプレートパラメータ名が小数だけならさほど変化はありませんが、標準のコンテナ型のように多様なテンプレートパラメータを取る場合に問題は大きくなります。

また、注入されたクラス名が使用できない場所でそのつもりでクラス名を使用しても、テンプレート名でしかないことから通常エラーになりますが、テンプレートパラメータにデフォルトパラメータが指定されている場合はそのパラメータについての指定を忘れていたとしてもエラーにはなりません。これはともすれば見つけづらいバグの元になる可能性があります。

Deducing thisのおかげでCRTPを記述する必要性は大きく減少していますが、C++20以前の環境でも使用されるコードなどにおいて依然としてCRTPを使用したいケースは残っています。そのため、この提案はクラス定義における基底クラスリスト内部でも注入されたクラス名を使用可能にしようとするものです。

ただし、クラステンプレートの基底クラスリストにおけるそのクラスの名前は、テンプレートテンプレート名としては有効であるため、基底クラスがテンプレートテンプレートに対して部分特殊化していたり、テンプレートテンプレートに対して動作が変わるような記述をしていると、現在有効なコードがコンパイルエラーとなるようになります。

```cpp
struct WasType {};
struct WasTemplate {};

template <typename Type>
auto foo() -> WasType; // overload 1

template <template <typename...> class Template>
auto foo() -> WasTemplate; // overload 2

template <typename Type>
struct CurrentlyUnambiguousBase
  : decltype(foo<CurrentlyUnambiguousBase>()) // 現在はok、overload 2が選択される、この提案ではエラー
{
  // 現在でもエラー、オーバーロード解決に失敗
  using InsideBody = decltype(foo<CurrentlyUnambiguousBase>());
};

// 現在の動作
static_assert(std::is_base_of_v<WasTemplate, CurrentlyUnambiguousBase<void>>);
```

さらに巧妙なコードを考えると、エラーにせずに動作を変更することもできます。

```cpp
struct WasType {};
struct WasTemplate {};

template <typename Type>
auto bar(int) -> WasType; // overload 1

template <template <typename...> class>
auto bar(long) -> WasTemplate; // overload 2

template <typename Type>
struct DifferentBehavior
  : decltype(bar<DifferentBehavior>(0)) // overload 2が選択される、この提案ではoverload 1が選択される
{
  using InsideBody = decltype(bar<DifferentBehavior>(0)); // overload 1が選択される
};

// 現在の動作
static_assert(std::is_base_of_v<WasTemplate, DifferentBehavior<void>>);
static_assert(std::is_same_v<WasType, DifferentBehavior<void>::InsideBody>);
```

先ほどの例はクラス名が注入されたクラス名としても扱われるようになることで2つの関数の間でオーバーロード解決が失敗していましたが、この例では追加の引数の一致によって順序がつく（`0`は`long`よりも`int`によりマッチする）ことによってエラーにならずに選択される関数が変化します。

これらのコードは標準仕様としては曖昧ではなく明確であったとしてもコードの読者にとっては既に曖昧であり、2つ目の例などは1行場所が異なるだけで異なることをしているのはほとんどの読者が気づかないものであるとして、このような例は考慮しないことを提案しています。

EWGのレビューにおいては消極的な推進の合意が得られており、実装経験を求めています。

- [P3009 進行状況](https://github.com/cplusplus/papers/issues/1673)

### [P3010R0 Using Reflection to Replace a Metalanguage for Generating JS Bindings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3010r0.pdf)

P2320の値ベースリフレクションを利用して、Javascriptバインディングを記述した経験の報告書。

この文書では、Bloomberg社内で使用されているROBというC++のプリプロセッサ言語フレームワークをP2320で提案されている値ベースリフレクションを用いて書き換え、その際に得られた経験を報告するもので、主に値ベースリフレクションの使用経験や改善案を報告することを目的とするものです。

ROBはBloomberg社内でCで記述されたアプリケーションサーバの処理のために使用されており、.robファイルに書かれたC++クラスに似た記述によるクラス定義をパースしてそこから実行時にJavascriptのクラスにマーシャリングを行うために必要な情報を抽出し、C++のクラス定義や関連するボイラープレートコードとともに生成して.cppと.hファイルに保存します。生成された.cpp/.hファイルをコンパイルすることで、実行時にその型のオブジェクトとJavascriptのクラスオブジェクトの間で相互に変換する処理が利用可能になります。

つまりは、C++コードとしてコンパイルする前に.robファイルをコンパイルするプログラムが必要となります。この文書では、現在使用されているROBをベースにrob2というフレームワークを試作し、そこで値ベースリフレクションによってそのような前処理を純粋なC++コードで記述したものです。

その使用経験をもとに、`meta::info`が関数引数で渡した時に定数式の文脈で使用不可能になること（`constexpr`引数の必要性）やあらゆるリフレクション情報が`meta::info`に畳まれてしまうことによってある時点の`meta::info`オブジェクトが何のどのような情報を保持しているのかわからなくなる点などの使いにくさや、ユーザー定義属性の必要性などについて報告しています。

- [P2320R0 The Syntax of Static Reflection - WG21月次提案文書を眺める（2021年02月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P2320R0-The-Syntax-of-Static-Reflection)

### [P3011R0 Supporting document for Hive proposal #1: outreach for evidence of container-style use in industry](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3011r0.pdf)

`std::hive`（元`plf::colony`）のために、コンテナの実使用実体を探るためのアンケートとその結果を記載した報告書。

LEWG/SG14の一部のメンバは`std::hive`のようなコンテナが本当に実使用されている、あるいは必要とされているのかに疑問を持っている人がいるようで、彼らを納得させるためと`std::hive`の標準導入へのサポートのために、C++を使用している企業やコミュニティに向けてアンケートを取りました。この文書は、その結果を報告するものです。

次のようなアンケートを、企業へメール送信、reddit/discordでポスト、その他ゲーム開発系Webコミュニティへポスト、の形でアンケートを募りました

1. 業務において次のようなタイプのコンテナを使用していますか？
    - 複数のメモリブロックまたは単一のメモリブロック内のシーケンシャルストレージ
    - 要素は削除時に何かしらのマーキングがなされ、マーキングされた要素はイテレーション中にスキップされる
2. 1がyesの場合、そのコンテナは複数のメモリブロックからなるのか、単一であるか？
    - また、可能であれば何に使用していますか？
3. `plf::colony`もしくは提案中の`std::hive`を知っていますか？
4. このタイプのコンテナが標準化されることで、メリットがあると思いますか？
5. その他質問やコメントがあれば

このアンケートに対して、企業メールは8社から、discordは4人、redditは11人、その他Webコミュニティ（TIGsource）は1人の回答が得られました。

1の回答

- email: 5/7 yes
- discord: 2/4 yes
- reddit: 6/11 yes
- TIGsource: 1/1 yes

2の回答

- Email: 3 multiple, 2 singular, 1 both.
- Discord: no responses
- Reddit: 1 multiple, 3 singular, 1 both.
- TIGsource: 1 singular.

3の回答

- email: 4 yes, 3 no.
- Discord: 省略
- Reddit: 省略
- TIGsource: 投稿漏れ

4の回答

- email: 6 yes, 1 yes but in the future.
- Discord: 省略?
- Reddit: 省略?
- TIGsource: 1 no opinion

得られた回答数はあまり多くないですが、筆者の方（`std::hive`提案者）の経験や実感と一致しているとのことです。

文書には、得られたコメントなどが詳細に記録されています。

### [P3012R0 Supporting document for Hive proposal #2: use of std::list in open source codebases](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3012r0.pdf)
### [P3014R0 Customizing std::expected's exception](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3014r0.html)
### [P3015R0 Rebuttal to Additional format specifiers for time_point](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3015r0.html)
### [P3016R0 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3016r0.html)
### [P3018R0 Low-Level Integer Arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3018r0.pdf)
### [P3019R0 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3019r0.pdf)
### [P3020R0 2023-09 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3020r0.html)
### [P3021R0 Unified function call syntax (UFCS)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3021r0.pdf)
### [P3022R0 A Boring Thread Attributes Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3022r0.html)
### [P3023R0 C++ Should Be C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3023r0.html)
