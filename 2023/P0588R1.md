# ［C++］ P0588R1　Simplifying implicit lambda capture　についてのメモ

C++20にひっそりと採択されているP0588R1という提案は、3度見したくらいでは何をしているのか、何がしたいのかさっぱりわかりません。一体これはなんなのでしょうか・・・

### P0588R1のやっていること

眺めているとP0588R1ではラムダ式に関連したいくつかのこと・振る舞いを明確化しようとしていることが朧げながら見えてきます。それはおそらく次の4つです

1. ラムダ式が名前をキャプチャする（できる）場所の明確化
2. ラムダ式がクラスメンバ初期化子で使用された時の挙動の明確化 (CWG1632)
3. ラムダ式の構文内でキャプチャした対象に対する`decltype((x))`の振る舞いの明確化 (CWG1913)
4. 構造化束縛をキャプチャできないことを明確化

これらの変更は全て、規格上でその振る舞いが不透明だったものをしっかりと記述し直そうとするもののようで、既存の振る舞いを変更することを意図するものではないようです。

そのため規格文書の言い回しを工夫する変更になっており、それが上記4要素分いっぺんに入っているので意味不明度を高めています。

### 言葉の定義

ここでは、P0588R1で導入されている用語や、それに使用されている用語などの定義をしておきます。なお、ここでの定義はP0588R1の変更を反映したものなので、それ以前の定義とは異なるものです。

#### エンティティ

エンティティ（*entity*）とは次のいずれかに該当するものです

- 値
- オブジェクト
- 参照
- 構造化束縛
- 関数
- 列挙体
- 型
- クラスメンバ
- ビットフィールド
- テンプレート
- テンプレート特殊化
- 名前空間
- パラメータパック

C++のコード上で構文以上の何かしらの意味を持つもののことを総じてエンティティと呼びます。

#### ローカルエンティティ

ローカルエンティティ（*local entity*）とは、エンティティの中でも次のいずれかに該当するものです

- 自動記憶域期間（*automatic storage duration*）にある変数
    - いわゆる自動変数（ローカル変数）
- 分解対象（構造化束縛宣言の右辺に来るオブジェクト）がローカルエンティティである構造化束縛
- `*this`オブジェクト

ほぼほぼ、一般的にローカル変数と呼ばれるもののことを言っていると思って差し支えありません。

#### 宣言領域

宣言領域（*declarative region*）とは、あるエンティティを指す名前が有効なコード上の最大の範囲（領域）のことです。

```cpp
void f() {
  int n = 0;

  {
    int n = 1;
  }

}
```

C++コード上の全ての名前（変数名やクラス名などなど）はそのコード上に宣言領域を持ちます。

#### スコープ

ある名前のスコープ（*scope*）とは、その名前が持つ宣言領域のことです。

例えば、変数名の宣言領域とは変数のスコープのことです。

#### ブロックスコープ

ブロックスコープ（*block scope*）とは、ブロック内で宣言された名前が持つスコープのことです。

その名前はブロック内でローカルであり、そのスコープは宣言された場所からブロックの終端までです。

ブロックとは構文定義で*compound-statement*として指定されるもので、関数定義の`{...}`やラムダ式の本体`{...}`はブロックですが、クラス定義の`{...}`や名前空間定義の`{...}`はブロックではありません。

```cpp
namespace N {
  // ブロックスコープではない
}

struct S {
  // ブロックスコープではない
};

export {
  // ブロックスコープではない
}

int main () {
  // ブロックスコープ

  {
    // ブロックスコープ
  }

  try {
    // ブロックスコープ
  } catch(...) {
    // ブロックスコープ
  }

  [] {
    // ブロックスコープ
  };
}
```

ブロックスコープで宣言された変数はローカル変数です。

#### 関数パラメータスコープ

関数パラメータスコープ（*function parameter scope*）とは、関数の仮引数名の持つスコープのことです。

関数パラメータスコープは関数の仮引数が宣言された地点から始まるため、関数のローカル引数よりも少しだけ広いスコープを占めます。

```cpp
void f(
  // 関数パラメータスコープ
  int a,
  int b
) {
  // 関数パラメータスコープ
  {
    // 関数パラメータスコープ
    int a = 1;
    // aの関数パラメータスコープではない
  }
  // 関数パラメータスコープ
}
```

#### クラススコープ

クラススコープ（*class scope*）とは、クラスで宣言された名前の持つスコープです。

クラススコープはその定義内だけでなく、クラス定義外のメンバ関数定義スコープなども含まれます。

```cpp
struct S {
  // Sのクラススコープ
  int n;

  void f() {
    // Sのクラススコープ
  }

  void g();
};

void S::g() {
  // Sのクラススコープ
}
```

#### odr-usable

odr-usableとはまず、ローカルエンティティに対する概念です。

あるローカルエンティティがその宣言領域内で参照される場合

- そのエンティティは`*this`ではない、もしくは
- その場所はクラススコープかラムダ式のものではない関数パラメータスコープに囲われている
    - そのスコープの最も内側のスコープが関数パラメータスコープであるならば、そのスコープは非静的メンバ関数のもの

のどちらかに該当しており（これを前段の条件と呼びます）

そのローカルエンティティが導入される地点とそのローカルエンティティが参照される領域との間に介在している全ての宣言領域について

- 介在する宣言領域はブロックスコープである、もしくは
- 介在する宣言領域はラムダ式の関数パラメータスコープであり
    - そのローカルエンティティを明示的にキャプチャしているか、デフォルトキャプチャを持っていて
    - そのラムダ式のブロックスコープ（本体）もまた、介在する宣言領域である

のどちらかに該当する場合に、そのローカルエンティティはodr-usableとなります（この条件を後段の条件と呼びます）。

介在する宣言領域というのは、ローカルエンティティの導入（宣言/定義）地点から、そのローカルエンティティを参照する地点の間に存在している宣言領域（スコープ）です。介在する（*intervening*）というのは、参照地点から導入地点の間でそのスコープが折り重なっている様を言っているのだと思われます。

そして、ローカルエンティティがodr-usableではない宣言領域でodr-usedとなる場合、プログラムはill-formedです。（odr-usedはとても難しい概念なので深入りはしませんが、ここでは定義が必要になる使われ方、のような意味だと思ってください）

規格書（[basic.def.odr]/9）より、サンプルコード

```cpp
void f(int n) {
  [] { n = 1; };                // #1 error: n is not odr-usable due to intervening lambda-expression

  struct A {
    void f() { n = 2; }         // #2 error: n is not odr-usable due to intervening function definition scope
  };

  void g(int = n);              // #3 error: n is not odr-usable due to intervening function parameter scope

  [=](int k = n) {};            // #4 error: n is not odr-usable due to being
                                // outside the block scope of the lambda-expression

  [&] { [n]{ return n; }; };    // #5 OK
}
```

この例の場合、ローカルエンティティ`n`は関数`f`の関数パラメータスコープを宣言領域として導入されていて、`*this`ではないので、odr-usableの前段の条件はクリアしており、問題となるのは後段の条件のみです。

1. ローカルエンティティ`n`はラムダ式の関数パラメータスコープに囲われて（介在して）いますが、そのラムダ式はキャプチャに何も指定していない（明示的にも暗黙的にも`n`をキャプチャしていない）ため、この場所で`n`はodr-usableではありません
2. ローカルエンティティ`n`は`A::f()`の関数定義スコープ（ブロックスコープ）と関数パラメータスコープと`A`のクラススコープに囲われています。後2つはブロックスコープではないため（当然ラムダ式の関数パラメータスコープでもないため）、odr-usableではありません
3. ローカルエンティティ`n`は`g()`の関数パラメータスコープに囲われていますが、これも後段2条件のどちらに合致するスコープでもないため、odr-usableではありません
4. ローカルエンティティ`n`はラムダ式の関  数パラメータスコープに囲われていて、そのラムダ式はデフォルトキャプチャを持っています。しかし、そのラムダ式の本体のスコープが介在していない（`n`が参照される地点は本体の外側の）ため、odr-usableではありません
5. ローカルエンティティ`n`は2つのラムダ式の関数パラメータスコープに囲われていて、いずれのラムダ式も`n`をキャプチャしており（デフォルトキャプチャ->明示的キャプチャ）、`n`が参照される地点は2つのラムダ式の本体のブロックスコープの内部です。従って、これはodr-usableです。

このサンプルコードをよく見ると、いずれのケースでもこの関数`f()`の外側にローカルエンティティ`n`を参照しているもの（関数やラムダ式、ローカルクラス）を持ち出すことができます。戻り値を`auto`にするとか関数ポインタにするとか、`std::function`を使用するとか・・・

もしこのng例がokだったとすると、それら外に持ち出したものを介してこれらの関数が呼び出し可能となるため、`f()`のローカルエンティティ`n`は`f()`の外側から読み書きされることになります。それはあたかもラムダ式における参照キャプチャが暗黙的に行われているようなもので、当然それは正しい振る舞いでも標準が意図する振る舞いでもないため禁止されなければなりません。ng例はいずれもそれが起こる場合を指していることがわかると思います。

逆に、okの最後の例は外に持ち出した時にそのようなことは起こらないことがわかります。参照キャプチャだけを使用した場合は同様の問題がありますが、少なくともそれはコードに表れているため暗黙的には起こりません（そして、この問題を解決しようとすることはまた別の問題でもあります）。

#### ローカルラムダ式

ローカルラムダ式（*local lambda expression*）とは、ラムダ式であって次のいずれかに該当するものです

- 宣言された場所を囲む最も内側のスコープがブロックスコープである
- クラスのデフォルトメンバ初期化子で現れており、囲む最も内側のスコープがそのメンバに対応するクラススコープである

```cpp
struct S {
  int m = []{ return 0; }(); // ローカルラムダ式
};

int N = []{ return 0; }();  // ローカルラムダ式ではない

int main() {
  []{}; // ローカルラムダ式
}
```

ローカルラムダ式のみが、デフォルトキャプチャ（`= &`）と明示的キャプチャ（名前を指定するキャプチャ）を行うことができます。言い換えると、非ローカルなラムダ式では初期化キャプチャのみが行えます。

```cpp
int N = 10;

int M1 = [=] { return 20; }();  // ng
int M2 = [&] { return 20; }();  // ng
int M3 = [N] { return 20; }();  // ng

int M4 = [n=N] { return n*2; }(); // ok

int main() {

  [=] { return 20; };  // ok
  [&] { return 20; };  // ok
  [N] { return 20; };  // ok
}
```

これは、ラムダ式がキャプチャする（必要がある）ものは常にローカルエンティティであることを反映しています。

####　ラムダ式のキャプチャに伴うローカルエンティティの参照

ラムダ式のキャプチャのために、式はローカルエンティティを参照する可能性があり、それは次の場合です

- 1つ以上の非静的クラスメンバを指定し、そのメンバへのポインタを形成するものではないid式（*id-expression*）は、`*this`を参照する可能性がある
    - これは、そのid式のオーバーロード解決の結果静的メンバ関数が選択された時でも発生する
- `this`（式）は、`*this`を参照する可能性がある
- ラムダ式はその明治的キャプチャに指定された名前のローカルエンティティを参照する可能性がある

```cpp
struct S {
  int m;

  void f() {
    [=] {
      int n = m;  // メンバmを参照する式によって、*thisの参照が発生する
    };

    [=] {
      [this]{};  // this式の使用によって、*thisの参照が発生する
    };
  }

  void g(float) {}

  static void g(int) {}

  void h() {
    [=] {
      g(0); // 結果的に静的メンバ関数が選択されるが、メンバgを参照する式によって*thisの参照が発生する
    };
  }
};

int main() {
  int n = 0;

  [n] {
    int m = n;  // nの明示的キャプチャによるローカルエンティティnの参照が発生する
  };
}
```

可能性があるのような書き方をしているのは、おそらくそれに該当する場合でも参照されない場合があり得るためです。例えばこの例でも、`S::f()`の2つ目のラムダ式では`this`を結局使用していないので参照はされないですし、`main()`のラムダ式中で`n`を使用しなければキャプチャしていても参照されないでしょう。

#### 暗黙的なキャプチャ

- ある式が、odr-usableなローカルエンティティを参照する可能性があり
- その式を囲んでいる`typeid`式の効果が無視された場合に評価される可能性がある（*potentially evaluated*）とき

そのローカルエンティティは、そのローカルエンティティを明示的にキャプチャしないデフォルトキャプチャを持つ介在するラムダ式によって、暗黙的にキャプチャされている（*implicitly captured*）と言います。

ここでの介在するは、odr-usableの宣言領域に対する条件の場合と同様にラムダ式がラムダ式がネストしている場合をハンドルしています。

規格書（[expr.prim.lambda.capture]/7）より、サンプルコード

```cpp
void f(int, const int (&)[2] = {});         // #1
void f(const int&, const int (&)[1]);       // #2

void test() {
  const int x = 17;
  auto g = [](auto a) {
    f(x);                       // OK: #1を呼び出す、xをキャプチャしない
  };

  auto g1 = [=](auto a) {
    f(x);                       // OK: #1を呼び出す、xをキャプチャする
  };

  auto g2 = [=](auto a) {
    int selector[sizeof(a) == 1 ? 1 : 2]{};
    f(x, selector);             // OK: #1か#2のどちらかを呼び出す、xをキャプチャする
  };

  auto g3 = [=](auto a) {
    typeid(a + x);              // OK: a + xが評価されないオペランドであるかどうかに関わらず、xをキャプチャする
  };
}
```

ラムダ式`g`の例では、`x`が左辺値から右辺値への変換（*lvalue-to-rvalue conversion*）の対象となるため`x`の使用（参照）はodr-usedではなく（そのためodr-usableである必要がなく）、キャプチャしなくても参照可能になります。

`g1~g3`の例ではラムダ式内からの`x`の参照はodr-usableであり、`x`は暗黙キャプチャされています。

ただし、実装は`g1`の場合は`x`が左辺値から右辺値への変換の対象であるため、`x`の参照はodr-usedではなく、それによって実装が`x`のキャプチャを最適化（キャプチャしないように）することが許可されています（どうやら、`g2, g3`の使用では`x`は左辺値から右辺値への変換の対象とならないようです）。

また、この暗黙的なキャプチャはローカルエンティティが破棄されるステートメントから参照される場合でも発生することがあります

```cpp
template<bool B>
void f(int n) {
  [=](auto a) {
    if constexpr (B && sizeof(a) > 4) {
      (void)n;  // Bとsizeof(int)の値に関係なく、ローカルエンティティnをキャプチャする
    }
  }(0);
}
```

暗黙的にキャプチャされるエンティティは構文的に決定されます。

### ラムダ式が名前をキャプチャする（できる）場所の明確化

まずこの作業は、残りの作業（特にCWG issue由来のもの）を進めるにあたって基礎を固めるためのものだと思われます。

初めに、次のような規定によってラムダ式の明示的キャプチャに対応する名前の探索がローカルエンティティだけを発見することが明確化されます

> 明示的なキャプチャに指定された識別子は、非修飾名探索（*unqualified name lookup*）の通常のルールを使用して探索される。この探索では、識別子に対応するローカルエンティティを発見しなければならない

以前は単に、エンティティを発見する、のようになっていたためキャプチャ対象が不透明だったのをローカルエンティティという言葉を用いて明確化した形です。

そして、ローカルエンティティがodr-usedとなる場合は、odr-usableでなくてはならないと規定し、暗黙的なキャプチャ（と明示的なキャプチャ）がどういうものか、いつ起こるのかを明確に定義しています。以前は、暗黙的/明示的キャプチャの定義が曖昧で、それがいつ何をするのかもまた不透明でした。

以前から、ラムダ式のキャプチャは次のように定義されていました

> エンティティは明示的または暗黙的にラムダ式によってキャプチャされたとき、エンティティはキャプチャされる（*captured*）。  
> ラムダ式にキャプチャされたエンティティは、そのラムダ式を含むスコープでodr-usedとなる。

結局、この提案によって

- ローカルラムダ式の定義し直しによって、ラムダ式がいつローカルになるのかを明確化し、それによってラムダ式が非初期化キャプチャ（暗黙的/明示的キャプチャ）を行える場所を明確化
    - ローカルラムダ式のみが、暗黙的/明示的キャプチャを行える
- 暗黙的なキャプチャがいつ起こるのかを明確化
    - 暗黙的なキャプチャはローカルエンティティに対してのみ起こる
- 明示的なキャプチャにおける名前探索の対象を明確化
    - 明示的なキャプチャはローカルエンティティに対してのみ起こる
- ローカルエンティティのodr-usableによって、ラムダ式がキャプチャできない（しない）ものを明確化
    - odr-usableではないローカルエンティティをodr-usedしようとするとill-formed
      - ラムダ式がキャプチャしたものはodr-usedとなるため、odr-usableではない明示的/暗黙的なキャプチャはill-formed
    - ラムダ式がキャプチャしないものは、odr-usableとならない
      - キャプチャしないものがラムダ式の宣言領域でodr-usedとなる場合ill-formed

のようにして、キャプチャ周りの挙動が明確になるように規定が修正されています。

### 構造化束縛をキャプチャできないことを明確化

C++17導入時点では構造化束縛をラムダ式がキャプチャできるかどうかは不透明でした。この提案ではそれが明確に禁止されます。これは次のように規定されることによります

> ラムダ式が明示的もしくは暗黙的に構造化束縛をキャプチャする場合、プログラムはill-formed

ただし、これはとりあえず振る舞いを明確化するのが目的であって禁止することが意図ではないようです。おそらく、それは別の問題でありここではなく別の提案で解決することを意図していたのでしょう。実際に、最終的にC++20では構造化束縛をラムダ式でキャプチャできるようになっています。

詳しくは以前の記事をご覧ください。

- [［C++］構造化束縛の動作モデルとラムダキャプチャ - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2019/10/04/122001)

#### ローカルクラス

ラムダ式はローカルクラスの特殊な場合でもあり、外側のエンティティの参照に関してほぼ同じ問題があります。そのため、ラムダ式同様にローカルクラスはローカルエンティティを参照できません。

より正確には

> ローカルクラスはその宣言内で囲むスコープのローカルエンティティをodr-usedできない
 
と規定されます。この提案では、ローカルクラスが参照できないエンティティをローカルエンティティという言葉で規定し直しており、これによって構造化束縛の参照が禁止されるようになっています。

規格書（[class.local]/1）より、サンプルコード

```cpp
void f() {
  int x;
  const int N = 5;
  int arr[2];
  auto [y, z] = arr;

  struct local {
    int g() { return x; }       // error: odr-use of non-odr-usable variable x
    int m() { return N; }       // OK: not an odr-use
    int* n() { return &N; }     // error: odr-use of non-odr-usable variable N
    int p() { return y; }       // error: odr-use of non-odr-usable structured binding y
  };
}
```

（サンプルコードは一部省略しています）

この例はいずれも、ローカルエンティティをローカルクラス内から参照しようとしています。それにあたってはodr-usableであるかどうかが問題となり、いずれもクラススコープが介在していることからodr-usableではありません。

ただし、`m()`の例だけは、式`N`が左辺値から右辺値への変換の対象となることから`N`の参照はodr-usedではなくなり、odr-usableであるかは問題とならなくなります。他の例は全てローカルエンティティをodr-usedしようとしています。

### ラムダ式がクラスメンバ初期化子で使用された時の挙動の明確化
### ラムダ式の構文内でキャプチャした対象に対する`decltype((x))`の振る舞いの明確化

### 参考文献

- [P0588R1: Simplifying implicit lambda capture](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0588r1.html)
- [CWG Issue 1632](http://wg21.link/cwg1632)
- [CWG Issue 1913](http://wg21.link/cwg1913)
- [CWG Issue 2380](https://cplusplus.github.io/CWG/issues/2380.html)
- [feat: P0588R1で追加されたodr-usableについて記述 by yumetodo・Pull Request #1103・cpprefjp/site](https://github.com/cpprefjp/site/pull/1103)

### メモ


まず、P0588R1のやっていることは4つあって

1. ラムダ式がクラスメンバ初期化子で使用された時の挙動の明確化 (CWG1632)
2. ラムダ式の構文内でキャプチャした対象に対する`decltype((x))`の振る舞いの明確化 (CWG1913)
3. ラムダ式が名前をキャプチャする（できる）場所の明確化
4. 構造化束縛をキャプチャできないことを明確化

だと思います。4はほぼオマケです。

大前提としてラムダ式がキャプチャする必要があるものは常にローカルなものです。ここではそれはローカルエンティティとして指定されており、ほぼローカル変数と`*this`のことです（非静的メンバ変数はローカルエンティティではありません）。

ここでのodr-usableとはおそらく、ある名前をラムダ式がキャプチャできるのかを言うために導入されており、キャプチャするのかどうか不明瞭だったところを弾く（あるいはキャプチャ範囲を狭める）ためにodr-usableではない場合は不適格、としています。これはCWG2380によって事後的にも制限されています。

従って、odr-usableという概念は最初のやっていることの1と3に関わるものです。

その上で、odr-usableとはまず、ローカルエンティティに対する概念であって

あるローカルエンティティがその宣言領域（シャドウイングされないで名前が有効な領域、スコープ）内で参照される場合、そのエンティティもしくはその場所が

- `*this`ではない、もしくは
- クラススコープかラムダ式のものではない関数パラメータスコープに囲われている
    - そのスコープの最も内側のスコープが関数パラメータスコープであるならば、そのスコープは非静的メンバ関数のもの

のどちらかに該当しており

そのローカルエンティティが導入される地点とそのローカルエンティティが参照される領域との間に介在している宣言領域のそれぞれについて

- 介在する宣言領域はブロックスコープである、もしくは
- 介在する宣言領域はラムダ式の関数パラメータスコープであり
    - そのローカルエンティティを明示的にキャプチャしているか、デフォルトキャプチャを持っていて
    - そのラムダ式のブロックスコープ（本体）もまた、介在する宣言領域である

のどちらかに該当する場合に、そのローカルエンティティはodr-usableとなります。

介在する宣言領域というのは、ローカルエンティティの導入（宣言/定義）地点から、そのローカルエンティティ（の名前）を参照する地点の間に存在している宣言領域（主に各種スコープのこと）です。介在する（*intervening*）というのは、参照地点から導入地点の間でそのスコープが重なっている様を言っているのだと思います

前段の条件の2は、P0588R1のやっていることの1に関わるもので、クラスメンバ初期化子と非静的メンバ関数の引数宣言で`this`をキャプチャするラムダ式のハンドリングのためだと思われます（これは今回関係ありません）。

P0588R1の中程で、ラムダ式が明示的にキャプチャするもの（ローカルエンティティ）はodr-usableでなければならないとされています（これも今回関係ありません）。

で、このPRのメインの謎であるサンプルコードが含まれる例を見ていくと

```cpp
void f(int n) {
  [] { n = 1; };                // #1 error: n is not odr-usable due to intervening lambda-expression
  struct A {
    void f() { n = 2; }         // #2 error: n is not odr-usable due to intervening function definition scope
  };
  void g(int = n);              // #3 error: n is not odr-usable due to intervening function parameter scope
  [=](int k = n) {};            // #4 error: n is not odr-usable due to being
                                // outside the block scope of the lambda-expression
  [&] { [n]{ return n; }; };    // #5 OK
}
```

この例の場合、ローカルエンティティ`n`は関数`f`の関数パラメータスコープを宣言領域として導入されていて、`*this`ではないので、odr-usableの前段の条件はクリアしており、問題となるのは後段の条件のみです。

1. ローカルエンティティ`n`はラムダ式の関数パラメータスコープに囲われていますが、そのラムダ式はキャプチャに何も指定していない（明示的にも暗黙的にも`n`をキャプチャしていない）ため、この場所で`n`はodr-usableではありません
2. ローカルエンティティ`n`は`A::f()`の関数定義スコープと`A`のクラススコープに囲われています。いずれもブロックスコープではないため（当然ラムダ式の関数パラメータスコープでもないため）、odr-usableではありません
3. ローカルエンティティ`n`は`g()`の関数パラメータスコープに囲われていますが、これも後段2条件のどちらに合致するスコープでもないため、odr-usableではありません
4. ローカルエンティティ`n`はラムダ式の関数パラメータスコープに囲われていて、そのラムダ式はデフォルトキャプチャを持っています。しかし、そのラムダ式の本体のスコープが介在していない（`n`が参照される地点は本体の外側の）ため、odr-usableではありません
5. ローカルエンティティ`n`は2つのラムダ式の関数パラメータスコープに囲われていて、いずれのラムダ式も`n`をキャプチャしており（デフォルトキャプチャ->明示的キャプチャ）、`n`が参照される地点は2つのラムダ式の本体のブロックスコープの内部です。従って、これはodr-usableです。

多分このサンプルの言いたいことは、関数ローカル変数を関数の外に持ち出すことができうるケースを厳しく制限（コンパイルエラーに）しているよ、ってことだと思います（感想

このPRの疑問に答えるにはこれで良いと思います、間違ってたらすいません・・・

