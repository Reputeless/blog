# ［C++］WG21月次提案文書を眺める（2022年08月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2022-08](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/#mailing2022-08)

全部で27本あります。

[:contents]

### [N4914 WG21 2022-07 Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4914.pdf)

WG21の各作業部会の管理者ミーティングの議事録。

前回から今回の会議の間のアクティビティの報告がされています。

### [N4915 Business Plan and Convener's Report: ISO/IEC JTC1/SC22/WG21 (C++)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4915.pdf)

ビジネスユーザ向けのC++およびWG21の現状報告書。

### [N4916 WG21 2022-07 Virtual Meeting Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4916.pdf)

2022年2月7日（北米時間）に行われた、WG21全体会議の議事録。

CWG/LWG/LEWGの投票の様子などが記載されています。

### [P0843R5 `static_vector`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0843r5.html)

静的な最大キャパシティを持ちヒープ領域を使用しない`std::vector`である`static_vector`の提案。

`static_vector<T, N>`は`std::vector`と`std::array`のキメラのようなコンテナで、`N`に指定した値を最大キャパシティとして、スタック領域（グローバル変数として使用する場合は静的ストレージ）を用いて`std::vector`のような可変長配列を実現するものです。

主たる性質は

- 動的メモリ確保を必要としない
- スタックor静的ストレージを使用する
- キャパシティ最大値がコンパイル時に指定される
- 要素は後から挿入/削除可能
- 要素のストレージは`static_vector`オブジェクト内に配置される
- `contiguous_range`コンセプトを満たす
- 要素型`T`がトリビアルであれば、全ての操作が定数式で可能

などで、`static_vector`は次のような場合に有用です

- 動的メモリ確保を行えない
    - 例えば、組み込み環境など
- 動的メモリ確保のコストが高くつく
    - 例えば、メモリ確保に伴うレイテンシに敏感なプログラム
- 静的ストレージ上に、変則的な生存期間をもつオブジェクトを構築したい
- デフォルト構築できない型の配列など、`std::array`が選択肢にならない
- `constexpr`関数内で可変長配列を使用したい
    - これはC++20以降`std::vector`でも可能
- `static_vector`の要素のストレージは`static_vector`オブジェクト自体が内包している必要がある
    - シリアライズのための`memcpy`サポートのためなど

この提案の`static_vector`は既存実装である`boost::container::static_vector`をベースとして設計されており、インターフェースや性質は`std::vector`との共通化が図られています。

```cpp
#include <static_vector> // <vector>になるかもしれない

int main() {
  std::static_vector<int, 8> sv = {1, 2, 3, 4};

  std::println("{}", sv); // [1, 2, 3, 4]

  sv.push_back(5);
  sv.emplace_back(6);

  std::print("{}", sv); // [1, 2, 3, 4, 5, 6]
}
```

なお、最大キャパシティを超えて要素を挿入しようとした場合、全ての操作において事前条件違反として未定義動作となります。例外を投げたリ`abort`したりするのかは実装の選択とされます。

- [Boost.Container static_vector - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/20130712/1373614497)
- [Class template static_vector - Boost](https://www.boost.org/doc/libs/1_80_0/doc/html/boost/container/static_vector.html)
- [P0843 進行状況](https://github.com/cplusplus/papers/issues/114)

### [P1255R9 A view of 0 or 1 elements: views::maybe](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1255r9.pdf)
### [P2019R1 Usability improvements for `std::thread`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2019r1.pdf)

`std::thread/std::jthread`において、そのスレッドのスタックサイズとスレッド名を実行開始前に設定できるようにする提案。

現在の`std::thread/std::jthread`には、スタックサイズを設定する方法もスレッド名を設定する方法も用意されていません。一方で、この2つのクラスが使用している実行環境のスレッドAPIでは、広くこの2つのスレッドプロパティの設定が可能となっています。

|環境|スタックサイズの設定|スレッド名の設定|
|---|---|---|
|Linux, QNX|`pthread_attr_setstacksize()`|`pthread_setname_np()`|
|Windows|`CreateThread()`|`SetThreadDescription()`|
|Darwin|`pthread_attr_setstacksize()`|`pthread_setname_np()`|
|Fuchsia||`zx_thread_create()`|
|Android|`pthread_attr_setstacksize()`|`JavaVMAttachArgs()`|
|FreeBSD, OpenBSD, NetBSD|`pthread_attr_setstacksize()`|`pthread_setname_np()`|
|RTEMS|`pthread_attr_setstacksize()`|`pthread_setname_np()`|
|FreeRTOS|`xTaskCreate()`|`xTaskCreate()`|
|VxWorks|`taskSpawn()`|`taskSpawn()`|
|eCos|`cyg_thread_create()`|`cyg_thread_create()`|
|Plan 9|`threadcreate()`|`threadsetname()`|
|Haiku||`spawn_thread()`|
|Keil RTX||`osThreadNew()`|
|WebAssembly|||

※ 空白はなし、スレッド名の設定は一部事後的にしか行えないものがある

また、他のプログラミング言語やC++ライブラリのスレッドAPIにおいても、これらに対応した機能を提供している場合が多くみられます。

- スタックサイズの設定 : Java, Rust, Python, C#, Haskell, D, Perl, Swift, Boost, Qt
- スレッド名の設定 : Rust, Python, D, C#, Java, Raku, Swift, Qt, Folly

スタックサイズの設定は、次のような場合に必要となります

- 特定のスタックサイズで実行できるように設計されているアプリケーションの移植性と信頼性のために、プラットフォーム間で一貫したスタックサイズを指定する
- プラットフォームのデフォルトよりも小さいスタックサイズを使用する
    - Windows : 1MB, Unix 2MB
    - 多数のスレッドを起動したときにメモリ消費を抑えられる（仮想メモリのないシステムにおいて）
- 一部のアプリケーションでは、メインスレッドに大きなスタックトレースを設定し、そこから起動されたスレッドにも継承させるものがある。これが望ましくない場合がある
- 有名なゲームや大規模アプリケーションなどでは、デフォルトよりも大きいスタックサイズを使用することがある

スレッド名はデバッガを始めとする外部ツールにおいて有用で、主にデバッグに活用できます

- デバッガーにおける利用
- 各種クラッシュダンプや実行トレースツール
- タスク/プロセスモニタ
- プロファイル/トレース/診断ツール
- Windows Performance Analyzer, ETW tracing

これらのことが欠けている事によって、`std::thread`や`std::jthread`を使用することができず、ほぼ同等のクラスを再実装したり、基底のAPIを直接使用したりしなければならないケースがあります。また、筆者の方は、「スタックサイズのサポートがないために`std::thread`を使うことができず、`std::thread`は語彙型として失敗している」という話をゲーム開発者の人々から聞いているようです。

この提案は、それらの既存のプラクティスを標準化することで、現在`std::thread/std::jthread`を使用できていない所で使用可能にしようとするものです。

ここで提案されているAPIは、プロパティ指定クラスを`std::thread_attribute`から継承させて定義した上で、そのオブジェクトを`std::thread`のコンストラクタで受け取るようにするものです。

```cpp
namespace std {
  // スレッドプロパティ指定識別用基底クラス
  class thread_attribute {};

  // スレッド名を指定するクラス
  class thread_name : thread_attribute {
  public:
    constexpr thread_name(std::string_view name) noexcept;
    constexpr thread_name(std::u8string_view name) noexcept;
  private:
    implementation-defined __name[implementation-defined]; // 説明専用
  };

  // スタックサイズを指定するクラス
  class thread_stack_size : thread_attribute {
  public:
    constexpr thread_stack_size(std::size_t size) noexcept;
  private:
    constexpr std::size_t __size; // 説明専用
  };


  class thread {
    ...

    // デフォルトコンストラクタ（元からある
    thread() noexcept;

    // 処理とその引数を受け取るコンストラクタ（元からある
    template<class F, class... Args>
    explicit thread(F&& f, Args&&... args);

    // 処理とプロパティ指定を受け取るコンストラクタ（この提案で追加
    template<class F, class... Attrs>
      requires (sizeof...(Attrs) != 0) &&
               ((is_base_of_v<thread_attribute, Attrs>) && ...) &&
               ...
    explicit thread(F&& f, Attrs&&... attrs);

    ...
  };

  // jthreadも同様（略

}
```

`std::thread_name/std::thread_stack_size`が渡された設定値をどのように保持して取り出せるようにするかは実装定義とされています。

これらのものを次のように使用してスレッドに設定します。

```cpp
void f();

int main() {
  // スレッド名とスタックサイズの指定
  std::jthread thread(f, std::thread_name("Worker"),
                         std::thread_stack_size(512*1024));
  return 0;
}
```

指定されたプロパティが設定可能でない場合（例えばWASM環境など）、実装はこの指定を無視することができます。

このプロパティ指定の方法はこの2つのプロパティ以外にも拡張可能で、例えばスレッドのアフィニティや優先度を指定可能とすることも将来的には可能なようにされています。とはいえ、この提案ではスタックサイズとスレッド名の2つのプロパティのみを提案しています。

- [P2019 進行状況](https://github.com/cplusplus/papers/issues/817)

### [P2164R6 views::enumerate](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2164r6.pdf)
### [P2264R4 Make assert() macro user friendly for C and C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2264r4.html)
### [P2477R3 Allow programmers to control coroutine elision](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2477r3.html)
### [P2511R2 Beyond operator(): NTTP callables in type-erased call wrappers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2511r2.html)
### [P2517R1 Add a conditional noexcept specification to std::apply](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2517r1.html)
### [P2537R1 Relax va_start Requirements to Match C](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2537r1.html)
### [P2581R1 Specifying the Interoperability of Built Module Interface Files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2581r1.pdf)
### [P2587R2 to_string or not to_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2587r2.html)
### [P2611R0 2022-07 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2611r0.html)
### [P2620R1 Lifting artificial restriction on universal character names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2620r1.pdf)
### [P2621R1 UB? In my Lexer?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2621r1.pdf)
### [P2623R1 implicit constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2623r1.html)
### [P2625R0 Slides: Life without operator() (P2511R1 presentation)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2625r0.pdf)
### [P2626R0 charN_t incremental adoption: Casting pointers of UTF character types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2626r0.pdf)
### [P2627R0 WG21 2022-07 Virtual Meeting Record of Discussion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2627r0.pdf)
### [P2628R0 Extend barrier APIs with memory_order](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2628r0.html)
### [P2629R0 barrier token-less split arrive/wait](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2629r0.html)
### [P2630R0 Submdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2630r0.html)
### [P2633R0 thread_local_inherit: Enhancing thread-local storage](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2633r0.html)
### [P2634R0 Allow qualifiers in constructor declarations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2634r0.html)
### [P2635R0 Enhancing the break statement](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2635r0.html)
