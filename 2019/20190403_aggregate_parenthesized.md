# 丸かっこによる集成体初期化

集成体初期化（Aggregate Initilization）とは、配列か集成体となる条件を満たしたクラスに対して行える特別な初期化方法の事です。

C++17まではこれは波かっこ（{}）の時にのみ考慮され、使用することができました。丸かっこ（()）による初期化は常にその型のコンストラクタを呼び出していました。  
しかし、C++20からはその制限がなくなり丸かっこによる初期化時にも集成体初期化が考慮され、行われるようになります。

```cpp
struct agg {
  int a;
  double b;
};

agg a{10, 3.14};  //ok　C++17 & 20
agg b(10, 3.14);  //C++17 ng. C++20 ok.

agg c = {20, 2.72};  //ok　C++17 & 20
agg d = (20, 2.72);  //?
```

丸かっこによる集成体初期化はなるべく波かっこによるものと同じように実行されるようにされます。一方で、今までの丸かっこによる初期化の持つ意味が変わらないようにもなっています。  
そのため、波かっこによる集成体初期化と少し異なる挙動をするところがあります。

### 仮想的なコンストラクタ
丸かっこによる集成体初期化は、あたかも指定された引数列を受け取るコンストラクタとそのコンストラクタ初期化子リストから各メンバを初期化したかのように初期化されます。

```cpp
struct agg {
  int a;
  double b;
  char c;

  //(1)
  agg(int arg1, double arg2, char arg3)
    : a(arg1)
    , b(arg2)
    , c(arg3)
  {}

  //(2)
  agg(int arg1, double arg2)
    : a(arg1)
    , b(arg2)
    , c()
  {}

  //(3)
  agg()
    : a()
    , b()
    , c()
  {}
};

agg a(10, 3.14, 'a');  //(1)を呼び出しかのように初期化
agg a(10, 3.14);  //(2)を呼び出しかのように初期化
agg a();  //(3)を呼び出したかのように初期化
```
これらのコンストラクタはあくまで仮想的なものです。実際にはコンストラクタ宣言のある型は集成体になれません。
つまりは、このような仮想的なコンストラクタがあるかのように初期化を行うわけです。

### あらゆる変換の許可
波かっこによる初期化時は集成体初期化でなくても、共変な変換以外のあらゆる変換が禁止されていました。  
それは思わぬところで変換エラーを引き起こし、特にテンプレートの中では波かっこ初期化は非常に使いづらくなってしまっていました。

```cpp
//case 1
template<typename T>
constexpr T pi() {
  return T{3.1415926535897932384626433832795};
  //こうするとok
  //return T(3.1415926535897932384626433832795);
}

auto pid = pi<double>(); //ok.
auto pif = pi<float>();  //compile error!

//case 2
constexpr char str[50]{};
constexpr auto begin = std::begin(str);
double pi_v = 3.1415926535897932384626433832795;

if (auto [end, err] = std::to_chars(begin, std::end(str), pi_v); err == std::errc{}) {
  std::cout << std::string_view{begin, end - begin};  //compile error!
  //こう書くとok
  //std::cout << std::string_view(begin, end - begin);
}

```
これらのエラーは波かっこ初期化時にはほぼ全ての変換が禁止されていることから発生しています。しかし、これをそうであると理解することはとても難しいです・・・。

しかし、丸かっこによる集成体初期化においてはそのような制限はなく、あらゆる変換が考慮され実行されます。これは同じ丸かっこによる初期化で、コンストラクタ呼び出しと集成体初期化とで挙動が異なることがないようにするためです。

その恩恵の最たる例は縮小変換が可能になることでしょう。  
縮小変換とは上記case 1の問題の原因で、変換後の型が変換前の型の表現を受け止めきれない時の変換です（double -> float, signed -> unsigned 等）。

ただし、このような変換が許可されるのはクラス型の集成体初期化時のみで、配列に対する丸かっこ集成体初期化時は相変わらず禁止されます。配列は元々丸かっこ初期化を持っておらず、挙動が曖昧にはならないためです。

### 潜む罠

### 参考文献
- [P0960R3 : Allow initializing aggregates from a parenthesized list of values](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0960r3.html)