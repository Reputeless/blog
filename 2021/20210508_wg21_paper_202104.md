# ［C++］WG21月次提案文書を眺める（2021年03月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2021 mailing2021-04](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/#mailing2021-04)

全部で55本あり、SG22（C/C++相互互換性に関する研究グループ）のCの提案を除くと48本になります。

[:contents]

### [P0323R10 std::expected](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0323r10.html)

エラーハンドリングを戻り値で行うための型、`std::expected<T, E>`の提案。

`std::expected<T, E>`のオブジェクトは型`T`か`E`のどちらかの値を保持しており、`T`の値を期待される値（正常値）、`E`の値をエラーとして扱うことでエラーハンドリングを行います。これは、Rustでは`Result<T, E>`として重宝されています。

`std::expected`を使うと、`std::optional<T>`は`std::expected<T, std::nullopt_t>`のように書くことができ、`std::optional`をエラー処理に用いる時に失われてしまっていたエラー詳細を同時に保持しておくことができるようになります。

`std::expected`のインターフェースは`std::optional`をベースに、エラー値を保持している場合の操作を加えた形のものになります。

```cpp
#include <expected>

auto maybe_succeed() -> std::expected<int, std::string_view> {
  bool is_err = false;

  // 何か失敗しうる処理
  // ...

  if (is_err) {
    return 46;  // 正常値を返す
  } else {
    return {std::unepect, "error!"};  // エラー値を返す
  }
}

int main() {

  auto exp = maybe_succeed();

  // bool値に変換して結果をチェック
  if (exp or exp.has_value()) {
    // 正常値の取り出し
    int n = *exp;
    int m = exp.value();

    // 未定義動作
    exp.error();

  } else {
    // エラー値の取り出し
    std::string_view s = exp.error();
    
    // 未定義動作
    *exp;
    // 例外を投げる
    ep.value(); 
  }
}
```

優れたエラーハンドリングメカニズムには、次のような事が求められます。

1. エラーの可視性 : なんらかの処理が失敗するケースがコード上で隠されず、明確に表示されている
2. エラーの情報 : エラーにはその発生場所や原因などが含まれる
3. クリーンコード : エラー処理はできる限り目立たないように行われる。エラー処理は読みやすくなければならない
4. 被侵入的 : エラーが通常の処理フローのためのチャネルを独占しない。それらはなるべく分離されているべき

この観点から、`std::expected`と例外機構や通常のエラーコード戻り値によるエラー処理を比較すると

|性質|`std::expected`|例外|エラーコード戻り値|
|---|:-:|:-:|:-:|
|可視性|◯|△|◯|
|情報|◯|◯|△|
|クリーンコード|◯※|◯|×|
|非侵入的|◯|◯|×|

※ monadicインターフェースがある場合（現在の提案には欠けている）

このように、`std::expected`はエラー処理という観点から既存の方法よりも優れています。また、例外機構と比べるとパフォーマンスでも勝ります。

- [エラーハンドリングを綺麗にこなすためのライブラリ・expectedの紹介と応用 - Qita](https://qiita.com/wx257osn2/items/32adec3126b03ede3034)
- [エラー値と正常値を表す汎用的な型：expected - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/2014/05/30/153325)
- [P0323 進行状況](https://github.com/cplusplus/papers/issues/254)

### [P0447R13 Introduction of std::colony to the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0447r13.html)
### [P1121R3 Hazard Pointers: Proposed Interface and Wording for Concurrency TS 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1121r3.pdf)
### [P1122R3 Proposed Wording for Concurrent Data Structures: Read-Copy-Update (RCU)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1122r3.pdf)

標準ライブラリにRead-Copy-Update(RCU)を導入する提案。

RCUは並行処理におけるデータ共有のための仕組みで、ロックフリーデータ構造の実装に用いることができます。

RCUでは、共有対象のデータはアトミックなポインタによって共有されており、共有データを更新する際は別の領域にデータを構築してから、ポインタを差し替えることで行います（ここまではハザードポインタと同じ）。共有データに触る際のクリティカルセクションでは、スケジューリング（プリエンプション）が起こらないようにして、クリティカルセクションはあるスレッドを占有して実行されるようにしてから、共有データへアクセスします。クリティカルセクションに入る際はOSの機能を使用してそのスレッドがスケジューリングされないようにしますが、何かロックを取得したりするわけではないのでオーバーヘッドはほぼゼロです。

読み取りの際は、共有データを読みだしている間そのスレッドはスケジューリングされず、データを見終わった後で通常通りスケジューリング対象に戻ります。

更新の際は、更新後のデータを別の領域に用意してからクリティカルセクションに入り、共有データを指すポインタを新しいデータを指すように差し替えます（この差し替えはアトミック）。その後、他のスレッドが最低一回以上スケジューリングされるまで待機してから、差し替え前の古いデータを削除しクリティカルセクションを抜けます。

クリティカルセクション中そのスレッドはスケジューリングされないので、処理はOSによって中断される事なく実行されています。そのため、更新スレッドから見て他のスレッドに対してスケジューリング一回以上行われたということは、共有データを読み取っている（更新前の古いデータを見ている）可能性のあるスレッドが読み取り処理を終えている事を意味します。

スレッドがスケジューリングされないようになるということは、クリティカルセクションの実行はCPUの論理コアを占有することになります。従って、更新スレッドが実行されているコアを除いたシステムのCPUの残りの論理コアにおいてスレッドの切り替えが一回以上行われていれば、更新スレッドが保持している古いデータを見ているスレッド（=クリティカルセクション）が無いこと分かるため、安全に削除できるということです。

RCUを使用して、複数のリーダー（*reader*）が並行して存在する時に、共有データの更新を実行する例。

```cpp
// 共有したいもの
std::atomic<std::string *> name;

// 並行して頻繁に呼ばれる
void print_name() {
  std::rcu_reader rr;
  std::string *s = name.load(std::memory_order_acquire);
  /* ...use *s... */
}

// あまり呼ばれない
void update_name(std::string_view &nn) {
  // 1. 値の更新
  std::string *new_name = new std::string(nn);
  std::string *s = name.exchange(new_name, std::memory_order_acq_rel);
  // 2. 遅延削除
  std::rcu_retire(s);
}
```

リーダー（`print_name()`）は1つのスレッドで実行され、更新処理（`update_name()`）はそれとは別のスレッドで実行されます。`print_name()`内`rcu_reader`のオブジェクトは、リーダーの処理が完了するまで参照しているオブジェクトが、`rcu_retire()`によって削除されないように保護しています。

RCUは読み取りが頻繁に起こるが更新はあまりされないような場合に適した方法です。

この提案は別の提案（[P0461R2](http://wg21.link/P0461r2)）の標準へ提案する文書をまとめたもので、Concurrency TSに向けて提案され、議論されています。

著者の方（Paul McKenneyさん）の実装経験をベースにして長い時間をかけて議論されてきており、Concurrency TSに向けての議論がLWGまで進行しているのでConcurrency TSには入りそうですが、標準ライブラリの一部として利用可能となるにはもう少しかかりそうです・・・

- [P0461R2 Proposed RCU C++ API](http://wg21.link/P0461r2)
- [P1121R2 Hazard Pointers: Proposed Interface and Wording for Concurrency TS 2 - WG21月次提案文書を眺める（2021年01月）](https://onihusube.hatenablog.com/entry/2021/02/11/153333#P1121R2-Hazard-Pointers-Proposed-Interface-and-Wording-for-Concurrency-TS-2)
- [P0561R5 An RAII Interface for Deferred Reclamation - WG21月次提案文書を眺める（2020年12月）](https://onihusube.hatenablog.com/entry/2021/01/17/005823#P0561R5-An-RAII-Interface-for-Deferred-Reclamation)
- [HTMはメモリ管理の為に生まれてきたんだよ！　ΩΩ＜な、なんだってー - Software Transactional Memo](https://kumagi.hatenablog.com/entry/2013/01/08/232549)
- [P1122 進行状況](https://github.com/cplusplus/papers/issues/39)

### [P1132R7 out_ptr - a scalable output pointer abstraction](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1132r7.html)

スマートポインタとポインタのポインタを取るタイプのC APIとの橋渡しを行う、`std::out_ptr`の提案。

C APIでは、関数の中でのメモリアロケーションの結果などを呼び出し元に出力するために、ポインタのポインタ（`T** / void**`）を引数に取るものがよく見られます。ポインタではなくポインタのアドレスを渡す必要があり、`std::unique_ptr`をはじめとするスマートポインタはそれを取得する手段がないため、相性が良くありませんでした。

提案文書より、ffmpegにおけるサンプル。

```cpp
#include <memory>
#include <avformat.h>

// カスタムデリータ
struct AVFormatContextDeleter {
  void operator() (AVFormatContext* c) const noexcept {
    avformat_close_input(&c);
    avformat_free_context(c);
  }
};

using av_format_context_ptr = std::unique_ptr<AVFormatContext, AVFormatContextDeleter>;

// libavformatのシグネチャ
//int avformat_open_input(AVFormatContext **ps, const char *url, AVInputFormat *fmt, AVDictionary **options);

int main (int, char* argv[]) {
  av_format_context_ptr context(avformat_alloc_context());

  // ...
  // used, need to reopen

  // AVFormatContext**にunique_ptrをセットしたいが・・・
  AVFormatContext* raw_context = context.release();
  if (avformat_open_input(&raw_context, argv[0], nullptr, nullptr) != 0) {
    // 処理が失敗した場合にデリータが走って欲しくないので、一旦release()している

    std::stringstream ss;
    ss << "ffmpeg_image_loader could not open file '"
      << path << "'";
    throw FFmpegInputException(ss.str().c_str());
  }

  // 成功したら出力されたポインタをセット
  context.reset(raw_context);

  // ... off to the races !

  return 0;
}
```

`std::out_ptr/std::inout_ptr`はこのような場合の`release()`と`reset()`の呼び出しを自動化し、スマートポインタに内包されているポインタのアドレスを抽出するものです。

```cpp
int main (int, char* argv[]) {
  av_format_context_ptr context(avformat_alloc_context());

  // ...
  // used, need to reopen

  // release()してからポインタのアドレスを渡し、終了後に元のunique_ptrにreset()する
  if (avformat_open_input(std::inout_ptr(context), argv[0], nullptr, nullptr) != 0) {
    std::stringstream ss;
    ss << "ffmpeg_image_loader could not open file '"
      << argv[0] << "'";
    throw FFmpegInputException(ss.str().c_str());
  }

  // ... off to the races!

  return 0;
}
```

このようなユーティリティは、大小様々な企業において再発明されていますが、その用途や目的はC APIの出力ポインタ（`T**`）引数にスマートポインタを直接渡せるようにする事で一貫しています。この提案は、そのような目的が同じでありながらそれぞれで再実装されているユーティリティの、将来性があり高性能で使いやすい共通の実装を標準で提供する事を目指したものです。

`std::out_ptr/std::inout_ptr`は関数であり、引数で受け取ったスマートポインタをラップした型（`std::out_ptr_t/std::inout_ptr_t`）のオブジェクトを返します。それらの型は元のポインタ型や`void**`への暗黙変換演算子を備えており、コンストラクタとデストラクタで`release()`と`reset()`を行います。

`std::out_ptr`と`std::inout_ptr`の違いは、対象となるスマートポインタが予めリソースの所有権を持っているか否かによって使い分けるためにあります。

```cpp
error_num c_api_create_handle(int seed_value, int** p_handle);
error_num c_api_re_create_handle(int seed_value, int** p_handle);
void c_api_delete_handle(int* handle);

struct resource_deleter {
  void operator()( int* handle ) {
    c_api_delete_handle(handle);
  }
};

// out_ptrの使用例
void normal_case() {
  std::unique_ptr<int, resource_deleter> resource(nullptr);

  // スマートポインタからそのポインタのアドレスへの変換をラップする
  error_num err = c_api_create_handle(24, std::out_ptr(resource));

  if (err == C_API_ERROR_CONDITION) {
    // handle errors
  }
}

// inout_ptrの使用例
void reallocate_case(std::unique_ptr<int, resource_deleter> resource) {

  // 予めリソースの所有権を保持している場合
  // release()してからポインタのアドレスを渡し、終了後に元のunique_ptrにreset()する
  error_num err = c_api_re_create_handle(24, std::inout_ptr(resource));

  if (err == C_API_ERROR_CONDITION) {
    // handle errors
  }
  // resource.get() the out-value from the C API function
}
```

`std::out_ptr`は空のスマートポインタにC API経由でリソースをセットするときに使用し、`std::inout_ptr`は予めリソースの所有権を保持しているスマートポインタをC APIに渡すときに使用します。

その他のサンプル

```cpp
#include <memory>
#include <cstdio>

// C API関数
int fopen_s(std::FILE** f, const char* name, const char* mode);

// カスタムデリータ
struct fclose_deleter {
  void operator()(std::FILE* f) const noexcept {
    std::fclose(f);
  }
};

int main(int, char*[]) {
  constexpr const char* file_name = "ow.o";
  std::unique_ptr<std::FILE, fclose_deleter> file_ptr;

  // unique_ptrをFILE**へ渡すためのキャスト構文
  int err = fopen_s(std::out_ptr<std::FILE*>(file_ptr), file_name, "r+b");
  if (err != 0) {
    return 1;
  }
  // *file_ptr is valid
  return 0;
}
```
```cpp
#include <memory>

struct StarFish* starfish_alloc();

// C API関数
int starfish_populate(struct StarFish** ps, const char *description);

// カスタムデリータ
struct StarFishDeleter {
  void operator() (struct StarFish* c) const noexcept;
};

using StarFishPtr = std::unique_ptr<StarFish, StarFishDeleter>;

int main(int, char*[]) {
  StarFishPtr peach(starfish_context());
  // ...
  // used, need to re-make
  int err = starfish_populate(std::inout_ptr(peach), "caring clown-fish liker");
  return err;
}
```

この提案は元々C++20入りを目指していましたが間に合いませんでした。C++20作業終了時点で提案は既にLWGに送付済みで、コロナウィルス流行などによって遅れていましたが、既にLWGでの最後のレビューが完了しています。次の全体会議で投票にかけられ、何事もなければC++23に導入されます。

- [P1132 進行状況](https://github.com/cplusplus/papers/issues/41)

### [P1169R1 static operator()](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1169r1.html)
### [P1401R5 Narrowing contextual conversions to bool](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1401r5.html)
### [P1664R3 reconstructible_range - a concept for putting ranges back together](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1664r3.html)
### [P1673R3 A free function linear algebra interface based on the BLAS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1673r3.pdf)
### [P1706R3 Programming Language Vulnerabilities for Safety Critical C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1706r3.pdf)
### [P1708R4 Simple Statistical Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1708r4.pdf)
### [P1847R4 Make declaration order layout mandated](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1847r4.pdf)
### [P1938R3 if consteval](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1938r3.html)
### [P1949R7 C++ Identifier Syntax using Unicode Standard Annex 31](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1949r7.html)
### [P1967R3 #embed - a simple, scannable preprocessor-based resource acquisition method](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1967r3.html)
### [P1989R2 Range constructor for std::string_view 2: Constrain Harder](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1989r2.pdf)
### [P2128R4 Multidimensional subscript operator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2128r4.pdf)
### [P2128R5 Multidimensional subscript operator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2128r5.pdf)
### [P2168R2 generator: A Synchronous Coroutine Generator Compatible With Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2168r2.pdf)
### [P2186R2 Removing Garbage Collection Support](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2186r2.html)
### [P2201R1 Mixed string literal concatenation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2201r1.html)
### [P2223R2 Trimming whitespaces before line splicing](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2223r2.pdf)
### [P2251R1 Require span & basic_string_view to be Trivially Copyable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf)
### [P2255R1 A type trait to detect reference binding to temporary](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2255r1.html)
### [P2265R1 Renaming any_invocable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2265r1.pdf)
### [P2273R1 Making std::unique_ptr constexpr](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2273r1.pdf)
### [P2283R1 constexpr for specialized memory algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2283r1.pdf)
### [P2295R1 Correct UTF-8 handling during phase 1 of translation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2295r1.pdf)
### [P2295R2 Support for UTF-8 as a portable source file encoding]([)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2295r2.pdf)
### [P2295R3 Support for UTF-8 as a portable source file encoding]([)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2295r3.pdf)
### [P2321R1 zip](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r1.html)
### [P2322R2 ranges::fold](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2322r2.html)
### [P2325R2 Views should not be required to be default constructible](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r2.html)
### [P2327R0 De-deprecating volatile compound assignment](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2327r0.pdf)
### [P2337R0 Less constexpr for <cmath>](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2337r0.pdf)
### [P2342R0 For a Few Punctuators More](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2342r0.pdf)
### [P2345R0 Relaxing Requirements of Moved-From Objects](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2345r0.pdf)
### [P2348R0 Whitespaces Wording Revamp](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2348r0.pdf)
### [P2350R0 constexpr class](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2350r0.pdf)
### [P2352R0 SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2352r0.html)
### [P2353R0 Metaprograms and fragments are needed in comma-separated contexts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2353r0.html)
### [P2355R0 Postfix fold expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2355r0.html)
### [P2356R0 Implementing Factory builder on top of P2320](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2356r0.pdf)
### [P2358R0 Defining Contracts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2358r0.pdf)
### [P2360R0 Extend init-statement to allow alias-declaration](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2360r0.html)
### [P2361R0 Unevaluated string literals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2361r0.pdf)
### [P2362R0 Make obfuscating wide character literals ill-formed](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2362r0.pdf)
### [P2363R0 Extending associative containers with the remaining heterogeneous overloads](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2363r0.html)