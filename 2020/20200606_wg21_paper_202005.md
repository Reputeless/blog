# ［C++］WG21月次提案文書を眺める（2020年5月）

文書の一覧
[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-05:embed:cite]

提案文書で採択されたものは今回はありません。

[:contents]

### [P0493R1 : Atomic maximum/minimum](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0493r1.pdf)

`std::atomic`に対して、指定した値と現在の値の大小関係によって値を書き換える`max/min`操作を追加する提案。

```cpp
#include <atomic>

std::atomic<int> a = 10;

auto max = a.fetch_max(20);
// max == 20, a == 20

auto min = a.fetch_min(5);
// min == 5, a == 5
```

これらの操作はread-modify-writeです。すなわち、現在の値と指定された値の大小関係に関わらず、値は常に更新されます。

```cpp
std::atomic<int> a = 10;

auto max = a.fetch_max(5);  // 値の入れ替えは起こらないが、書き込みは行われている
// max == 10, a == 10
```

この提案では今の所、`std::atomic<T>`の整数型とポインタ型の特殊化に対してだけ`fetch_max()/fetch_min()`メンバ関数を追加しています。「[P0020 : Floating Point Atomic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0020r6.html)」が採択されれば浮動小数点型の特殊化についても追加すると書かれているので、次のリビジョンくらいで浮動小数点型の`std::atomic`特殊化についても同様のものが追加されるかもしれません。

また、他の`atomic`操作に準ずる形で非メンバ関数版も用意されています。

```cpp
namespace std {
  template<class T>
  T atomic_fetch_max(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;

  template<class T>
  T atomic_fetch_max(atomic<T>*, typename atomic<T>::value_type) noexcept;

  template<class T>
  T atomic_fetch_max_explicit(volatile atomic<T>*, typename atomic<T>::value_type, memory_order) noexcept;

  template<class T>
  T atomic_fetch_max_explicit(atomic<T>*, typename atomic<T>::value_type, memory_order) noexcept;

  // fetch_min()も同様
}
```

### [P0870R3 : A proposal for a type trait to detect narrowing conversions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0870r3.html)

### [P1679R2 : String Contains function](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1679r2.html)

### [P1841R1 : Wording for Individually Specializable Numeric Traits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1841r1.pdf)

### [P1861R1 : Secure Networking in C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1861r1.html)

### [P1897R3 : Towards C++23 executors: A proposal for an initial set of algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1897r3.html)

### [P1898R1 : Forward progress delegation for executors](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1898r1.html)

### [P1974R0 : Non-transient constexpr allocation using propconst](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1974r0.pdf)

### [P1985R1 : Universal template parameters](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1985r1.pdf)

### [P2066R2 : Suggested draft TS for C++ Extensions for Transaction Memory Light](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2066r2.html)

### [P2128R1 : Multidimensional subscript operator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2128r1.pdf)

### [P2136R1 : invoke_r](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2136r1.html)

### [P2142R1 : Allow '.' operator to work on pointers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2142r1.pdf)

### [P2145R0 : Evolving C++ Remotely](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2145r0.html)

### [P2159R0 : An Unbounded Decimal Floating-Point Type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2159r0.html)

### [P2160R0 : Locks lock lockables (wording for LWG 2363)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2160r0.html)

### [P2161R0 : Remove Default Candidate Executor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2161r0.pdf)

### [P2162R0 : Inheriting from std::variant (resolving LWG3052)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2162r0.html)

### [P2163R0 : Native tuples in C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2163r0.pdf)

### [P2164R0 : views::enumerate](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2164r0.pdf)

### [P2165R0 : Comparing pair and tuples](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2165r0.pdf)

### [P2167R0 : Improved Proposed Wording for LWG 2114](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2167r0.html)

### [P2168R0 : generator: A Synchronous Coroutine Generator Compatible With Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2168r0.pdf)

### [P2169R0 : A Nice Placeholder With No Name](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2169r0.pdf)

### [P2170R0 : Feedback on implementing the proposed std::error type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2170r0.html)

### [P2171R0 : Rebasing the Networking TS on C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2171r0.pdf)

### [P2172R0 : What do we want from a modularized Standard Library?](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2172r0.pdf)

### [P2173R0 : Attributes on Lambda-Expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2173r0.pdf)

### [P2174R0 : Compound Literals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2174r0.html)