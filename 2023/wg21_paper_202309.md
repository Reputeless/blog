# ［C++］WG21月次提案文書を眺める（2023年08月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-09](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-09)

全部で40本あります。

もくじ

[:contents]

### [P0843R9 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0843r9.html)
### [P1068R9 Vector API for random number generation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1068r9.pdf)
### [P1255R10 A view of 0 or 1 elements: views::maybe](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1255r10.pdf)
### [P2264R5 Make assert() macro user friendly for C and C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2264r5.html)
### [P2542R4 views::concat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2542r4.html)
### [P2542R5 views::concat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2542r5.html)
### [P2686R2 constexpr structured bindings and references to constexpr variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2686r2.pdf)
### [P2748R2 Disallow Binding a Returned Glvalue to a Temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2748r2.html)
### [P2755R0 A Bold Plan for a Complete Contracts Facility](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2755r0.pdf)

C++の契約プログラミング機能について、将来的な完成形のための計画を練る提案。

現在、C++26に向けて契約プログラミング機能を導入すべく作業が続けられていますが、それは本来の契約プログラミング機能の合意がとれたサブセットです。本来想定される契約プログラミング機能はより広いものですが、そこにはまだ合意がとれていないものや議論が紛糾しているもの、実装経験が乏しいものなどが含まれており、それらを全て導入しようとすればさらに長い時間が必要となります。

この提案は、そのような最終的なC++契約プログラミング機能がどのようなニーズの元に構成され、何を備えているべきかを説明し、提案するものです。必然的に、C++26に導入されようとしている機能を超えた部分についての提案になっています。

1章を除いた残りの部分は

- 2章 : 契約機能のC++におけるユースケースについての説明
- 3章 : 提案する個々の機能についての解説や提案
- 4章 : 3章を踏まえた、より大規模で現実的なサンプルの提示
- 5章 : 最終的に対処する必要がある、言語と契約機能についての他の（3章に含まれない）側面についての議論

のような構成となっています。

- [P2958 進行状況](https://github.com/cplusplus/papers/issues/1630)

### [P2760R0 A Plan for C++26 Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2760r0.html)

C++26に向けての、`<ranges>`ライブラリ関連作業の予定表。

C++23では`<ranges>`ライブラリ関連作業のまとめを[P2214](https://wg21.link/p2214r2)で行っていました。最終的に、そこで提案されていた優先度1のほとんどのものと優先度2の一部のものをC++23に導入することができました。

この提案は、C++26でも同様に作業を優先付けして分類し、追加の考慮が必要なものについてまとめておくためのものです。

この提案で優先度1とされているものは次のものです

- Rangeアダプタ
    - `views::concat`
    - `take/drop`のファミリ
      - `views::drop_last`と`views::take_last`
      - `views::drop_last_while`と`views::take_last_while`
      - `views::drop_exactly`と`views::take_exactly`
      - `views::slice`
    - 単純な合成アダプタ
      - `views::transform_join`
      - `views::replace`と`views::replace_if`
      - `views::remove`と`views::remove_if`
      - `views::upto`
    - `views::as_input`
    - `views::cache_last`
    - `views::chunk_on`
    - `views::cycle`
    - `views::delimit`と`views::c_str`
    - より複雑な状況における、より多くのアダプタの`borrowed_range`対応
    - ジェネレータ
      - `views::scan`
      - `views::generate`と`views::generate_n`
- Rangeアルゴリズム
    - `ranges::reduce`
    - `ranges::sum`
    - `ranges::product`

他にも優先度2と3の分類がありますが、C++26に向けてはこの優先度1のものについての作業を優先的に行う予定です。

- [P2760 進行状況](https://github.com/cplusplus/papers/issues/1635)

### [P2762R1 Sender/Receiver Interface For Networking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2762r1.pdf)
### [P2833R2 Freestanding Library: inout expected span](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2833r2.html)
### [P2846R1 size_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2846r1.pdf)
### [P2865R3 Remove Deprecated Array Comparisons from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2865r3.pdf)
### [P2866R1 Remove Deprecated Volatile Features From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2866r1.pdf)
### [P2867R1 Remove Deprecated strstreams From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2867r1.html)
### [P2868R2 Remove Deprecated `std::allocator` Typedef From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2868r2.pdf)
### [P2869R2 Remove Deprecated `shared_ptr` Atomic Access APIs From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2869r2.pdf)
### [P2870R2 Remove `basic_string::reserve()` From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2870r2.pdf)
### [P2871R2 Remove Deprecated Unicode Conversion Facets From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2871r2.pdf)
### [P2872R2 Remove `wstring_convert` From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2872r2.pdf)
### [P2875R2 Undeprecate `polymorphic_allocator::destroy` For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2875r2.pdf)
### [P2885R2 Requirements for a Contracts syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2885r2.pdf)
### [P2909R1 Fix formatting of code units as integers (Dude, where's my char?)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2909r1.html)
### [P2909R2 Fix formatting of code units as integers (Dude, where's my char?)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2909r2.html)
### [P2932R0 A Principled Approach to Open Design Questions for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2932r0.pdf)

契約機能に関する未解決の問題についての設計原則に基づく解決策の提案。

C++26に向けて契約プログラミング機能を導入するべく、SG21での作業は順調に進行しています。今年に入ってから、主に契約注釈の意味論についての議論が交わされ、合意の下でいくつかの提案がMVPにマージされました。

- [P2751R1 Evaluation of Checked Contract-Checking Annotations](https://wg21.link/P2751R1) : 契約条件式で許可されるものと、その評価結果がどう解釈されるかの規定
- [P2811R7 Contract-Violation Handlers](https://wg21.link/P2811R7) : 実行時に契約違反に対する処理をカスタマイズすることのできる、リンク時に置換可能な契約違反ハンドラの追加
- [P2834R1 Semantic Stability Across Contract-Checking Build Modes](https://wg21.link/P2834R1) : 関数の事前条件・事後条件は`noexcept`（指定/演算子）に影響を及ぼさない
- [P2877R0 Contract Build Modes, Semantics, and Implementation Strategies](https://wg21.link/P2877R0) : 契約注釈のセマンティクス（無視される、評価される、など）の選択を実装定義とし、特にその選択は評価ごとに異なる可能性があり、そのため契約注釈の意味論は契約注釈のコンパイル時の特性ではない、とした。これによって、ビルドモードの概念は削除された。

MVP仕様（P2521R4）に対してこれらをマージすれば、C++の言語機能としての契約プログラミング機能がすぐにでも得られますが、いくつかのエッジケースや設計ポイントにはまだ対処すべき問題が残っています。

契約プログラミングに関する議論が紆余曲折を経ていることもあって、C++における契約プログラミング機能の設計に関するドキュメントは存在していません。この提案は、C++26の契約プログラミング機能のための残りの作業の完遂のために、C++における契約プログラミング機能の設計意図を体系化する基本原則をまとめ、それらをもとに現在残っているいくつかの問題への回答を示すものです。

提案されている原則とは次の4つです

1. 契約注釈は平易な言語（非プログラミング言語）による契約をチェックする
    - 関数の宣言に付加された契約注釈は、それが評価されたときにその関数の平易な言語による契約の違反を特定しなければならない
2. プログラムのセマンティクスは（実装によって）選択された契約注釈のセマンティクスから独立している
    - 契約注釈のセマンティクスは、それがなされている地点を取り巻く近接した部分のコンパイル時のセマンティクスに影響を与えてはならない
3. 無視される契約述語（つまり、条件が評価されない場合）はゼロオーバーヘッドである
    - 無視される契約注釈付近のコードの動作は、その注釈がコメントアウトされているかのようになる
    - ただし、無視される場合でも構文チェックは継続される（エンティティがODR-usedであるかは変わらない）
4. 未定義動作はill-formed（コンパイルエラー）とする
    - 現在の契約機能ではサポートされていないユースケースに対応するために、未定義（安全でない）や実装定義（ポータブルでない）ではなく、未解決の振る舞いをill-formedとすることで拡張性を柔軟に保つことを好む

これらの原則をベースとして、この提案では次の問題についての解決が提案されています

1. トリビアルな特殊メンバ関数と契約
    - 契約注釈は関数のトリビアル性に影響を与えない
    - そのような契約注釈は評価されない可能性がある
2. 暗黙のラムダキャプチャ
    1. ラムダ式における契約注釈を許可する
    2. 契約注釈中のODR-usedは暗黙的にキャプチャしない
        - 契約注釈（`assert`を含む）はラムダ式がキャプチャしていないものをキャプチャしない
        - それがなされている場合はill-formed
3. 定数式における契約チェック
    1. コンパイル時の契約違反は診断を発行する
        - 契約違反プロセスがコンパイル時に評価されると（*observe*もしくは*enforce*セマンティクスでコンパイル時に評価される場合に契約違反が発生すると）診断が発行される
          - *enforce*セマンティクスによって評価されている場合、プログラムはill-formed
    2. セマンティクスはコンパイル時に選択される可能性がある
        - 契約注釈を評価する際の実装定義の評価セマンティクスの選択は、コア定数式の一部として評価される可能性がある
        - つまり、契約注釈の評価の一部としてそのセマンティクスを選択しても、それを含む式はコア定数式ではなくならない
    3. コンパイル時に契約条件が評価される場合に、定数式で実行不可能な式を使用するのはill-formed
        - コア定数式として有効な式において、コア定数式として有効ではない契約条件を評価すると診断が発行される
          - *enforce*セマンティクスによって評価されている場合、プログラムはill-formed
    4. コンパイル時定数ではないものの、定数式として有効な初期化子内の契約注釈は、実行時に評価される
        - 潜在的なコンパイル時定数である非コンパイル時定数変数の初期化式が、その全ての契約注釈が*ignore*セマンティクスで評価されたときにコア定数式とならない場合、その初期化式はコア定数式ではない
        - 従って、異なるセマンティクスを持つ可能性のある契約条件を使用してその式を再度定数評価しようとすることは行われない
    5. 定数式における契約注釈の評価について、まとめ
        - 式が定数式として有効であるかを判断するときは、まず*ignore*セマンティクスで契約注釈とその式を評価することで、式が定数式として有効であるかを調べる
          - 式は定数式として有効である、もしくは、定数式として有効ではないが*manifestly constant-evaluated*なコンテキストにある場合
            - 実装定義の方法で選択されたセマンティクスに基づいて、契約注釈を評価しながら式を再評価する
              - *observe*セマンティクスの元で契約違反が発生した場合、診断を発行し実行（コンパイル）を継続
              - *enforce*セマンティクスの元で契約違反が発生した場合、プログラムはill-formed、診断を発行する
              - 式が定数式で実行できない場合、プログラムはill-formed
          - それ以外の場合、式は定数式ではない 
4. 仮想関数 : 次のどちらか
    1. 契約注釈は継承されない
        - 宣言に事前条件・事後条件を持たない仮想関数は、事前条件・事後条件を持たない
        - オーバーライドされる関数の契約条件を継承しない
    2. 仮想関数には契約注釈を行えない
        - 事前条件・事後条件を`virtual`とマークされた関数もしくはそれをオーバライドする関数に行うのはill-formed
5. コルーチン
    - コルーチンには契約注釈を行えない
      - コルーチンである関数に事前条件・事後条件を指定することはill-formed
      - コルーチン本体内での`assert`は許可
6. 最初の宣言の契約
    1. 契約注釈は最初の宣言でのみ行える
        - 関数の宣言がその最初の宣言ではない場合、事前条件・事後条件を持つことはできない
    2. 関数の契約注釈のリストは一貫している必要がある
        - ある関数について、全ての翻訳単位における最初の宣言における契約注釈リストは同じである必要がある。ただし、診断は不要

この提案が採択されることで、P2896R0で収集されている全ての未解決の問題は解決されます。そして、それによって（構文の選択は必要ですが）契約機能の提案はC++言語に統合するための準備ができている状態になります。

- [P2896R0 Outstanding design questions for the Contracts MVP - WG21月次提案文書を眺める（2023年08月）](https://onihusube.hatenablog.com/entry/2023/10/14/223052#P2896R0-Outstanding-design-questions-for-the-Contracts-MVP)
- [P2932 進行状況](https://github.com/cplusplus/papers/issues/1636)

### [P2935R1 An Attribute-Like Syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2935r1.pdf)
### [P2935R2 An Attribute-Like Syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2935r2.pdf)
### [P2944R2 Comparisons for reference_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2944r2.html)
### [P2951R3 Shadowing is good for safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2951r3.html)
### [P2955R1 Safer Range Access](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2955r1.html)
### [P2961R0 A natural syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2961r0.pdf)

契約プログラミング機能のための構文の提案。

C++26に向けた契約プログラミングの議論において、あとは構文の選択が大きな議題として残っています。現在のところ構文の候補として有力なのは属性like構文と呼ばれるもので、これはC++20の頃の構文を踏襲し新しい文法やキーワードを発明する必要がなく、属性の無視という性質を自然に利用でき、さらにGCCによる実装経験があります。

属性like構文にもいくつか欠点があります

1. 契約注釈の区切りのトークン`[[ ... ]]`が構文として重い
    - 一部のユーザーからは醜いと認識されている
2. 契約構文は属性と同様の記法を利用するが属性ではないため、混乱が生じる
    - 契約構文は違反ハンドラを通じるなどして、関数から新しいコードパスを作成できるが、標準属性はこのようなことを行うように設計されていない
3. 契約注釈を置ける構文上の位置は関数宣言の自然な読み取り順序に反している
    - 属性の置ける位置を再利用するため、後置戻り値の前（`override`や`requires`節の前）に事前条件と事後条件がくる
4. `assert`は式ではないため、Cの`assert`の完全な代替となり得ない
5. 3と4を属性構文のまま解決しようとすると、属性構文の利点が失われる
    - 現在それらが可能なように標準属性はできていない、そのため実装経験もない
6. 属性構文では、その内部の述語の前に`:`がくる場合に、それより前の内容に区切りを導入しない
    - 視覚的な情報の区別（契約種別や戻り値の名前、ラベルなどの見分け）が難しくなり、将来的に構文解析の曖昧さを生じさせる
7. 契約注釈自体に属性を付加する場合、属性内の属性という文法を導入させなければならない

属性like構文の代替としていくつか構文の提案があります

- P2461R1 closure-based syntax
    - [P2461R0 Closure-based Syntax for Contracts - WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2461R0-Closure-based-Syntax-for-Contracts)
    - 契約条件を`{}`の中に配置するが、`{}`は文に使われるもの。契約条件は式
    - 契約注釈とラムダの間には共通点がほぼないが、構文が似ている
- P2737R0 condition-centric syntax
    - [P2737R0 Proposal of Condition-centric Contracts Syntax - WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2737R0-Proposal-of-Condition-centric-Contracts-Syntax)
    - 完全な提案ではない
    - ラベルや契約注釈への`requires`節、明示キャプチャなど将来の機能拡張を考慮していない

P2373は契約注釈のために`contract-kind ( predicate )`という新しい文法を発明しました。そしてそれに加えて幾つかの設計上の選択を提案しました

- assertionをinconditionにリネーム
- `pre, post, assert`の代わりに、`precond, postcond, incond`を使用
- `precond, postcond, incond`を文脈依存ではない完全なキーワードとして追加
- 事後条件では、戻り値を`result`という固定的な名前で参照する

これらのことがSG21では受け入れられなかったようで、この提案の方向性も問題を抱えています。

この提案は、P2461R1とP2373R0で提示されたアイデアを流用しながら、それら2つと属性like構文にある問題を解決しつつP2885で示された契約構文に対する要件を満たすような、契約プログラミング機能のためのより自然な構文を提案するものです。

この提案の目指す設計ゴールは次のようなものです

- 構文は既存のC++に自然に馴染む。
    - 契約機能に慣れていないユーザーでも混乱を招くことなく直感的に理解できるものである必要がある
- 契約注釈構文は、属性やラムダ式など既存のC++の構成要素に似ていてはならない
    - ぱっと見で認識可能な独自の設計空間に置かれているべき
- 構文はエレガントかつ軽量である
    - 必要以上にトークンや文字を使用するべきではない
- 読みやすくするために、一次情報とニ次情報を構文的に分離する
    - 一次情報（条件種別、契約条件式、戻り値名、キャプチャなど）をそれ以外のニ次情報（ラベルなど）よりも視覚的に強調する

これらの目標は、現在の構文候補が満たしていないものでもあります。

この提案による構文は、P2461R1とP2373R0で提案されたアイデアをベースとしており、関数の一番最後の位置に`pre(...)`、`post(...)`によって事前条件と事後条件を指定します。

```cpp
float sqrt(float x)
  pre (x >= 0);     // 事前条件

int f(int x)
  post (r: r > x);  // 事後条件
```

`pre(...)`、`post(...)`のように`()`の内部に述語（契約条件）を指定することは、`if(expr)`や`while(expr)`などの既存のC++構文と一貫しており、非常に自然なものです。また、事後条件で戻り値を使用する場合は、条件式の前に`:`を置いて、その前で任意の名前を使用できます。

`pre, post`はどちらも文脈依存なキーワードであり、関数の一番最後（`requires`の後）にくることもあって、関数の他の部分で`pre, post`を任意のエンティティの名前として使用することができます。

```cpp
template <typename T>
auto f(T x) -> bool
  requires std::integral<T>
  post (x > 0);
```

文法の詳細は提案の4.1 Grammarに記載されています。少し大きめなのと差分をわかりやすく表示できないためここには転記しません。

`assert`も事前・事後条件と同様の構文によるのですが、この場合既存のCの`assert`マクロと衝突してしまうので、それを回避する必要があります。そのために、キーワードを少し変更しています

```cpp
void f() {
  int i = get_i();

  // C assertと衝突する
  assert(i >= 0);

  // この提案によるassert
  assrt(i >= 0);
}
```

ここでは`assrt`としていますが、他の選択肢（`ass, assertion, co_assert`など）でも良いとしています。コルーチンのキーワードである`co_yield`などと同様に、ユーザーはすぐに慣れるとしています。

`assrt(expr)`は式であるため、現在の`assert`マクロと同様に式として使用できます。

```cpp
class X {
  int* _p;
public:
  X(int* p)
   : _p((assrt(p), p))  // ok
  {}
};
```

これによって、単純な文字列置換によって`assert`マクロから`assrt`式へ移行することができます。

この提案ではさらに、P2885で示されているC++26契約の後の機能拡張のアイデアを考慮しています。

例えばキャプチャ

```cpp
void vector::push_back(const T& v)
    post [old_size = size()] ( size() == old_size + 1 ); // 初期化キャプチャ、関数の実行によって変更される前の値を保存する
```

ここでは、キャプチャ関連に限ってのみラムダ式のキャプチャ構文を流用しますが、契約種別のワード（`post`）が先行し契約条件が`()`内で記述されることでラムダ式との混同を回避しています。

他の例として、契約注釈に対する`requires`節

```cpp
template <typename T>
void f(T x)
  pre (x > 0) requires std::integral<T>;

// もしくは
template <typename T>
void f(T x)
  pre requires std::integral<T> (x > 0);
```

契約注釈に対する`requires`節が述語の前後どちらに来るべきかはまだ議論されていませんが、この提案による構文はどちらの場合でも拡張可能です。

契約注釈に対する属性指定

```cpp
template <typename T>
void f(T x)
  pre (x > 0) [[deprecated]];
```

これも属性がどこに来るかはまだ決まっていませんが、やはりどちらも受け止めることができます。属性like構文の場合のように属性内属性を考慮する必要もありません。

ラベルの指定

ラベルとは、契約注釈に対するメタ注釈となるものです。現在想定されているのは、契約注釈のセマンティクスを指定するものです。

```cpp
void f(int x)
  pre (x > 0) [audit]; // or <audit>, or {audit}, or [{audit}], or @audit ...
```

前のものと同様にこれも位置について異論がありますが、どちらでも受け止めることができます。

戻り値の分解

構造化束縛に近い構文によって、事後条件で参照する戻り値を分解して参照する拡張が考えられます

```cpp
std::tuple<int, int, int> f()
  post ([x, y, z] : x != y && y != z);
```

これらの構文はまた、P2885で示された契約構文に対する要件の多く（将来の拡張も含めて）を考慮し、満たすように設計されています。

P2461（closure-based syntax）の著者の方はこの提案がP2461のアイデアを包含し改善するものであるとしてこの提案を支持し、P2461の追及を停止することにしたそうです。そのため、契約機能の構文提案としては、属性like構文とP2737R0の条件中心構文、及びこの提案の3つがアクティブとなっています。

- [P2885R0 Requirements for a Contracts syntax - WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P2885R0-Requirements-for-a-Contracts-syntax)
- [P2961 進行状況](https://github.com/cplusplus/papers/issues/1637)

### [P2963R0 Ordering of constraints involving fold expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2963r0.pdf)

コンセプトの制約式として畳み込み式を使用した場合に、意図通りの順序付を行うようにする提案。

現在のコンセプトの制約の半順序ルールでは、畳み込み式はそれ全体で1つの原子制約式と扱われます。それによって、プログラマの意図と異なる制約順序付けが行われ、特に可変長テンプレートにおける適切な制約を難しくしています。

```cpp
template <class T>
concept A = std::is_move_constructible_v<T>;

template <class T>
concept B = std::is_copy_constructible_v<T>;

template <class T>
concept C = A<T> && B<T>;


template <class... Ts>
  requires (A<Ts> && ...)
void g(T...);

template <class... Ts>
  requires (C<Ts> && ...)
void g(T...);
```

この例のコンセプト`C`は型に対してコピー構築可能性とムーブ構築可能性を要求しています。同じ型のシーケンス`Ts`に対して、`C<Ts> && ...`は`A<Ts> && ...`を包含しているため、制約の順序づけもそれを反映したものとなることが期待されます。しかし、現在は畳み込み式はその全体で1つの原子制約式として扱われて順序づけが行われてしまうため、同じ型のシーケンス`Ts`に対して`C<Ts> && ...`と`A<Ts> && ...`の間には包摂関係が成立せず順序づけ不可能となります。

その結果、上記の例では`A`と`B`を満たす型`T`を1つ以上`g()`に渡すと、2つのオーバーロードの間で優先順位が付かないため呼び出しは曖昧になり、コンパイルエラーとなります。

この提案は、畳み込み式においてはその全体ではなく、含まれる個別の制約式を原子制約式として扱うようにして、この問題を解決しようとするものです。

提案では次のような手順によって畳み込み式の半順序を規定しようとしています

1. 畳み込み式を正規化して、二項畳み込み式を単行畳み込み式に変換する
    - `(init && ... && Pack)`もしくは`(Pack && ... && init)`を、`(Pack && ...)`と`init`を正規化したものを`&&`で繋げた形に変換
    - `||`も同様
2. `(... op Pack)`を`(Pack op ...)`に変換し、以降区別しない
    - `op`は`&& ||`のどちらか
3. 残った`(Pack && ...)`もしくは`(Pack || ...)`について、比較する2つの畳み込み式のパラメータパックが同じサイズならば、通常の原子制約式の包摂のルールに従って包摂関係が判定される

この提案の一部はclangにおいて実装されているようで、そこでは実装においてもコンパイル時間においても大きな影響はなかったとのことです。また、この提案は現在曖昧になるオーバーロードを意図通りに順序づけするだけで、既存のコードの動作を変えるものではありません。

- [可変長コンセプト×畳み込み式: The glass is half full or half empty? - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20210825/p1)
- [制約とコンセプトとオーバーロードと半順序 #C++](https://qiita.com/kazatsuyu/items/ea6b8f1c8c7d384505b8)
- [P2963 進行状況](https://github.com/cplusplus/papers/issues/1638)

### [P2966R0 Making C++ Better for Game Developers -- Progress Report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2966r0.pdf)
### [P2966R1 Making C++ Better for Game Developers -- Progress Report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2966r1.pdf)
### [P2968R0 Make std.ignore a first-class object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2968r0.html)
### [P2971R0 Implication for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2971r0.pdf)
### [P2972R0 2023-09 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2972r0.html)
### [P2973R0 Erroneous behaviour for missing return from assignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2973r0.html)
### [P2976R0 Freestanding Library: algorithm, numeric, and random](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2976r0.html)