# ［C++］TU-local Entityをexposureするのこと（禁止）


### モジュールと内部リンケージ名

内部リンケージをもつエンティティ（関数、クラスや変数）は、外部リンケージをもつ関数など、翻訳単位のインターフェースの実装詳細をある粒度で分解して表現するために使用されています。それによって、コードの保守性や再利用可能性の向上が見込めます。

従来のヘッダファイルとソースファイルからなる一つの翻訳単位の構成においては、内部リンケージ名はソースファイル内に隠蔽されているか、ヘッダファイルに書かれていてもヘッダをインクルードした翻訳単位それぞれで内部リンケージを持つ別のものとして扱われるため、内部リンケージを持つエンティティが翻訳単位外部から参照されることはありませんでした。

```cpp
/// header.h

#include <iostream>

int external_f(int);

// 翻訳単位毎に定義される
// それぞれの定義が翻訳単位を超えて参照されることはない
static void internal_f(int n) {
  std::cout << n << std::endl;
} 
```

```cpp
/// source.cpp

#include "header.h"

namespace {
  // この翻訳単位の外から呼ぶことはできない
  int internal_g() {
    return 10;
  }
}

int external_f(int n) {
  internal_f(n);
  return n + internal_g();
}
```

しかしC++20以降のモジュールにおいては、そのインターフェース単位で定義されている内部リンケージ名がそのモジュール（インターフェース単位）をインポートした先の翻訳単位からも参照できてしまいます。

ヘッダファイルとは異なり、モジュールのインターフェース単位は一つの翻訳単位であり、そのインポートはインターフェース単位にあるすべての宣言を（インポートした側から）到達可能にし、エクスポートされている宣言を可視（名前探索で見えるように）にします。この到達可能性は、内部リンケージを持つ名前であってもインポートした側の翻訳単位の宣言に影響を及ぼす可能性があります。

また、モジュールで定義されたテンプレートがインスタンス化されたとき、インスタンス化が発生した地点から定義に至る一連のインスタンス化経路上で可視になっている宣言を参照することができます。このインスタンス化経路は翻訳単位を超えて定義され、そこでは内部リンケージを持つ名前を参照することができます。

```cpp
/// mymodule.cpp
module;
#include <iostream>
export module mymodule;

// 内部リンケージ名を翻訳単位外から参照できないのは変わらないが
// インポートした側から宣言は到達可能となる
static void internal_f(int n) {
  std::cout << n << std::endl;
}

namespace {
  int internal_g() {
    return 10;
  }
}

// エクスポートされている、外部リンケージ
export int external_f(int n) {
  // 外部リンケージを持つ定義内での内部リンケージ名の使用
  // 例えばこの関数がインライン展開されたとき、何が起こる・・・？
  internal_f(n);
  return n + internal_g();
}
```

直接的に別の翻訳単位にある内部リンケージを持つ名前を参照できるわけではありませんが、間接的に内部リンケージを持つ名前が翻訳単位から露出してしまっています。例えばエクスポートされた関数が使われた先でインライン展開されるとき、内部リンケージの名前が参照されていたらどうするべきでしょうか・・・？

そのため、最終的なC++20モジュール仕様では、内部リンケージを含めた翻訳単位ローカルのエンティティ（*TU-local Entities*）が翻訳単位の外から間接的にも直接的にも参照されることが禁止されました。

内部リンケージ名は実装の整理や分割のために用いられるものであり、そのような実装詳細はモジュールの外部に公開されるべきではない、という判断です。このことを規格書では、*TU-local Entities*とその暴露（*exposure*）として表現しています。

### TU-local Entityの暴露（*exposure*）

宣言は次の場合にTU-localエンティティを暴露（*exposure*）しています。

1. TU-localな値によって初期化された`constexpr`変数を定義する場合
2. 次の場合を除いて、TU-localエンティティを指名（参照）する場合
      1. 非`inline`関数または関数テンプレートの本体
         - TU-localな型が、プレースホルダによる戻り値型で宣言された関数の推定された戻り値型となる場合を除く
      2. 変数または変数テンプレートの初期化子
      3. クラス定義内フレンド宣言
      4. 非`volatile`な`const`オブジェクトへの参照、またはodr-useされておらず定数式で初期化された内部リンケージかリンケージ名の無い参照

TU-localとは、翻訳単位内にローカルな、みたいな意味です。暴露されているとはすなわち、TU-localなものが翻訳単位外部から参照できうる場所に現れている事です。

たとえば1のケース、`constexpr`変数は定数伝播の結果、その初期化子が参照先にインライン展開される可能性があります。それがTU-localな値を使って初期化されている場合、そのTU-localな値が翻訳単位外に曝される可能性があります。

2のケースはごく一部の例外を除いて殆どの場合に宣言が暴露されることを示しています。

注意としては、TU-localなものを一切含まない宣言は、外部リンケージを持つものであっても暴露されているわけではありません。暴露されているというのは、TU-localなものを含んでいて、かつそれが翻訳単位外に曝される可能性がある場合です。

### TU-local Entities？

TU-localとなるエンティティは次のものです。

1. 内部リンケージ名をもつ関数、型、変数、テンプレート
2. TU-localエンティティの定義内で、ラムダ式によって導入または宣言された、リンケージ名を持たない関数、型、変数、テンプレート
3. クラスの宣言・定義、関数本体、初期化子、の外側で定義されている名前のない型
4. TU-localエンティティを宣言するためだけに使用される、名前のない型
5. TU-localテンプレートの特殊化
6. TU-localテンプレートを実引数として与えられたテンプレートの特殊化
7. 宣言がTU-localエンティティを暴露しているテンプレートの特殊化
      - この場合の特殊化は、暗黙的あるいは明示的にインスタンス化済みである可能性がある

基本的には1と3が1次TU-localエンティティであり、他はそれによって副次的にTU-localとなっています。つまり、ほとんどの場合に気にすべき対象は内部リンケージ名を持つものです。

7は一見逆では？と思えます。テンプレートの特殊化は翻訳単位毎に行われるため、宣言が暴露されている（簡単には外部リンケージをもつ）テンプレートの、各翻訳単位における特殊化はTU-localであるとみなすことができます。そのような特殊化が統一されるのはリンク時まで遅れます。

また、値やオブジェクトは次の場合にTU-localとなります

1. TU-local関数またはTU-local変数に関連付けられているオブジェクトであるか、そのポインタ型の場合
2. クラスか配列のオブジェクトであり、そのサブオブジェクト（メンバ、基底クラス、要素）のいずれかがTU-localである
3. クラスか配列のオブジェクトであり、その参照型の非静的データメンバが参照するオブジェクトまたは関数のいずれかがTU-localである

ややこしいですが、TU-localなものの中にある変数や値はTU-localで、TU-localなものを参照しているものも、それを含むものもTU-localという事です。

### 暴露してたら・・・

モジュールインターフェース単位（プライベートモジュールフラグメントがある場合その外側）、あるいはモジュールパーティションにおいて、TU-localではない宣言（あるいはそのための推論補助）が暴露されている場合、コンパイルエラーとなります。

TU-localな宣言が単にモジュールのインターフェース単位に書いてあるだけではコンパイルエラーとはなりません。それらの宣言が

ただし、非モジュールなところ、あるいはモジュールのパーティションではない実装単位においては、この事は単に非推奨とされ、コンパイルエラーとはなりません。


ある翻訳単位に現れた宣言が、ヘッダユニットではない別の翻訳単位のTU-localエンティティを指名する場合、プログラムはill-formed。テンプレートの特殊化によってインスタンス化された宣言は、その特殊化のインスタンス化地点に現れている。


### テンプレート

### 例

### 参考文献
- [P1815R2: Translation-unit-local entities](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1815r2.html)
- [P1779R3: ABI isolation for member functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1779r3.html)
- [P1498R1 Constrained Internal Linkage for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1498r1.html)