# ［C++］コンセプトの無言のお願い事

[http://eel.is/c++draft/concepts.equality]
主にここに書いてあることを訳しただけの記事です。

### 等しさの保持（*equality preservation*）

ある式が等しい入力に対して等しい出力を返すとき、その式は **等しさを保持（*equality-preserving*）** しています。式とはわかりやすいところでは関数であり、演算子のことです。ある式を`f()`とすると`a == b`ならば`f(a) == f(b)`となり、かつ常にこれが成り立つ時、`f()`は等しさを保持する式ということです。

この場合の入力とは、その式に直接与えられた引数全ての集合のことであり、引数とは1つの式のことです。正確には以下のものだけを含む一番大きな部分式のことです。

- id-expression（一次式）
- `std::move(), std::forward(), std::declval()`の呼び出し

例えば、`f(std::move(a), std::declval<T>(), c)`みたいなコードでは、まずこの全体が1つの式です。この式の部分式とは`std::move(a), a, std::declval<T>(), c`で、上記2つだけを含む最大の部分式=入力は、`std::move(a), std::declval<T>(), c`の3つです。  
別の例では、`a = std::move(b)`と言う式の入力は`a, std::move(b)`の2つです。

式は最終的に結果となる1つの値になるので、等しさを保持する式の入力（の式）というのはつまりある1つの引数値と言う事です。

そして、出力とは式の結果（上記の`f()`ならその戻り値）および、その式の実行によって変更された引数の集合です（変更されなかった引数は含まれない）。

等しさを保持する式の入力と出力はこれら以外にあってはいけません。

#### 安定（*stable*）

あるオブジェクトを入力（引数）にとるある式の2回の評価において、そのオブジェクトの明示的な変更が介在しない限り等しい出力が得られる時、その式は **安定（*stable*）** な式です。等しさを保持する式は安定でなければなりません。

つまり、等しさを保持し安定である式は内部や外部の状態に依存してはならず、直接の引数以外に対して副作用を持ってはならないと言う事です。

そして、標準ライブラリにおけるコンセプト定義内の全ての制約式は、特に注釈がない限り等しさを保持し安定でなければなりません。これは、そのコンセプトを満たそうとする場合にユーザーコードに対しても要求されます。

等しさを保持することを要求されないコンセプトには例えば[`std::invocable`](https://cpprefjp.github.io/reference/concepts/invocable.html)などがあります。

#### 定義域（*domain*）

等しさを保持する式はその入力となりうる全ての値について有効である必要はありません。例えば、整数に対する`a / b`と言う式は等しさを保持する式ですが、`b == 0`の時この式は有効ではありません。  
しかし、この様な入力を取り得たとしても、そのことはその式が等しさを保持することに影響を与えません。

ある等しさを保持する式の入力の全体から、この様な有効ではない入力を除いた集合をその式の **定義域（*domain*）** と呼びます。

この用語はコンセプトの意味論的な制約条件に出現することがあります（例えば、[std::
equality_comparable_with](https://cpprefjp.github.io/reference/concepts/equality_comparable.html)など）。
 

### 制約式の引数に対しての制約

標準ライブラリのコンセプト定義においては、ある`requires`式内の各制約式が引数に対して副作用を及ぼすか否か（引数を変更するかどうか）をその`requires`式の引数（ローカルパラメータ）の`const`修飾によって表現しています。ローカルパラメータが`const`修飾されている場合はそのパラメータを引数に取る制約式は対応する引数を変更してはなりません。逆に、`const`修飾されていなければ変更しても構いません。

このことも、コンセプトを満たそうとすれば自然にユーザーコードに対して要求されることになります。とはいえ、`const`修飾されたローカルパラメータが渡ってくるところでその引数を変更しようとするのは、`const_cast`とか`mutable`とかなんかおかしなことをしない限りそれを破ることは無いでしょう・・・？

```cpp
// 何か関数f()があるとして・・・
template<typename T>
concept C1 = requires(T a, T b) {
  f(a, b);
  a + b;
  // このC1コンセプトを満たす型は、f(T, T)とoperator+(T, T)の呼び出しが可能である必要がある
  // そして、そのような型に対するf()とoperator+の実装は、2つの引数に対して副作用を及ぼしても（引き数を変更しても）ok
};

template<typename T>
concept C2 = requires(const T a, T b) {
  f(a, b);
  a + b;
  // このC2コンセプトを満たす型Tは、f(T, T)とoperator+(T, T)の呼び出しが可能である必要がある
  // そのようなTに対するf()とoperator+の実装は、その第一引数は変更してはならない（`const`修飾されたローカルパラメータ`a`が渡されている）
  // ただし、第二引数は`const`修飾のないローカルパラメータ`b`が渡されているので、変更してもok
};
```

この様に決めた上で、コンセプトの型パラメータ`T`がCV修飾されていないオブジェクト型であり完全型と仮定すると、その定義内`requires`式内ではそのローカルパラメータのCV/参照修飾から各ローカルパラメータの値カテゴリとCV修飾を確定することができます。
このようにCV修飾と値カテゴリを指定したローカルパラメータを利用すれば、各制約式が引数としてどのようなCV修飾でどの値カテゴリを受け取るべきなのか？という制約を表現することができます。

```cpp
// このTがCV修飾されていないオブジェクト型であり完全型と仮定すると
template<typename T>
concept C = requires(T a, T&& b, const T& c) {
  // aの型はCV無しのTであり、左辺値
  // bの型はTの参照型であり、右辺値
  // cの型はconst T&であり、左辺値
  // というように、CV修飾と値カテゴリを指定できる

  f(a);             // 式f()はTのconst無し左辺値を受け取れる必要がある
  g(std::move(b));  // 式g()はTのconst無し右辺値を受け取れる必要がある
  h(c);             // 式h()はTのconst左辺値参照を受け取れる必要がある
};
```

#### `requires`式と`requires`節

### 暗黙的な式のバリエーション（*implicit expression variations*）

### コンセプトのモデルとなるために

### 参考文献

- [18.2 Equality preservation [concepts.equality]](http://eel.is/c++draft/concepts.equality)
- [`<concepts>` - cpprefjp](https://cpprefjp.github.io/reference/concepts.html)
- [P2102R0 Make “implicit expression variations” more explicit (Wording for US185)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2102r0.html)
