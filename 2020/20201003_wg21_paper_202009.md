# ［C++］WG21月次提案文書を眺める（2020年9月）

文書の一覧
[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-08:embed:cite]

提案文書で採択されたものはありません。全部で32本あります。

[:contents]

### [P0288R7 : any_invocable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0288r7.html)

ムーブのみが可能で、関数呼び出しの`const`性や`noexcept`性を指定可能な`std::function`である`std::any_invocable`の提案。

先月の記事を参照

[https://onihusube.hatenablog.com/entry/2020/09/18/222444#P0288R6--any_invocable:embed:cite]

前回からの変更は、規格書に追加するための文言を調整しただけの様です。

- [P0288 進行状況](https://github.com/cplusplus/papers/issues/400)

### [P0443R14 : A Unified Executors Proposal for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r14.html)

処理をいつどこで実行するかを制御するための汎用的な基盤となる*Executor*ライブラリの提案。

以前の記事を参照。

[https://onihusube.hatenablog.com/entry/2020/05/24/205222:embed:cite]

R13からの変更は、いくつか*Editorial*なバグを修正した事です。

- [P0288 進行状況](https://github.com/cplusplus/papers/issues/102)

### [P0881R7 : A Proposal to add stacktrace library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0881r7.html)

スタックトレースを取得するためのライブラリを追加する提案。

先月の記事を参照。

[https://onihusube.hatenablog.com/entry/2020/09/18/222444#P0881R6--A-Proposal-to-add-stacktrace-library:embed:cite]

LWGでのレビューが終了し、この提案は本会議での投票に向かうようです。このリビジョンはLWGでのレビューを受けて最終的な文言調整を反映したものです。多分C++23入り確定でしょう。

- [P0881 進行状況](https://github.com/cplusplus/papers/issues/119)

### [P0958R2 : Networking TS changes to support proposed Executors TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0958r2.html)

Networking TSの*Executor*の依存部分をP0443の*Executor*提案の内容で置き換える提案。

現在のNetworking TSは以前のBoost.asioをベースにしており、asioの持つ*Executor*はP0443のものとは異なっているので、Networking TSの*Executor*部分もまたP0443のものとは異なった設計となっています。

Networking TSは*Executor*に強く依存しており、C++23に導入される予定の*Executor*はP0443のものがほぼ内定しているので、Networking TSもそれに依存するように変更するものです。

Boost.asioライブラリは既にP0443ベースの*Executor*周りを実装し終えて移行しており、その実装をベースとする形で書き換えています。その経験によれば、一部のものを除いて殆どのアプリケーションでは追加の変更を必要としなかったとのことです。

- [P0958 進行状況](https://github.com/cplusplus/papers/issues/339)

### [P1322R2 : Networking TS enhancement to enable custom I/O executors](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1322r2.html)

Networking TSのI/Oオブジェクトを`io_context`だけではなく、任意の*Executor*によって構築できるようにする提案。

Networking TSの`io_context`はBoost.asioでは`io_service`と呼ばれていたもので、P0443の*Executor*にいくつかの機能が合わさったものです。

`io_context`は実行コンテキストを抽象化し表現するという役割がありますが、実行コンテキストを変更する事は単体ではできません。P0443では`executor`コンセプトによってそれら*Executor*と実行コンテキストを表現します。

Networking TSのI/Oオブジェクト（`socket, acceptor, resolver, timer`）は`io_context`を構築時に受け取り、それを利用して実行します。そこに任意の*Executor*を渡せるようにすることでユーザーが用意したものやプラットフォームネイティブの実行コンテキストでそれらの処理を実行できるようにしようとする提案です。

また、各I/Oオブジェクトのクラスのテンプレートパラメータに*Executor*を指定できるようにし、それらの動作をカスタマイズ可能としています。

この提案はおそらくNetworking TS仕様の*Executor*をベースとしており、P0443ベースで書かれていないようです。

- [Boost.Asioまとめ(1)::io_service - yutopp's blog](https://yutopp.hateblo.jp/entry/2011/12/15/001518)
- [`io_service` の使い方 - あめだまふぁくとりー](https://amedama1x1.hatenablog.com/entry/2015/12/14/000000_1)
- [P1322 進行状況](https://github.com/cplusplus/papers/issues/361)

### [P1371R3 : Pattern Matching](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1371r3.pdf)

オブジェクトの実際の状態に応じた分岐処理のシンタックスシュガーであるパターンマッチング構文の提案。

現在のC++には`if`と`switch`という二つの条件分岐用の構文があります。`if`は複雑な`bool`の式を扱うことができますが、`switch`は整数値しか扱えず、`if`は分岐条件を一つづつ書いて行くのに対して`switch`は条件を羅列した形で（宣言的に）書くことができるなど、は2つの構文の間にはギャップがあります。  
パターンマッチングはそれらの良いとこどりをしたような構文によって、特に代数的データ型の検査と分岐を書きやすく、読みやすくするものです。

この提案では`inspect`式によって構造化束縛宣言を拡張する形で`switch`的な書き方によってパターンマッチングを導入しています。これを提案中では*structured inspection*（構造化検証？）と呼んでいます。

#### `std::string`

<table>
<tr>
<th>`if`文</th>
<th>`inspect`式</th>
</tr>
<tr>
<td valign="top">

```cpp
if (s == "foo") {
  std::cout << "got foo";
} else if (s == "bar") {
  std::cout << "got bar";
} else {
  std::cout << "don't care";
}
```

</td>
<td valign="top">

```cpp
inspect (s) {
  "foo" => { std::cout << "got foo"; }
  "bar" => { std::cout << "got bar"; }
  __ => { std::cout << "don't care"; }
};
```

</pre>
</td>
</tr>
</table>

#### `std::tuple`

<table>
<tr>
<th>`if`文</th>
<th>`inspect`式</th>
</tr>
<tr>
<td valign="top">

```cpp
auto&& [x, y] = p;
if (x == 0 && y == 0) {
  std::cout << "on origin";
} else if (x == 0) {
  std::cout << "on y-axis";
} else if (y == 0) {
  std::cout << "on x-axis";
} else {
  std::cout << x << ',' << y;
}
```

</td>
<td valign="top">

```cpp
inspect (p) {
  [0, 0] => { std::cout << "on origin"; }
  [0, y] => { std::cout << "on y-axis"; }
  [x, 0] => { std::cout << "on x-axis"; }
  [x, y] => { std::cout << x << ',' << y; }
};

```

</pre>
</td>
</tr>
</table>

#### `std::variant`

<table>
<tr>
<th>`if`文</th>
<th>`inspect`式</th>
</tr>
<tr>
<td valign="top">

```cpp
struct visitor {
  void operator()(int i) const {
    os << "got int: " << i;
  }
  void operator()(float f) const {
    os << "got float: " << f;
  }
  std::ostream& os;
};
std::visit(visitor{strm}, v);
```

</td>
<td valign="top">

```cpp
inspect (v) {
  <int> i => {
    strm << "got int: " << i;
  }
  <float> f => {
    strm << "got float: " << f;
  }
};
```

</pre>
</td>
</tr>
</table>

#### *polymorphic*な型

<table>
<tr>
<th>`if`文</th>
<th>`inspect`式</th>
</tr>
<tr>
<td valign="top">

```cpp
struct Shape { 
  virtual ~Shape() = default;
  virtual int Shape::get_area() const = 0;
};

struct Circle : Shape {
  int radius;

  int Circle::get_area() const override {
    return 3.14 * radius * radius;
  }
};

struct Rectangle : Shape {
  int width, height;

  int Rectangle::get_area() const override {
    return width * height;
  }
};
```

</td>
<td valign="top">

```cpp
struct Shape { 
  virtual ~Shape() = default;
};

struct Circle : Shape {
  int radius;
};

struct Rectangle : Shape {
  int width, height;
};

int get_area(const Shape& shape) {
  return inspect (shape) {
    <Circle> [r] => 3.14 * r * r;
    <Rectangle> [w, h] => w * h;
  };
}
```

</pre>
</td>
</tr>
</table>

この例だけを見てもかなり広い使い方が可能であることが分かると思います。しかし、この例以上に`inspect`式による構文は柔軟な書き方ができるようになっています（ここで説明するには広すぎるので省略します。そこのあなたm9！解説記事を書いてみませんか？？）。

- [P1371 進行状況](https://github.com/cplusplus/papers/issues/166)

### [P1701R1 : Inline Namespaces: Fragility Bites](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1701r1.pdf)

`inline`名前空間の名前探索に関するバグを修正する提案。

当初のインライン名前空間と名前空間名の探索には次のようなバグがありました。

```cpp
namespace A {
  inline namespace b {
    namespace C {
      template<typename T>
      void f();
    }
  }
}

namespace A {
  namespace C {
    template<>
    void f<int>() { }  // error!
  }
}
```

当初の名前空間名の探索は宣言領域 （*declarative region*） という概念をベースに行われていました。宣言領域とは簡単にいえば、ある宣言を囲む宣言の事です。  
宣言領域の下では、2つ目の名前空間`A::C`の宣言は1つ目の`A::b::C`は宣言領域が異なるため、それぞれの名前空間`C`は同一のものとはみなされません。

しかし、これはテンプレートの特殊化を行う際に問題となるため、[DR 2061](https://wg21.cmeerw.net/cwg/issue2061)によって規格書の定義としては修正されました。その修正方法は、名前空間を宣言するとき、そのコンテキストからネストした`inline`名前空間も考慮したうえで到達可能な名前空間名を探索し、同じ名前が見つかった場合は同一の名前空間として扱い、見つからない場合にのみ新しい名前空間名を導入する。という感じです。

これによって先程のバグは解決されましたが、筆者の方がそれをGCCに実装する時に問題が浮かび上がったようです。

```cpp
inline namespace A {
  namespace detail { // #1
    void foo() {} // #3
  }
}

namespace detail { // #2
  inline namespace C {
    void bar() {} // #4
  }
}
```

DR2061以前は2つ目の名前空間`detail`は新しい名前空間を導入し、`#3, #4`はそれぞれ`A::detail::foo`と`detail::C::bar`という修飾名を持ちます。

しかしDR2061による修正によれば、2つ目の名前空間`detail`の宣言は一つ目の名前空間`A::detail`と同一視されます。その結果、`#3, #4`はそれぞれ`A::detail::foo`と`A::detail::C::bar`という修飾名を持つことになります。

このことはヘッダファイルやモジュールのインポートを介すことで、意図しない名前空間名の汚染を引き起こすことになります。  
これによって、ヘッダと実装でファイルを分けている場合、実装ファイルで名前空間名の指定が意図通りにならず、最悪別の名前に対する実装を行ってしまうかもしれません。また、`inline`名前空間を`using`することでAPIの一部だけを有効化するような手法をとるライブラリでは、意図しないものがスコープ中にばらまかれることにもなりかねません。

```cpp
namespace component {
  inline namespace utility {
      namespace detail {
        // component::utility::detail
      }
  }
}

namespace component {
  namespace detail {
    // DR2061以前は component::detail
    // DR2061の後は component::utility::detail
  }
}
```

一方、DR2061が無いとC++20以降は特に困ったことが起きます。

```cpp
namespace std {
  namespace ranges {
    template<>
    constexpr bool disable_sized_range<MyType> = true;
  }
}
```

`std::range::disable_sized_range`は変数テンプレートであり、ユーザー定義の型について特殊化することで`std::range::sized_range`コンセプトを無効化するものです。C++20の`range`ライブラリ周りではこのようなオプトアウトのメカニズムがほかにもいくつかあります。

現在、多くの実装はABI保護のために`std`名前空間内の実装には何かしらの形でインライン名前空間を挿入しています。すると、このコードで行っているような特殊化はDR2061による変更が無ければ特殊化としてみなされなくなります。

この提案ではこれらの問題の解決として次の2つのことをサジェストしています。

1. DR2061を元に戻す
2. 標準ライブラリ内でユーザーが特殊化することを定義されているものについて、修飾名で特殊化すること、という規定を追加する。

つまり、先程の特殊化は次のように書くことを規定するということです。

```cpp
template<>
constexpr bool std::ranges::disable_sized_range<MyType> = true;
```

こうすれば、名前空間の宣言を伴わないため上記のような問題に悩まされることはありません。

- [CWG Issue 2061. Inline namespace after simplifications](https://wg21.cmeerw.net/cwg/issue2061)
- [Bug 90291 - [8/9/10/11 Regression] Inline namespace erroneously extends another namespace - GCC Bugzilla](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=90291)
- [P1701 進行状況](https://github.com/cplusplus/papers/issues/470)

### [P1885R3 : Naming Text Encodings to Demystify Them](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1885r3.pdf)

システムの文字エンコーディングを取得し、識別や出力が可能ならライブラリを追加する提案。

C++の標準は文字エンコーディングを参照する時にロケールを介して参照しています。これは歴史的なものですが、ユニコードの登場によってもはや機能しなくなっています。そして、C++はシステムがどのエンコーディングを使用し、また期待しているかを調べる方法を提供していないためそれを推測しなければならず、文字列の取り扱いを満足に行う事ができません。

この提案は、現在取得する方法のないシステムやコンパイラの使用するエンコーディングを取得・識別できるようにし、また、エンコーディングを表現する標準的なプリミティブを提供することを目指すものです。  
なお、ここでは文字コード変換のための標準機能の追加を目指してはいません。

```cpp
#include <text_encoding>  // 新ヘッダ
#include <iostream>

int main() {
  // char文字（列）リテラルのエンコーディングを取得
  std::cout << std::text_encoding::literal().name() << std::endl;  
  // wchar_t文字（列）リテラルのエンコーディングを取得
  std::cout << std::text_encoding::wide_literal().name() << std::endl;
  // システムのマルチバイト文字エンコーディングを取得 
  std::cout << std::text_encoding::system().name() << std::endl;  
  // システムのワイド文字エンコーディングを取得 
  std::cout << std::text_encoding::wide_system().name() << std::endl;  
}
```

この提案による全てのものは`std::text_encoding`クラスの中にあります。上記の4つの関数はその環境で対応する文字エンコーディングを表す`std::text_encoding`のオブジェクトを返します。

`std::text_encoding`は非`static`メンバ関数`name(), mib(), aliases()`によってその名前、IANAのMIBenum、文字エンコーディング名の別名（複数）を取得することができます。

また、システムの文字エンコーディングが特定のエンコーディングであるかを判定する機能も提供されています。

```cpp
int main() {
  assert(std::text_encoding::system_is<std::text_encoding::id::UTF8>());
  assert(std::text_encoding::system_wide_is<std::text_encoding::id::UCS4>());
}
```

ただ、残念ながらこれらは`constexpr`ではありません。

`std::text_encoding::id`は各種文字エンコーディングを表す`enum class`で、IANAの定義するCharacter Setにある名前が列挙値として登録されています。この列挙値か、対応する文字コード名文字列をによっても`std::text_encoding`クラスを構築することができます。

また、`std::text_encoding`のオブジェクト同士を`==`で比較することもできます。

- [Character Sets - Internet Assigned Numbers Authority](https://www.iana.org/assignments/character-sets/character-sets.xhtml)
- [P1885 進行状況](https://github.com/cplusplus/papers/issues/634)

### [P1949R6 : C++ Identifier Syntax using Unicode Standard Annex 31](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1949r6.html)

識別子（*identifier*）の構文において、不可視のゼロ幅文字や制御文字の使用を禁止する提案。

以前の記事を参照
[https://onihusube.hatenablog.com/entry/2020/05/01/194425#P1949R3--C-Identifier-Syntax-using-Unicode-Standard-Annex-31:embed:cite]

[https://onihusube.hatenablog.com/entry/2020/07/05/003248#P1949R4--C-Identifier-Syntax-using-Unicode-Standard-Annex-31:embed:cite]

[https://onihusube.hatenablog.com/entry/2020/09/18/222444#P1949R5--C-Identifier-Syntax-using-Unicode-Standard-Annex-31:embed:cite]

このリビジョンの変更点は、この提案によって変更されるものと変更されないものを明記したのと、いくつかのサンプルを追加した事です。

- [P1949 進行状況](https://github.com/cplusplus/papers/issues/688)

### [P2013R3 : Freestanding Language: Optional ::operator new](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2013r3.html)

フリースタンディング処理系においては、オーバーロード可能なグローバル`::operator new`を必須ではなくオプションにしようという提案。

以前の記事を参照
[https://onihusube.hatenablog.com/entry/2020/05/01/194425#P2013R1--Freestanding-Language-Optional-operator-new:embed:cite]

このリビジョンの変更点は、8月のEWGの電話会議での投票結果を記載した事と、いくつかの文言の修正、機能テストマクロについては[P2198](https://wg21.link/P2198)の将来のリビジョンで検討することになったことです。

- [P2013 進行状況](https://github.com/cplusplus/papers/issues/749)

### [P2029R3 : Proposed resolution for core issues 411, 1656, and 2333; escapes in character and string literals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2029r3.html)

文字（列）リテラル中での数値エスケープ文字（`'\xc0'`）やユニバーサル文字名（`"\u000A"`）の扱いに関するC++字句規則の規定を明確にする提案。

以前の記事を参照
[https://onihusube.hatenablog.com/entry/2020/08/12/014639#P2029R2--Proposed-resolution-for-core-issues-411-1656-and-2333-escapes-in-character-and-string-literals:embed:cite]

このリビジョンの変更点は、電話会議の結果を受けて提案している文言を調整しただけの様です。

- [P1864 進行状況](https://github.com/cplusplus/papers/issues/760)

### [P2066R3 : Suggested draft TS for C++ Extensions for Transaction Memory Light](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2066r3.html)
### [P2077R1 : Heterogeneous erasure overloads for associative containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2077r1.html)

連想コンテナに対して透過的な要素の削除と取り出し方法を追加する提案。

C++20では、非順序連想コンテナに対して透過的な検索を行うことのできるオーバーロードが追加されました。「透過的」というのは連想コンテナのキーの型と直接比較可能な型については、一時オブジェクトを作成することなくキーの比較を行う事が出来ることを指します。これによって、全ての連想コンテナで透過的な検索がサポートされました。

一方、削除の操作に関しては順序/非順序どちらの連想コンテナも透過的な削除をサポートしていませんでした。この提案は、全ての連想コンテナの`erase()`と`extract()`に対しても同じ目的のオーバロードを追加しようとするものです。

```cpp
std::unordered_map<std::string, int> map = {{"16", 16}, {"1024", 1024}, {"65536", 65536}};

const std::string key{"1"}

// C++20より、どちらも一時オブジェクトを作成しない
map.contains(key);
map.contains("1024");

map.erase(key);     // 一時オブジェクトを作成しない
map.erase("1024");  // stringの一時オブジェクトが作成される
```

この提案によるオーバロードを有効化する手段は透過的な検索と同様の方法によります。  
順序連想コンテナではその比較を行う関数オブジェクトの型が`is_transparent`というメンバ型を持っていて、渡された型がイテレータ型に変換されない場合に有効になり、非順序連想コンテナではそれに加えてハッシュ関数オブジェクトの型が`is_transparent`というメンバ型を持っていれば有効化されます。

- [非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3), (P1690R1) - cppmap](https://cppmap.github.io/standardization/cpp20/#key_type-p0919r3-p1690r1)
- [P0919R3 Heterogeneous lookup for unordered containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0919r3.html)
- [P2077 進行状況](https://github.com/cplusplus/papers/issues/804)

### [P2138R3 : Rules of Design <=> Specification engagement](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2138r3.html)
### [P2145R1 : Evolving C++ Remotely](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2145r1.html)
### [P2164R2 : views::enumerate](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2164r2.pdf)
### [P2166R1 : A Proposal to Prohibit std::basic_string and std::basic_string_view construction from nullptr](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2166r1.html)
### [P2169R2 : A Nice Placeholder With No Name](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2169r2.pdf)
### [P2192R2 : std::valstat -Transparent Returns Handling](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2192r2.pdf)
### [P2194R0 : The character set of the internal representation should be Unicode](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2194r0.pdf)

C++標準の想定するコンパイル中のC++ソースコードの表現について、ユニコード以外を認める必要が無いという根拠を示す文書。

これはSG16(Unicode Study Group)での議論のために書かれた報告書です。

C++20では、翻訳フェーズ1以降のソースコードの規格的な表現（エンコーディング）はユニコードです。SG16での議論の中で、そこにユニコードのスーパーセットたるエンコーディングを許可しようというアイデアが提出されたらしく、この文書はそのアイデアを採用する根拠がない事を説くものです。

### [P2195R0 : Electronic Straw Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2195r0.html)

委員会での投票が必要となる際に、メールまたは電子投票システムを用いて投票できるようにする提案。

これは標準化のプロセスについてのもので、C++に対する提案ではありません。

コロナウィルスの流行によって対面での会議が行えなくなったため、現在のC++標準化委員会の作業は主に電話会議で行われており、投票が行われる場合も電話会議でリアルタイムに行われていました。

より議論と作業を効率化させるために、この投票を電子メールなどによって非同期的、かつ定期的（四半期ごと）に行うことを提案しています。  
また、CWGやEWGでは現状の体制でも特に問題が無かったため、この提案の対象はLWG/LEWGに絞られています。

他にも、標準化の作業の投票やコンセンサスがどのように決定されるかなどについて詳細に書かれています。

### [P2206R0 : Executors Thread Pool review report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2206r0.html)

Executor提案（[P0443R13](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r13.html)）の`static_thread_pool`周りのレビューの結果見つかった問題についての報告書。

### [P2212R1 : Relax Requirements for time_point::clock](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2212r1.html)
### [P2215R1 : "Undefined behavior" and the concurrency memory model](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2215r1.pdf)
### [P2216R0 : std::format improvements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2216r0.html)

`std::format`の機能改善の提案。

主に、次の二点を改善しようとするものです。

#### コンパイル時にフォーマット文字列をチェックするようにする

C++20の`std::format`では、フォーマットエラーは実行時に`std::format_error`例外を投げることで報告されます。

```cpp
std::string s = std::format("{:d}", "I am not a number");
```

例えばこのコードは、`:d`が通常の文字列に対するフォーマットとして不適切なため、実行時に例外を投げます。  
この提案では、このようなフォーマットのエラーをコンパイル時にコンパイルエラーとして報告することを提案しています。

ただし、言語と実装の特別なサポートなくしてはこのままのコードでコンパイル時のフォーマットチェックを行うことはできません。そのような特別扱いを嫌う場合、ユーザー定義リテラルや静的な文字列型など何かしらの手段が必要となります。

#### `std::vformat_to`のバイナリサイズの削減

[`std::vformat_to`](https://cpprefjp.github.io/reference/format/vformat.html)は[`std::format_to`](https://cpprefjp.github.io/reference/format/vformat_to.html)の引数型を型消去したもので、フォーマット文字列とフォーマット対象を受けとり、任意の出力イテレータにフォーマット済み文字列を出力します。主に`format`ライブラリの内部で使用されるものです。

次のように宣言されています。

```cpp
template<class Out, class charT>
using format_args_t = basic_format_args<basic_format_context<Out, charT>>;

template<class Out>
Out vformat_to(Out out, string_view fmt,
                 format_args_t<type_identity_t<Out>, char> args);
```

ここで問題となるのは、第二引数の型`format_args_t<type_identity_t<Out>, char>`が出力イテレータ型`Out`に依存していることによって、異なる`Out`毎に個別の[`format_args_t`](https://cpprefjp.github.io/reference/format/basic_format_args.html)がインスタンス化されてしまい、コードサイズが肥大化する原因となることです。これはフォーマットしない引数型に対しても引き起こされうるので、使用しないものに対して余計なコストを支払うことになりかねません。  
また、`std::format/vformat`は内部バッファを介してイテレータ型を型消去しており、同じ方法をとればこの特殊化は必要ありません。

そこで、シグネチャを次のように変更することを提案しています。

```cpp
template<class Out>
Out vformat_to(Out out, string_view fmt, format_args args);
```

`format_args`はあらかじめ定義されているイテレータ型を型消去し引数を保持しておくものです。これによって、`std::format/vformat`と同様の方法でイテレータ型の型消去を行うようになり、不要なテンプレートのインスタンス化を防ぐことができます。

なお、これらの事は明らかにC++20の`<format>`ライブラリに対する破壊的変更となりますが、`<format>`は現在のところ誰も実装していないので壊れるコードは無い、と筆者の方は述べています（個人的にはDRにしてほしい気持ちです・・・）。

- [P2216 進行状況](https://github.com/cplusplus/papers/issues/919)

### [P2217R0 : SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2217r0.html)

SG16（*Unicode Study Group*）の会議の議事録の要約。

### [P2218R0 : More flexible optional::value_or()](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2218r0.pdf)

`std::optional`の`value_or()`メンバ関数をベースとした、利便性向上のための新しいメンバ関数を追加する提案。

`value_or()`メンバ関数は`std::optional`が有効値を保持していればその値を返し、無効値を保持している場合は指定された値を代わりに（`std::optional`の要素型に変換して）返すものです。  
`value_or()`関数は有効値からのフォールバックという性質上、多くの場合その型のデフォルト値が使用されます。その場合リテラルを持つ組み込み型ならばあまり困る事も無いのですが、コンストラクタを持つユーザー定義型では意図通りにならない事があります。

例えば`std::optional<std::string>`の`value_or`で`std::string`のデフォルト値（空文字列）を返そうとしてみると

```cpp
std::optional<int> oi{};
std::optional<bool> ob{};
std::optional<std::string> os{};

// 無問題、意図通り  
std::cout << oi.value_or(0) << std::endl;
std::cout << ob.value_or(false) << std::endl;

// 実行時エラー
std::cout << os.value_or(nullptr) << std::endl;
// パフォーマンス的に最適ではない
std::cout << os.value_or("") << std::endl;
// コンパイルエラー
std::cout << os.value_or({}) << std::endl;
// 正解、でも型名を省略したい
std::cout << os.value_or(std::string{}) << std::endl;
```

特に3番目の様な書き方ができないのがとても不便です。要素型がさらに複雑な型になるとより面倒になります。

この原因は`value_or()`のテンプレートパラメータが要素型とは無関係になっていることにあります。そのため、要素型からの推論を行う事が出来ません。

```cpp
template<typename T>
class optional {

  // おおよそこんな感じの実装になっている
  template<typename U>
    requires (is_copy_constructible_v<T> and is_convertible_v<U&&, T>)
  constexpr T value_or(U&& u) const & {
    return this->has_value() ? this->value() : static_cast<T>(std::forward<U>(u));
  }
};
```

そこで、このテンプレートパラメータ`U`のデフォルト引数として要素型`T`を与えておくことで、`U`を`T`から推論することができるようになります。ただし、`std::optional`の要素型は`const`修飾を行っておくことが可能なので、それは除去しておきます。

```cpp
template<typename T>
class optional {

  // おおよそこのような実装だが、おそらくこのままだとエラーになる
  template<typename U = remove_cv<T>>
    requires (is_move_constructible_v<T> and is_convertible_v<U&&, T>)
  constexpr T value_or(U&& u) const & {
    return this->has_value() ? this->value() : static_cast<T>(std::forward<U>(u));
  }
};
```

これによって、既存の振る舞いを壊すことなく全ての要素型において`value_or({})`の様な呼び出しが出来るようになります。

次に、`value_or()`を発展させて、無効値を保持している場合に指定された引数で要素を構築して返す`value_or_construct()`関数を追加することを提案しています。これは、あくまでその場で構築して返すだけで、その`std::optional`の無効状態を変更するものではありません。

```cpp
std::optional<std::string> os{};

// デフォルト構築したstd::stringを返す
os.value_or_construct();

// 指定した文字列で構築したstd::stringを返す
os.value_or_construct("left value");
```

最後に、`value_or_construct()`をさらに発展させて、構築のための引数の評価を遅延させる`value_or_else()`関数を提案しています。

```cpp
using namespace std::string_literals;
std::optional<std::vector<std::string>> ovs{};

// 呼び出し時点でstd::initializer_list<std::string>が構築される
ovs.value_or_construct({"Hello"s, "World"s});

// 呼び出し時点ではstd::vector<std::string>>は構築されない
// 無効値を保持している場合にのみラムダ式の呼び出しを通して構築される
ovs.value_or_else([]{ return std::vector{"Hello"s, "World"s}; });
```

`value_or_construct()`と`value_or_else()`は一見似通ったもの二見えますが、それぞれ異なる欠点があり使いどころが異なっているため、両方追加することを提案しています。

- [`std::optional::value_or()` - cpprefjp](https://cpprefjp.github.io/reference/optional/optional/value_or.html)
- [P2216 進行状況](https://github.com/cplusplus/papers/issues/921)

### [P2219R0 : P0443 Executors Issues Needing Resolution](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2219r0.pdf)

*Executor*提案（[P0443R13](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r13.html)）のレビューの結果見つかった解決すべき問題点の一覧。

地味に63個も問題があり、これの解決後にさらなるレビューが必要となるので、もう少し時間がかかりそうです・・・

### [P2220R0 : redefine properties in P0443](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2220r0.pdf)
### [P2221R0 : define P0443 cpos with tag_invoke](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2221r0.pdf)
### [P2223R0 : Trimming whitespaces before line splicing](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2223r0.pdf)
### [P2224R0 : A Better bulk_schedule](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2224r0.pdf)
