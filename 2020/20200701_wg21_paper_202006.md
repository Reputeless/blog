# ［C++］WG21月次提案文書を眺める（2020年6月）

文書の一覧
[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-06:embed:cite]

提案文書で採択されたものはありません。全部で28本あります。

[:contents]

### [P1401R3 : Narrowing contextual conversions to bool](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1401r3.html)

`constexpr if`や`static_assert`の引数でのみ、整数型から`bool`型への暗黙の縮小変換を定数式で許可する提案。

現在定数式での整数の暗黙変換では、文脈的な`bool`変換も含めて縮小変換が禁止されており次のようなコードはコンパイルエラーになります。

```cpp
enum Flags { Write = 1, Read = 2, Exec = 4 };

template <Flags flags>
int f() {
  if constexpr (flags & Flags::Exec) // 縮小変換が起きるためコンパイルエラー
  // if constexpr (bool(flags & Flags::Exec)) とするとok
    return 0;
  else
    return 1;
}

int main() {
  return f<Flags::Exec>();  // コンパイルエラー
}
```
```cpp
template <std::size_t N>
class Array {
  static_assert(N, "no 0-size Arrays"); // 縮小変換が起きるためコンパイルエラー
  // static_assert(N != 0); とするとok

  // ...
};

Array<16> a;  // コンパイルエラー
```

一方対応する実行時コードは普通にコンパイルでき、期待通りに動作します。

```cpp
if (flags & Flags::Exec) // ok
  {}

assert(N); // ok
```

このような一貫しておらず直感的ではない挙動を修正するために、`constexpr if`と`static_assert`の条件式に限って、文脈的な`bool`変換時の縮小変換を許可しようというものです。

そもそもこれらの条件式でさえも`bool`への縮小変換が禁止されていたのは、`noexcept`式での縮小変換を禁止した時に巻き込まれてしまったためのようです。関数`f()`の例外仕様が別の関数`g()`と同じ（あるいはそれに従う）場合、`noexcept`を二つ重ねて書きます。しかし、その場合に書き間違えて関数名だけを書いたり、1つにしてしまって`g()`が`constexpr`関数だったりすると思わぬバグを生みます。

```cpp
int f() noexcept(noexcept(g()));  // 書きたいこと、noexcept指定指の中にnoexcept式を書く

int f() noexcept(g);    // 関数ポインタからの暗黙変換、でもこう書きたさもある・・・
int f() noexcept(g());  // 定数評価の結果bool値へ変換されると・・・
```

このような些細な、しかし気づきにくいバグを防ぐために定数式での文脈的な`bool`変換の際は縮小変換を禁止することにしました。しかし、`noexcpet`以外のところではこれによって（最初に上げたような）冗長なコードを書くことになってしまっていました。

この欠陥報告（CWG 2039、C++14）を行ったRichard Smithさんによると、本来は`noexcept`式にだけ適用するつもりで、`static_assert`には表現の改善のみで縮小変換禁止を提案してはいなかったそうですが、その意図に反して両方で縮小変換が禁止されてしまいました。結果、おそらくその文言を踏襲する形で`constexpr if`や`explicit(bool)`にも波及したようです。

- [CWG Issue.2039 Constant conversions to bool](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#2039)

### [P1450R3 : Enriching type modification traits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1450r3.pdf)

型の修飾情報などを操作するためのいくつかの新しいメタ関数の提案。

主に次の2種類のものが提案されています。

- `remove_all_pointers`
- 型に付いている情報をコピーする`copy_*`メタ関数

```cpp
using remove_ptr = std::remove_all_pointers_t<int************>;     // int
using copy_ptr1 = std::copy_all_pointers_t<int***, double>;         // double***
using copy_ptr2 = std::copy_all_pointers_t<int***, double*>;        // double****
using copy_r1 = std::copy_reference_t<int&, double>;                // double&
using copy_r2 = std::copy_reference_t<int&, double&>;               // double&&
using copy_r3 = std::copy_reference_t<int&, double&&>;              // double&
using copy_const1 = std::copy_concst_t<const int, double>;          // const double  
using copy_const2 = std::copy_const_t<const volatile int, double>;  // const double  
using copy_cvr = std::copy_cvref_t<const volatile int&&, double>;   // const volatile double&&
```

この他にも`copy_volatile`とか`copy_extent`、`copy_pointer`などが提案されています。

`copy_*`系メタ関数の引数順は`<From, To>`になっており、全てに`_t`付きのエイリアスが用意されています。また、対象の修飾がコピー先にすでに付いている場合はそれはそのままに追加でコピーする形になり、コピー元に対象の修飾がない場合は何もコピーしません。

筆者の方々の経験からプロクシクラス作成やカスタムオーバーロードセットを構築するツールの実装に有用であった型特性を提案しているそうです。

- [std::remove_all_extents - cpprefjp](https://cpprefjp.github.io/reference/type_traits/remove_all_extents.html)
- [vreverdy/type-utilities - Github](https://github.com/vreverdy/type-utilities)

### [P1467R4 : Extended floating-point types and standard names](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1467r4.html)

C++コア言語/標準ライブラリに拡張浮動小数点型のサポートを追加する提案。

機械学習（特にディープラーニング）では多くの場合それほど高い精度が求められないため、`float`（32bit浮動小数点数）よりもより小さい幅の浮動小数点型（時には整数型）を利用することでその時間的/空間的なコストを抑えることが行われており、それを支援する形でハードウェア（GPU/CPU）やソフトウェア（CUDA/LLVM-IR）でのサポートが充実してきています。

現在のC++には3種類の浮動小数点型だけが定義されておりそれ以外のものは何らサポートがあリません。そのため、拡張浮動小数点型は算術・変換演算子をオーバーロードして組み込み型に近い挙動をするようなクラス型を定義することでサポートされています。しかし、そのような方法は完全ではなく面倒で、効率化のためにインラインアセンブラやコンパイラ固有のサポートが必要とされます。  
これらの問題はユーザー定義のライブラリで解決できるものではなく、コア言語でのサポートが必要です。そして、拡張浮動小数点型が求められる場所ではC++が使用される事が多くこれらの問題を解決するに足る価値（ポータビリティや効率性の向上など）があるので、拡張浮動小数点型の言語/ライブラリサポートを追加しようという提案です。

ただし、現在のところ拡張浮動小数点型のスタンダードとなるものは確定しておらず、将来どれが使われていく（あるいは廃れる）のか予測することは困難であるため、何がいくつ定義されるかは実装定義とされます。そのため、`bfloat16`とか`float16`みたいな具体的な型は提供されませんが、代わりに似た形のエイリアスが実装定義で提供されます。

変更は既存の浮動小数点型の振る舞いを保ったままで追加の浮動小数点型をより安全に利用可能かつ拡張可能である（ハードウェアに依存しない）ようにされています。

- 拡張浮動小数点型は`double`に昇格されない
- 拡張浮動小数点型の関わる暗黙変換では縮小変換を許可しない
    - ただし、定数式では許可される
- 式のオペランドとなっている2つの浮動小数点型を統一する算術型変換（*Usual arithmetic conversions*）では、どちらのオペランドももう片方の型に変換できない場合はill-formed
    - `float, double`等は従来のルール通りにより幅の広い型に自動昇格する

```cpp
float f32 = 1.0;
std::float16_t f16 = 2.0;
std::bfloat16_t b16 = 3.0;

f32 + f16; // OK、f16はfloatに変換可能、結果の型はfloat
f32 + b16; // OK、b16はfloatに変換可能、結果の型はfloat
f16 + b16; // NG、2つの型の間に互換性がなく、どちらの型ももう片方の型に値を変更することなく変換できない

std::float16_t x{2.1};  // OK、2.1は2進浮動小数で表現可能ではないため縮小変換が発生している、定数式なのでok

// <charconv>が使用可能
char out[50]{};
if (auto [ptr, ec] = std::to_chars(out, std::end(out), f16); ec == std::errc{}) {
  std::cout << std::string_view(out, ptr - out) << std::endl;

  std::float16_t outv;
  if (auto [_, ec2] = std::from_chars(out, ptr, outv); ec2 == std::errc{}) {
    std::cout << outv << std::endl;
  }
}

// ユーザー定義リテラルが用意される
using namespace std::float_literals;

// complexも規定される
std::complex<std::bfloat16_t> z = {1.0bf16, 2.0bf16};
```

これら型エイリアスが定義されるヘッダには`<fixed_float>`か`<stdfloat>`という名前を提案しているようですが、筆者の方々はあまり気に入っていないようでより良い名前やふさわしい既存のヘッダを考慮中のようです。いい名前が思いついたらコントリビュートチャンスです。

- [半精度浮動小数点数 - wikipedia](https://ja.wikipedia.org/wiki/半精度浮動小数点数)
- [bfloat16 floating-point format - wikipedia](https://en.wikipedia.org/wiki/Bfloat16_floating-point_format)

### [P1468R4 : Fixed-layout floating-point type aliases](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1468r4.html)

この提案文書は拡張浮動小数点型の既知のレイアウトとその名前についての提案でしたが、今回P1467R4（１つ前のの拡張浮動小数点型に対する提案）にマージされたため、内容は空です。それが行われたことを記しておくために存在しているようです。

### [P1642R3 : Freestanding Library: Easy [utilities], [ranges], and [iterators]](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1642r3.html)

[[utility]](https://timsong-cpp.github.io/cppwp/n4861/#utilities)、`<ranges>`、`<iterator>`から一部のものをフリースタンディングライブラリに追加する提案。

[[utility]](https://timsong-cpp.github.io/cppwp/n4861/#utilities)は範囲が広いですが、ほとんど`pair, tuple`を対象にしています。また、動的メモリ確保を必要としたり例外を送出しうるもの、`iostream`のようにOSのサポートを必要とするものは当然含まれていません。`<utility>, <tuple>, <ratio>`ヘッダの全てと、特筆する所では`std::unique_ptr`や`std::function`のフリースタンディング化が提案されています。

`<ranges>`、`<iterator>`からは`(i|o)stream_iterator`、`(i|o)streambuf_iterator`や`istream_view`等に関わるもの以外の全てを追加することが提案されています。

また、これらのものには機能テストマクロが用意されています。

筆者の方は、`<optional>`や`<variant>`などを今後別の提案で詳細に検討していくつもりのようです。

ライブラリ機能のフリースタンディング化に慎重な検討が必要になるのは、フリースタンディング処理系とホスト処理系とである関数呼び出し時のオーバーロードセットが変化することで暗黙のうちに動作が変わってしまうことを防ぐためです。変わったとしてもちゃんとエラーになるのかや選択されるオーバーロードが変化しないかなどを慎重に検討せねばならないようです。とても大変そうです・・・

- [フリースタンディング処理系とホスト処理系 - cppreference](https://ja.cppreference.com/w/cpp/freestanding)

### [P1944R1 : Add Constexpr Modifiers to Functions in cstring and cwchar Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1944r1.pdf)

`<cstring>`と`<cwchar>`の関数に`constexpr`を追加する提案。

これらのヘッダに定義されている文字列操作関数を`constexpr`にすることを意図しています。ただし、ロケールやグローバルオブジェクトの状態に依存したり、スレッドローカルな作業域を持つような関数は除外しています。また、`std::memcpy`や`std::memmove`などのメモリ操作系の関数も`constexpr`にすることが提案されています。これらは引数に`void`ポインタを取るためそのままだと定数式で使えないのですが、コンパイラマジックにより定数式で使用可能にしてもらうようです。

`<cstring>`と`<cwchar>`はC++として独自実装している処理系とCのコードを流用している処理系が存在しているようですが、前者はそのまま`constexpr`を付加し、後者はコンパイラの特別扱いによってABIを破損することなく`constexpr`対応できるだろうということです。

- [Neargye/cstring-constexpr-proposal - GitHub](https://github.com/Neargye/cstring-constexpr-proposal)

### [P1949R4 : C++ Identifier Syntax using Unicode Standard Annex 31](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1949r4.html)

識別子（*identifier*）の構文において、不可視のゼロ幅文字や制御文字の使用を禁止する提案。

前回の記事を参照
[https://onihusube.hatenablog.com/entry/2020/05/01/194425#P1949R3--C-Identifier-Syntax-using-Unicode-Standard-Annex-31:embed:cite]

前回（R3）との変更点は文書にSummaryが追加されたことと、提案する字句トークン（プリプロセッシングトークン）のEBNF定義の修正だけのようです。

この提案はすでにCWGでの文言レビューを待つだけになっており、C++23に導入される可能性は高いです。その場合、C++においては識別子（クラス・変数・関数等の名前）に絵文字を使用できなくなります（欠陥報告になる可能性があるので以前のバージョンも含めて）。

- [P1949 進行状況](https://github.com/cplusplus/papers/issues/688)

### [P1990R1 : Add `operator[]` to `std::initializer_list`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1990r1.pdf)
### [P2025R1 : Guaranteed copy elision for return variables](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2025r1.html)
### [P2034R2 : Partially Mutable Lambda Captures](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2034r2.pdf)
### [P2037R1 : String's gratuitous assignment](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2037r1.html)
### [P2093R0 : Formatted output](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2093r0.html)
### [P2138R2 : Rules of Design<=>Wording engagement](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2138r2.html)
### [P2139R1 : Reviewing Deprecated Facilities of C++20 for C++23](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2139r1.html)
### [P2141R0 : Aggregates are named tuples](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2141r0.html)
### [P2146R1 : Modern std::byte stream IO for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2146r1.pdf)
### [P2152R0 : Querying the alignment of an object](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2152r0.pdf)
### [P2161R1 : Remove Default Candidate Executor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2161r1.pdf)
### [P2164R1 : views::enumerate](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2164r1.pdf)
### [P2166R0 : A Proposal to Prohibit `std::basic_string` and `std::basic_string_view` construction from `nullptr`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2166r0.html)
### [P2176R0 : A different take on inexpressible conditions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2176r0.html)
### [P2178R0 : Misc lexing and string handling improvements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2178r0.pdf)
### [P2179R0 : SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2179r0.html)
### [P2181R0 : Correcting the Design of Bulk Execution](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2181r0.html)
### [P2182R0 : Contract Support: Defining the Minimum Viable Feature Set](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2182r0.html)
### [P2184R0 : Thriving in a crowded and changing world: C++ 2006-2020](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2184r0.pdf)
### [P2185R0 : Contracts Use Case Categorization](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2185r0.html)
### [P2188R0 : Zap the Zap: Pointers should just be bags of bits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2188r0.html)


### 次

7月半ば

[この記事のMarkdownソース](https://github.com/onihusube/blog/blob/master/2020/20200701_wg21_paper_202006.md)