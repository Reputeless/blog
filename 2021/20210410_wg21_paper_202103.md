# ［C++］WG21月次提案文書を眺める（2021年03月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2021 mailing2021-03](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/#mailing2021-03)

全部で36本あり、SG22（C/C++相互互換性に関する研究グループ）のCの提案を除くと32本になります。

[:contents]

## 採択された文書

### [P2313R0 Core Language Working Group "tentatively ready" issues for the February, 2021 meeting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2313r0.html)

2月の会議で採択されたコア言語のIssue解決の一覧。

解決されたIssueは一件だけです。

1. [2470. Multiple array objects providing storage for one object](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#2470)
      - `unsigned char/std::byte`の配列上に別のオブジェクトを構築する時、新しく作成されるオブジェクトにどの配列がストレージを提供したのかが曖昧にならないようにした。

## その他文書

### [N4884 WG21 2021-02 Virtual Meeting Minutes of Meeting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/n4884.pdf)

2021年2月22日（米国時間）に行われた、WG21全体会議の議事録。

CWG/LWG/LEWGの投票の様子などが記載されています。

### [N4885 Working Draft, Standard for Programming Language C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/n4885.pdf)

C++23ワーキングドラフト第4弾。

### [N4886 Editors’ Report - Programming Languages - C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/n4886.html)

↑の変更点をまとめた文書。

2月の会議で採択された提案とコア言語/ライブラリのIssue解決が適用されています。

### [P0448R4 A strstream replacement using span as buffer](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0448r4.pdf)
### [P0958R3 Networking TS changes to support proposed Executors TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0958r3.html)
### [P1018R9 C++ Language Evolution status - pandemic edition - 2021/01–2021/03](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1018r9.html)
### [P1315R7 secure_clear](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1315r7.html)
### [P1425R4 Iterators pair constructors for stack and queue](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1425r4.pdf)
### [P1518R1 Stop overconstraining allocators in container deduction guides](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1518r1.html)

↓

### [P1518R2 Stop overconstraining allocators in container deduction guides](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1518r2.html)

コンテナとコンテナアダプタのクラステンプレート引数推論時の振る舞いを修正し、`pmr`コンテナの初期化を行いやすくする提案。

```cpp
std::pmr::monotonic_buffer_resource mr;
std::pmr::polymorphic_allocator<int> a = &mr;
std::pmr::vector<int> pv(a);

// CTADを使用しない構築、全てok
auto s1 = std::stack<int, std::pmr::vector<int>>(pv);
auto s2 = std::stack<int, std::pmr::vector<int>>(pv, a);
auto s3 = std::stack<int, std::pmr::vector<int>>(pv, &mr);

// CTADを使用する構築
auto ds1 = std::stack(pv);
auto ds2 = std::stack(pv, a);
auto ds3 = std::stack(pv, &mr); // NG!
```
[[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ](https://wandbox.org/permlink/PDyRONeSAYdBB4jD)

※CTAD = Class Template Argument Deduction (クラステンプレートの実引数推定)

`stack`をはじめとするコンテナアダプタのアロケータ引数は、クラステンプレートのテンプレートパラメータの推論に寄与しません。従って、対応するCTADを使用しない構築の時と同様にコンテナ型からの推論を行うのが望ましいはずです。

```cpp
namespace std {

  template<typename Container, typename Allocator>
  class stack;

  // stackの2引数推論補助
  template<class Container, class Allocator>
  stack(Container, Allocator)
    -> stack<typename Container::value_type, Container>;
}
```

このことは何か意図があってのものではなく、単に見落とされただけだと思われるので修正しようとする提案です。

なぜこのようなことが起こるのかというと、コンテナアダプタの推論補助について次のような規定が存在しているためです。

> A deduction guide for a container adaptor shall not participate in overload resolution if any of the following are true: 
> - ...
> - It has an Allocator template parameter and a type that does not qualify as an allocator is deduced for that parameter.
> - ...

[[N4861 container.adaptors.general]/4.4](https://timsong-cpp.github.io/cppwp/n4861/container.adaptors.general#4.4)

アロケータとしての資格のない型がアロケータ型として渡されている場合、そのアロケータ型がテンプレートパラメータの推論に寄与しないとしても、アロケータ型を受け取る推論補助を無効化してしまいます。

アロケータとしての資格がある型というのは実装定義ですが、最小の要件の一つとして、アロケータ型`A`についてメンバ型`A::value_type`が利用可能であることがあります（[[container.requirements.general]/17](https://timsong-cpp.github.io/cppwp/n4861/container.requirements.general#17)）。

```cpp
auto ds3 = std::stack(pv, &mr); // NG!
```

先程の例のここでは、第二引数の`&mr`の型は`std::pmr::monotonic_buffer_resource*`というポインタ型であって、当然メンバ型を持っておらず、アロケータとしての資格がある型ではないため対応する推論補助は考慮されなくなります。ただ一方で、`std::pmr::vector<int>`は`std::pmr::monotonic_buffer_resource*`をアロケータとして利用して構築することができます。

さらに、似た問題が`std::vector`そのものにも存在しています。

```cpp
std::pmr::monotonic_buffer_resource mr;
std::pmr::polymorphic_allocator<int> a = &mr;
std::pmr::vector<int> pv(a);

// CTADによらない構築、全てok
auto v1 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv);
auto v2 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv, a);
auto v3 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv, &mr);

// CTADを使用する構築
auto dv1 = std::vector(pv);
auto dv2 = std::vector(pv, a);
auto dv3 = std::vector(pv, &mr);  // NG!
```

ここでの問題は先ほどとは少し違っていて、暗黙に生成される推論補助を利用する経路で問題が起きています。

推論補助が無い場合、対応するコンストラクタから推論補助を生成してテンプレートパラメータを推論しようとします。ここで対応しているコンストラクタはアロケータを受け取るコピーコンストラクタです。

```cpp
namespace std {

  template<typename T, typename Allocator>
  class vector {

    // アロケータを受け取るコピーコンストラクタ
    vector(const vector<T, Allocator>&, const Allocator&);
  };
}
```

そして、第1引数からは`T = int, Allocator = std::polymorphic_allocator<int>`が導出され、第2引数からは`Allocator = std::pmr::monotonic_buffer_resource*`が導出されます。同一のパラメータに対して衝突する候補が発生しているので、推論は失敗しコンパイルエラーとなります。

この提案ではこれらの解決のために、すべてのコンテナのアロケータを受け取るコンストラクタ引数を`std::type_identity_t`で包むことでアロケータ引数をCTAD推論の対象から外し、またコンテナアダプタのアロケータ型がある場合の推論補助の要件を「コンテナ型が無く、アロケータ型がある場合」のように少し緩和します。

```cpp
namespace std {

  template<typename T, typename Allocator>
  class vector {

    // 現在
    vector(const vector<T, Allocator>&, const Allocator&);

    // この提案
    vector(const vector<T, Allocator>&, const type_identity_t<Allocator>&);
  };
}

void stack() {
  std::pmr::monotonic_buffer_resource mr;
  std::pmr::polymorphic_allocator<int> a = &mr;
  std::pmr::vector<int> pv(a);

  // この提案の後では、共にOK
  auto ds3 = std::stack(pv, &mr);
  auto dv3 = std::vector(pv, &mr);
}
```

`std::vector`の場合は、`std::type_identity_t`によって第2引数の`&mr`から`Allocator`パラメータを推論しなくなるので`Allocator`が一つに定まるようになり、`std::stack`の場合は文言の変更によって`&mr`から推論されるアロケータ型の適格性がチェックされなくなるので既存の推論補助によって正しく推論が行われるようになります。

この提案の内容は標準ライブラリの主要な3実装がそれぞれ、*誤って* 先行して実装しているようです。特に連想コンテナはMSVCとClang（と一部GCCも）すでにこうなっているようです。

- [`std::stack` 推論補助 - cpprefjp](https://cpprefjp.github.io/reference/stack/stack/op_deduction_guide.html)
- [`std::type_identity` - cpprefjp](https://cpprefjp.github.io/reference/type_traits/type_identity.html)
- [テンプレート引数として使用するtype_identity_tはなんのため？ - cpprefjp/site - Github](https://github.com/cpprefjp/site/issues/829)
- [P1518 進行状況](https://github.com/cplusplus/papers/issues/381)

### [P1875R2  Transactional Memory Lite Support in C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1875r2.pdf)
### [P2025R2 Guaranteed copy elision for return variables](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2025r2.html)
### [P2041R1 template = delete](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2041r1.html)
### [P2066R6 Suggested draft TS for C++ Extensions for Minimal Transactional Memory](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2066r6.html)
### [P2093R5 Formatted output](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2093r5.html)
### [P2210R2 Superior String Splitting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2210r2.html)
### [P2242R2 Non-literal variables (and labels and gotos) in constexpr functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2242r2.html)
### [P2266R1 Simpler implicit move](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2266r1.html)
### [P2299R0 `mdspan` and CTAD](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2299r0.html)

提案中の`std::mdspan`のCTAD対応についての問題を報告する文書。

[P0009R10](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0009r10.html)で提案されている`std::mdspan`は、`std::basic_mdspan`を基礎として、そのエイリアスとして`std::mdspan`を定義しています。

```cpp
template <class ElementType, ptrdiff_t... Extents>
using mdspan = basic_mdspan<ElementType, extents<Extents...>>;
```

これは例えば次のように利用できます

```cpp
int main() {
  // 何かメモリ領域
  double* data = ...;

  // 静的サイズ
  mdspan<double, 64, 64> a1(data);
  // 動的サイズ
  mdspan<double, dynamic_extent, dynamic_extent> a2(data, 64, 64);
  // 静的+動的サイズ
  mdspan<double, 64, dynamic_extent> a3(data, 64);
}
```

C++20からはエイリアステンプレートに対するCTADが利用可能となっているので、上記の2つめの例は次のように書けるはずです。

```cpp
int main() {
  // 何かメモリ領域
  double* data = ...;

  // 動的サイズ
  mdspan a2(data, 64, 64);
}
```

冗長な`dynamic_extent`指定を排除し非常に読みやすくなります。しかし、これはどうやら意図通りに動かないようです。

ここでは、`std::mdspan<double>`を推論した後、`std::basic_mdspan<double, extents<>>`を推論しインスタンス化します。これは`std::basic_mdspan`の動的エクステントのコンストラクタで`static_assert`に引っかかりコンパイルエラーを起こします。

単純には、`std::mdspan`に推論補助を追加すればこの問題の解決は図れるはずですが、現在の仕様ではエイリアステンプレートに推論補助を追加できません。かといって、`std::mdspan`を単独のクラスにしてしまうと`std::basic_mdspan`との相互運用性がなくなるなど様々な問題が発生します。

この提案はこの問題の周知を図り、よりよい解決策を募るものです。

- [P0009R10 MDSPAN](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0009r10.html)
- [P2299 進行状況](https://github.com/cplusplus/papers/issues/1009)

### [P2314R1 Character sets and encodings](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2314r1.html)
### [P2322R1 ranges::fold](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2322r1.html)
### [P2325R1 Views should not be required to be default constructible](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r1.html)
### [P2328R0 join_view should join all views of ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2328r0.html)

`std::ranges::join_view`の制約を緩和して、*prvalue*の`view`ではない`range`を平坦化できるようにする提案。

`join_view`は`range`の`range`となっているシーケンスを1つの`range`に平坦化するもので、他のところでは`flatten`とも呼ばれています。

ここに1つ機能を加えて、要素（内側の`range`）を変換しつつ平坦化する`flat_map`というものがあります。そのまま書くと、C++20時点では次のようになるはずです。

```cpp
template<std::ranges::range R, std::invocable<std::ranges::range_value_t<R>> F>
  requires std::ranges::range<std::ranges::range_value_t<R>> and
           std::ranges::range<std::invoke_result_t<F, R>>
auto flat_map(R&& r, F&& f) {
  return r | std::views::transform(f) | std::views::join;
}
```

このような`range`アダプタのチェーンはほとんどの場合にコンパイルエラーとなります。

現在の`join_view`が平坦化できるのは次の2つのどちらかです。

- *glvalue*な`range`の`range`
- *prvalue*な`view`の`range`

`r | std::views::transform(f)`の結果は`f`の結果の`range`による*prvalue*な`view`となり、`f`の結果の`range`が*prvalue*な`view`とならない場合にコンパイルエラーとなります。少し考えてみると、これはかなり一般的なユーズケースであることがわかると思います（`f`の結果として範囲を返すとき、`std::vector`を使いたくなりませんか？）。

現在の`join_view`に*prvalue*な（`view`ではない）`range`の`range`サポートが欠けていることによってこの問題は発生しています。

Range-v3ライブラリでは、`views::cache1`（提案されている名前は`views::cache_latest`）という`view`を間に挟むことでこの問題を解決し、`views::flat_map`を導入しています。

`cache1`は元の`range`のイテレータの間接参照結果をキャッシュとして持っておくことによって、*prvalue*な`range`の`range`を*glvalue*な`range`の`range`に変換するものです。これによって`join_view`はあらゆるケースで平坦化できるようになります。

ただ、`cache1`（`cache_latest`）にはいくつかの問題があります

- イテレータの`operator*() const`（`std::indirectly_readble`コンセプトで要求される）は内部でキャッシュを操作するため、スレッドセーフではない。
    - 標準ライブラリの`const`メンバ関数はスレッドセーフであることを表明している。
- `cache1`の理解や発見は自明ではない。
    - なぜそれが必要なのかのヒントはなく、`join_view`の使用を通してその存在の必要性を納得するしかない。

現在の`join_view`は、*prvalue*な`view`の`range`を処理する際に、内側の*prvalue*な`view`を内部でキャッシュしておくことによって処理しています。この提案では、`cache_latest`を導入する代わりに、このキャッシュ機構を*prvalue*な（`view`ではない）`range`の`range`に対しても行うことで上記の問題の解決を図ります。

ただし、この場合のキャッシュは伝播しません。すなわち、そのようなキャッシュを保持している`join_view`をコピー/ムーブすると、コピー/ムーブ先ではキャッシュは空となります。これによって、`join_view`のコピー/ムーブが元の`range`の生成するものに依存しないことが保証されています。また、このようなキャッシュをしている場合の`join_view`は`input_range`であり、`begin()`の呼び出しは1度しか行えません（最初の`begin()`の呼び出し後に`range`として使用不可能となる）。

- [［C++］ <ranges>のviewを見る12 - join_view - Zenn](https://zenn.dev/onihusube/articles/42b5465e778cee595f76)
- [P2328 進行状況](https://github.com/cplusplus/papers/issues/1008)

### [P2330R0 WG21 2021-02 Virtual Meeting Record of Discussion ](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2330r0.pdf)

2月のWG21本会議における発言記録。

コア言語に関して

- 昨年11月の本会議で採択された[P2238R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2238r0.html)にあるコア言語IssueがC++20に対する*Defect Report*(DR)として扱うことを決定。
- [P1787R6](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1787r6.html)の内容をDRとして扱うことを決定（バージョンは指定されていない）。
- [P2313R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1787r6.html)の内容をDRとして扱うことを決定（バージョンは指定されていない）。

ライブラリ機能に関しては[P0533R7 constexpr for `<cmath>` and `<cstdlib>`（リンクはR）](http://open-std.org/JTC1/SC22/WG21/docs/papers/2020/p0533r6.pdf)がリジェクトされた過程が記載されています。

それによれば、精度低下によるエラーが定数評価を妨げる可能性があるという問題提起があり、その解決策について十分に議論が尽くされておらず、このままだと実装が困難となるか実装間で相違が発生する可能性があるという点が懸念され、投票の結果反対および中立が多く出たため、リジェクトされたようです。

### [P2332R0 Establishing std::hive as replacement name for the proposed std::colony container](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2332r0.html)
### [P2333R0 2021 Winter Library Evolution Poll Outcomes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2333r0.html)
### [P2334R0 Add support for preprocessing directives elifdef and elifndef](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2334r0.pdf)
### [P2338R0 Freestanding Library: Character primitives and the C library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2338r0.html)
### [P2339R0 Contract violation handlers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2339r0.html)
### [P2340R0 Clarifying the status of the ‘C headers’](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2340r0.html)
### [P2400R0 Library Evolution Report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2400r0.html)