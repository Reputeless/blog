# ［C++］WG21月次提案文書を眺める（2022年01月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2022-01](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/#mailing2022-01)

全部で52本あります（SG22のWG14からのものは除きます）。

[:contents]

### [P0447R18 Introduction of std::hive to the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0447r18.html)

要素が削除されない限りそのメモリ位置が安定なコンテナである`std::hive`（旧名`std::colony`）の提案。

以前の記事を参照

- [P0447R11 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2020年12月）](https://onihusube.hatenablog.com/entry/2020/12/06/015108#P0447R11-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R12 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2021年01月）](https://onihusube.hatenablog.com/entry/2021/02/11/153333#P0447R12-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R13 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P0447R13-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R14 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2021年05月）](https://onihusube.hatenablog.com/entry/2021/06/13/165215#P0447R14-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R15 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P0447R15-Introduction-of-stdhive-to-the-standard-library)
- [P0447R16 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2021年09月）](https://onihusube.hatenablog.com/entry/2021/10/03/193523#P0447R16-Introduction-of-stdhive-to-the-standard-library)
- [P0447R17 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P0447R17-Introduction-of-stdhive-to-the-standard-library)

このリビジョンでの変更は、`<=>`を追加したこと、標準ライブラリ内外のコンテナ選択ガイドをapendixに追加したこと、提案する文言の改善、などです。

- [P0447 進行状況](https://github.com/cplusplus/papers/issues/328)

### [P0792R6 function_ref: a non-owning reference to a Callable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0792r6.html)

*Callable*を所有しない`std::function`である`std::function_ref`の提案。

C++において高階関数（関数を受け取る/返す関数）を書くときに、既存の関数（*Callable*）を参照したいことがよくあります。しかし、現在の標準ライブラリにはそのために使用できる効果的なものがありません。既存のユーティリティには以下の3つがあります

- 関数ポインタ
    - 参照するものがステートレスである場合にのみ使用可能。また、メンバ関数ポインタやメンバ変数ポインタを処理しなければならない
- `std::function`
    - 格納する*Callable*を所有するため、意図しないオーバーヘッドが発生しうる
    - 所有権が必要ない場合には不適格
- テンプレート
    - 特定のシグネチャに制約するのが難しく、ヘッダにコードを書かなければならない

特定の*Callablel*を単に参照したいだけの場合に最適なものが現在のC++には欠けており、`std::function_ref`はそのギャップを埋めるためのユーティリティです。`std::function_ref`はその名前の通り受け取った*Callable*を所有せず参照し、なおかつ`std::function`とほぼ同等のインターフェースと型消去を提供します。

`std::function_ref`は特に、関数の引数で任意の*Callablel*を受け取りたい場合に有用です。例えば次のような関数を書くとき

```cpp
struct payload { /* ... */ };

// times回までactionを繰り返す
// actionが有効なpayloadを返したときはそこで終了
// それ以外の場合はnulloptを返す
std::optional<payload> retry(std::size_t times, /* ????? */ action);
```

この`/* ????? */`の部分には前述のいくつかの書き方があります

```cpp
// 関数ポインタ
// 利点 : 実装が簡単で追加の制約が必要なく、オーバーヘッドも最小（コンパイラは呼び出しをインライン化できるはず）
// 欠点 : ステートフルなCallableを扱えない
std::optional<payload> retry(std::size_t times,
                             std::optional<payload>(*action)())
{
    /* ... */
}

// std::function
// 利点 : ステートフルも含めて、指定したシグネチャに合う任意のCallableを受け取れる
// 欠点 : 所有権が不明瞭（reference_wrapperを使用している可能性がある）、大きなオーバーヘッドを発生させうる（動的割り当て、分岐、例外、インライン化困難）
std::optional<payload> retry(std::size_t times,
                             std::function<std::optional<payload>()> action)
{
    /* ... */
}

// テンプレート
// 利点 : ステートフルも含めて任意のCallableを受け取れる、オーバーヘッドがない
// 欠点 : 実装しづらく読みづらい（enable_ifやis_invocableによる制約周り）、ヘッダに書かざるを得ない
template <typename F>
auto retry(std::size_t times, F&& action)
    -> std::enable_if_t<std::is_invocable_r_v<std::optional<payload>, F&&>,
                        std::optional<payload>>
{
    /* ... */
}
```

`std::function_ref`はこれらのいいとこ取りをするもので、次のように使用できます

```cpp
// function_ref
template <typename F>
auto retry(std::size_t times, std::function_ref<std::optional<payload>()> action)
{
    /* ... */
}
```

使用感は`std::fucntion`と同様で、`std::fucntion`のメリットをそのまま享受でき、所有権は明確（所有していない）です。オーバーヘッドに関しては関数ポインタとほぼ同等であり、コンパイラによるインライン展開を期待できます。また、`std::function_ref`は空の状態がないため呼び出し時のnullチェックが不要で、`target_type`などのRTTIが必要なインターフェースも持ちません。

他にも、`std::function_ref`は`std::move_only_function`と同様に`const, noexcept`を指定することができます。

```cpp
struct A {
  int operator()() const noexcept { return 1; }
  int operator()() { return 2;}
} obj;

function_ref<int() const noexcept> fr = obj;
fr();  // 1
```

この提案は、C++23を目指してLWGでのレビュー中です。

- [P0792 進行状況](https://github.com/cplusplus/papers/issues/866)

### [P1018R14 C++ Language Evolution status 🦠 pandemic edition 🦠 2021/09–2022/01](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1018r14.html)

2021年9月から2022年1月の間のEWGの活動についてのレポート。

2022年1月末までにEWGの電子投票にかけられる提案は以下のものです

- [P2280R3 Using unknown references in constant expressions](https://wg21.link/P2280R3)
- [P2468R1 The Equality Operator You Are Looking For](https://wg21.link/P2468R1)
- [P2327R1 De-deprecating volatile compound operations](https://wg21.link/P2327R1)
- [P2266R2 Simpler implicit move](https://wg21.link/P2266R2)
- [P1467R8 Extended floating-point types and standard names](https://wg21.link/P1467R8)
- [P2350R2 constexpr class](https://wg21.link/P2350R2)
- [P1169R3 static operator()](https://wg21.link/P1169R3)
- [P1774R5 Portable assumptions](https://wg21.link/P1774R5)
- [P1494R2 Partial program correctness](https://wg21.link/P1494R2)
- [P2448R0 Relaxing some constexpr restrictions](https://wg21.link/P2448R0)
- [P2437R0 Support for #warning](https://wg21.link/P2437R0)
- [P2324R1 Labels at the end of compound statements (C compatibility)](https://wg21.link/P2324R1)
- [P2071R1 Named universal character escapes](https://wg21.link/P2071R1)
- [P2295R5 Support for UTF-8 as a portable source file encoding](https://wg21.link/P2295R5)
- [P2290R2 Delimited escape sequences](https://wg21.link/P2290R2)
- [P2362R3 Remove non-encodable wide character literals and multicharacter wide character literals](https://wg21.link/P2362R3)
- [P2348R2 Whitespaces Wording Revamp](https://wg21.link/P2348R2)

これらの提案は全て、C++23に導入するべくEWGからCWGへ転送するための最終確認の投票にかけられています。特に、最初の3つとP2448R0はDRです。

C++23に向けたEWGの活動としてはあとはコア言語Issueの解決のみで、おそらくこれ以上コア言語に対する機能追加がC++23に対して行われることはなさそうです。

### [P1083R4 Move `resource_adaptor` from Library TS to the C++ WP](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1083r4.pdf)

`pmr::resource_adaptor`をLibrary Foundermental TSからワーキングドラフトへ移動する提案。

`pmr::resource_adaptor`は任意のアロケータを`memory_resource`のインターフェースにアダプトさせるものです。これによって、`std::pmr::polymorphic_allocator`で任意のアロケータをより簡易に利用できるようになります。

```cpp
template<typename Alloc>
class resource_adaptor_impl : std::memory_resource {
  // ...
};

template<typename Alloc>
using resource_adaptor = resource_adaptor_impl<typename std::allocator_traits<Allocator>::template rebind_alloc<char>>;
```

この`resource_adaptor_impl`のようなものは説明専用のクラスとして指定されているため、実際にはこの名前ではありません。これは例えば次のように使用します

```cpp
// オレオレアロケータ
class my_allocator;

int main() {
  std::pmr::resource_adaptor<my_allocator> mr{};

  std::pmr::polymorphic_allocator<> pmralloc{&mr};
}
```

`pmr::resource_adaptor`がない場合、`my_allocator`をラップして`memory_resource`にアダプトするようなクラスを手書きする必要がありました。

`polymorphic_allocator`はアロケータカスタマイズポイントとして便利であるため、今後テンプレートパラメータでアロケータを取る代わりに利用されることが増えていくと思われます。そこにアロケータを渡すには、それがすでに`polymorphic_allocator`そのものであるか`memory_resource`にアダプトされている必要があります。`resource_adaptor`は後者のケースのヘルパとなるユーティリティであり、これがあることで`polymorphic_allocator`の利用がより促進されます。また、`resource_adaptor`は長期間Library Foundermental TSに存在しており、その実装は安定しているためワーキングドラフトへの導入の敷居も低いと思われるます。この提案はこれらの理由から`resource_adaptor`の標準入りを目指すものです。

ただし、この提案ではアライメント指定周りの設計が少し変更されています。`memory_resource`の`.do_allocate()`（および`.do_deallocate()`）では第二引数にアライメント指定を受け取ります。`resource_adaptor`がラップしているアロケータに正しくこのアライメント指定を伝達するには、そのアライメント指定に沿ったアライメントを持つ別の型`U`で元のアロケータを`rebind`することですが、`.do_allocate()`にはアライメント指定が実行時に渡ってきます。そのため、`resource_adaptor::do_allocate()`では、可能なアライメント指定毎にそのアライメントを持つ型を求めてそれによって元のアロケータを`rebind`してから`allocate()`を呼び出します。

```cpp
template<typename Alloc>
class resource_adaptor_impl : std::memory_resource {
  Alloc m_alloc;

  // ...

  void* do_allocate(std::size_t bytes, std::size_t alignment) override {
    // alignmentは2のべき乗の値だけを考慮する
    // alignmentの値毎に適切な型Uでrebindする
    switch(alignment) {
      case 4 :
        {
          using U = int32_t;
          const std::size_t n = (bytes + sizeof(U) - 1) / sizeof(U);
          return allocator_traits<Alloc>::template rebind_traits<int32_t>::allocate(m_alloc, n);
        }
      case 8 :
        {
          using U = int64_t;
          const std::size_t n = (bytes + sizeof(U) - 1) / sizeof(U);
          return allocator_traits<Alloc>::template rebind_traits<int32_t>::allocate(m_alloc, n);
        }
      case 16 :
        ...
      case 32 :
        ...
      case 64 :
      ...
      default : assert(false);
    };

  }
};
```

おおよそこのような実装が行われるらしいですが、この実装は明らかに余計なテンプレートの実体化を伴うため、コードの肥大化やコンパイル時間の増大といった問題があります。それはどうしようもないですが、せめて考慮すべき数を減らすためにこの提案の`resource_adaptor`は第二テンプレート引数にこのアライメントの最大値を指定できるように修正されています。この最大値によって上記のようなコード生成の上限を指定します。

また、上記例では`U`に`int32_t`などを使用しましたがこれも適切ではなく、この指定したアライメントを持つ`U`を求めるための`aligned_raw_storage<Align, Size>`（オーバーアラインされる場合の`U`を求める）、`aligned_type<Align>`（オーバーアラインされない場合に`U`として適切なスカラ型を指定する）、`aligned_object_storage<T>`（`T`について`aligned_raw_storage<sizeof(T), sizeof(T)>`を求め、ストレージとして利用しやすくするヘルパ型）といった型特性クラスも同時に提案されています

- [`std::experimental::pmr::resource_adaptor` - cppreference](https://en.cppreference.com/w/cpp/experimental/resource_adaptor)
- [P1083 進行状況](https://github.com/cplusplus/papers/issues/33)

### [P1206R7 Conversions from ranges to containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1206r7.pdf)

任意の*range*をコンテナへ変換/実体化させるための`std::ranges::to`の提案。

- [P1206R2 ranges::to: A function to convert any range to a container - ［C++］WG21月次提案文書を眺める（2020年10月）](https://onihusube.hatenablog.com/entry/2020/11/02/221657#P1206R2-rangesto-A-function-to-convert-any-range-to-a-container)
- [P1206R3 ranges::to: A function to convert any range to a container - ［C++］WG21月次提案文書を眺める（2020年11月）](https://onihusube.hatenablog.com/entry/2020/12/06/015108#P1206R3-rangesto-A-function-to-convert-any-range-to-a-container)
- [P1206R4 Conversions from ranges to containers - ［C++］WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P1206R4-Conversions-from-ranges-to-containers)
- [P1206R6 Conversions from ranges to containers - ［C++］WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P1206R6-Conversions-from-ranges-to-containers)

このリビジョンでの変更は、全体的なtypoの修正と、提案する文言の改善です。

この提案は、2月の全体会議に投票にかけられ、C++23WD入りが決定しています。

- [P1206 進行状況](https://github.com/cplusplus/papers/issues/145)

### [P1240R2 Scalable Reflection](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1240r2.pdf)

値ベースの静的リフレクションの提案。

現在のReflection TS（N4766）はテンプレートメタプログラミングとの親和性を意識して型ベースのリフレクションとして設計されています。そこでは、`reflexpr()`という構文によって任意のエンティティからメタ情報を型として抽出し、各種traits型によってそれを処理します。

```cpp
#include <reflect>

// 型名を取得する
template <typename T>
std::string get_type_name() {
  namespace reflect = std::experimental::reflect;
  
  // T（テンプレートパラメータ）のメタ情報を取得
  using T_t = reflexpr(T);

  // テンプレートパラメータから元の型のメタ情報を得る
  using aliased_T_t = reflect::get_aliased_t<T_t>;

  // Tの元の型名をstringで取得
  return reflect::get_name_v<aliased_T_t>;
}
```

このような型ベースリフレクションはTMPの文脈では扱いやすいものですが`constexpr`の文脈においては扱いづらく、静的リフレクションで得たメタ情報からコード生成をする処理などが書きづらくなります。そこで、`constexpr`と親和性の高い値ベースのリフレクションが提案され（P0425R0）、SG7(Reflection Study Group)ではその方向性でリフレクションを検討していくことにしたようです。

この提案はその後の議論や提案の作業を反映した、値ベースの静的リフレクションを提案するものです。

先ほどの型名取得コードは、この提案では次のようになります。

```cpp
#include <meta>

template<typename T>
std::string get_type_name() {

  // Tのメタ情報を取得
  constexpr std::meta::info reflected = ^T;

  // Tの型名をstring_viewで取得
  std::string_view name = std::meta::name_of(reflected);

  return std::string(name);
}
```

`reflexpr`は`^`になり、その結果は型ではなく値となります。その後でも、`get_name_v<T>`のような型特性クラスではなく`name_of()`のような関数によってメタ情報を処理していくことができます。テンプレートパラメータに対する`reflexpr(T)`ではテンプレートパラメータそのもののメタ情報がまず得られていましたが、`^T`ではインスタンス化後、具体的な型で置き換えられた`T`についてのメタ情報（すなわち与えられた型の直接のメタ情報）が得られます。むしろ、この提案ではテンプレートパラメータそのもののメタ情報を得る手段を提供していません。

別のサンプル

```cpp
// 列挙値名を文字列化する
template<Enum T>
std::string to_string(T value) {
  // Tの列挙値のシーケンスを取得
  template for (constexpr auto e : std::meta::members_of(^T)) {
    // valueに一致する列挙値名を返す
    if ([:e:] == value) {
      return std::string(std::meta::name_of(e));
    }
  }

  return "<unnamed>";
}
```

このコードは次の3つのことを行なっています

1. 列挙型から列挙値のシーケンスを取得する
2. 列挙値のシーケンスから、`value`と一致するものを探す
3. 一致した列挙値の名前を返す

1は、`^T`によって取得した`T`のメタ情報から`members_of()`によって列挙型`T`のメンバ（すなわち列挙値）のメタ情報のシーケンスを取得します。`T`の列挙値それぞれに対して`^`した結果の型を`info`とすると（これは実際に`std::meta::info`という型です）、`members_of()`の戻り値型は`std::span<info, N>`となります。

2は`template for`構文によって行われており、これは*expansion-statement*という構文です。`members_of()`の戻り値の`span`の各要素に対してその本体が繰り返し適用されますが、これは実行時ループではなく、`I = 0...N-1`毎に次のようなコードの繰り返しとして展開されます。

```cpp
{
  constexpr std::meta::info e = s[I];
  if ([:e:] == value)
    return std::meta::name_of(e);
}
```

*expansion-statement*内では、`[:e:]`の構文によって`T`の列挙値のメタ情報`e`からその値を復元します。この処理はスプライシングと呼ばれ、これによって実行時の値`value`との比較が可能となり、最初にマッチした`e`について、その名前（コード上での列挙値名）を`name_of()`によって取得（`std::string_view`で得られる）して返します。もし一致するものが見つからない場合（`|`でビット合成した列挙値など）、`"<unnamed>"`を返します。

このコードは実行時とコンパイル時が入り乱れていてわかりづらいですが、`^`などによって得られるメタ情報や*expansion-statement*によるイテレート、`[:...:]`によるスプライシングなどは全てコンパイル時に実行されており、これらの機能によって生成・追加される実行時メタ情報は何もありません。`^`から始まる一連のメタ情報の処理は全て静的に解決されており、これが値ベースの静的リフレクションです。

この提案も含めて値ベースリフレクションはまだSG7での議論中であるので、C++23に入ることはないでしょう。現在のReflection TSも、値ベースリフレクションによって書き換えられるはずなので、それもC++23に導入されることはなさそうです。静的リフレクションがC++に導入されるのは早くてもC++26、TSとしての経験を重視する場合はもっと後になるかもしれません。

- [N4766 Working Draft, C++ Extensions for Reflection](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4766.pdf)
- [P0425R0 Metaprogramming by design, not by accident](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0425r0.pdf)
- [P0993R0 Value-based Reflection](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0993r0.pdf)
- [P1240 進行状況](https://github.com/cplusplus/papers/issues/545)

### [P1664R6 `reconstructible_range` - a concept for putting ranges back together](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1664r6.html)

`view`によって別の`range`に変換されてしまった範囲を、元の`range`（と同じ型）に戻す操作、`std::ranges::reconstruct`と関連するコンセプトの提案。

以前の記事を参照

- [P1664R3 reconstructible_range - a concept for putting ranges back together - ［C++］WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P1664R3-reconstructible_range---a-concept-for-putting-ranges-back-together)
- [P1664R4 reconstructible_range - a concept for putting ranges back together - ［C++］WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P1664R4-reconstructible_range---a-concept-for-putting-ranges-back-together)
- [P1664R5 reconstructible_range - a concept for putting ranges back together - ［C++］WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P1664R5-reconstructible_range---a-concept-for-putting-ranges-back-together)

このリビジョンでの変更は、モチベーションセクションの改善、カスタマイゼーションポイントの調整、`ranges::reconstruct`に4つのオーバーロードがあることの説明の追記、提案する文言の改善、SG9からのフィードバックの反映、などです。

- [P1664 進行状況](https://github.com/cplusplus/papers/issues/578)

### [P1841R2 Wording for Individually Specializable Numeric Traits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1841r2.pdf)

`std::numeric_limits`に代わる新たな数値特性（*numeric traits*）取得方法を導入する提案。

以前の記事を参照

- [P1841R1 : Wording for Individually Specializable Numeric Traits - WG21月次提案文書を眺める（2020年05月）](https://onihusube.hatenablog.com/entry/2020/06/01/001003#P1841R1--Wording-for-Individually-Specializable-Numeric-Traits)

このリビジョンでの変更は、提案する文言の改善と[P2485R0](https://wg21.link/p2485r0)の内容を反映したことです。

この提案はC++23に導入すべく、現在LWGにおいて最終レビューが行われています。

- [P1841 進行状況](https://github.com/cplusplus/papers/issues/594)

### [P1854R3 Conversion to literal encoding should not lead to loss of meaning](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1854r3.pdf)

文字列リテラルのエンコーディングを実行時エンコーディングに変換する際、文字表現が失われる場合をコンパイルエラーとする提案。

以前の記事を参照

- [P1854R1 Conversion to literal encoding should not lead to loss of meaning - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P1854R1-Conversion-to-literal-encoding-should-not-lead-to-loss-of-meaning)
- [P1854R2 Conversion to literal encoding should not lead to loss of meaning - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P1854R2-Conversion-to-literal-encoding-should-not-lead-to-loss-of-meaning)

このリビジョンでの変更は、typo修正と、提案する文言について[P2362R3](https://wg21.link/P2362R3)によるものとの違いを明確化したことです。

- [P1854 進行状況](https://github.com/cplusplus/papers/issues/608)

### [P1885R9 Naming Text Encodings to Demystify Them](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1885r9.pdf)

システムの文字エンコーディングを取得し、識別や出力が可能なライブラリを追加する提案。

以前の記事を参照

- [P1885R3 Naming Text Encodings to Demystify Them - ［C++］WG21月次提案文書を眺める（2020年9月）](https://onihusube.hatenablog.com/entry/2020/10/09/221025#P1885R3--Naming-Text-Encodings-to-Demystify-Them)
- [P1885R4 Naming Text Encodings to Demystify Them - ［C++］WG21月次提案文書を眺める（2020年11月）](https://onihusube.hatenablog.com/entry/2020/12/06/015108#P1885R4-Naming-Text-Encodings-to-Demystify-Them)
- [P1885R5 Naming Text Encodings to Demystify Them - ［C++］WG21月次提案文書を眺める（2021年02月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P1885R5-Naming-Text-Encodings-to-Demystify-Them)
- [P1885R6 Naming Text Encodings to Demystify Them - ［C++］WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P1885R6-Naming-Text-Encodings-to-Demystify-Them)
- [P1885R7 Naming Text Encodings to Demystify Them - ［C++］WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/10/03/193523#P1885R7-Naming-Text-Encodings-to-Demystify-Them)
- [P1885R7 Naming Text Encodings to Demystify Them - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P1885R8-Naming-Text-Encodings-to-Demystify-Them)

このリビジョンでの変更は

- 提案する文言の修正
- ほとんどの関数が`CHAR_BIT == 8`を適格要件（破られればコンパイルエラー）とした
- ワイド文字列版のオーバーロードを削除（[P2419R0](https://wg21.link/P2491r0)への対応）
- [P2498R0](https://wg21.link/P2498R0)への対応（提案されている解決策を採用しない）

などです。

- [P1885 進行状況](https://github.com/cplusplus/papers/issues/634)


### [P1899R2 `stride_view`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1899r2.html)

範囲を等間隔の要素からなる範囲に変換するRangeアダプタ`stride_view`の提案。

以前の記事を参照

- [P1899R1 `stride_view` - ［C++］WG21月次提案文書を眺める（2020年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P1899R1-stride_view)

このリビジョンでの変更は、[P2442R1](https://wg21.link/P2442R1)の内容を反映するように提案する文言を修正した事です。

- [P1899 進行状況](https://github.com/cplusplus/papers/issues/647)

### [P2000R3 Direction for ISO C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2000r3.pdf)

C++の標準化の方向性を記した文書。

C++23の設計終了を受けて、C++26に向けて内容を更新したものです。

### [P2079R2 System execution context](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2079r2.html)

ハードウェアの提供するコア数（スレッド数）に合わせた固定サイズのスレッドプールを提供する*Scheduler*の提案。

この提案はR1ではP0443の`executor`として設計されていましたが、このリビジョンではP2300の`scheduler`として再設計されています。

- [P2079R1 : Parallel Executor - ［C++］WG21月次提案文書を眺める（2020年8月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P1899R1-stride_view)

提案されているのは、実行コンテキストの*view*となる`system_context`とそれを用いた`scheduler`である`system_scheduler`および、`system_context`で実行される処理を表現する`sender`である`system_sender`（名前は実装定義）の3つです。

```cpp
class system_context {
public:
  system_context();
   ~system_context();

  system_context(const system_context&) = delete;
  system_context(system_context&&) = delete;
  system_context& operator=(const system_context&) = delete;
  system_context& operator=(system_context&&) = delete;

  system_scheduler get_scheduler();

  implementation-defined_delegation_sender execute_chunk() noexcept;
  implementation-defined_delegation_sender execute_all() noexcept;
  
  size_t max_concurrency() noexcept;
};
```

`system_context`は任意の実行コンテキストの上にかぶせて使用し、`system_context`のオブジェクトはそこから取得した`scheduler`およびその上で起動されたすべての作業よりも長生きする必要があります。また、`system_context`の全てのオブジェクトは同じ実行コンテキストを参照しており、ことなる`system_context`のオブジェクトから投入された処理は同じ実行コンテキストで実行されます。

`execute_chunk()`は実装定義の数（チャンク）の作業だけを開始するための`sender`を返す関数で、`execute_all()`は現在`system_context`にキューイングされているすべての作業の実行を開始する`sender`を返すものです。これらの`sender`は処理の完了までを表現するものではなく、処理の投入だけを担うもので、実行コンテキストへ処理を投入し終えた段階で完了し、結果（`set_value()`チャネル）として投入（開始）することに成功した作業の数を返します。

`max_concurrency()`は`system_context`の最大スレッド数を返す関数ですが、0を返すことができ、その場合はメインスレッドを利用します。

`system_context`はスレッドプールを意識してはいるものの、その実行コンテキストの詳細についてはほぼ何も指定していません。そのため、提案ではリリースビルドとデバッグビルドで実行コンテキストを変更可能とすることを提案しています。

```cpp
class system_scheduler {
public:
  system_scheduler() = delete;
  ~system_scheduler();

  system_scheduler(const system_scheduler&);
  system_scheduler(system_scheduler&&);
  system_scheduler& operator=(const system_scheduler&);
  system_scheduler& operator=(system_scheduler&&);

  bool operator==(const system_scheduler&) const noexcept;

  friend implementation-defined-system_sender tag_invoke(
    std::execution::schedule_t, const system_scheduler&) noexcept;

  friend std::execution::forward_progress_guarantee tag_invoke(
    std::execution::get_forward_progress_guarantee_t,
    const system_scheduler&) noexcept;

  friend implementation-defined-bulk-sender tag_invoke(
    std::execution::bulk_t,
    const system_scheduler&,
    Sh&& sh,
    F&& f) noexcept;
};
```

`system_scheduler`は`system_context::get_scheduler()`から取得できる`scheduler`で、`system_context`への参照を保持しています。2つの`system_scheduler`オブジェクトは、同じ`system_context`を共有している場合に同値（`==`で`true`）となります。`system_scheduler`が`system_context`オブジェクトの破棄後に生存している場合、デストラクタ呼び出し以外のすべての操作が未定義動作となります。

提案文書より、使用例。

```cpp
using namespace std::execution;

// system_contextオブジェクトの作成
system_context ctx;
// system_schedulerの取得
scheduler auto sch = ctx.get_scheduler();

// 処理のチェーン
sender auto begin = schedule(sch);
sender auto hi = then(begin, []{
    std::cout << "Hello world! Have an int.";
    return 13;
});
sender auto add_42 = then(hi, [](int arg) { return arg + 42; });

auto [i] = this_thread::sync_wait(add_42).value();


// execution::onを使用すると、よりよいstructured concurrencyな表現が得られる

sender auto hi = then(just(), []{
    std::cout << "Hello world! Have an int.";
    return 13;
});
sender auto add_42 = then(hi, [](int arg) { return arg + 42; });

auto [i] = this_thread::sync_wait(on(sch, add_42)).value();
```

バルク実行のサンプル

```cpp
auto bar() {
  return
    ex::let_value(
      ex::get_scheduler(),          // 接続されたreceiverからschedulerを取得する
      [](auto current_sched) {
        return bulk(
          current_sched.schedule(),
          16,                       // 例えば16並列
          [](auto idx){
            // idxにはShape（ここでは16）に応じた作業カウントが渡される
            std::osyncstream{std::cout} << "Index: " << idx << "\n";
          })
      });
}

void foo() {
  using namespace std::execution;

  system_context ctx;

  auto [i] = this_thread::sync_wait(
    on(
      ctx.scheduler(),  // bar()をsystem_schedulerで開始する
      bar()))           // onによって用意されたreceiverを通してsystem_schedulerを伝播する
    .value();
}
```

これは標準ライブラリの提供する基本的で基礎的な`scheduler`となり、もっともよく使用されるものとなるはずです。ただし、これはまだ提案としては初期段階で、C++23には間に合いません。

- [P2079 進行状況](https://github.com/cplusplus/papers/issues/806)

### [P2093R12 Formatted output](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2093r12.html)


`std::format`によるフォーマットを使用しながら出力できる新I/Oライブラリ`std::print`の提案。

以前の記事を参照

- [P2093R0 Formatted output - ［C++］WG21月次提案文書を眺める（2020年6月）](https://onihusube.hatenablog.com/entry/2020/07/05/003248#P2093R0--Formatted-output)
- [P2093R1 Formatted output - ［C++］WG21月次提案文書を眺める（2020年7月）](https://onihusube.hatenablog.com/entry/2020/08/12/014639#P2093R1--Formatted-output)
- [P2093R2 Formatted output - ［C++］WG21月次提案文書を眺める（2020年10月）](https://onihusube.hatenablog.com/entry/2020/11/02/221657#P2093R2-Formatted-output)
- [P2093R3 Formatted output - ［C++］WG21月次提案文書を眺める（2021年1月）](https://onihusube.hatenablog.com/entry/2021/02/11/153333#P2093R3-Formatted-output)
- [P2093R4 Formatted output - ［C++］WG21月次提案文書を眺める（2021年2月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P2093R4-Formatted-output)
- [P2093R5 Formatted output - ［C++］WG21月次提案文書を眺める（2021年3月）](https://onihusube.hatenablog.com/entry/2021/04/10/222356#P2093R5-Formatted-output)
- [P2093R6 Formatted output - ［C++］WG21月次提案文書を眺める（2021年4月）](https://onihusube.hatenablog.com/entry/2021/06/13/165215#P2093R6-Formatted-output)
- [P2093R7 Formatted output - ［C++］WG21月次提案文書を眺める（2021年7月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2093R8-Formatted-output)
- [P2093R8 Formatted output - ［C++］WG21月次提案文書を眺める（2021年8月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2093R8-Formatted-output)
- [P2093R9 Formatted output - ［C++］WG21月次提案文書を眺める（2021年9月）](https://onihusube.hatenablog.com/entry/2021/10/03/193523#P2093R9-Formatted-output)
- [P2093R10 Formatted output - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2093R11-Formatted-output)

このリビジョンでの変更は、提案する文言の修正のみです。

- [P2093 進行状況](https://github.com/cplusplus/papers/issues/884)

### [P2165R3 Compatibility between tuple, pair and tuple-like objects](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r3.pdf)

`std::pair`と2要素`std::tuple`及び`tuple-like`な型の間の非互換を減らし比較や代入をできるようにする提案。

前回の記事を参照

- [P2165R0 Compatibility between tuple and tuple-like objects - ［C++］WG21月次提案文書を眺める（2020年05月）](https://onihusube.hatenablog.com/entry/2020/06/01/001003#P2165R0--Comparing-pair-and-tuples)
- [P2165R1 Compatibility between tuple and tuple-like objects - ［C++］WG21月次提案文書を眺める（2020年07月）](https://onihusube.hatenablog.com/entry/2020/08/12/014639#P2165R1--Compatibility-between-tuple-and-tuple-like-objects)
- [P2165R2 Compatibility between tuple and tuple-like objects - ［C++］WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P2165R2-Compatibility-between-tuple-pair-and-tuple-like-objects)

このリビジョンでの変更は

- 対象とする`tuple-like`な型を`std`名前空間にあるものに絞った
- `views::zip`関連の変更の追加
- 連想コンテナに対する変更を削除（別の提案とする）
- `pair/tuple`の既存のコンストラクタ/代入演算子/比較演算子を変更しないようにした
- `uses_allocator_construction_args`を取るオーバーロードの追加
- 機能テストマクロの追加
- `tuple-like`コンセプトを参照型をサポートするように修正

などです。

この提案はC++23を目指して、LEWG通過のための投票待ちをしています。

- [P2165 進行状況](https://github.com/cplusplus/papers/issues/876)

### [P2248R4 Enabling list-initialization for algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2248r4.html)

値を指定するタイプの標準アルゴリズムにおいて、その際の型指定を省略できるようにする提案。

以前の記事を参照

- [P2248R0 Enabling list-initialization for algorithms - ［C++］WG21月次提案文書を眺める（2020年11月）](https://onihusube.hatenablog.com/entry/2020/12/06/015108#P2248R0-Enabling-list-initialization-for-algorithms)
- [P2248R1 Enabling list-initialization for algorithms - ［C++］WG21月次提案文書を眺める（2020年12月）](https://onihusube.hatenablog.com/entry/2021/01/17/005823#P2248R1-Enabling-list-initialization-for-algorithms)
- [P2248R2 Enabling list-initialization for algorithms - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2248R2-Enabling-list-initialization-for-algorithms)
- [P2248R3 Enabling list-initialization for algorithms - ［C++］WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2248R3-Enabling-list-initialization-for-algorithms)

このリビジョンでの変更は`std::replace_copy`（`std::ranges`のものではない）のデフォルト指定をドロップした事、提案する文言の修正と明確化などです。

この提案はC++23を目指して、LEWG通過のための投票待ちをしています。

- [P2248 進行状況](https://github.com/cplusplus/papers/issues/944)

### [P2249R4 Mixed comparisons for smart pointers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2249r4.html)

スマートポインターの比較演算子に生ポインタとの直接比較を追加する提案。

以前の記事を参照

- [P2249R0 Mixed comparisons for smart pointers - ［C++］WG21月次提案文書を眺める（2021年02月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P2249R0-Mixed-comparisons-for-smart-pointers)
- [P2249R1 Mixed comparisons for smart pointers - ［C++］WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2249R1-Mixed-comparisons-for-smart-pointers)
- [P2249R2 Mixed comparisons for smart pointers - ［C++］WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2249R2-Mixed-comparisons-for-smart-pointers)
- [P2249R3 Mixed comparisons for smart pointers - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P2249R3-Mixed-comparisons-for-smart-pointers)

このリビジョンでの変更は、P2405へのリンクを修正した事のみです。

- [P2249 進行状況](https://github.com/cplusplus/papers/issues/981)

### [P2286R5 Formatting Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2286r5.html)

↓

### [P2286R6 Formatting Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2286r6.html)

任意の範囲を手軽に出力できる機能を追加する提案。

以前の記事を参照

- [P2286R0 Formatting Ranges - ［C++］WG21月次提案文書を眺める（2021年1月）](https://onihusube.hatenablog.com/entry/2021/02/11/153333#P2286R0-Formatting-Ranges)
- [P2286R1 Formatting Ranges - ［C++］WG21月次提案文書を眺める（2021年2月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P2286R1-Formatting-Ranges)
- [P2286R2 Formatting Ranges - ［C++］WG21月次提案文書を眺める（2021年8月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2286R2-Formatting-Ranges)
- [P2286R3 Formatting Ranges - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P2286R3-Formatting-Ranges)
- [P2286R4 Formatting Ranges - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2286R4-Formatting-Ranges)

R5での変更は

- デリミタの変更をドロップした
- `retargeted_format_context, end_sentry`を削除
- `range_formatter`が必要となる理由について追記
- 文字エスケープの振る舞いについて、Python/Rustを例にして追記
- コンテナアダプタに関する説明を追加
- 提案する文言を追加

R6での変更は

- 機能テストマクロの追加
- 提案する文言の改善
    - `range`型`R`についての`formatter<R, charT>`が`range_formatter<range_reference_t<R>>`を継承するように変更
    - `formattable`コンセプトの出力イテレータについての指定を実装定義から未規定へ変更
  
などです。

この提案はC++23へ向けて、LEWGでの最終投票待ちをしています。

- [P2285 進行状況](https://github.com/cplusplus/papers/issues/977)

### [P2300R4 `std::execution`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2300r4.html)

[P0443R14](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r14.html)のExecutor提案を置き換える、任意の実行コンテキストで任意の非同期処理を構成・実行するためのフレームワークおよび非同期処理モデルの提案。

以前の記事を参照

- [P2300R0 `std::execution` - WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P2300R0-stdexecution)
- [P2300R1 `std::execution` - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2300R1-stdexecution)
- [P2300R2 `std::execution` - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2300R2-stdexecution)
- [P2300R3 `std::execution` - WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2300R3-stdexecution)

このリビジョンでの変更は

- いくつかのバグ修正
- *Dependently-typed* `sender`のサポート
- `receiver`に対して`query`を発行しその結果を`set_value()`チャネルで返す`sender`ファクトリ、`read(query)`の追加
- typed `sender`のメタデータを宣言的に定義するための`completion_signatures`の追加
- 別の`sender`の*completion signature*からアダプトして`sender`の*completion signature*を指定するための`make_completion_signatures`の追加
- `sender`の定義のデフォルトをtyped `sender`に変更し、そのチャネル型指定のない`sender`サポートをなくした
    - typed `sender`とは、その`set_value(), set_error()`チャネルを介して送信する値の型を`S::value_types, S::error_types`として公開する`sender`
- `set_done()`チャネル（`receiver`の完了（not 成功）チャネル）の名前を`set_stopped()`に変更
- `sender`アダプタのレイヤを介して`scheduler, sender, receiver`および環境クエリの伝送を制御するためのカスタマイズポイントの追加
- *delegatee scheduler*を取得するための`get_delegatee_scheduler()`を追加
    - *delegatee scheduler*とは、アルゴリズムもしくは`scheduler`が作業を委任して実行するために使用する`scheduler`のこと
- `schedule_result_t`（`scheduler`からその`sender`型を取得する）の追加
- `stopped_as_error`（`sender`のエラーチャネルが指定したエラーを返すように変換する`sender`アダプタ）をCPOとして再指定
- `tag_invoke`の診断を改善
    - `tag_invoke`の呼び出し失敗がSFINAE可能であることを規定（これは通常のCPOと同様）

などです。

このリビジョンでの大きな変更は、*Dependently-typed* `sender`をサポートするようにしたことです。

`stop_token`、アロケータ、`scheduler`などの現在の実行環境に関する情報をコンシューマからプロデューサーへ自然に伝達される必要があります。コルーチンではそれは`promise`型を通して、呼び出したコルーチンから呼び出し側へ伝播します。`sender/receiver`モデルでもその伝達はされていますが、多くの情報は`receiver`に関連づけられており、`sender`と`receiver`が`connect`された後で、`sender`や`operation_state`によって照会されます。これはすなわち、最終的に起動される非同期処理に関する情報は`sender`と`receiver`で分割して保持されており、情報の一部は`receiver`を通して遅れて提供されるということです。

`sender`アルゴリズムはそれらの情報を`sender_traits`機構（`completion_signatures_of_t<Sender>`）によって取得します。しかし、R3までの`sender_traits`機構は`sender`型しかパラメータに取らず、`receiver`によって決定される情報の一部を静的に引き出すことができませんでした。このため、`sender`によってはその情報を確定できず（typed `sender`となれず）、コンパイルエラーを起こすことがありました。

```cpp
namespace ex = std::execution;

// この段階ではreceiverが不定
ex::sender auto task =
  ex::let_value(
    ex::get_scheduler(), // receiverからschedulerを取得する
    [](auto current_sched) {
      // そのschedulerでネストした作業を開始する
      return ex::on(current_sched, nested work...);
    });

// sync_waitの用意するreceiverとconnectして処理を開始、完了を待機
std::this_thread::sync_wait(std::move(task));   // コンパイルエラー
```

`get_scheduler()`は接続されている`receiver`から`scheduler`を取得するもので、引数なしでの呼び出しはその値チャネル（`set_value`）で`scheduler`を返す`sender`を返します。その`sender`の`value_type`は`receiver`に接続された`scheduler`の型です。この時、`sender_traits<get_scheduler_sender>::value_types`も同じ型になって欲しいですが、`receiver`がないためその型は不定となります。

`sync_wait()`は`run_loop`実行コンテキスト（現在のスレッドで処理を開始するシングルスレッド実行コンテキスト）で処理を開始するもので、その戻り値型の確定のために入力の`sender`はtyped `sender`でなければなりません。しかし、`let_value(sender, work)`は入力の`sender`がtypedではない場合得られる`sender`もtypedではなく、それを`sync_wait()`に入力しようとするとコンパイルエラーとなります。`get_scheduler()`の返す`sender`はtypedではない（`sender_traits<get_scheduler_sender>::value_types`が決定できない）ため、上記例ではコンパイルエラーを起こしています。

この解決のための変更が*Dependently-typed* `sender`であり、その内容は単純に`sender_traits`機構が`receiver`の型も追加で受け取れるようになっただけです。アルゴリズムは``sender_traits<Sender, Receiver>`を介して、非同期処理に関する情報の全てを取得することができます。

ただし、このような`receiver`型の使用は、型のサイクルを引き起こしやすく、謎のエラーが多発するようで、`sender_traits`機構は実際には`receiver`型ではなく環境オブジェクト（*environment object*、key/valueペアの袋）を受け取ります。これは、コンテキスト情報は`receiver`から環境へ移動させるための設計で、`sender_traits`や`typed_sender`（このリビジョンでは`sender`）は`receiver`型の代わりにこの環境オブジェクトを受け取ります。ただし、`receiver`と環境の分離は完全ではないようで、さらなる分離が可能なようですが、この提案ではそこに踏み込んではいません。

環境オブジェクトと呼ばれている値（実際には型っぽいですが）に`sender`（にまつわる環境情報）型が依存するので、*Dependently-typed*（依存型）`sender`という呼び名のようです。

- [ExecutorとNetworking TSで起きていたこと - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2021/12/23/190053)
- [P2300 進行状況](https://github.com/cplusplus/papers/issues/1054)

### [P2302R3 `std::ranges::contains`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2302r3.html)

新しいアルゴリズムとして`std::ranges::contains`を追加する提案。

- [P2302R0 Prefer std::ranges::contains over std::basic_string_view::contains - ［C++］WG21月次提案文書を眺める（2021年2月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P2302R0-Prefer-stdrangescontains-over-stdbasic_string_viewcontains)
- [P2302R1 std::ranges::contains - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P2302R1-stdrangescontains)
- [P2302R2 std::ranges::contains - ［C++］WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2302R2-stdrangescontains)

このリビジョンでの変更はよくわかりません。

この提案はC++23へ向けて、LEWGでの最終投票待ちをしています。

- [P2295 進行状況](https://github.com/cplusplus/papers/issues/988)

### [P2324R2 Labels at the end of compound statements (C compatibility)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2324r2.pdf)

複合ステートメント（*compound statement*）の末尾にラベルを置けるようにする提案。

- [P2324R0 Labels at the end of compound statements (C compatibility) - ［C++］WG21月次提案文書を眺める（2021年02月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P2324R0-Labels-at-the-end-of-compound-statements-C-compatibility)
- [P2324R1 Labels at the end of compound statements (C compatibility) - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2324R1-Labels-at-the-end-of-compound-statements-C-compatibility)

このリビジョンでの変更は、提案する文言の修正のみです。

この提案はC++23に向けてEWGでの最終投票待ちをしていますが、すでにCWGのレビューと承認を終えており、EWGを通過すれば次の全体会議で投票にかけられます。

- [P2321 進行状況](https://github.com/cplusplus/papers/issues/1006)

### [P2363R3 Extending associative containers with the remaining heterogeneous overloads](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2363r3.html)

連想コンテナの透過的操作を、さらに広げる提案。

以前の記事を参照

- [P2363R0 Extending associative containers with the remaining heterogeneous overloads - WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P2363R0-Extending-associative-containers-with-the-remaining-heterogeneous-overloads)
- [P2363R1 Extending associative containers with the remaining heterogeneous overloads - WG21月次提案文書を眺める（2021年09月）](https://onihusube.hatenablog.com/entry/2021/10/03/193523#P2363R1-Extending-associative-containers-with-the-remaining-heterogeneous-overloads)
- [P2363R2 Extending associative containers with the remaining heterogeneous overloads - WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2363R2-Extending-associative-containers-with-the-remaining-heterogeneous-overloads)

このリビジョンでの変更は、`at()`に事前条件を追加したこととその説明を追記したことです。

この提案はC++23へ向けて、LEWGでの最終投票待ちをしています。

- [P2363 進行状況](https://github.com/cplusplus/papers/issues/1037)

### [P2370R2 Stacktrace from exception](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2370r2.html)

現在投げられている例外オブジェクトに基づくスタックトレースを取得できるようにする提案。

以前の記事を参照

- [P2370R0 Stacktrace from exception - WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P2370R0-Stacktrace-from-exception)
- [P2370R1 Stacktrace from exception - WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2370R1-Stacktrace-from-exception)

このリビジョンでの変更は、[P2490](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2490r0.html)の内容についての議論を追記し、P2490のアプローチを実装可能とするように文言を修正したことです。

この提案の現在の設計はスレッドローカルなフラグを用いて例外キャッチ時のスタックトレース取得を制御していますが、それはTLSへのアクセスというオーバーヘッドを伴います。対してP2490では、`catch`に応じてそれをするかしないかを静的に判定するアプローチを提案しています。これを受けてこのリビジョンでは、P2490のアプローチには次のような短所があると主張しています

1. 実行時にスタックトレースキャプチャを無効化する方法が提供されていない
2. 再スローするとスタックトレースが失われる
3. ゼロオーバヘッド例外（[P0709](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf)）では機能しない
    - P0709の例外機構は`std::expected`を返すのに近いことをしており、例外がキャッチブロックに到達した時にはスタックトレースは失われている
    - この提案では、例外発生元であらかじめスタックトレースを保存し、`std::expected`（的なもの）の内部に保存しておけば動作する

その上で、P2490のアプローチを受け入れ可能なように提案する文言を調整しています。その結果として、スタックトレースを保存する場所が実装定義とされたようです。

- [P2490R0 Zero-overhead exception stacktraces](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P2490R0-Zero-overhead-exception-stacktraces)
- [P2370 進行状況](https://github.com/cplusplus/papers/issues/1056)

### [P2375R1 Generalisation of nth_element to a range of nths](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2375r1.pdf)
### [P2404R1 Move-only types for equality_comparable_with, totally_ordered_with, and three_way_comparable_with](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2404r1.pdf)
### [P2404R2 Move-only types for equality_comparable_with, totally_ordered_with, and three_way_comparable_with](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2404r2.pdf)
### [P2424R0 Abbreviated Parameters](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2424r0.html)

関数引数の簡易宣言構文の提案。

1行で済むような単純な関数をラムダ式を用いて定義して使用することが多く、そのためラムダ式を可能な限り簡潔に書くことができるようにしたいという要望が強くあります。それを受けて、短縮ラムダ提案（[P0573R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0573r2.html)）などいくつかの提案がされましたが、以下のような理由によってリジェクトされています。

1. 通常のラムダ式と意味論が異なる。関数本体が同じでも、短縮形か否かによって戻り値型が異なる。
2. 任意の先読みパースが必要となる。パーサーはラムダ式が短縮形かどうかを判定するためにラムダ式本体を先読みしなければならない。
3. 後置戻り値型との不一致。ラムダ本体と後置戻り値型とでは解析が異なるため、短縮ラムダは意図通りに動作しない可能性がある
      - この問題は[P2036R2](https://wg21.link/p2036r2)で解決される（予定）

この問題のうち、1と3はラムダ本体の意味論に関することで、2はラムダの引数宣言に関する事です。そして、多くの場合ラムダ式の冗長性を最も高めているのは引数宣言周辺の構文です。

```cpp
[](const auto& a, const auto& b) { return a < b; }
```

`auto&&`を用いるともう少し短縮できるという主張もありますが、`auto&&`が`const`となるのは実引数がすでに`const`である場合のみです。ラムダ式では非`const`なものを渡して内部では`const`として扱いたい場合が多く、`auto&&`は意味が異なってしまいます。

ここで、この引数宣言からこれらの型の指定を取り除くことができれば、大きく冗長性を低下させることができることが見えます。そこで、この提案では上記に列挙した2つ目の問題（引数宣言周りの問題）に的を絞り、省略された仮引数宣言（*Abbreviated Parameters*）という構文の導入によりこの解決を図ります。

```cpp
// ラムダ式
[]((a, b)) { return a < b; }
// 関数
auto less_then((a, b)) { return a < b; }
```

二重かっこ`(())`で囲まれているものが省略された仮引数リストです。この内部の識別子は型名ではなく変数名（引数名）として扱われます

```cpp
// string型、vector型の仮引数宣言、引数名なし
auto something(string, vector);

// string、vectorという名前の仮引数宣言、型指定なし（この提案）
auto something((string, vector));
```

この時、カンマ区切りリストの各要素に2つ以上の識別子が指定された場合、それは通常の仮引数宣言と同じものとして扱われます。

```cpp
// この2つは同じ宣言となる
auto something(vector v);
auto something((vector v));

// この2つも同じ宣言となる
auto something(const vector& v);
auto something((const vector& v));
```

言い換えると、省略された仮引数宣言において型名の省略はオプションです。これは当然混在することができます。

```cpp
auto something((string, const vector& v));  // ok
```

省略された仮引数宣言（のうち型名指定がないもの）はテンプレートパラメータを伴う引数宣言とみなされ、通常のテンプレート実引数推論に従って型が推論されます。つまりは、ラムダ式の引数宣言からさらに`auto`を省略しているような感じです。

```cpp
// これらは（ほぼ）同じ宣言となる
template<typename T>
auto something(T v);

auto something(auto v);

auto something((v));
```

ただし、修飾（`&&`とか`const`など）は異なり、この提案では`const auto&`と同じ推論を行うことを提案しています。

```cpp
// これらは同じ宣言となる
template<typename T>
auto something(const T& v);

auto something(const auto& v);

auto something((v));
```

`auto&&`はデフォルトが可変参照でありそれが見えなくなることで危険性が増すとともに注意すべきことや前提知識が増えるため、この提案ではデフォルトimmutableが最適だとしています。また、デフォルトが参照となるため型によっては非効率となり得ますが、そのような型に対してオプティマイザがこれをコピーに置き換えることができるようにすることも提案されています。

```cpp
std::string s;
std::vector<std::string> v;

std::for_each(s.begin(), s.end(), []((c)){ ... }); // decltype(c) is `const char`
std::for_each(v.begin(), v.end(), []((s)){ ... }); // decltype(s) is `const std::sting&`
```

このような振る舞いはユーザーが引数のアドレスを取得する場合に問題となる可能性がありますが、引数をポインタ型で宣言しないのに実引数の参照元のアドレスを取得するようなケースは考えづらいため、この提案では考慮しないことにしています。

```cpp
// 問題となりうるケースだが
void func((arg)) { persistAddrOf(&arg); ... }

// 普通はこう書かれるはず？
void func(const auto* arg)) { persistAddrOf(arg); ... }
```

- [P2424 進行状況](https://github.com/cplusplus/papers/issues/1166)

### [P2437R1 Support for #warning](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2437r1.pdf)
### [P2447R2 std::span and the missing constructor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2447r2.html)
### [P2448R1 Relaxing some constexpr restrictions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2448r1.html)
### [P2457R0 2021 December Library Evolution Poll Outcomes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2457r0.html)

2021年12月に行われたLEWGにおける全体投票の結果。

次の12の提案が投票にかけられ、否決されたものはありません（全てLWGへ転送されています）。また、投票に当たって寄せられた賛否のコメントが記載されています。

- [P0009R14 mdspan](https://wg21.link/P0009R14)
- [P2093R11 Formatted Output](https://wg21.link/P2093R11)
- [P1467R7 Extended Floating-Point Types](https://wg21.link/P1467R7)
- [P2278R2 cbegin Should Always Return A Constant Iterator](https://wg21.link/P2278R2)
- [P2408R4 Ranges Iterators As Inputs To Non-Ranges Algorithms](https://wg21.link/P2408R4)
- [P2374R3 views::cartesian_product](https://wg21.link/P2374R3)
- [P2441R1 views::join_with](https://wg21.link/P2441R1)
- [P2446R1 views::all_move](https://wg21.link/P2446R1)
- [P2467R0 Support Exclusive Mode For fstreams](https://wg21.link/P2467R0)
- [P2438R1 string::substr() &&](https://wg21.link/P2438R1)
- [P2396R0 Concurrency TS v2 Fixes](https://wg21.link/P2396R0)
- [P2198R3 Freestanding Feature-Test Macros And Implementation-Defined Extensions C++23](https://wg21.link/P2198R3)



### [P2458R0 2022 January Library Evolution Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2458r0.html)
### [P2468R2 The Equality Operator You Are Looking For](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2468r2.html)
### [P2474R1 views::repeat](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2474r1.html)
### [P2494R1 Relaxing range adaptors to allow for move only types](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2494r1.html)
### [P2498R1 Forward compatibility of text_encoding with additional encoding registries](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2498r1.pdf)
### [P2507R1 Limit [[assume]] to conditional-expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2507r1.pdf)
### [P2508R1 Exposing std::basic-format-string](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2508r1.html)
### [P2511R0 Beyond `operator()`: NTTP callables in type-erased call wrappers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2511r0.html)

`std::move_only_fuction`を、呼び出し可能なNTTP値を型消去するCallable Wrapperへ拡張する提案。

`move_only_fuction`にユーザー定義のオブジェクトを渡すには、それが関数呼び出し演算子によって次のように呼び出し可能である必要があります。

```cpp
obj(some, args);
```

しかし、`operator()`は全てのクラス型で実装されるわけではなく、ユーザー定義のクラス型では例えば次のようにメンバ関数によって呼び出すことができるようになっています。

```cpp
obj.send(some, args);
```

この提案は、このようにメンバ関数によって呼び出しを行うものを`move_only_fuction`で扱えるようにしようとする提案です。つまりは、このようなメンバ関数による呼び出しを`operator()`によってラップする機能を`move_only_fuction`に入れ込もうとしています。

このようなラッピングは現在、ラムダ式を用いて行われます。

```cpp
auto wrap = [obj = std::move(obj)]<typename... Args>(Args&&... args) mutable {
  return obj.send(obj, std::forward<Args>(args)...);
};
```

しかし見て分かる通り記述が冗長でボイラープレートが多すぎます。また、完全転送や`this`(`obj`)の値カテゴリなど、気にすべき事項も多いです。ラムダ式はこの用途にはあまり適していません。

ほかには、[`std::bind_front`](https://cpprefjp.github.io/reference/functional/bind_front.html)を使用することもできます。

```cpp
auto wrap = std::bind_front(&Obj::send, std::move(obj));
```

かなりシンプルに書くことができますが、この場合は追加のコスト（特にテンプレートの実体化コスト）がかかります。

ここで当初の目的を思い出すと、このようなラッパーは最終的に`movo_only_function`へ入れ込みたいのでした。そして、このようなラッパーの対象となっている呼び出し可能なものとはメンバ関数ポインタ（あるいは関数ポインタ）であり、それはコンパイル時に値が定まるものです（ここではこれをNTTP値と呼ぶことにします）。

NTTP値の保存に当たっては追加のストレージ領域を必要としない（テンプレートパラメータとして保持することができ、実体的にはストレージの型名に埋め込まれる）ため、本来Callableオブジェクトを保持する領域を別の事に使用することができます。すなわち、その領域に束縛対象の`*this`オブジェクトを保存することができます。従って、`movo_only_function`にそれを受け取れるインターフェースを追加するだけで上記のようなラッピングができそうです。

この提案では、`std::nontype_t<V>`を標準へ導入し、それを用いて`std::move_only_fuction`を構築できるようにします。

```cpp
std::move_only_function<void(Some, Args)> wrap{std::nontype<&Obj::send>, std::move(obj)});
```

また、`std::nontype_<V>`だけから変換するコンストラクタも用意されます。

```cpp
move_only_function<int(const char*, const char*)> fn = strcmp;
fn = nontype<strcasecmp>;
```

これらの事は同時に`std::fuction_ref`についても提案されていますが、そちらはまだ標準への文言が固まっていないため、ここでも文言は保留中です。一方で、これらの事は既存のもの（`std::function, std::pckaged_task`）には提案されていません。

サンプルコード

```cpp
// DB::connect()がこのようなシグネチャだとして
std::vector<std::move_only_function<bool(std::string, double, double)>> q{};

// C++11（std::bindによるthisの束縛）
q.push(std::bind(&DB::connect, std::move(db), _1, _2, _3));

// C++14（ジェネリックラムダによるthisの束縛）
q.push([db{std::move(db)}] (auto &&... args) mutable
       {
           return db.connect(std::forward<decltype(args)>(args)...);
       });

// C++20（std::bind_frontによるthisの束縛）
q.push(std::bind_front(&DB::connect, std::move(db)));
// あるいは（ジェネリックラムダ+ラムダのテンプレートパラメータ指定）
q.push([db{std::move(db)}] <class ...T>(T &&... args) mutable
       {
           return db.connect(std::forward<T>(args)...);
       });

// この提案
q.emplace(nontype<&DB::connect>, std::move(db));
```

この`std::nontype_t<V>`によって、`std::move_only_function`をはじめとする型消去ラッパーは、関数ポインタなどのNTTP値を型消去するようになったと見ることもできます。型消去（*Type erasure*）は異なる型に依存しているコードをそれらの型に依存しないようにすることで、この場合はそのようなコードが型ではなくコンパイル時の値（関数ポインタ）に依存していたわけです。

- [P2511 進行状況](https://github.com/cplusplus/papers/issues/1169)

### [P2512R0 SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2512r0.html)

2021年6月から12月の半年間のSG16（Unicode Study Group）のミーティング議事録。

例えばP2093R6: Formatted output等の提案に関する議論と投票の様子が詳しく記されています。

### [P2513R0 `char8_t` Compatibility and Portability Fixes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2513r0.html)

`char8_t`の非互換性を緩和する提案。

C++20で導入された`char8_t`はUTF-8文字を表す専用の型であり、そのエンコーディングは常にUTF-8であることが保証されます（変なことしなければ）。ただし、`u8`文字/文字列リテラルの型を変更しており、C++17以前に対する壊的変更を伴っています。

```cpp
const char* a = u8"a";            // C++17まではok、C++20からはng
const char b[] = u8"b";           // C++17まではok、C++20からはng
const unsigned char c[] = u8"c";  // C++17まではok、C++20からはng
```

`char8_t`による文字/文字列は`char, const char*, const char[]`などに暗黙変換することができません。これはUTF-8の文字を表すために`char8_t`を導入するという観点からは当然の変更ではありますが、既存のコードへの影響が小さかったわけでもありません。このような影響を緩和するために`-fno-char8_t`(GCC)とか`/Zc:char8_t`(MSVC)等の、C++20モードで`char8_t`を無効化するコンパイラオプションが提供されています。

さらに、この非互換性はC++17以前だけにとどまらず、Cとの互換性も壊しています。Cには`char8_t`はありませんが`u8`リテラルは使用可能で、その型は`char[N]`です。すなわち同じ問題がCとC++20の間で起こります。さらに、C23以降にCにも`char8_t`が導入される可能性があり（[N2653](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2653.htm)）、そこでは`char16_t/char32_t`と同じく`char8_t`は`unsigned char`の`typedef`として提案されており、`u8""`リテラルの戻り値は`char`と`char8_t`の配列どちらにも変換できるように規定されます。すなわち、CはC++の様な非互換を導入しておらず、結局この互換性問題は残り続けます。

```cpp
extern const unsigned char d[] = u8"d"; // N2653後のCでもok、C++20はng
```

このような非互換性を緩和するために、この提案では`u8""`文字列リテラルから`unsgined char`の配列が初期化できるようにすることを提案しています。

```cpp
extern const unsigned char d[] = u8"d"; // この提案の後、C++でもok
```

これは変換ではなく配列の初期化時に特別扱いするものです（CのN2653の`u8""`文字列リテラルもほぼ同様です）。従って`char8_t`の型付けが弱くなることはなく、これ以外の特別扱いや変換は提案されていません。

```cpp
// この提案の後
const char* a = u8"a";            // ng
const char b[] = u8"b";           // ok
const unsigned char c[] = u8"c";  // ok
```

この提案によって、直接的に`u8""`リテラルの非互換性が解消されるわけではありませんが（多くの場合、`char`の文字列は`const char*`で扱われるため）、`char8_t`文字列を`const char*`に渡すときに、変なことをする必要のない経路を作ることができます。

```cpp
// UTF-8文字列を受け取る関数
void input_u8str(const char* str);

int main() {
  // C++17まではok、この提案の後でもC++20以降はng
  input_u8str(u8"UTF-8 string.");

  // C++20の回避策
  const char8_t* u8str = u8"UTF-8 string.";
  input_u8str(reinterpret_cast<const char*>(u8str));

  // この提案の回避経路
  const char tmp_str[] = u8"UTF-8 string.";
  input_u8str(tmp_str);
}
```

特に、`reinterpret_cast`を使用しなくてもよくなるのでこのような回避策は定数式でも使用可能になります。また、世の中では`char`の文字列とUTF-8文字列を意味的に区別するために`typedef std::basic_string<unsigned char, my_u8_traits> u8string;`のようなものを定義するのが一般的なテクニックとなっているらしく、この提案はこのようなテクニックがC++20に移行するための一助にもなります。

このように、この提案では単純で小さな変更によって、C++20以前のコードをC++20に対応するための経路を提供し、Cコードとの互換性を確保することができます。そして、この提案はC++20への欠陥報告とすべく作業されているようです。

- [C++20 UTF-8エンコーディングされた文字の型としてchar8_tを追加 - cpprefjp](https://cpprefjp.github.io/lang/cpp20/char8_t.html)
- [P2513 進行状況](https://github.com/cplusplus/papers/issues/1171)

### [P2514R0 `std::breakpoint`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2514r0.html)

C++コード上からブレークポイントを設定するための`std::breakpoint()`の提案。

コードのデバッグ時にブレークポイントは重宝しますが、ブレークポイントそのものはC++コードの外の概念です。慣れれば大したことない作業ではありますが、初学者にとっては混乱の元で、C++の外のIDEやデバッガのインターフェースや構文を学習しなければなりません。

`std::breakpoint()`があることによってブレークポイントの配置をコードで表現でき、特に実行時の条件によるブレークポイントの制御がより簡単に行えるようになります。

```cpp
#include <debugging>

// なんかの処理
auto f() -> double;

int main() {
  double d = f();

  if (std::isnan(d)) {
    std::breakpoint();  // dがNaNの時にブレークする
  }

  ...

}
```

`std::breakpoint()`はプログラムの実行中にデバッガがアタッチされている時だけ動作し、それが呼び出されると通常のブレークポイントがあるかのようにプログラムの実行を一時停止します。この振る舞いは現在でもほぼ全てのプラットフォームとデバッガでサポートされているようです。

- MSVC : `__debugbreak`
- GCC : `__builtin_trap`
- Clang : `__builtin_debugtrap`
- Keil armcc : `__breakpoint`
- Unreal Engine 4 : マクロによる同様の実装

`std::breakpoint()`はこれらの実装定義のものを標準化するものでもあります。

- [P1279 `std::breakpoint`, Isabella Muerte 2018-10-05](https://wg21.link/P1279)
- [P2514 進行状況](https://github.com/cplusplus/papers/issues/1172)

### [P2515R0 `std::is_debugger_present`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2515r0.html)

プログラムがデバッグ中であるかを知るための関数`std::is_debugger_present()`の提案。

プログラムがデバッガにアタッチされて実行されている時だけ特別なこと（追加のメッセージの出力、追加のテストコードの実行、デバッグに有用なユーザーへの表示など）をしたい場合、それは簡単ではなく実行環境に関する深い知識が求められます。この提案は、ユーザーがそのような負担を負うことなく、デバッグ中であることを判定できるようにするものです。

追加するのは`std::is_debugger_present()`と言う関数で、これはデバッガがアタッチされている場合に`true`を返す引数なしの関数です。

```cpp
namespace std {
	bool is_debugger_present() noexcept;
}
```

一部のプラットフォームでは`IsDebuggerPresent()`や`IsDebuggerActive()`としてこれらの機能を提供しており、これはそれを標準化するものでもあります。

- [P2515 進行状況](https://github.com/cplusplus/papers/issues/1173)

### [P2516R0 `string_view` is implicitly convertible from what?](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2516r0.html)

`std::basic_string_view`からRangeコンストラクタを削除する提案。

`std::basic_string_view`に対するRangeコンストラクタ（同じ文字型による任意の`contiguous_range`から構築するコンストラクタは）C++23に対して[P1391](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1391r4.pdf)で導入されました。一見するとこれは便利でありいいアイデアに思えますが、実際に使用してみるといくつかの罠が潜んでいます。

```cpp
template <typename Container>
auto print(const Container& c)
    -> std::enable_if_t<!std::is_convertible_v<Container, std::string_view>> {
  std::cout << '[';
  const char* sep = "";
  for (const auto& item: c) {
    std::cout << sep << item;
    sep = ", ";
  }
  std::cout << ']';
}

void print(std::string_view s) {
  std::cout << '"' << s << '"';
}
```

この関数はコンテナに対しては`[a, b, ...]`の形式で出力し、文字列likeな型（`std::string_view`に変換可能な型）に対しては文字列として`"ab..."`のように出力する関数です。これを`print(std::vector{'a', 'b'})`のように使用した時、C++20までは`[a, b]`と出力されますが、C++23からは`"ab"`と出力されるようになります。これはC++23で導入されたRangeコンストラクタを通して暗黙変換が行われているために起きていることです。

`std::string_view`は文字列の参照となるもので、その名前やインターフェースにもそれが現れています。Rangeコンストラクタによる暗黙変換はその仮定を破壊し、`std::string_view`を文字列への参照ではなく任意の`contiguous_range`の参照へと意味を変更してしまっています。この変換の問題点は文字列であるためのプロクシに連続性を使用して、文字列の実表現と意味論を混同してしまっていることにあります。

||C++17|C++20|C++23|
|---|---|---|---|
|`print(std::list{'a', 'b'});`|`[a, b]`|`[a, b]`|`[a, b]`|
|`print(std::deque{'a', 'b'});`|`[a, b]`|`[a, b]`|`[a, b]`|
|`print(std::vector{'a', 'b'});`|`[a, b]`|`[a, b]`|`"ab"`|

このように比較した時、`std::vector`が他のコンテナと異なるところはどこなのでしょうか？そしてこれは本当に文字列likeなものなのでしょうか？`contiguous_range`を参照する型が欲しい場合、すでに`std::span<const T>`があります。

このことは`{fmt}`ライブラリで報告されたことで発見され、問題を回避するために`print`のような関数の定義を変更するのは根本的な解決にはなりません。文字列とコンテナを区別する必要のある他のテキスト処理やシリアル化処理でも問題となる可能性があります。また、`char`には2つの意味（文字とバイトの単位）があり、バイト列として使用されている`std::vector<char>`や`std::span<char>`が`std::string_view`として暗黙変換可能になってしまうと型安全性を破壊する可能性があります。

これらの理由から、`std::basic_string_view`のRangeコンストラクタはメリット（主に利便性の向上）よりもデメリットの方が大きいため、P1391R4の内容を全て削除しようとする提案です。

- [P1391R4 Range constructor for `std::string_view`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1391r4.pdf)
- [P2516 進行状況](https://github.com/cplusplus/papers/issues/1174)

### [P2517R0 Add a conditional noexcept specification to std::apply](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2517r0.html)

`std::apply`に`noexcept`指定を行う提案。

C++23に導入される予定の`views::zip`とその仲間は複数のシーケンスを纏めて一つのシーケンスとする`view`で、その`operator*`の結果は元のシーケンスの各要素を纏めた`std::tuple`オブジェクトで返されます。`zip_transform_view`など、その要素に何か関数適用するタイプの`view`では、その効果を指定するために`std::apply`が使用されます。

```cpp
// zip_transform_view::iterator::operator*()の効果の指定
return apply([&](const auto&... iters) -> decltype(auto) {
  return invoke(*parent_->fun_, *iters...);
}, inner_.current_);
```

しかし、この`operator*`の`noexcept`指定は次のように指定されています

```cpp
// Isはzipしている入力範囲の数を指すstd::index_sequence<Is>
noexcept(invoke(*parent_->fun_, *std::get<Is>(inner_.current_)...))
```

ここで`std::apply`が使用されていないのは、`std::apply`に`noexcept`の指定が無いためです。

`std::apply`の効果は次のような`apply-impl`を用いて指定されています。

```cpp
template<class F, class Tuple, size_t... I>
constexpr decltype(auto) apply-impl(F&& f, Tuple&& t, index_sequence<I...>) {
  return INVOKE(std::forward<F>(f), get<I>(std::forward<Tuple>(t))...)
}
```

`std::get`は`ranges::subrange`のものを除いて例外を投げることはありません（`tuple`等の要素の参照を取り出すだけのため）。従って、例外を投げるとすれば`f`を呼び出したときだけだとみなすことができます。`std::invoke`は既に条件付き`noexcept`であるため、`std::apply`を同様にすることができるはずで、この提案はそれを提案するものです。

この提案の内容はすでにlibstdc++とlibc++では実装されているようです。

- [P2517 進行状況](https://github.com/cplusplus/papers/issues/1175)

### [P2520R0 `move_iterator<T*>` should be a random access iterator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2520r0.html)

`std::move_iterator<T*>`を`random_access_iterator`となるようにする提案。

`std::move_iterator<T*>`はC++17イテレータとしてはランダムアクセスイテレータになりますが、C++20イテレータとしては`input_iterator`にしかなりません。

C++17以前にこれについて議論された際に、パフォーマンス上の理由により`move_iterator<I>`は`I`の性質を継承することになりました。しかしC++20にて`<ranges>`追加と共にイテレータライブラリが改修された際、`move_iterator<I>::iterator_concept`は常に`input_iterator`であるようにされました。これによって、C++20`move_iterator`は常に`input_iterator`となります。

```cpp
vector<A> v;
vector<A> temp = ...;

using MI = move_iterator<vector<A>::iterator>;

// MIがランダムアクセスイテレータであることで、ここでのアロケーションを一回で済ませられる
v.insert(v.begin() + N, MI(temp.begin()), MI(temp.end()));
```

`vector::insert`では、挿入される要素数が予めわかっていれば`vector`の領域をあらかじめ拡張しておくことでアロケーションの回数を最小にできます。それができない場合、挿入要素数分`push_back()`するのと同じことになります。

C++20ではイテレータ間距離を求められるかどうかはイテレータカテゴリから分離され、`sized_sentinel_for`（あるいは`sized_range`）コンセプトによって別に指定されます。`move_iterator<I>`は自身のカテゴリとは関係なく、`I`が`sized_sentinel_for<I, I>`であれば`-`によって距離を定数時間で求めることができるため、`move_iterator`が`random_access_iterator`である必要はありません。

一方、このようなコードはC++23では次のように書くこともでき、ここでは`move_iterator`のカテゴリが問題となってきます。

```cpp
// アロケーションは一回
some_sized_range | views::move | ranges::to<vector>();

// アロケーションは要素数による
some_unsized_forward_range | views::move | ranges::to<vector>();
```

`views::move`は入力の`range`の各要素をムーブする`view`で、`ranges::to`はそれをコンテナに変換するものです。`views::move`を通すことで、入力要素をムーブして`vector`を構築することができます。

ここで、`views::move`は`move_iterator`を内部で用いているため、`move_view`のカテゴリは常に`input_iterator`となってしまいます。それでも入力`range`が`sized_range`であれば範囲としての長さを求めることができるため、上記１つ目のコードは`ranges::to`による`vector`構築時にも要素数をあらかじめ求めることができます。しかし、入力が`range`が`sized_range`でない場合はそのイテレータが何であれ`move_view`は`sized_range`ではない`input_range`でしかなく、上記の2つ目のコードでは`ranges::to`による`vector`構築時にその要素数をあらかじめ利用できません。

これは例えば、`move_view`がそういう性質のものであると了解したうえで、そこから元の`range`を`.base()`によって取り出して次に渡すみたいなことをすれば回避できますが、それは明らかに間違っています。この提案は、この問題を回避するためにユーザーがそのようなことをしなくてもいいように、`move_iterator<I>`が`I`の性質を継承するように変更するものです。

`move_view`が`input_range`ではなくなることで、`input_range`では利用できないアルゴリズムで利用できるようになります。`move_view`の性質上、`ranges::min`など、アルゴリズムの中には意図通りに動作しないものがあります。

```cpp
void f(vector<string> words) {
  // この提案以前はinput_range
  auto r1 = words | views::move;

  // 他の全ての要素もムーブされている
  auto min_str = std::ranges::min(r1);
}
```

とはいえこのことは、`move_view`の問題を回避するために`views::transform`を使用したときにも起こります。

```cpp
void f(vector<string> words) {
  // 現在でもrandom_access_range
  auto r2 = words | views::transform([](string& s) -> string&& { return std::move(s); });
  
  // 他の全ての要素もムーブされている
  auto min_str = std::ranges::min(r2);
}
```

つまりは、`move_view`のカテゴリを変更したことによって生じる問題は、`move_view`のカテゴリが`input_range`であることから生じる問題を回避する場合にも生じます（これは現在でも起こり得ます）。ここでの一番の問題は、このような回避策を適用した方が一部の場合でパフォーマンスが良いため、このような構文が推奨されてしまう事です。この問題は標準ライブラリで解決されるべきです。

- [LWG Issue 1211. Move iterators should be restricted as input iterators](https://cplusplus.github.io/LWG/issue1211)
- [P2520 進行状況](https://github.com/cplusplus/papers/issues/1176)

### [P2521R0 Contract support -- Working Paper](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2521r0.html)

C++に最小の契約プログラミングサポートを追加する提案。

この提案は、現在アクティブな契約関連の提案であるP2388R4とP2461R1をベースとして、SG21でコンセンサスが得られているものとそうでないものとを明確にするためのものです。

従って、P2388R4とP2461R1で議論されていない事は含まれておらず、多くの部分がP2388R4の内容に基づいています。その上で次の部分を未解決の問題としています

1. 構文の選択
2. 契約術後の副作用除去と重複
3. 事後条件で参照される非参照引数の扱い

これらのことをシンプルに書き下していく事で、SG21におけるコンセンサスを文書化しています。

- [P2388R4 Minimum Contract Support: either No_eval or Eval_and_abort](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2388r4.html)
- [P2461R1 Closure-Based Syntax for Contracts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf)
- [P2521 進行状況](https://github.com/cplusplus/papers/issues/1177)

### [P2523R0 Request for re-inclusion of `std::hive` proposal in C++23](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2523r0.html)

`std::hive`をC++23に含めるよう求める提案。

`std::hive`（P0447）はC++26への導入を目指して作業されることになっており、C++23に導入されないことが決定されています。この提案はこれを覆そうとするものです。

しかし、C++23の*design freeze*がすぐそこ（太平洋時間の2022/2/7）に迫っており、P0447が大きいこともあってこれはすでに否決（LEWG議長の裁量による？）されています。

- [P2523 進行状況](https://github.com/cplusplus/papers/issues/1178)

### [P2524R0 SG14: Low Latency/Games/Embedded/Finance/Simulation 2020/12/09-2022/01/12](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2524r0.pdf)

SG14（Low Latency/Games Dev/Embedded/Financial/Trading/Banking/Simulation等に関するStudy Group）の2020年12月から2022年1月までの間の9回のミーティングの議事録。

### [P2525R0 SG19: Machine Learning Meeting Minutes 2020/12/10-2022/01/13](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2525r0.pdf)

SG19（機械学習に関するStudy Group）の2020年12月から2022年1月までの間の10回のミーティングの議事録。

### [P2527R0 `std::variant_alternative_index` and `std::variant_alternative_index_v`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2527r0.html)

`std::variant`に対して、型からそのインデックスを取得するための方法を追加する提案。

`std::variant`に対する`std::get()/std::get_if()`はインデックスもしくは型を指定して値を取り出すことができ、`std::variant_alternative`によってインデックスに対応する型を取得することができます。しかし、型に対応するインデックスを取得する方法は用意されていません。

この提案は、`std::variant_alternative_index`としてそれを追加しようとするものです。

インデックス指定に従うシリアライズ/デシリアライズを行うサンプル。

```cpp
struct Reset { };
struct Close { };
struct RunCommand { std::string command; };

using Action = std::variant<Reset, Close, RunCommand>;

void serializeAction(const Action& action, std::vector<uint8_t>& buffer) {
  // 現在のvariantのインデックスを先頭に保存
  buffer.push_back(action.index());

  if (auto* runCommand = std::get_if<RunCommand>(&action); runCommand != nullptr) {
    serializeString(runCommand->command, buffer);
  }
}

std::optional<Action> deserializeAction(std::span<const uint8_t> source) {
  if (source.size() == 0) {
    return std::nullopt;
  }

  // 先頭にあるインデックスによるswitch分岐
  switch (source[0]) {
  case std::variant_alternative_index_v<Reset, Action>:
    return Reset { };
  case std::variant_alternative_index_v<Close, Action>:
    return Close { };
  case std::variant_alternative_index_v<RunCommand, Action>:
    return RunCommand { deserializeString(source.subspan(1)) };
  }

  return std::nullopt;
}
```

このサンプルは、Webkitにおいて`std::variant_alternative_index`相当のものを実装するきっかけとなったもののようです。

- [P2527 進行状況](https://github.com/cplusplus/papers/issues/1181)
