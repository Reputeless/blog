#  ［C++］コンセプトの文脈におけるmeet、satisfyとmodelの使い分けについて

どれもあるコンセプトを満たすという意味で使われているのですが、標準ライブラリでは明確な使い分けがなされているようです。

### *meet*

*meet*が使われるのはC++17までの名前付き要件を使用しているところです。それはC++20からは`Cpp17CopyConstructible`のような名前になっています。

これらの名前付き要件はコンセプトのように構文的にチェックされるわけではなく、満たすべき要件は規格書に記述されており、それを使用する所では入ってくる型は暗黙にそれを満たしているものとして扱います。  
この制約には型が満たすべき静的なものと、実際の値が満たすべき動的なものの2種類が含まれます。

特にイテレータが絡む所での`InputIterator`などがお馴染みでしょうか。

このような制約を仮に満たさなかった場合プログラムはill-formdとなりますが、必ずしもそれはコンパイルエラーになるとは限りません。ひょっとしたら実行時にすらエラーとはならないかもしれません。未定義動作の世界です。

これは原初のSTL時代からの制約手法でありますが、C+20以降はコンセプトを使用することが望ましく、標準ライブラリからも次第に姿を消していくでしょう・・・


### *satisfy*

*satisfy*が使われるのはコンセプトを使用している文脈です。  
特に、「*Constraints: T satisfies C*」みたいに使われるようです。これは、（テンプレートパラメータに対する）制約として型TはコンセプトCを満たしていること、のような意味です。

この場合の満たしている（*satisfy*）とは、そのコンセプトによってチェックされる構文的（Syntactic）な制約を満たしていること、という意味です。

構文的な制約はコンセプトによってコンパイル時にチェックされるため、制約を満たさない場合は必ずコンパイルエラーになります。  
このことからもわかるように、この制約には型が満たしているべき静的なものだけが含まれます。


### *model*

*model*が使われるのはコンセプトを定義、使用している文脈の両方です。

コンセプト定義の文脈では、「*T models C only if 条件列*」のように使用されます。

ライブラリ中で使用される際は、「*Preconditions: T models C.*」のように使用されます。

### 実際の利用例


### 参考文献

- [Library-wide: Use "model" instead of "satisfy" with library concept requirements - cplusplus/draft](https://github.com/cplusplus/draft/pull/2797)
- [P0898R3 Standard Library Concepts (comment) - cplusplus/draft](https://github.com/cplusplus/draft/pull/2176#discussion_r196590990)
- [モデルとは何か? -  北海道大学大学院情報科学研究科 システム環境情報学特論](http://dse.ssi.ist.hokudai.ac.jp/~onosato/lectures/DSE19/H19-Model.pdf)

### 謝辞

この記事の9割は以下の方々によるご指摘によって成り立っています。

- [yohhoyさん](https://twitter.com/yohhoy/status/1177578518164561922)