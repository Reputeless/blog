# TU-local Entityの漏洩の禁止


### モジュールと内部リンケージ名

内部リンケージをもつエンティティ（関数、クラスや変数）は、外部リンケージをもつ関数など、翻訳単位のインターフェースの実装詳細をある粒度で分解して表現するために使用されています。それによって、プログラムの保守性や再利用可能性の向上が見込めます。

従来のヘッダファイルとソースファイルからなる一つの翻訳単位の構成においては、内部リンケージ名はソースファイル内に隠蔽されているか、ヘッダファイルに書かれていてもヘッダをインクルードした翻訳単位それぞれで内部リンケージを持つ別のものとして扱われるため、内部リンケージを持つエンティティが翻訳単位外部から参照されることはありませんでした。

しかしC++20以降のモジュールにおいては、そのインターフェース単位で定義されている内部リンケージ名がそのモジュール（インターフェース単位）をインポートした先の翻訳単位からも参照できてしまいます。

ヘッダファイルとは異なり、モジュールのインターフェース単位は一つの翻訳単位であり、そのインポートはインターフェース単位にあるすべての宣言を（インポートした側から）到達可能にし、エクスポートされている宣言を可視にします。この到達可能性は、内部リンケージを持つ名前であってもインポートした側の翻訳単位の宣言に影響を及ぼす可能性があります。

また、モジュールで定義されたテンプレートがインスタンス化されたとき、インスタンス化が発生した地点から定義に至る一連のインスタンス化経路上で可視になっている宣言を参照することができます。このインスタンス化経路は翻訳単位を超えて定義され、そこでは内部リンケージを持つ名前を参照することができます。

どちらの場合も、直接的に別の翻訳単位にある内部リンケージを持つ名前を参照できるわけではありませんが、間接的に内部リンケージを持つ名前が翻訳単位から露出してしまっています。

そのため、最終的なC++20モジュール仕様では、内部リンケージを含めた翻訳単位ローカルのエンティティ（*TU-local Entities*）が翻訳単位の外から間接的にも直接的にも参照されることが禁止されました。




### TU-local Entities？

### TU-local Entityの暴露（*exposure*）

### 参考文献
- [P1815R2: Translation-unit-local entities](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1815r2.html)
- [P1779R3: ABI isolation for member functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1779r3.html)
- [P1498R1 Constrained Internal Linkage for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1498r1.html)