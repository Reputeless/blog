# ［C++］WG21月次提案文書を眺める（2023年01月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-01](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-01)

SG22のWG14からのものを除いて、全部で84本あります（R0が36本、R1以上で見てないのが6本）

[:contents]

### [N4928 Working Draft, Standard for Programming Language C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4928.pdf)

C++23のワーキングドラフト第8弾。

### [N4929 Editors' Report - Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4929.html)

↑の変更点をまとめた文書。

11月のKona会議で採択された提案とコア言語/ライブラリのIssue解決が適用されています。

### [N4933 WG21 November 2022 Kona Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4933.pdf)

2022年11月7-12日にハワイのKonaで行われた、WG21全体会議の議事録。

開催期間中の各グループの活動報告や、CWG/LWG/LEWGの投票の様子などが記載されています。

### [N4934 2023 WG21 admin telecon meetings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4934.pdf)

2023年（今年）のWG21管理者ミーティングの予定表。

### [N4935 2023 Varna Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4935.pdf)

2023年6月にブルガリアのヴェルナで開催される予定のWG21全体会議のインフォーメーション。

主に開催場所やその注意点などが記載されています。

### [N4936 2023-11 Kona meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4936.pdf)

2023年11月にハワイのKonaで開催される予定のWG21全体会議のインフォーメーション。

同上。

### [N4937 Programming Languages — C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n4937.pdf)

次期標準ライブラリ機能候補の実装経験を得るためのTSである、Library Fundamental TS v3のFDIS。

### [N4939 Working Draft, C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4939.html)

次期標準ライブラリ機能候補の実装経験を得るためのTSである、Library Fundamental TS v3のドラフト文書。

おそらく内容はN4937と同一です。

### [N4938 Editor's Report: C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4938.html)

↑の変更点を記した文書。

この版での変更は、typoの修正などです。

### [P0260R5 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0260r5.html)

標準ライブラリに並行キューを追加するための設計を練る提案。

キューはシステムコンポーネント間のデータのやり取りの方法を提供する基礎的なものです。現在のC++標準ライブラリにも`std::deque`などが用意されていますが、それらは全てシーケンシャルなデータ構造であり、その要素アクセスとキューの操作を並行に行うことができません。そのため、並行キューを導入するためには、それらとは別のものが必要となります。

さらに、並行性の要求はパフォーマンスとそのセマンティクスに新たな評価軸を追加し、並行キューにおいては競合しない操作のコスト、競合する操作のコスト、要素の順序保証をトレードオフにする必要があり、これによって既存のキューよりもセマンティクスが弱くなります。

そのような対立軸にはたとえば

- 固定長 vs 可変長
- ブロッキング vs 上書き
- シングルエンド vs マルチエンド
- 厳密なFIFOによる順序 vs 優先度による順序

などがあります。

この提案は今の所、そのような並行キューのインターフェースのベースとなる概念的なインターフェースの要件を定義しています。

**基本操作**

並行キューイングの問題に対する本質的な解決策は、参照ベースではなく値ベースの操作へ以降することです。そのために次の2種類の基本操作を定義しています

```cpp
// 要素をキューイングする
void queue::push(const Element&);
void queue::push(Element&&);

// 要素をキューから取り出す
// 要素はコピーではなくムーブされる
void queue::pop(Element&);
```

ここでの`queue`は特定のキューを示すものではなく、コンセプト的なプレースホルダです。

これらの操作はまたブロッキングを伴う操作でもあり、キューが満杯/空の場合に待機し、操作の競合を回避するためにブロックされる可能性があります。

**即時操作**

満杯/空のキューで待機すると操作が完了するまでにしばらく時間を要する可能性があり、機会費用がかかります。この待ち時間を回避することで、満杯/空のキューで操作の完了を待機する代わりに他の作業を行うことができます。そのために、次の2種類の即時操作（待機しない操作）を定義しています

```cpp
// キューが満杯/クローズ状態の場合はその状態を返し、そうではない場合にキューイングしqueue_op_status::successを返す
queue_op_status queue::try_push(const Element&);

// キューが満杯/クローズ状態の場合はその状態を返し、第一引数を第二引数へムーブする
// そうではない場合にキューイングしqueue_op_status::successを返す
queue_op_status queue::try_push(Element&&, Element&);

// キューが空ならqueue_op_status::emptyを返し
// そうではない場合に要素をキューから取り出し（コピーではなくムーブされる）、queue_op_status::successを返す
queue_op_status queue::try_pop(Element&);
```

`queue_op_status`は次のようなスコープ付き列挙型です

```cpp
enum class queue_op_status { 
  success, 
  empty,
  full,
  closed
};
```

これらの操作はキューが満杯/空の場合にブロックしませんが、操作の競合を回避するためにブロックされる可能性があります。

**キューのクローズ**

通信にキューを使用しているスレッドでは、キューが不要になった場合にそのキューを使用している他のスレッドにそのことを通知するメカニズムが必要になる場合があります。典型的には、それはキューとは別の条件変数やアトミック変数などの帯域外信号が使用されます。ただし、このアプローチでは、そのキューで待機している他のスレッドを起床しなければならない問題があり、そのためにキューの満杯/空のブロッキングに使用される条件変数にアクセスする必要が出てくるなど、インターフェースの複雑さと危険性を増大させます。また、ミューテックスやアトミック変数を使用することでパフォーマンスに影響が及ぶ可能性もあります。

そのため、この提案ではそのようなシグナルをキュー自体でサポートすることを選択しており、これによってコーディングがかなり簡素化されます。

このシグナルのために、キューはクローズ（`close()`）を行うことができます。あるスレッドでキューがクローズされると新しい要素をそのキューに挿入（`push`）することができなくなります。クローズ済キューに対する挿入操作は`queue_op_status::closed`を返すか例外としてスローします。キューに存在する要素は取り出し（`pop`）が可能ですが、キューが空でクローズされている場合、取り出し操作は`queue_op_status::closed`を返すか例外としてスローします。

```cpp
// キューを閉じる
void queue::close() noexcept;

// キューが閉じられていればtrueを返す
bool queue::is_closed() const noexcept;

// キューが閉じられていればqueue_op_status::closedを返す
// そうでないならば、要素をキューイングする
queue_op_status queue::wait_push(const Element&);
queue_op_status queue::wait_push(Element&&);

// キューが空で閉じられていればqueue_op_status::closedを返す
// そうではなく、キューが空ならばqueue_op_status::emptyを返す
// それ以外の場合、キューから要素を取り出しqueue_op_status::successを返す
queue_op_status queue::wait_pop(Element&);
```

`wait_`とある`push/pop`操作は、キューが閉じられている場合に例外を回避するためのインターフェースです。この操作はキューが閉じられておらず満杯/空の場合に待機し、操作の競合を回避するためにブロックされる可能性があります。

クローズ後のキューを再開したいユースケースがあり、この提案ではそのためのインターフェースも定義しています

```cpp
// キューをオープンする
void queue::open();
```

キューを再開する機能が困難になる実装は現在把握されてはいませんが、存在する可能性があります。また、キューの再開は通常キューが閉じていて空の場合にのみ呼び出すことができ、これによってクリーンな動機ポイントを提供することができます。ただし、空でないキューで`open()`を呼び出すことは可能です。

`is_closed()`が`false`を返す場合でも、他のスレッドがキューを同時にクローズする可能性があるため、後続の操作でキューが閉じられている保証はありません。

オープン操作が利用できない場合、キューが閉じられるとキューは閉じたままになるという保証があります。したがってその場合、プログラマが他のすべてのスレッドがキューを閉じないように細心の注意を払わない限りは、`is_closed()`の戻り値は`true`のみが意味を持ちます。

キューの再開にはこれらの問題があるため、この提案ではこのインターフェースを提案してはいません。

**要素型の要件**

上記の操作のためには、要素型にはコピー/ムーブコンストラクタ、コピー/ムーブ代入演算子、及びデストラクタが必要になります。

コンストラクタと代入演算子は例外を投げる可能性がありますが、後続の操作のためにはオブジェクトを有効な状態のままにしておく必要があります。

**例外ハンドリング**

基本操作の2つの操作（`push()/pop()`）はキューの状態によって例外を投げる可能性があります。その例外オブジェクトは`std::exception`の派生クラスであり、`queue_op_state`の値を含んでいる必要があります。

他のスレッドがキューの状態を監視している時に変更を透過的に元に戻すことができないため、並行キューは要素型がスローした例外の影響を完全に隠すことはできません。そのような例外は要素型のコピー/ムーブコンストラクタ及びコピー/ムーブ代入演算子から投げられる可能性があります。

それ以外の場合、キューは、メモリ確保、キューテックス、条件変数から例外を再スローする可能性があります。

要素のコピー/ムーブが例外を投げる可能性がある場合、一部のキュー操作には追加の動作が定義されています

- 構築時は例外を再スローし、構築しようとしていた要素を破棄する
- 挿入操作は再スローし、キューの状態は変化しない
- 取り出し操作は再スローし、取り出そうとしていた要素はキューから取り除かれる（要素は実質的に失われる）


この提案ではこれらの要件に沿った具体的なキューを提案してはいませんが、[P1958R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1958r0.html)でその一つである`buffer_queue`が提案されている他、[google-concurrency-library](https://github.com/alasdairmackintosh/google-concurrency-library)にこの提案の初期のインターフェースをベースとした実装があります。

この提案は、フィードバックを得るためにConcurrency TS v2入りを目指しています。

- [P0260 進行状況](https://github.com/cplusplus/papers/issues/99)

### [P0342R1 What does "current time" mean?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0342r1.pdf)

`<chrono>`の時計型の`now()`が最適化によって並べ替えられないようにする提案。

`<chrono>`の時計型（`steady_clock`など）はその静的メンバ関数`now()`によってその時計の示す現在の時刻（*current point in time*）を取得することができます。しかし、この現在の時刻が何を指すのか不明瞭であり、必ずしもコードに記述した実行地点での現在時刻を取得しないことがあります。

提案より、サンプルコード

```cpp
#include <chrono>
#include <atomic>
#include <iostream>

std::size_t fib(std::size_t n) {
  if (n == 0)
    return n;
  if (n == 1)
    return 1;
  return fib(n - 1) + fib(n - 2);
}
int const which{42};

int main() {
  // fib()の実行にかかる時間を計測する
  auto start = std::chrono::high_resolution_clock::now(); // #1
  auto result = fib(which);                               // #2
  auto end = std::chrono::high_resolution_clock::now();   // #3

  std::cout << "fib(" << which << ") is " << result << std::endl;
  std::cout << "Elapsed time is "
            << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()
            << "ms" << endl;

  return 0;
}
```

[godbolt](https://godbolt.org/z/ofvfd7WbK)

このようなコードはかなり基本的なものですが、少なくともMSVCは最適化を有効にすると`#2 #3`の順番を入れ替えて、`#1 -> #3 -> #2`のように実行してしまい、結果0msが出力されます。このような最適化は標準の範囲内で許可されているため、この最適化自体は合法です。

これはシングルスレッドプログラムにおける実行順序の並べ替えであるため、標準の範囲内で回避するのは難しいようです。ファイルを分割することで回避できるようですが、それもプログラム全体の最適化やリンク時最適化を考慮すると確実なものとは言えません。また、この問題はコンパイラによっては起こらないかもしれず、回避策を含めたこのようなコードの移植性を損ねています。

プログラム中で現在のタイムスタンプを取得するという単純な処理にすらこのような罠が潜んでいて回避が難しいというのは大きな問題であり、この提案はその改善のためのものです。

この提案ではこの問題の解決のためにいくつかの方法を挙げています

- 標準を変更はしないが、ガイダンスを充実させる
    - SG20で配布可能なガイダンスを作成するだけでも教育者には大きな助けになる
- 編集上の変更を加える
    - ↑のガイダンスを標準に記述する
- `now()`の並べ替えを禁止する
    - このアプローチはR0の議論において実装可能性について懸念があった
- シングルスレッドフェンスを導入する
    - この問題が発生するのは時刻取得に止まらないと考えられるため、このユースケースに応えるためにより一般的なソリューションを提供する
    - このアプローチはR0で提案していたものだったが、実装可能性について懸念があった

ただし、現在のところどれかを選択してはいません。

この提案のR0ではこの問題の解決のためのシングルスレッドフェンスを提案していましたが、2016年にレビューされた際にはその実装可能性の懸念などから受け入れられず、提案の追求はストップしていました。しかし、2022年のKona会議におけるSG1のミーティング中にこの問題が取り上げられ、この提案の改訂版が望まれたことで、とりあえず問題を整理したR1（このリビジョン）が再度提出されました。

著者の方やSG1のメンバは、現在の時刻の取得という単純なタスクでプログラマが直面するこの問題は、現状の改善をより広く検討するのに十分に深刻だと考えているようです。

- [P0342 進行状況](https://github.com/cplusplus/papers/issues/1417)
- [C++標準化委員会の文書: P0340R0-P0349R0 - 本の虫](https://ezoeryou.github.io/blog/article/2016-08-09-cpp-P0340R0-P0349R0.html#:~:text=P0342R0%3A%20Timing%20barriers)

### [P0792R12 function_ref: a non-owning reference to a Callable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0792r12.html)
### [P1383R1 More constexpr for `<cmath>` and `<complex>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1383r1.pdf)

`<cmath>`と`<complex>`の数学関数を`constexpr`にする提案。

`<cmath>`の数学関数をはじめとする浮動小数点数を扱うものを`constexpr`対応させるにあたって問題となっているのは、同じ浮動小数点数値に対するある関数の結果がコンパイラの設定やプラットフォーム、実行タイミング等のコンテキストによって等しい必要があるのか？という点です。明らかにそうなって欲しいのですが、浮動小数点数の特性などの事情によってそれは実際には困難であり、そうするとそれら関数の実行結果についてどのように規定するのか、あるいはどのような保証を与えるのか？が問題となります。

C++23におけるP0533R9による`<cmath>`等の関数の`constexpr`対応にあたってもそのような問題の議論を回避するために、四則演算（`+ - * /`）よりも（その事情の下では）複雑でないとみなされる関数のみが`constexpr`対応されました。

この提案は次のような設計指針によって、`<cmath>`と`<complex>`にあるほぼすべての数学関数を`constexpr`対応させようとしています

1. 数学関数の実行結果が実行時とコンパイル時で異なることを許容する
2. 数学関数の定数実行が異なるプラットフォームで異なることを許容する
3. `<cmath>`内の既存関数に正確な動作を義務付けるのではなく、QoIの定量化を奨励することが望ましい

そもそも実行時における現在の`<cmath>`の数学関数や浮動小数点演算は、異なるコンパイラやプラットフォームの間、あるいは異なるコンパイラオプション（`-ffast-math`など）の間で結果が一致しないことはない間許容されています。また、定数式では数学関数を呼び出さない浮動小数点演算は可能であり、規格も利用者もその結果の実行時とコンパイル時の差異を許容してきています（実行時における丸めモードの変更やFMAの利用など）。

`costexpr`な数学関数にのみ過剰な正確性や結果の一貫性を要求することは、実装の困難さを高めるとともにそれそのものが実行時とコンパイル時の出力差の原因となります。そのためこの提案では、許容されている現在の実行時の振る舞いをベースとした設計指針によって数学関数を`constexpr`対応させる方針を押しています。

- [P1383 進行状況](https://github.com/cplusplus/papers/issues/168)

### [P1673R11 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r11.html)
### [P1684R4 mdarray: An Owning Multidimensional Array Analog of mdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1684r4.html)
### [P1883R2 file_handle and mapped_file_handle](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1883r2.pdf)
### [P1928R2 Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r2.pdf)
### [P1967R10 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1967r10.html)
### [P2013R5 Freestanding Language: Optional ::operator new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2013r5.html)
### [P2047R5 An allocator-aware optional type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2047r5.html)
### [P2075R2 Philox as an extension of the C++ RNG engines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2075r2.pdf)
### [P2164R9 views::enumerate](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2164r9.pdf)
### [P2169R3 A Nice Placeholder With No Name](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r3.pdf)
### [P2198R6 Freestanding Feature-Test Macros and Implementation-Defined Extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2198r6.html)
### [P2198R7 Freestanding Feature-Test Macros and Implementation-Defined Extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2198r7.html)
### [P2338R3 Freestanding Library: Character primitives and the C library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2338r3.html)
### [P2363R4 Extending associative containers with the remaining heterogeneous overloads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r4.html)
### [P2406R1 Fix counted_iterator interaction with input iterators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2406r1.html)
### [P2406R2 Add lazy_counted_iterator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2406r2.html)
### [P2407R2 Freestanding Library: Partial Classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2407r2.html)
### [P2508R2 Exposing std::basic-format-string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2508r2.html)
### [P2530R2 Why Hazard Pointers should be in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2530r2.pdf)
### [P2537R2 Relax va_start Requirements to Match C](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2537r2.html)
### [P2545R2 Why RCU Should be in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r2.pdf)
### [P2570R2 Contract predicates that are not predicates](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2570r2.html)
### [P2591R2 Concatenation of strings and string views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2591r2.html)
### [P2616R3 Making std::atomic notification/wait operations usable in more situations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2616r3.html)
### [P2630R2 Submdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r2.html)
### [P2636R2 References to ranges should always be viewable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2636r2.html)
### [P2642R2 Padded mdspan layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2642r2.html)
### [P2656R1 C++ Ecosystem International Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2656r1.html)
### [P2659R2 A Proposal to Publish a Technical Specification for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2659r2.pdf)
### [P2675R1 LWG3780: The Paper (format's width estimation is too approximate and not forward compatible)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2675r1.pdf)
### [P2677R2 Reconsidering concepts in-place syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2677r2.pdf)
### [P2680R1 Contracts for C++: Prioritizing Safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2680r1.pdf)
### [P2689R1 atomic_accessor](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2689r1.html)
### [P2700R1 Questions on P2680 "Contracts for C++: Prioritizing Safety"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2700r1.pdf)
### [P2713R0 Escaping improvements in std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2713r0.html)
### [P2713R1 Escaping improvements in std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2713r1.html)
### [P2714R0 Bind front and back to NTTP callables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2714r0.html)
### [P2717R0 Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2717r0.html)
### [P2723R1 Zero-initialize objects of automatic storage duration](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2723r1.html)
### [P2724R0 constant dangling](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2724r0.html)
### [P2725R1 std::integral_constant Literals](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2725r1.html)
### [P2728R0 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2728r0.html)
### [P2729R0 Unicode in the Library, Part 2: Normalization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2729r0.html)
### [P2730R0 variable scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2730r0.html)
### [P2732R0 WG21 November 2022 Kona meeting Record of Discussion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2732r0.pdf)
### [P2733R0 Fix handling of empty specifiers in std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2733r0.html)
### [P2734R0 Adding the new 2022 SI prefixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2734r0.pdf)
### [P2736R0 Referencing the Unicode Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2736r0.pdf)
### [P2737R0 Proposal of Condition-centric Contracts Syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2737r0.pdf)
### [P2738R0 constexpr cast from void*: towards constexpr type-erasure](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r0.pdf)
### [P2739R0 A call to action: Think seriously about "safety" then do something sensible about it](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2739r0.pdf)
### [P2740R0 Simpler implicit dangling resolution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2740r0.html)
### [P2741R0 user-generated static_assert messages](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2741r0.pdf)
### [P2742R0 indirect dangling identification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2742r0.html)
### [P2743R0 Contracts for C++: Prioritizing Safety - Presentation slides of P2680R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2743r0.pdf)
### [P2746R0 Deprecate and Replace Fenv Rounding Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2746r0.pdf)
### [P2747R0 Limited support for constexpr void*](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2747r0.html)
### [P2748R0 Disallow Binding a Returned glvalue to a Temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2748r0.html)
### [P2750R0 C Dangling Reduction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2750r0.html)
### [P2751R0 Evaluation of Checked Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2751r0.pdf)
### [P2752R0 Static storage for braced initializers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2752r0.html)
### [P2756R0 Proposal of Simple Contract Side Effect Semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2756r0.pdf)
### [P2757R0 Type checking format args](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2757r0.html)
### [P2758R0 Emitting messages at compile time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2758r0.html)
### [P2759R0 DG Opinion on Safety for ISO C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2759r0.pdf)
### [P2762R0 Sender/Receiver Interface For Networking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2762r0.pdf)
### [P2763R0 `layout_stride` static extents default constructor fix](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2763r0.html)
### [P2764R0 SG14: Low Latency/Games/Embedded/Finance/Simulation virtual meeting minutes 2023/01/11](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2764r0.pdf)
### [P2765R0 SG19: Machine Learning Virtual Meeting Minutes 2022/12/08-2023/01/12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2765r0.pdf)
### [P2766R0 SG16: Unicode meeting summaries 2022-10-12 through 2022-12-14](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2766r0.html)
### [P2769R0 get_element customization point object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2769r0.html)
