# ［C++］WG21月次提案文書を眺める（2023年07月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-07](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-07)

全部で106本あります。

### [N4955 WG21 2023-06 Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4955.pdf)

2023年6月に行われた、WG21管理者ミーティングの議事録

### [N4957 WG21 February 2023 Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4957.pdf)

2023年6月に行われた、WG21全体会議の議事録

### [P0260R6 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0260r6.html)
### [P0260R7 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0260r7.html)
### [P0543R3 Saturation arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0543r3.html)
### [P0843R7 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0843r7.html)
### [P0843R8 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0843r8.html)
### [P0901R11 Size feedback in operator new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0901r11.html)
### [P1030R6 std::filesystem::path_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1030r6.pdf)
### [P1324R1 RE: Yet another approach for constrained declarations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1324r1.html)

制約付きの`auto`による関数宣言構文において、そのテンプレートパラメータ名を直接導入できる構文の提案。

この提案のモチベーションは以前に紹介したP2677R0と共通なので、以前の記事を参照

- [P2677R0 Reconsidering concepts in-place syntax - ［C++］WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2677R0-Reconsidering-concepts-in-place-syntax)

P2677では`auto:T`のような構文でテンプレートパラメータ名を導入しようとしていましたが、この提案は`void sort(Sortable auto& c);`を`void sort(Sortable S& c);`のように書けるようにすることで、`auto`の代わりに直接テンプレートパラメータ名を導入しようとするものです。

```cpp
namespace current {
  // 現在の制約付きauto関数テンプレート
  void f(Sortable auto&& x) {
    using S = decltype(x); // テンプレートパラメータ名Sを取り出す
    // use S
  }
}

namespace p2677 {
  // P2677提案の制約付き関数テンプレート
  void f(Sortable auto:S&& x) // テンプレートパラメータ名Sが導入される
  {
    // use S
  }
}

namespace p1324 {
  // この提案による制約付き関数テンプレート
  void f(Sortable S&& x) // テンプレートパラメータ名Sが導入される
  {
    // use S
  }
}
```

この提案ではさらに、この構文を戻り値型制約や変数宣言に対する制約にまで広げています

```cpp
// 現在
void f(Sortable auto x);
Sortable auto f(); 
Sortable auto x = f(); 
template <Sortable auto N>void f();

// この提案
void f(Sortable S x);             // 関数引数のテンプレートパラメータ導入
Sortable S f();                   // 関数戻り値型のテンプレートパラメータ導入
Sortable S x = f();               // 変数宣言時の型名エイリアス導入
template <Sortable S N> void f(); // NTTP宣言時のテンプレートパラメータ導入
```

ただし、コンセプト パラメータ名 変数名、のような宣言であるため、変数名を省略するとコンパイルエラーになります。

```cpp
// Numberはコンセプトとする

void f(Number N);     // ng、Numberが型名ではない
void f(Number auto);  // ok、テンプレートパラメータ名も変数名も導入されない
void f(Number N __);  // 別の提案（P1110）で提案されていたプレースホルダ
```

この制限によって、通常の関数とジェネリックな関数が混同されることが無くなります

```cpp
void f(Foo V)     // 2id: 常に通常の関数宣言
void f(Foo F V)   // 3id: ジェネリック関数（この提案）
void f(Foo auto)  // 1id + auto: ジェネリック関数
```

この宣言によって導入されたテンプレートパラメータ名は以降の引数宣言のために使用できるほか、別のコンセプトのために使用することもできます

```cpp
// Number, Concept, AnotherConceptは何かコンセプトとする

// 1つのテンプレートパラメータで2つの引数を宣言する
void f(Number N x, N y) { }

// 複数のコンセプトでそれぞれ変数を宣言し、テンプレートパラメータ名を別のコンセプトで使用する
Concept R f(Number N a, AnotherConcept<R> U b); 
```

- [P2677R0 Reconsidering concepts in-place syntax - ［C++］WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2677R0-Reconsidering-concepts-in-place-syntax)
- [P1324 進行状況](https://github.com/cplusplus/papers/issues/68)

### [P1383R2 More constexpr for cmath and complex](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1383r2.pdf)
### [P1729R2 Text Parsing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1729r2.html)

`std::format`の対となるテキストスキャン機能の提案。

C++20で`std::format`が追加されたことで、いくつか問題を抱えていた従来のテキスト書式付き出力機能である`std::ostream`や`printf`等に代わるものをC++は手に入れました。しかし、テキスト入力面では改善はなく、同様に問題を抱えている従来の`std::istream`や`scanf`等を利用するしかありません。`std::format`の対となるものを欠いているということでもあり、このことは標準ライブラリの一貫性を損ねてもいます。

この提案は、`std::format`の対となる書式付きテキスト入力機能`std::scan`を提供し、その欠けている部分を補おうとするものです。

基本的な使用法

```cpp
if (auto result = std::scan<std::string, int>("answer = 42", "{} = {}")) {
  //                        ~~~~~~~~~~~~~~~~   ~~~~~~~~~~~    ~~~~~~~
  //                          output types        input        format
  //                                                           string

  const auto& [key, value] = result->values();
  //           ~~~~~~~~~~
  //           読み取られた値

  // result == true
  // result.begin() points to the end of the given input (the null terminator)
  // key == "answer"
  // value == 42
} else {
  // エラーが起きた場合
  // result.error()からエラー情報を取得できる
}
```

基本的には、`std::scan<Types...>(input, format)`のようにして、入力文字列`input`に対するフォーマット文字列を`format`、型指定を`Types`に渡して使用します。フォーマット文字列の構文はほぼ`std::format`のものと共通しており、入力文字列とフォーマット文字列をマッチして、フォーマット文字列中の置換フィールド`{}`のある位置に対応する入力文字列中の文字列を`Types`の対応する位置にある型の値として読み取ります。

```cpp
auto input = "25 54.32E-1 Thompson 56789 0123";

auto result = std::scan<int, float, string_view, int, float, int>(
  input, "{:d}{:f}{:9}{:2i}{:g}{:o}");

// resultはstd::expected、 operator->は失敗時に例外をスローする
auto [i, x, str, j, y, k] = result->values();

// i == 25
// x == 54.32e-1
// str == "Thompson"
// j == 56
// y == 789.0
// k == 0123
```

`std::scan<Types...>(...)`の結果は`std::expected`で返されており、成功時は`std::scan_result`という型の値に対して`.value()`関数を呼ぶことでスキャン結果を`std::tuple<Types...>`オブジェクトとして得ることができます。

スキャン対象の入力は文字列に限らず、スキャン可能な範囲をとることができます。この要件は`scannable_range`コンセプトで表現されています。

```cpp
// scannable_rangeの定義例
template <class Range, class CharT>
concept scannable_range =
  ranges::forward_range<Range> && same_as<ranges::range_value_t<Range>, CharT>;
```

`forward_range`でありその要素型が`CharT`（文字型）であるような範囲であれば読み取ることができ、文字列の範囲となっている多くのものを対象にしています。

```cpp
// views::reverseからの読み取り例

std::string input{"123 456"};
if (auto result = std::scan<int>(std::views::reverse(input), "{}")) {
  // 読み取り対象の値が1つなら、result->value()はそのオブジェクトを直接返す
  // result->value() == 654
}
```

`std::scan`においては`scannable_range`に与えられる`CharT`はフォーマット文字列の文字型から取得されるため、入力文字列とフォーマット文字列の文字型は一致している必要があります。

```cpp
std::scan<int>("42", "{}");   // OK
std::scan<int>(L"42", L"{}"); // OK
std::scan<int>(L"42", "{}");  // Error: wchar_t[N] is not a scannable_range<char>
```

エラー時は`scan_error`という専用のエラー型（列挙型ではない）の値が得られ、`.code()`からエラーコードが取得できるほか`.msg()`からエラーメッセージを取得することができます。

```cpp
if (auto result = std::scan<std::string, int>("answer = 42", "{} = {}")) {
  ...
} else {
  // エラーが起きた場合
  auto err = result.error();

  auto ec = err.code(); // エラーコードの取得
  std::println("Error! : {:s}", err.msg()); // エラーメッセージの出力
}
```

フォーマット文字列は`std::format`にほとんど準じていますが、数値型に対する一部のオプションは無効化されます

- *sign* : `+ -`およびスペース
  - 符号の指定
- *alt* : `#`
  - 代替表示形式、整数型の場合は基数プリフィックス、浮動小数点数型の場合は小数点を常に表示する
- *pad* : `0`
  - 先頭のゼロフィル
- *precision* : `.`+数値
  - 浮動小数点数型の精度指定

これらのオプションは読み取り時には意味がなく、スキャン時は全ての可能性を考慮しどれかの形式をデフォルトにしたり無効化することを回避しています。

そのほかのオプションは利用可能となりますが、出力ではなく読み取りに使用するものであるため`std::format`からその意味が少し変わっています。

また、`std::scan`でのみ利用できるオプションも追加されています

- `i` : プリフィックスから基数を検出する（デフォルトは10進数）
  - 整数型のみ
- `u` : `-`を考慮しない10進整数値
  - 整数型のみ
- `c` : 入力文字（列）をそのままコピーする
  - 文字列型/文字型/数値型で有効

`std::formatter`と同様に`std::scanner`クラステンプレートを特殊化することで、ユーザー定義型をスキャン可能な型として登録することができます。

```cpp
// tmのスキャンを有効化する際の宣言の例

template <>
struct std::scanner<tm, char> {
  constexpr auto parse(scan_parse_context& ctx)
    -> expected<scan_parse_context::iterator, scan_error>;

  template <class ScanContext>
  auto scan(tm& t, ScanContext& ctx) const
    -> expected<typename ScanContext::iterator, scan_error>;
};
```

ロケールはデフォルトでは考慮せず、`L`オプションとともに`std::locale`オブジェクトを渡すことでロケール依存の読み取りを行うことができます。その際、ロケールオブジェクトは引数の先頭で渡します。

この提案の内容は、[scnlib](https://github.com/eliaskosunen/scnlib)（特にdevブランチ）および`{fmt}`ライブラリにおいて試験実装されているようです。

- [`std::expected` - cpprefjp](https://cpprefjp.github.io/reference/expected/expected.html)
- [eliaskosunen/scnlib - Github](https://github.com/eliaskosunen/scnlib)
- [P1729 進行状況](https://github.com/cplusplus/papers/issues/493)

### [P1928R5 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r5.pdf)
### [P1928R6 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r6.pdf)
### [P2169R4 A Nice Placeholder With No Name](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf)
### [P2407R4 Freestanding Library: Partial Classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2407r4.html)
### [P2487R1 Is attribute-like syntax adequate for contract annotations?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2487r1.html)
### [P2521R4 Contract support -- Record of SG21 consensus](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2521r4.html)
### [P2542R3 views::concat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2542r3.html)
### [P2546R5 Debugging Support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2546r5.html)
### [P2548R6 copyable_function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2548r6.pdf)
### [P2552R3 On the ignorability of standard attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2552r3.pdf)
### [P2591R4 Concatenation of strings and string views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2591r4.html)
### [P2630R4 Submdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
### [P2637R3 Member visit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2637r3.html)
### [P2641R4 Checking if a union alternative is active](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2641r4.html)
### [P2642R3 Padded mdspan layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2642r3.html)
### [P2662R2 Pack Indexing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2662r2.pdf)
### [P2689R2 atomic_accessor](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2689r2.html)
### [P2697R1 Interfacing bitset with string_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2697r1.pdf)
### [P2714R1 Bind front and back to NTTP callables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2714r1.html)
### [P2717R2 Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2717r2.html)
### [P2727R3 std::iterator_interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2727r3.html)
### [P2728R4 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2728r4.html)
### [P2728R5 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2728r5.html)
### [P2741R3 user-generated static_assert messages](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2741r3.pdf)
### [P2752R3 Static storage for braced initializers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2752r3.html)
### [P2757R3 Type checking format args](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2757r3.html)
### [P2767R1 flat_map/flat_set omnibus](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2767r1.html)
### [P2776R0 2023-05 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2776r0.html)

2023年5月に行われたLEWGの全体投票の結果を報告する文書。

次の13本の提案が投票にかけられ、否決されたものはありませんでした。

- [P1673R12 BLAS Linear Algebra](https://wg21.link/P1673R12)
- [P2630R3 submdspan](https://wg21.link/P2630R3)
- [P1383R1 More constexpr For <cmath> And <complex>](https://wg21.link/P1383R1)
- [P2546R3 Debugging Support](https://wg21.link/P2546R3)
- [P2548R5 copyable_function](https://wg21.link/P2548R5)
- [P2714R0 Bind Front And Back To NTTP Callables](https://wg21.link/P2714R0)
- [P2637R2 Member visi](https://wg21.link/P2637R2)
- [P2757R2 Type-Checking Format Args](https://wg21.link/P2757R2)
- [P2641R3 Checking If A Union Alternative Is Active](https://wg21.link/P2641R3)
- [P1759R6 Native Handles And File Streams](https://wg21.link/P1759R6)
- [P2697R0 Interfacing bitset With string_view](https://wg21.link/P2697R0)
- [P2248R7 Enabling List-Initialization For Algorithms](https://wg21.link/P2248R7)
- [P2734R0 Adding The New 2022 SI Prefixe](https://wg21.link/P2734R0)

全て、C++26に向けてLWGに転送するための投票です。これらのうちのいくつかは、2023年6月の全体会議でC++26 WDに導入されています。

### [P2779R1 Make basic_string_view's range construction conditionally explicit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2779r1.html)
### [P2781R3 std::constexpr_v](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2781r3.html)
### [P2785R0 Relocating prvalues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2785r0.html)

↓

### [P2785R1 Relocating prvalues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2785r1.html)

↓

### [P2785R2 Relocating prvalues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2785r2.html)

↓

### [P2785R3 Relocating prvalues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2785r3.html)

*prvalue*からのリロケーションを可能とするための機能を導入する提案。

リロケーションについてと提案のモチベーションは以前の同種提案と共通しているのでそちらを参照

- [P1144R6 Object relocation in terms of move plus destroy - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1144R6-Object-relocation-in-terms-of-move-plus-destroy)
- [P1144R8 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P1144R8-stdis_trivially_relocatable)
- [P2786R0 Trivial relocatability options - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2786R0-Trivial-relocatability-options)
- [P2839R0 Nontrivial relocation via a new "owning reference" type - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2839R0-Nontrivial-relocation-via-a-new-owning-reference-type)

この提案では特に、構築後に動かせなくなるオブジェクトの扱いを改善するためにもリロケーション操作が有効であると述べています。

例えば、`gsl::not_null`というクラスは`nullptr`状態を取り得るクラスのムーブコンストラクタ等を無効化することでそのクラスが`nullptr`ではないことを保証するクラスです。`gsl::not_null<std::unique_ptr<T>>`のように使用する場合、この型のオブジェクトはムーブもコピーもできなくなります。

このようなオブジェクトは`nullptr`ではないことが保証されていることからコードの正確性やパフォーマンスを向上させるために有効ですが、現在のC++コードでは扱うのが現実的ではありません。コピーもムーブもできないため構築後にメモリ上を移動できなくなり、関数に渡したりコンテナに保存したりすることやクラスのメンバとなることを妨げます。

しかし、リロケーション操作が可能になればそのようなオブジェクトは、そのクラスの不変条件を保ったままリロケーションによってメモリ上を移動することができるようになり、その取り扱いのしやすさが改善します。

同様の問題は定数（`const`）オブジェクトにもあります。定数オブジェクトはその生存期間を通じて変化しないため、人間にとっても機械（コンパイラ）にとってもプログラムの状態に関する推論がしやすくなります。そのため、自動変数はさまざまなガイドラインで可能なら`const`とすることが推奨されています。

しかし、`const`オブジェクトはムーブすることができず、そのため後でムーブすることを意図するオブジェクトは`const`にすることができません。生存期間中は`const`でありながらも、その終わりに所有するリソースを手放すことができれば、より安全で読みやすいコードが可能になります。

この提案のリロケーション操作はこれらの2点を改善することを主目的としており、その点が以前の提案と大きく異なる部分です。

この提案が導入しようとしているのは次のものです

- 2つの特殊メンバ関数
    - リロケーションコンストラクタ : `T(T)`
    - リロケーション代入演算子 : `T& operator=(T)`
- 新しいキーワード`reloc`
- オーバーロード解決ルールの若干の変更
- 一部の関数にABI破壊が生じる可能性がある
- リロケーション操作のサポートのためのライブラリ関数

この提案では、リロケーションのために新しい型を導入することを避け、代わりに*prvalue*（修飾なしの素の型）をそのために利用しようとしています。

提案より、サンプルコード

```cpp
void foo(std::string str);
auto get_string() -> std::string;
auto get_strings() -> std::pair<std::string, std::string>;

std::string gStr = "static string";

void bar(void) {
	std::string str = "test string";
	foo(reloc str);   // OK: std::stringにリロケーションコンストラクタがあればリロケーションされる
	foo(reloc gStr);  // ill-formed: gStrはローカル変数ではない

	std::pair p{std::string{}, std::string{}};
	foo(reloc p.first); // ill-formed: p.firstは完全なオブジェクトではなく、変数名でもない

	foo(reloc get_string());        // ill-formed: 変数名ではない
	foo(reloc get_strings().first); // ill-formed: 完全なオブジェクトではなく、変数名でもない

  foo(auto(str));   // ill-formed: リロケーション後の変数名は使用できない
}

void foobar(const std::string& str) {
	foo(reloc str); // OK: 参照をリロケーションする
                  // strの参照先オブジェクトの生存期間は影響を受けない
}

void foobar(std::string* str) {
	foo(reloc *str); // ill-formed: *strは変数名ではない
}

void foobar2(std::string* str) {
	foobar(reloc str); // OK, ポインタをリロケーションする
                     // strの参照先オブジェクトの生存期間は影響を受けない
} 

class A {
	std::string _str;
public:
	void bar() {
		foo(reloc _str); // ill-formed: _strは完全なオブジェクトではなく、ローカル変数でもない
	}
};
```

- [P2785 進行状況](https://github.com/cplusplus/papers/issues/1579)

### [P2786R2 Trivial relocatability options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2786r2.pdf)
### [P2795R0 Correct and incorrect code, and &quot;erroneous behaviour&quot;](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2795r0.html)

↓

### [P2795R1 Erroneous behaviour for uninitialized reads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2795r1.html)

↓

### [P2795R2 Erroneous behaviour for uninitialized reads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2795r2.html)

未初期化変数の読み取りに関して、Erroneous Behaviourという振る舞いの規定を追加する提案。

未初期化変数の読み取りに関するErroneous BehaviourとはP2754R0で導入された概念で、未初期化変数を実装定義の値に初期化した上でその値の（ユーザーが書き込む前の）読み取りに対して指定される標準で定義された動作の1つです。

P2754R0については以前の記事を参照

- [P2754R0 Deconstructing Avoiding Uninitialized Reads of Auto Variables  - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2754R0-Deconstructing-Avoiding-Uninitialized-Reads-of-Auto-Variables)

Erroneous Behaviour（誤った動作、EB）は未定義動作ではなく、実装はユーザーによって初期化されていない変数を特定の値で変数を初期化しているためそれが起きたとしても安全であり、初期化する値を調整することでテストやデバッグに役立てることができます。また、EBを未定義動作として扱えば現状維持になり、EB/UBのまま維持しておくことで将来のさらなる大胆な改善（デフォルト初期化仕様の値初期化への完全な置き換えなど）のための門戸を開いておくこともできます。

未初期化変数の読み取りという問題の解決策としてEBの導入は最善（実現可能性、後方互換性、表現力の保護の観点で最善）であると認識されていますが、現在のC++標準ではEBという概念は定義されておらず、その導入そのものがハードルだとされていました。

この提案は、そのErroneous Behaviourという概念を標準に導入し、未初期化変数読み取り問題の解決を図るものです。

この提案では、自動変数のデフォルト初期化を次のように変更することを提案しています

> 自動変数のデフォルト初期化は、実装によって定義された固定値で変数を初期化する。  
> 実装はこのエラーを診断することが許可されており、また推奨されているが、エラーを無視して読み取りを有効なものとして扱うことも許可されている。

Erroneous Behaviourというワードが直接出現するわけではありませんが、この文章の後半部分（2行目）がそれを意図しています。すなわち、初期化されていない値を読むことは意図したものではなく間違いなくバグではあり修正する必要があるものの、それを含むコードはwell-definedでありその点について診断されないとしてもプログラムは予測可能である（未定義動作ではない）、とするものです。

言い換えると、未初期化の値を読み取ることは誤りではあるものの、実装がそれを止めなければプログラムはその読み取りの結果として（未定義ではない）何らかの特定の値を得ることになります。実装は診断をしてもいいが、してもしなくてもそれについてwell-definedであることを保証する必要があり、誤った振る舞いが実行された場合に未定義動作及びそれに起因する結果（ソースコードからは予測できない命令の実行、タイムトラベルなど）をもたらすことはありません。

```cpp
extern void f(int);

int main() {
  int x;     // default-initialized, value of x is indeterminate
  f(x);      // glvalue-to-prvalue conversion has undefined behaviour
}
```

この現在UBとなるコードについて、現在及びP2723R1（強制ゼロ初期化）とこの提案によるコンパイル結果の違いは次のようになります

|動作について|C++23|P2723R1|この提案|
|---|---|---|---|
|未定義動作？|UB|well-defined|EB|
|それはバグ？|確実にバグ|意図的に0初期化しているのか忘れているのかわからない|確実にバグ|
|コンパイラの診断は可能か？|コンパイラはこれを拒否することが許可されている|適合するコンパイラは診断できない|適合するコンパイラは受け入れなければならないが、QoIによって拒否することが許可されている|

この提案の下での動作においては、`x`の値は何か特定の値に初期化されていますがその値は必ずしも0ではありません。デバッグやテストに役立てるために特定の値を設定することを許可することと、特定の固定値にプログラマが依存してしまうことを回避することを意図しています。

この提案による標準の他の部分への影響は次のようなものが想定されます

- 自動変数は全て何かしら初期化されるため、パフォーマンスに影響を与える可能性がある
    - このコストに関する分析はP2723R1でなされている
    - また、このコストは非クラス型だけではなく、パディングを持たずデフォルトコンストラクタが全てのメンバを初期化するようなクラス型にもかかってくる
- 特に、共用体は完全に初期化される
    - 一般に、共用体をコピーしても誤りではなくパディングビットをコピーしても誤りではない
    - これは、誤りのある値の*glvalue*から*prvalue*への変換自体は誤りではないものの、その値をコピー以外のことに使用するのは誤りであることを意味する
- この提案は初期化のセマンティクスのみに影響し、不定値の使用の全般に影響するわけではない
    - 例えば、初期化された変数に不定値をコピーすることができ、その値を読み取ると未定義動作となる可能性がある
- この提案は単一操作としての自動変数のデフォルト初期化にのみ影響する
    - 自動変数をplacement newでデフォルト初期化するような場合はこの提案の保証はない

この提案の実装に関しては、ほぼ同様のことを行うことがgcc/clangにおいて`ftrivial-auto-var-init=zero`というオプションによって利用可能となっています（ただしこれは診断を意図したものではないようです）。この提案の変更は主に標準内の動作仕様に関する変更であり、実装の負担は軽微だと思われます。

この提案の採択によって未初期化変数読み取りに関する未定義動作が誤った動作に変更される場合、コードベースに対する影響は次のようになるでしょう

- 今日の正しいコード : パフォーマンスが低下する可能性がある他は観測可能な変化はない
- 今日の正しくないコード : UBをEBに変更した場合（診断しない場合）、そのコードは依然として正しくはないもののその振る舞いは未定義動作ではなくなり、特定の振る舞いするようになる

また、EBはこの提案では未初期化変数の読み取りのために導入しようとしていますが、同様に現在未定義動作となっているもののバグと意図的なものを弁別でき、バグについてのみ診断が可能な未定義動作についてもこれと同様にEBとして指定することで未定義動作やそれに伴う意図しない動作を回避しながら安全な動作をさせるようにすることができる可能性があり、その候補リストも示されています。

- [P2723R1 Zero-initialize objects of automatic storage duration - WG21月次提案文書を眺める（202年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2723R1-Zero-initialize-objects-of-automatic-storage-duration)
- [P2795 進行状況](https://github.com/cplusplus/papers/issues/1460)

### [P2809R1 Trivial infinite loops are not Undefined Behavior](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2809r1.html)
### [P2810R1 is_debugger_present is_replaceable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2810r1.html)
### [P2811R5 Contract-Violation Handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r5.pdf)
### [P2811R6 Contract-Violation Handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r6.pdf)
### [P2811R7 Contract-Violation Handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r7.pdf)
### [P2814R1 Trivial Relocatability --- Comparing P1144 with P2786](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2814r1.pdf)
### [P2819R1 Add tuple protocol to complex](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2819r1.pdf)
### [P2821R2 span.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2821r2.html)
### [P2821R3 span.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2821r3.html)
### [P2828R2 Copy elision for direct-initialization with a conversion function (Core issue 2327)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2828r2.html)
### [P2834R1 Semantic Stability Across Contract-Checking Build Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2834r1.pdf)
### [P2835R1 Expose std::atomic_ref's object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2835r1.html)
### [P2836R1 std::basic_const_iterator should follow its underlying type's convertibility](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2836r1.html)
### [P2845R1 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2845r1.html)
### [P2865R1 Remove Deprecated Array Comparisons from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2865r1.pdf)
### [P2872R1 Remove `wstring_convert` From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2872r1.pdf)
### [P2874R1 Mandating Annex D](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2874r1.pdf)
### [P2874R2 Mandating Annex D](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2874r2.pdf)
### [P2877R0 Contract Build Modes and Semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2877r0.pdf)

現在の契約プログラミングの仕様を、現在明らかなユースケースをサポートし将来の拡張に対して開いているようにする提案。

現在SG21で議論されている契約プログラミング仕様では、No_evalとEval_and_abortの2つのビルドモードのみが提供されており、翻訳単位間でのビルドモードの混合は実装定義のセマンティクスによって条件付きでサポートされています。

No_evalビルドモードでは全ての契約アノテーション（1つの関数に指定されている契約条件の全体）は*ignore*セマンティクスを持ち、契約アノテーションに含まれる各条件式は評価されず契約違反が起こることはありません。そのため、このビルドモードでは他のセマンティクスに影響を与えません。

Eval_and_abortビルドモードでは全ての契約アノテーションは*enforce*セマンティクスを持ち、契約アノテーションに含まれる各条件式が評価されそれが`true`を返さない場合は契約違反処理プロセスが発生し、その終了後にプログラムは終了されます。

これによってC++の実装には制限が課されており、2つのビルドモードのプロパティはすなわちC++コントラクト機能のプロパティであるとみなされ、プラットフォーム固有のビルドモードまたは将来のビルドモードの追加によってこの2つのビルドモードのプロパティや前提に反するようなセマンティクスを持つビルドモードを追加することが妨げられます。これらのプロパティの重要な特徴は、翻訳単位内の全ての契約アノテーションが同じセマンティクスを持つことです。

この提案は、契約アノテーションのセマンティクスとビルドモードの制限を取り払い実装の自由度を最大化することを目指し、それによってC++契約プログラミング機能が満たすべき現在明らかなニーズを満足しつつ、将来のニーズに適応するための拡張の余地を残しておくようにしようとするものです。

提案で挙げられている現在明らかなニーズとは次のようなものです

- パッケージマネージャ
    - 現在利用可能なパッケージマネージャの多くは、各パッケージについて単一のビルドのみを提供する。つまり、デバッグとリリースの両方を提供したりしない
    - 契約アノテーションのセマンティクスがビルド時に決定しなければならない設計は、パッケージマネージャにとって大きな負担となる
    - パッケージマネージャの管理者が契約機能のビルドモードのどちらを選択するにせよ、その決定はパッケージの作成者の契約機能の使用意欲にネガティブな影響を与える可能性がある
    - パッケージマネージャの管理者がビルドモードの決定を各プロジェクトのビルドモードまで遅延する場合、エコシステム内での契約機能の使用は一貫性がなくなる可能性がある
      - ことなるオブジェクトファイルが異なるビルドモードでビルドされている場合、条件付きサポートとなる
- パッケージとして配布されるソフトウェア
    - 歴史的に、一部のパッケージ提供者はアサーションを有効にしたパッケージを配布することを選択し、そうではない提供者はアサーションを含むテストをパスしていることを根拠として品質とサポートの目標を達成しているとみなしてアサーションを無効化したパッケージを配布することを選択している
    - C++契約機能はこのような選択肢をサポートし続ける必要がある。すなわち、契約アノテーションが評価されないことを許可しない設計は実行可能ではない
- 契約の解除
    - 運用環境で契約チェックを利用する際の最も難しい問題の1つは、既存のコードに契約チェックを導入すること。
    - 契約違反によるプログラムの終了のコストが高くつくため、契約違反によってプログラムが終了する場合、現在動作しているプログラムに契約チェックを導入する意欲が失われる
    - 現在の2つのセマンティクス（ビルドモード）だけではこの問題を解消できない
- [REPL](https://ja.wikipedia.org/wiki/REPL)
    - REPL環境ではプログラムはコンパイルされないため、ビルドモードが存在しない
    - 契約の評価が有効かどうか、及び違反時の振る舞いについては、ユーザーがいつでも変更できる動的なプロパティとなる
- デバッグ
    - 契約条件式はプログラムの本質的な動作に影響を与える副作用を持つべきではないが、それを検出するメカニズムが存在しないため、副作用が混入する可能性を受け入れなければならない
    - 副作用が発生しているかを判断するテクニックの一つは、契約アノテーションの評価を無効化した時と有効化した時の間で同じプログラムの動作を比較すること
    - 現在の2つのビルドモードではこれをサポートできない（この場合、契約違反を検出したいわけではないため）

これらのニーズは全て、現在のC++契約プログラミング仕様ではサポートできていません。これらのニーズを満たすには少なくとも次の要件を満たしている必要があります

- 標準に準拠した契約実装では、リビルドを必要とせずにを必要とせずに契約アノテーションの評価の有効/無効を切り替えられなければラナイ
- 標準に準拠した契約実装では、ユーザーが契約アノテーションごとに、もしくは違反ハンドラの動作を通して、契約違反後に実行を継続するかを選択可能である必要がある

また、これらの要件がユーザーベースに適さない場合、実装はこれらの要件をサポートしないことも選択できるべきです。この提案の意図は、全てのC++実装や実行環境が全て同じ機能セットをサポートする必要があることではなく、それらの実装が全て標準に実装しwell-definedであり、他のC++プログラムに適用可能な動作に関するトレーニングと推論の対象になり続けるように維持することにあります。

その上でこの提案の変更は、大きく分けて次の2つです

1. 契約アノテーションが評価される場合、その評価は*ignore*、*observe*、*enforce*のいずれかのセマンティクスを持つ
    - *ignore* : 契約アノテーションは各契約条件を評価しないため、契約違反を起こさない
    - *observe* : 契約アノテーションは各契約条件を評価し、そのいずれかが`true`を返さない場合は契約違反処理プロセスが発生する
    - *enforce* : 契約アノテーションは各契約条件を評価し、そのいずれかが`true`を返さない場合は契約違反処理プロセスが発生する。契約違反処理プロセスの終了後、プログラムは実装定義の方法で終了する
2. 契約アノテーションの個々の評価において、それがどのようなセマンティクスを持つかは実装定義とする
    - プログラム内の全てのアノテーションが同じセマンティクスを持つように強制される場合がある
    - 異なる評価で異なるセマンティクスを持つことにより、同じ関数の異なるインライン版で異なるセマンティクスをコンパイル時に選択することができ、それはODR違反ではなくなる
    - 実装は、その選択をどのように行うかを指定する仕組みがユーザーに公開されていれば、契約アノテーションのセマンティクスをコンパイル時・リンク時・実行時のいずれかのタイミングで選択できる

この提案は、（ビルドモードの）セマンティクスとして*observe*を1つ追加するとともに、契約アノテーションの評価のセマンティクスを契約アノテーション全体からその個々のプロパティとすることで、契約アノテーションを持つもののコンパイル時プロパティが契約アノテーションのセマンティクスに依存しない（できない）ようにするものです。

これによって、P2834R0で提案されている契約アノテーションに関する三原則の1つ目（契約アノテーションがビルドモードによって他の言語機能に影響を与えないこと）が満たされ、翻訳単位間で契約アノテーションのセマンティクスが混合していることも許可されます。

この提案の後でも、実装は現在の2つのビルドモードだけをサポートすることを選択することができ、また、コンパイラはリンク時やコンパイル時、実行時で契約アノテーションのセマンティクスを選択できるようなビルドオプションを提供することもできます。

この提案の内容はどうやらSG21の合意のもとで契約仕様に導入（Contratcts MVPにマージ）されたようで、P2811R6の採用と相まって、C++契約プログラミング仕様はビルドモードの概念から解き放たれることになります。そこでは、この提案で解説されているように、契約条件のセマンティクス（評価されるかどうか、評価された時にどうなるかなど）は*ignore*・*observe*・*enforce*のいずれかが契約アノテーションごとに決定され、その決定は実装定義となります。さらに、*observe*の場合に契約違反を起こした場合の振る舞い（即終了するのか、例外を投げるのか、継続するのか）は違反ハンドラの差し替えによってユーザーがカスタマイズすることができます。

- [P2834R0 Semantic Stability Across Contract-Checking Build Modes - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2834R0-Semantic-Stability-Across-Contract-Checking-Build-Modes)
- [P2811R4 Contract Violation Handlers - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2811R4-Contract-Violation-Handlers)
- [2023-06 Varna ISO C++ Committee Trip Report — First Official C++26 meeting! : r/cpp - reddit](https://www.reddit.com/r/cpp/comments/14h4ono/202306_varna_iso_c_committee_trip_report_first/)
- [P2877 進行状況](https://github.com/cplusplus/papers/issues/1586)

### [P2878R2 Reference checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2878r2.html)
### [P2878R3 Reference checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2878r3.html)
### [P2878R4 Reference checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2878r4.html)
### [P2885R0 Requirements for a Contracts syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2885r0.pdf)
### [P2898R1 Build System Requirements for Importable Headers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2898r1.pdf)
### [P2902R0 constexpr 'Parallel' Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2902r0.pdf)

並列アルゴリズムを定数式で使用できるようにする提案。

並列アルゴリズムとはC++17で追加された実行ポリシーを受け取るオーバーロードの事で、これれらのものは並列化やベクトル化によってアルゴリズムの実行時パフォーマンスを向上させることが目的であるため、`cosntexpr`指定はされておらず定数式では使用できません。

並列アルゴリズムも含めたアルゴリズムは他の処理や他のアルゴリズムと組み合わせて使用するものであり、他のアルゴリズムや標準ライブラリの多くのものが`constexpr`対応を果たしている中で並列アルゴリズムが`constexpr`対応しない場合、そのような並列アルゴリズムと組み合わされた一連の処理を定数式で実行することができなくなります。

その場合でも、`std::is_constant_evaluated()`や`if consteval`を使用して分岐をすればとりあえず対応はさせられますが、そもそも並列アルゴリズムが`constexp`であればより単純に目的を達成できます。

この提案はそのような目的のために並列アルゴリズムを`constexpr`対応させることを目指すものです。ただし、コンパイル時にも並列化を要求するものではありません。

この提案では、全ての実行ポリシーを定数式で指定可能とすることを提案しており、その実装はコンパイル時に対応する通常のアルゴリズム関数に処理を委譲することでコンパイル時実行することを意図しています。

- [P2902 進行状況](https://github.com/cplusplus/papers/issues/1593)

### [P2904R0 Removing exception in precedence rule(s) when using member pointer syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2904r0.pdf)
### [P2905R0 Runtime format strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2905r0.html)
### [P2905R1 Runtime format strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2905r1.html)
### [P2906R0 Structured bindings for std::extents](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2906r0.html)
### [P2910R0 C++ Standard Library Ready Issues to be moved in Varna, Jun. 2023](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2910r0.html)
### [P2911R0 Python Bindings with Value-Based Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2911r0.pdf)
### [P2912R0 Concurrent queues and sender/receivers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2912r0.html)
### [P2915R0 Proposed resolution to CWG1223](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2915r0.pdf)
### [P2917R0 An in-line defaulted destructor should keep the copy- and move-operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2917r0.pdf)
### [P2917R1 An in-line defaulted destructor should keep the copy- and move-operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2917r1.pdf)
### [P2918R0 Runtime format strings II](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2918r0.html)
### [P2918R1 Runtime format strings II](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2918r1.html)
### [P2920R0 Library Evolution Leadership's Understanding of the Noexcept Policy History](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2920r0.pdf)
### [P2921R0 Exploring std::expected based API alternatives for buffer_queue](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2921r0.html)
### [P2922R0 Core Language Working Group "ready" Issues for the June, 2023 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2922r0.html)
### [P2925R0 inplace_vector - D0843R7 LEWG presentation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2925r0.pdf)
### [P2926R0 std::simd types should be regular - P2892R0 LEWG presentation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2926r0.pdf)
### [P2929R0 simd_invoke](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2929r0.html)
### [P2930R0 Formatter specializations for the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2930r0.html)
### [P2931R0 WG21 February 2023 Meeting Record of Discussion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2931r0.pdf)
### [P2937R0 Freestanding: Remove strtok](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2937r0.html)
### [P2940R0 switch for Pattern Matching](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2940r0.html)
### [P2941R0 Identifiers for Pattern Matching](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2941r0.html)
### [P2944R0 Comparisons for reference_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2944r0.html)
### [P2945R0 Additional format specifiers for time_point](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2945r0.html)
### [P2946R0 A flexible solution to the problems of `noexcept`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2946r0.pdf)
### [P2947R0 Contracts must avoid disclosing sensitive information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2947r0.pdf)
### [P2949R0 Slides for P2861R0: Narrow Contracts and `noexcept` are Inherently Incompatable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2949r0.pdf)
### [P2950R0 Slides for P2836R1: std::basic_const_iterator should follow its underlying type's convertibility](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2950r0.pdf)
### [P2951R0 Shadowing is good for safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2951r0.html)
### [P2951R1 Shadowing is good for safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2951r1.html)
