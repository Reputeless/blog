# ［C++］モジュール 理論編

### モジュールの構成

### ファイルの分割

### `export`

### `import`

### 非モジュールコードとの相互運用

#### Header Unit

### 参考文献

- [P1103R3 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)
- [モジュール - cpprefjp](https://cpprefjp.github.io/lang/cpp20/modules.html)
- [C++ ModulesのHeader units - Qita](https://qiita.com/tetsurom/items/e25b2683cb7e7c0fa91c)
- [C++ Modulesの分割 - Qita](https://qiita.com/tetsurom/items/0de4795866b52f5bcf65)
- [C++ ModulesとDLLの関係 (MSVCの場合) - Qita](https://qiita.com/tetsurom/items/0f6aad21e06b043f42bd)
- [Understanding C++ Modules: Part 1: Hello Modules, and Module Units - vector<bool>{ true, true, false };](https://vector-of-bool.github.io/2019/03/10/modules-1.html)
- [Understanding C++ Modules: Part 2: export, import, visible, and reachable - vector<bool>{ true, true, false };](https://vector-of-bool.github.io/2019/03/31/modules-2.html)
- [C++20: Modules - MODERNES C++](https://www.modernescpp.com/index.php/c-20-modules)
- [C++20: More Details to Modules - MODERNES C++](https://www.modernescpp.com/index.php/c-20-more-details-to-modules)

# メモ

- module unit : モジュール単位
モジュールを構成する翻訳単位
ファイル先頭のモジュール宣言によりモジュール単位は開始される
その後にimport宣言が続く（なくてもよい

モジュール宣言
```cpp
module foo;  //ファイル先頭で行う
```

- module interface unit : モジュールインターフェース単位  
module unitであり、モジュール宣言にexportを伴うもの

モジュールインターフェース宣言
```cpp
export module foo;  //ファイル先頭で行う
```

モジュールのインターフェースを定義する
インターフェース：シグネチャ、宣言みたいな

モジュールは少なくとも一つがモジュールインターフェース単位である必要がある

- primary module interface unit : プライマリモジュールインターフェース単位  
モジュール名と同じモジュールインターフェース宣言を含むモジュール単位  
モジュールfooなら`export module foo;`

- module interface partitions : モジュールインタフェースパーティション  
プライマリではないすべてのモジュールインターフェース単位

## visible と reachable

- visible : 可視  
名前探索によって宣言が見つかれば、そのコンテキストでその宣言は可視である

- reachable : 到達可能  
定義（意味論的効果）が使用可能である場合、そのコンテキストでその宣言は到達可能である  
例えば、あるコンテキストでクラスが完全型であるならば、そのクラスの定義は到達可能である

宣言は可視 -> 到達可能 : true  
到達可能 -> 宣言は可視 : false (trueとなることもある)

importはどの名前空間スコープの名前が可視になるか
および、どの宣言が意味論的に（semantically）到達可能か
だけをコントロールする。

あるエンティティの振る舞いは、そのエンティティの到達可能な宣言の集合によって決まる（エンティティ = 名前・定義？）
例えば、クラス・列挙体のメンバはその定義が到達可能であるとき、名前探索で可視である

## export
宣言は`export`を用いてモジュールインターフェース単位内でエクスポートできる

内部リンケージを持つものを除いて、エクスポートされていない宣言はそのモジュール単位をインポートする同じモジュール内の名前探索で可視である

推移的にインポートされたモジュール単位内のすべての宣言は、エクスポートされているかにかかわらず到達可能（？？

モジュール単位は対応するモジュールインタフェース単位を暗黙にインポートする

名前空間内の宣言（名前空間を伴う宣言）がエクスポートされると、その名前空間も暗黙的にエクスポートされる。
名前空間をエクスポートすると、名前空間内の宣言は（暗黙的に）エクスポートされる。

## module partitions : モジュールパーティション

一つのモジュールは単一のファイルでも複数のファイルでも定義できる。  
例えば、宣言（モジュールインターフェースユニット）と定義（実装）をファイルで分割することができる。

モジュールパーティションは、そのようなインターフェースと実装を分割することを可能にする

- module interface partitions : モジュールインターフェースパーティション

モジュールインターフェースは必要に応じて複数のファイルに分割することができる。
それらのファイルをモジュールインターフェースパーティションと呼ぶ。
以下のようなモジュールインターフェースパーティション宣言を（その他のモジュール宣言の代わりに）含む翻訳単位のこと。

モジュールインターフェースパーティション宣言
```cpp
export module foo::part;
```

モジュールインターフェースパーティションに含まれるエンティティの所有権は属しているモジュールと共有される。  
それ以外は、モジュールインターフェースパーティションは単一のモジュールと同じ振る舞いをする。  

そのため、エンティティの宣言と定義を別々のパーティションで行うことができる
これは、モジュール内部で発生しうる循環参照（依存関係のループ）を解決するために必要
これはまた、ABIを変えることなくモジュール内でコードを移動することができる

プライマリモジュールインターフェース単位は、モジュール内のすべてのインターフェースパーティションの推移的インポートと再エクスポートをしなければならない。

- module implementation partitions : モジュール実装区分

モジュール内で実装が複数のファイルに分割されており、モジュール内で他のモジュールインターフェースパーティションで定義されたものを使用している場合、実装の詳細（定義）に依存することを避けるために、宣言をモジュールインターフェース単位に含めずに実装単位間で共有することが望ましいことがある  
そうすることで、定義が変更されたときにモジュールインターフェースとその依存関係を再構築する必要がなくなる  
それを可能にするのが モジュール実装区分である。

モジュール実装区分宣言
```cpp
module foo:part;
```
これは、モジュールインターフェース単位の一部ではないモジュールパーティションとなる

モジュール実装区分はエクスポートされた宣言を含めることができない
代わりに、モジュール実装区分をインポートすることで、そのモジュール実装区分のすべての宣言は同じモジュール内の他の翻訳単位から可視となる

`export`はモジュール外部への名前と宣言の可視性にのみ影響を与える。

- module partitions : モジュールパーティション  
モジュールインタフェースパーティションとモジュール実装区分はまとめて、モジュールパーティションと呼ぶ

モジュールパーティションはモジュールの実装の詳細であり、その名前をモジュール外部から参照することはできない。
そのため、モジュールパーティションを指名する`import`宣言はモジュール名を指定できず、パーティション名のみを指定することができる


```cpp
module foo;    //モジュール宣言
import :part;  //モジュールパーティションのインポート

//モジュール名の指定はコンパイルエラー
import bar:part;  //ng
import foo:part;  //ng
```

## 非モジュールコードとの相互運用

### グローバルモジュールフラグメント

以下のように、モジュール（インターフェース）単位で旧来のヘッダをインクルードした場合、そのモジュール内のすべての翻訳単位でインクルードしたのと同じことになってしまう（同じモジュール内の他のファイルでもインクルードしたヘッダの中身が見える）。

```cpp
export module mymodule;

#include <iostream>
```

グローバルモジュールフラグメントは、モジュール内部で他のモジュールパーティションから見えないように旧来のヘッダファイルを#includeするための仕組み

```cpp
module;  //グローバルモジュールフラグメントの（開始）宣言

#include <iostream>

//グローバルモジュールフラグメントの終了
export module mymodule;  //モジュールインターフェース宣言
```

グローバルモジュールフラグメント内の宣言はモジュールによって所有されない

グローバルモジュールフラグメントに含まれる宣言によってモジュールが肥大化することを防ぐため、モジュール単位で参照されていないグローバルモジュールフラグメント内の宣言は破棄される  
そのような宣言は、モジュール単位をインポートするほかの翻訳単位からは到達不可能であり 
モジュール単位の外での2段階目のテンプレートのインスタンス化（two phase name lookup）の際に見つからない

すなわち、グローバルモジュールフラグメント内の宣言は
- グローバルモジュールフラグメント終了後のそのモジュール単位内で名前が現れるか
- そのように参照されている宣言で名前が現れる

場合にその宣言が参照されているとみなされる。

```cpp
module;

#include <tuple>

export module mymodule;

export using int_tuple = std::tuple<int, int, int>;

export auto f() -> std::tuple<char, short, double>;

//これ以外のstd::tuple特殊化および、すべての関数の宣言は使用されていないので破棄される
//破棄された宣言はモジュールに含まれず、コンパイルもされない
//そして、このモジュールをimportした先で参照することもできない
```

### ヘッダーユニット

```cpp
export module foo;  //モジュールインターフェース宣言

//ヘッダーユニットのインポート宣言
import "some-header.h";
import <version>; 
```

`import`に指定されたヘッダファイルはソースファイルのように処理され、ヘッダー内のインターフェースが抽出され`import`した翻訳単位で使用可能になる。  
また、ヘッダー内でプリプロセス時に定義されたマクロも保存され、`import`した翻訳単位で使用可能になる。

ヘッダーユニット内の宣言及びコードはどのモジュールにも所有されない。  
同じエンティティを別のヘッダーユニットもしくは非モジュールコードにおいて再宣言できる。

ヘッダーユニットは通常の再エクスポート宣言と同じように再エクスポートできる。

```cpp
export module foo;
export import "some-header.h";  //ヘッダーユニット”some-header.h”の再エクスポート
```

ただし、マクロをインポートできるのはヘッダーユニット構文だけであり、再エクスポートではマクロはエクスポートされない。

### 非モジュールコード内宣言の到達可能性
グローバルモジュールフラグメント及びヘッダーユニット内の宣言は可視であるときに到達可能である。

そのような宣言が可視ではないが、推移的にインポートされている文脈でも到達可能かどうかは未規定。  
理想的にはそのような（推移的にインポートされた）宣言は到達可能であるべきではないが、そのように規定すると実装によっては実装コストが大きくなってしまうため、標準はその扱いについて規定しない。  
このルールが適用される範囲は実装に任せている。

グローバルモジュールフラグメントにおいて破棄された宣言は、モジュールの外側で可視ではなく、到達可能でもない。


### 非モジュールコードでのモジュールの利用
モジュールとヘッダーユニットは非モジュールコードにインポートすることができる。そのような`import`宣言はプリアンブルに限定されず、どこでも行うことができる。  
これによって、ボトムアップなモジュール化が可能になり、ライブラリはモジュールによるインターフェースのみを提供し、かつモジュールによるインターフェースによってヘッダーインターフェースを定義する事を切り替えることができる。

非モジュールコードには、モジュール単位を除いた翻訳単位（インポートされたヘッダーユニットを含む）及び、モジュール単位内のグローバルモジュールフラグメントが含まれる。

非モジュールコードに#includeがあり、そこで指名されているヘッダファイルがヘッダーユニット化可能である場合、実装はその#includeをヘッダーユニットのインポートに置き換える。

このような置き換えが可能な#includeを見つける方法は実装定義である。  
実装方法は様々考えられ、研究が進むことを期待してのこと。
（ヘッダーユニットを明示的にビルドしてその後のコンパイル時に利用する、ヘッダーユニットの構成を記述するファイルを導入する、など）

実装は、マッピングメカニズムを提供せずに各ヘッダーユニットを個別に処理してもいい

