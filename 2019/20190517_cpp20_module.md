# ［C++］モジュール理論 基礎編

※この内容はC++20より有効なものです。C++20正式策定までの間に内容が変化する可能性があります。

より読みやすい解説がすでにあるのでそちらにも目を通されるといいと思われます。→ [モジュール - cpprefjp](https://cpprefjp.github.io/lang/cpp20/modules.html)

### モジュールのインターフェースと実装
あるファイルをモジュールである！と宣言するには、__モジュール宣言__（`module モジュール名;`） をファイル先頭で行います。モジュール宣言を行うことでそのファイルは1つの __モジュール単位__、かつ1つの翻訳単位となります。

通常のC++コードがヘッダファイル（宣言）とソースファイル（定義）に分割できる様に、モジュールにおいても宣言と定義を別のファイル（別々のモジュール単位）に分けて実装する事ができます。その時、それらのモジュール単位はそれぞれ __モジュールインターフェース単位__ と __モジュール実装単位__ と呼ばれます。

以下、コメントでファイル名が書かれている部分は、そこから別のファイルにあるものとして書いています。

```cpp
///mymodule.cpp
//（プライマリ）モジュールインターフェース単位の宣言
export module MyModule;

//export宣言、宣言をモジュール外部で使用可能にする
export int f(int n);

///mymodule_impl.cpp
//モジュール実装単位の宣言
module MyModule;
//ここでは暗黙的にプライマリーモジュールインターフェース単位をimportしている
//import MyModule; のようには書けないため

int f(int n) {
  return n;
}

///main.cpp（非モジュール）
//モジュールMyModuleのインポート宣言、exportされているものを取り込む
import MyModule;

int main() {
  int n = f(10);  //ok, f()は使用可能
}
```

このように、`export module`の形のモジュール宣言によってインターフェース単位を宣言します。このインターフェース単位は __プライマリーモジュールインターフェース単位__ と呼ばれ、モジュールには必ず __唯一つだけ__ 含まれていなければなりません。

その名の通り、（モジュール）インターフェース単位にはモジュールのインターフェース、すなわち外部に公開する宣言を、実装単位にはそれら宣言の実装をそれぞれ書く、という事を想定しています。

どちらの宣言においても`module`の後に来るのがモジュール名で、（一部のキーワードを除いて）好きな名前を付けることができます。

モジュールインターフェースでは、モジュール外に提供したい宣言をエクスポート宣言（`export 宣言;`）によって外部へ公開します。  
そして、モジュールを利用する側（翻訳単位）ではインポート宣言（`import モジュール名;`）によってモジュールからエクスポートされている宣言を取り込みます。

モジュール実装単位とインターフェース単位は同じ名前を持つことができます。すると、実装単位においてインターフェース単位をインポートしようとすると自分自身をインポートすることになってしまいます。  
いかなるモジュールも自分自身をインポートすることはできません。そのため、モジュール実装単位は対応する（プライマリー）モジュールインターフェース単位を暗黙的にインポートします。  
そして、これらのことからモジュール実装単位はエクスポートもインポートもできない事がわかります。

なお、ヘッダーやソースファイルがそうである様に、モジュールファイルの拡張子は規定されていません。コンパイラがそれと認識すれば、拡張子は自由です。

#### モジュールパーティション

そしてさらに、モジュールの内部のファイルを複数のファイルに分けて実装する事ができます。  
これは例えば、自作のライブラリを1つのモジュールとして提供したいが、その内部の実装においては整理のためにも複数のファイルに分けたい、という際に役立ちます。

その様にモジュール内部で分割したファイル（これもまたモジュール単位）は __モジュールパーテイション__ と呼ばれます。  
そして、モジュールパーティションもまたインターフェースと実装に分割する事ができ、分割後のモジュール単位はそれぞれ __モジュールインターフェースパーティション__、__モジュール実装パーティション__ と呼ばれ、それぞれモジュールインターフェース単位とモジュール実装単位でもあります。

```cpp
///mymodule_part.cpp
//モジュールインターフェースパーティションの宣言
export module MyModule:InterfacePart;
import :ImplPart;  //import宣言、モジュールパーティションMyModule:ImplPartを取り込む

export double g(double v) {
  return g_impl(v);  //パーティション:ImplPart内の関数を使用
}

///mymodule_part_impl.cpp
//モジュール実装パーティションの宣言
module MyModule:ImplPart;

//実装パーティションでは、export宣言を行えない

double g_impl(double v) {
  return v + v;
}

///mymodule.cpp
//（プライマリー）モジュールインターフェース単位の宣言
export module MyModule;
export import :InterfacePart;  //インターフェースパーティション:InterfacePartの再エクスポート、必須

export int f(int n);

///mymodule_impl.cpp
//モジュール実装単位の宣言
module MyModule;

int f(int n) {
  return n;
}

///main.cpp
import MyModule; 

int main() {
  //共に使用可能
  int n = f(10);
  double v = g(1.0);
}
```

モジュールパーティションの宣言はモジュール宣言とほぼ同様ですが、モジュール名の後に`:パーティション名`を指定します。`:`がモジュールパーティションである証です。  
通常のモジュールインターフェース単位は実質プライマリーモジュールインターフェース単位の一つしか作ることができませんが、インターフェースパーティションはいくつでも作ることができます。

ただし、同じモジュール内で複数のモジュールパーティションが同じ名前を持つことは出来ません。従って、インターフェースパーティションと実装パーティションでは異なる名前を付ける必要があります（このため、あるパーティションは使用する別のパーティションを明示的にインポートする必要があります）。

このようなモジュールのパーティションへの分割はモジュールの外からは観測することができません。したがって、モジュールパーティションはモジュール外でインポートすることが出来ません。  
そのため、インターフェースパーティション内でエクスポートした宣言は全て、プライマリーモジュールインターフェース単位から再エクスポートされなければなりません。  

また、モジュールパーティションをインポートするときは、（`:`も含めた）そのパーティション名だけを指定する必要があります。モジュール名は要らず、むしろコンパイルエラーになります。

上記の例では以下のように書いてはいけません。

```cpp
///mymodule_part.cpp
//モジュールインターフェースパーティションの宣言
export module MyModule:InterfacePart;
import MyModule:ImplPart;  //compile error!

///mymodule.cpp
//（プライマリー）モジュールインターフェース単位の宣言
export module MyModule;
export import MyModule:InterfacePart;  //モジュール名を指定してはいけない
```

モジュール実装パーティションでは`export`宣言を行うことができず、（インターフェースから）実装パーティションを再エクスポート（`export import`）することもできません。  
また、モジュールパーティションを（同モジュール内で）インポートした際は通常のインポートとは異なり、そのパーティションのすべての宣言が利用可能になります。

#### モジュール宣言、まとめ

ここまで4種類のモジュールが出てきましたが、モジュールはその種別にかかわらず1ファイル1モジュール（単位）であり、モジュール1つは1つの翻訳単位を成しています（すなわち、個別にコンパイルされます）。  
そのような複数のモジュール単位は、そのモジュール名によって1つのモジュールとしてまとめて扱われます。  

4つしかないとはいえ名前がこんがらがってとてもややこしいですが、インターフェースか実装か、パーティションか否か、という2つの軸から分割できます。そして、モジュール宣言に`export`が含まれていればインターフェース、`:`が含まれていればパーティション、という風に見分けられます。

モジュール名を`M`、パーティション名を`:Part`として、それぞれのモジュール（宣言）は以下の様な関係にあります。

|パーティション？ ＼ インターフェース？|インターフェース|実装|
|:---:|:---:|:---:|
|__モジュール__|`export module M;`|`module M;`|
|__パーティション__|`export module M:Part;`|`module M:Part;`|

#### インターフェースオンリーなモジュール

ヘッダオンリーライブラリの様に、ファイル分割とかしないから1ファイルにまとめたい！という事もあるでしょう。単にパーティションを使わないだけでは、実装単位と（プライマリな）インターフェース単位の2つが必要になってしまうのでそれを達成できません。

その様な場合は、プライマリモジュールインターフェース単位のみを用いると似た様な事ができます。

```cpp
///mymodule .cpp
//Mymoduleのプライマリモジュールインターフェース単位の宣言、かつMymoduleの唯一のモジュール単位
export module Mymodule;

int f_impl(int n) {
  return n * n;
}

export int f(int n) {
  return f_impl(n);
}

///main.cpp
import MyModule;

int main() {
  int n = f(10);
}
```

ただし、プライマリモジュールインターフェース単位に書かれた宣言と定義は、エクスポートしているかに関わらずインポートした側の翻訳単位に公開されます。
エクスポートしていないものは名前探索において見つからないだけで、インポートした翻訳単位から見えています。これは思わぬバグの原因になるかもしれません。

```cpp
///main.cpp
import MyModule;

//ODR違反！モジュールの中身を知らずに定義してしまった
int f_impl(int n) {
  return n + n;
}

int main() {
  int n = f(10);
  int m = f_impl(10);  //Undefined Behavior! とはいえ、おそらく m == 20 
}
```

モジュール実装単位を用いる場合、実装単位内にあるものはそのモジュール外部に一切公開されず、インポートによってはそのプライマリモジュールインターフェース単位のみを取り込むことになります。そのためこの様な問題は起こらないのです。

これらのことをあとで説明する言葉を用いて表現すると、モジュール単位内のエクスポートされていないものはそれをインポートした翻訳単位において、「到達可能だが可視ではない」状態に置かれる、と言えます。

それでは、それらの問題を解決した上でモジュールを1ファイルで定義する方法は無いのでしょうか？？  
もちろんそれは用意されています。詳細は下の方で説明しますが、 __プライベートモジュールフラグメント__ を用いる事で、不要なものを隠蔽しながらモジュールを1ファイルで定義する事ができます。

```cpp
///mymodule .cpp
//Mymoduleのプライマリモジュールインターフェース単位の宣言、かつMymoduleの唯一のモジュール単位
export module Mymodule;

//f()の宣言のエクスポート
export int f(int n);

//プライベートモジュールフラグメントの（開始）宣言
module : private;

//f_impl()の宣言・定義はモジュール外から見えない（到達可能でない）
int f_impl(int n) {
  return n * n;
}

//エクスポートされている宣言の再宣言は外部リンケージを持っている
int f(int n) {
  return f_impl(n);
}

///main.cpp
import MyModule;

//ok、以前の定義は見えてない（到達可能でない）
int f_impl(int n) {
  return n + n;
}

int main() {
  int n = f(10);      //ok
  int m = f_impl(10); //ok, m == 20
}
```

`module : private;`という宣言によってプライベートモジュールフラグメントが開始され、それ以降の宣言・定義はモジュール外からは一切観測できません（以前にエクスポートされていない限り）。そのため、プライベートモジュールフラグメント内ではエクスポート宣言を行えません。

この様に、プライベートモジュールフラグメントを利用することで宣言と定義を適切に分離・隠蔽しつつ1ファイルでモジュールを構成することができます。

### 可視と到達可能（Visible and Reachable）

__可視__ と __到達可能__ はモジュール内の宣言や定義の参照についての2つの重要な概念です。この言葉をぬいてモジュールを説明していくのは少し難しいのでここでそれらの説明しておきます。

- 可視（Visible）
  - ある宣言は（いずれかの）名前探索において見つかる（候補に上がる）時、そのコンテキストにおいて可視となる
- 到達可能（Reachable）
  - ある宣言は、（名前探索とは無関係に）その宣言の持つ意味論的な性質が利用可能である時、そのコンテキストにおいて到達可能となる

可視の方は新しく導入されたのではなく同じ様な意味合いで前からあった様です。こちらは問題無いでしょう。

到達可能の方は何をいっているのかわかりづらいですが、ほぼその名前の通りの意味です。  
宣言の持つ意味論的な性質とはその宣言の持つC++コードとして規定された効果のことです。  
たとえば、クラスの定義の持つ効果はクラスを完全型にしてそのメンバを利用可能にします。逆にいうと、クラスの定義が到達可能であるときそのクラスは完全型となりそのメンバが利用可能になります。

定義は必ず宣言を含むので、宣言が定義を兼ねている場合はその宣言に到達可能=定義に到達可能、ということになります。

可視と到達可能という2つの概念の間には次の様な関係性があります。

- 宣言が可視 → 宣言は到達可能：常に成り立つ
- 宣言が到達可能 → 宣言は可視：成り立たない事がある

例えば、モジュールをインポートするとそのインターフェース（プライマリーインターフェース単位）内でエクスポートされている宣言はインポートした側で可視となり、同時に到達可能になります。  
しかし、そのインターフェース内でエクスポートされていない宣言は到達可能ではありますが、可視ではありません。  
このために、上のインターフェースオンリーなモジュールの項で上げたような意図しないODR違反が起こってしまう可能性があります。

```cpp
///mymodule2.cpp
export module Mymodule2;

#include <iostream>

namespace Mymodule2 {

  export void print(int n);

  export void print(double v);

  void print(const char* str) {
    std::cout << str << std::endl;
  }

}

module : private;

namespace MyModule2 {

  void print(int n) {
    std::cout << n << std::endl;
  }

  void print(double v) {
    std::cout << v << std::endl;
  }
}


///mymodule_part.cpp（インターフェースパーティション）
export module MyModule:InterfacePart;
//他モジュールの再エクスポート
export import Mymodule2;

export double h(double v);

///mymodule_part_impl.cpp（実装パーティション）
module MyModule:ImplPart;
import :InterfacePart;

double h(double v) {
  MyModule2::print(v); //ok、可視であり到達可能

  return v + v;
}


///mymodule.cpp（プライマリモジュールインターフェース単位）
export module Mymodule;
export import :InterfacePart;

export struct S;

export int f(int n);

int g() {
  return 1;
}


///mymodule_impl.cpp（実装単位）
module Mymodule;

struct S {
  int n;
  double v;
};

int f(int n) {
  return n * n;
}

char get_a() {
  return 'a';
}


///main.cpp
import Mymodule;

int main() {
  int n = f(2);         //ok、可視であり到達可能
  double d = h(0.1)     //ok、可視であり到達可能
  MyModule2::print(n);  //ok、可視であり到達可能
  S* ps = nullptr;      //ok、型名`S`は可視であり到達可能

  int m = g();          //ng、到達可能だが可視ではない
  print("Hello World.");//ng、到達可能だが可視ではない

  S s = {10, 3.14};     //ng、`S`の型名は可視だが定義は到達可能ではない

  char a = get_a();     //ng、可視でも無く到達可能でもない
}

//到達可能な定義と同名のものに対して（異なった）定義をしてしまうとODR違反！
int g() {
  return 2;
}
```

可視ではないということは名前探索で見つからないということなので、可視でなければその宣言は使用不可です。そして、その宣言の持つ期待する効果を利用するためには、その宣言が到達可能である必要があります。  
すなわち、モジュール内部の宣言をモジュール外で利用するための必要十分条件は、（`import`を前提として）可視かつ到達可能、であることです。

#### ODR（One-definition rule）の緩和

ここまでの例で垣間見えているように、モジュールの導入に伴ってODRに若干の変更が入っています。

C++20からのODRは基本的には次の規則に従います

- ある宣言に対する定義は、以前の定義が __到達可能__ なところで再定義されてはならない
  - ただし、その以前の定義が別の翻訳単位にある場合は診断されない（エラーとならない）

- （非グローバルの）モジュールに属している宣言は複数の定義を持ってはならない
  - ただし、その以前の定義が到達可能でなければ診断されない（エラーとならない）

ここでの宣言とは、変数、関数、クラス型、列挙型、テンプレート、の事です。

モジュールに属するとは、宣言があるモジュールファイルの本文内に現われるときに、その宣言はそのモジュールに属しているとみなされます。  
この場合に属するモジュールはインターフェースや実装、そのパーティション毎ではなく、それらをまとめるモジュールに属します。

このルールはモジュールを利用（インポート）する時だけでなく、モジュール内部、モジュール外部（グローバルモジュール）でのコーディングにおいても同様です。  
特に、2つ目のルールはモジュール内部においてODRは（ほぼ）従来通りであることを意味しています。

また、これまではヘッダに定義されてインクルードされるもの（`inline`変数・関数やクラスの定義など）のように、その定義の文字列とプログラムとしての意味が全く同一であるとき、宣言は複数の定義を持つことが許されていました。基本的にそれは変わりませんが、モジュールに属するものが複数の定義を持つことはできず、モジュールに属する宣言が到達可能である場合に同じ宣言に対して複数の定義を行うことは（たとえ同一であっても）許されません。

モジュールは必ずしも自分で作成したものではなく、その中身を隅々まで把握出来るわけではありません。しかし、モジュールは複数の翻訳単位からなるので、モジュール内部とその外側で偶然に定義がぶつかることが起こりえます。ヘッダファイルならばヘッダに書いて`#include`することで、その定義を同一とする、もしくは少なくともヘッダに書かれている事によって気付くことができます。  
しかし、モジュールでは必ずしもエクスポートされている宣言がヘッダのようにまとまっているわけではありませんし、配布方法によってはソースコードとして配布されないかもしれません。少なくともヘッダファイルに比べてよりODRに怯えながらコーディングすることになるでしょう・・・。  
そのような状況を避けるために、ODRが到達可能という言葉を使って変更（実質緩和）されたのでしょう。

### `export`
ここまでモジュール外部に宣言を公開するんだよーくらいの意味で`export`を説明していましたが、その詳細を見て行きます。

モジュール内で`export`によって宣言を外部公開する構文は、`export`宣言（エクスポート宣言）と呼びます。
`export`宣言は伴う宣言の宣言としての効果（名前の導入等）を持ちます。逆に言うと、宣言できるものは基本的に`export`できます。

モジュールによる`export`宣言によって導入・再宣言された名前はそのモジュールによって __エクスポートされている__ と言われます。エクスポートされた名前はそのモジュールをインポートしている翻訳単位内で（の名前探索において）可視となります。  
なお、クラスのメンバ名はそのクラスの定義が到達可能である場合に可視となります。

```cpp
///Mymodule.cpp
export module Mymodule;  //これはエクスポート宣言ではない

//エクスポート宣言の例

export struct S {
  int n = 10;
};

export int f() {
  return 0;
}

export int g();

int g() {
  return -1;
}

export constexpr double PI = 3.14159;
```

`export`宣言はモジュールインターフェース単位の本文内の名前空間スコープ（グローバル名前空間を含む）で現れることができ、必ず何らかの名前を導入しなければなりません。そして、その名前は外部リンケージを持つ必要があります。

```cpp
///Mymodule.cpp
export module Mymodule;  //これはエクスポート宣言ではない

//以下全てNG集

//内部リンケージ
export static int f() {
  return 0;
}

namespace {
  //内部リンケージ
  export constexpr double PI = 3.14159; 
}

//名前を宣言していない
export static_assert(true);

//名前を宣言していない
export using namespace std;


///Mymodule_impl.cpp
module Mymodule;

//モジュール実装単位にあらわれている
export int h();
```

`export`宣言を出来るのはモジュールインターフェース単位内だけです。パーティションであろうとなかろうと、実装単位ではできません。

`export`宣言はブロックでまとめて行うことができます。この場合のブロックはスコープを導入せず、内部に`export`が現れてはいけません。

```cpp
///Mymodule.cpp
export module Mymodule;  //これはエクスポート宣言ではない

//ブロックのエクスポート宣言、内部のものは暗黙的にエクスポートされる
export {
  struct S {
    int n = 10;
  };

  int f() {
    return 0;
  }

  constexpr double PI = 3.14159;

  //ng! exportキーワードは現れてはならない
  export int g() {
    return -1;
  }
}

//ok、ブロックのエクスポート宣言はスコープを導入しない
export constexpr PI_2 = 2.0 * PI;
```

`export`宣言は当然名前空間に対しても行うことができます。その場合、エクスポートされた名前空間内の宣言は暗黙的にエクスポートされることになります。従って、内部の宣言は全て外部リンケージを持つ必要があります。  
すなわち、無名名前空間は`export`宣言に関わってはいけません。

また、エクスポートしていない名前空間内部に`export`宣言が現れることもできます。この場合、それを囲む名前空間は暗黙的にエクスポートされます。

```cpp
///Mymodule.cpp
export module Mymodule;  //これはエクスポート宣言ではない

//名前空間のエクスポート宣言、内部のものは暗黙的にエクスポートされる
export Mymodule {
  struct S {
    int n = 10;
  };

  int f() {
    return 0;
  }

  constexpr double PI = 3.14159;
}

namespace Detail {
  //名前空間内でのエクスポート、Detail::g()がエクスポートされる
  export int g() {
    return -1;
  }
}

//ダメな例
export NG {
  //名前を宣言していない
  using namespace std;

  //内部リンケージ
  static int N = 10;

  //exportキーワードは現れてはならない
  export int g() {
    return -1;
  }

  //名前を宣言していない
  export static_assert(true);

  //無名名前空間は名前空間のエクスポート宣言に現れてはならない
  namespace {
    int h() {
      return 1;
    }
  }
}

//無名名前空間はエクスポートできない
export namespace {
    int h() {
      return 1;
    }
}
```

また、`export`宣言は`using`（`typedef`）宣言に対しても行えます。ただし、上記の例でも示したように名前を導入するものでなくてはならず、参照先の名前は外部リンケージを持っていなければなりません。  
ただし、`using`（`typedef`）による型エイリアスの宣言では、参照先の名前が外部リンケージを持つ必要はありません。

```cpp
///OtherModule.cpp
export module Other;

export int f() {
  return 0;
}

export int g() {
  return -1;
}

export struct S {
  int n = 10;
};

///Mymodule.cpp
export module Mymodule;

export using ::f, ::g;  //まとめてエクスポート！
export using ::S;

//ng!名前を宣言していない
export using namespace std;

static int h1() {
  return 1;
}

double h2(double v) {
  return v;
}

struct T {
  int n = 0;
  double v = 0.0;
}

//ng!内部リンケージを持つ名前のエクスポート
export using ::h1;

//ng!モジュールリンケージ（後述）を持つ名前のエクスポート
export using ::h2
export using ::T;

//ただし型エイリアスならok
export using C1 = ::T;  //::Tのエイリアスとなる名前C1をエクスポート
export typedef ::T C2;  //同様
```

また、変わったところではリンケージ指定もエクスポートできます。とはいえ、出来ることできないことはこれまでと変わりありません。

```cpp
///Mymodule.cpp
export module Mymodule;  //これはエクスポート宣言ではない

//リンケージ指定のエクスポート宣言
export extern "C++" int f() {
  return 0;
}


//リンケージ指定ブロックのエクスポート宣言、内部のものは暗黙的にエクスポートされる
export extern "C" {
  int g() {
    return -1;
  }

  constexpr double PI = 3.14159;

  //ng!exportキーワードは現れてはならない
  export int h() {
    return 1;
  }

  //ng!内部リンケージ
  namespace {
    int h() {
      return 1;
    }
  }
}

//ok、ブロックのエクスポート宣言はスコープを導入しない
export constexpr PI_2 = 2.0 * PI;
```

#### 再宣言における`export`

あらゆる宣言は再宣言を行うことができます。その際、`export`があったりなかったりすることがあるでしょう。その時、どうなるかは主に2つのパターンに分かれます、

- 以前に`export`宣言によって宣言されている場合
  - その宣言は暗黙的にエクスポートされる
- 以前の宣言は`export`宣言ではない場合
  - 再宣言は`export`宣言であってはならない
  - `export`宣言は名前のリンケージを変更できない

```cpp
///Mymodule.cpp
export module Mymodule;

//エクスポート宣言によるfの導入
export int f();

//fの定義、暗黙的にエクスポート
int f() {
  return 0;
}

export struct S;

//暗黙的にエクスポート
struct S {
  int n = 10;
};

//エクスポートしないTの宣言
struct T {
  int n = 10;
  double v = 0.0;
};

//Tの再宣言、以前にエクスポートされていないのでng!
export struct T;

namespace {
  int g() {
    return -1;
  }
}

int h() {
  return 1;
}

//内部リンケージを持つgはエクスポートできない（再宣言はリンケージを変更できない）
export int g();

//モジュールリンケージを持つhはエクスポートできない（再宣言はリンケージを変更できない）
export int h();
```


#### モジュールリンケージ

モジュールに属しかつ外部リンケージを持つ宣言（定義）が`export`されていないとき、これまでの規則で考えるとその宣言を用意してやりさえすればモジュール外部から参照できるはずです。  
しかし、これをやられるとモジュールの意味が薄くなってしまうので出来ないようになっています。

モジュールに属している宣言によって導入される名前が外部リンケージを持ち、エクスポートされていない場合、その名前は __モジュールリンケージ__ を持ちます。

モジュールリンケージを持つ名前は次の場所から参照され、参照することができます。

- 同じモジュール単位内の他のスコープにある名前
- 同じモジュール内の他のモジュール単位のスコープにある名前

名前というのはそのままの意味で、変数名や関数名、クラス名などのことです。

任意の翻訳単位を超えて参照することができるのは、これまで通り外部リンケージを持つ名前だけなので、モジュールリンケージを持つ名前は同じモジュール内でしか参照できません。

これらのことは、宣言や定義が到達可能であるかどうかとは関係がありません。

### `import`

### 変り者のモジュール

#### グローバルモジュール

#### プライベートモジュールフラグメント

#### グローバルモジュールフラグメント

#### Header Unit

### モジュールにおけるテンプレートのインスタンス化

### ADLとモジュール

### `inline`変数・関数

### プリプロセッサの扱い

### おまけ、モジュール史（2004 - 2019）
- Moduleのあけぼの
  - [N1736: Modules in C++ (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1736.pdf)
  - [N1778: Modules in C++ (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1778.pdf)
  - [N1964: Modules in C++ (Revision 3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1964.pdf)
  - [N2073: Modules in C++ (Revision 4)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf)
  - [N2316: Modules in C++ (Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2316.pdf)
  - [N3347: Modules in C++ (Revision 6)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf)
- MSの隆盛
  - [N4047: A Module System for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4047.pdf)
  - [N4214: A Module System for C++ (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4214.pdf)
  - [N4465: A Module System for C++ (Revision 3)](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4465.pdf)
  - [P0142R0: A Module System for C++ (Revision 4)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0142r0.pdf)
- Moduleの挑戦とつまづき
  - [N4466: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4466.pdf)
  - [P0143R0: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0143r0.pdf)
  - [P0143R1: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0143r1.pdf)
- Module TSの時代
  - [N4592: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)
  - [N4610: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4610.pdf)
  - [N4637: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4637.pdf)
  - [N4681: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4681.pdf)
  - [N4720: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4720.pdf)
- googleの台頭（Atom Proposals）
  - [P0947R0: Another take on Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r0.html)
  - [P0947R1: Another take on Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r1.html)
  - [P0986R0: Comparison of Modules Proposals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0986r0.html)
- ひらけゆくModule
  - [P1103R0 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r0.pdf)
  - [P1103R1 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r1.pdf)
  - [P1103R2 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r2.pdf)
  - [P1103R3 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)

### 参考文献

- [P1103R3 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)
- [モジュール - cpprefjp](https://cpprefjp.github.io/lang/cpp20/modules.html)
- [C++ ModulesのHeader units - Qita](https://qiita.com/tetsurom/items/e25b2683cb7e7c0fa91c)
- [C++ Modulesの分割 - Qita](https://qiita.com/tetsurom/items/0de4795866b52f5bcf65)
- [C++ ModulesとDLLの関係 (MSVCの場合) - Qita](https://qiita.com/tetsurom/items/0f6aad21e06b043f42bd)
- [Understanding C++ Modules: Part 1: Hello Modules, and Module Units - vector<bool>{ true, true, false };](https://vector-of-bool.github.io/2019/03/10/modules-1.html)
- [Understanding C++ Modules: Part 2: export, import, visible, and reachable - vector<bool>{ true, true, false };](https://vector-of-bool.github.io/2019/03/31/modules-2.html)
- [C++20: Modules - MODERNES C++](https://www.modernescpp.com/index.php/c-20-modules)
- [C++20: More Details to Modules - MODERNES C++](https://www.modernescpp.com/index.php/c-20-more-details-to-modules)
- [C++ MODULES - HSAE - Wuhan · 张轶](http://purecpp.org/purecpp/static/717887c97bf947d68e67da309cdd0611.pdf)