# ［C++］丸かっこによる集成体初期化

※この記事は[C++20を相談しながら調べる会 #1](https://cpp20survey.connpass.com/event/124051/)の成果です。

※内容はC++20正式策定までに変化する可能性があります。

集成体初期化（Aggregate Initilization）とは、配列か集成体（Aggregate）となる条件を満たしたクラスに対して行える特別な初期化方法の事です。

C++17まではこれは波かっこ"{}"の時にのみ使用することができ、丸かっこ"()"による初期化は常にその型のコンストラクタを呼び出していました。  
しかし、C++20からはその制限がなくなり丸かっこによる初期化時にも集成体初期化が考慮され、必要なら行われるようになります。

```cpp
struct aggregate {
  int a;
  double b;
};

aggregate a{10, 3.14};  //ok
aggregate b(10, 3.14);  //ok

aggregate c = {20, 2.72};  //ok
aggregate d = (20, 2.72);  //ng

int arr1[]{0, 1, 2, 3};  //ok
int arr2[](0, 1, 2, 3);  //ok

int arr3[] = {0, 1, 2, 3};  //ok
int arr4[] = (0, 1, 2, 3);  //ng
```

丸かっこによる集成体初期化はなるべく波かっこによるものと同じように実行されます。一方で、今までの丸かっこによる初期化の持つ意味が変わらないようにもなっています。  
そのため、波かっこによる集成体初期化と少し異なる挙動をするところがあります。

### コンストラクタとの競合

集成体初期化と従来のコンストラクタ呼び出しが競合する場合はコンストラクタ呼び出しが優先されます。これは波かっこでも同様ですが、集成体はコンストラクタ宣言を行えないので問題となるのはコピー・ムーブコンストラクタとの競合時です。  
そして、この時の挙動が少し異なっています。

```cpp
struct A;

struct C { 
  operator A();  //実装略
};

struct A {
  C c;
};

C c();  //cを値初期化（デフォルトコンストラクタ呼び出し）

{
  A a(c);  //C::operator A()を呼び、その戻り値からaをムーブ（コピー）構築
  A b(a);  //bをaからコピー初期化
}

{
  A a{c};  //A::cをcからコピー初期化
  A b{a};  //bをaからコピー初期化
}
```

波かっこによる初期化においては、渡されたリストの要素が一つであり、その要素が初期化しようとしている型`T`もしくはその派生型である場合にのみ、その要素から`T`をコピー・ムーブ初期化します。  
それ以外の場合はすべて集成体初期化が行われます。

丸かっこによる初期化においては、あらゆる変換が考慮された（通常のオーバーロード解決を行った）うえで、マッチングするコンストラクタが見つからないときに集成体初期化が行われます。  

このように微妙ではありますが初期化方法が選択されるまでの手順が異なります。とはいえ、ただ1つの要素で初期化しようとしたときにのみ起こる事なのであまり出会わないでしょう。

これは、丸かっこによる初期化の持つ意味を変更しないようにしているために生じています。  
配列は元々丸かっこ初期化を持っておらず挙動が曖昧にはならないため、配列の初期化時はこの問題は起きません。

### 縮小変換の許可 

縮小変換とは変換後の型が変換前の型の表現を受け止めきれないような型の変換です（double -> float, signed -> unsigned 等）。  
波かっこによる初期化時は集成体初期化でなくても、縮小変換が禁止されていました。それは思わぬところで変換エラーを引き起こし、特にテンプレート関数の中では波かっこ初期化は非常に使いづらくなってしまっていました。

```cpp
template<typename T>
float to_float(T v) {
  return float{v};
  //こうするとok
  //return float(v);
}

auto d = to_float(3.14);  //compile error!
auto e = to_float(3.14f); //ok.


constexpr char str[50]{};
constexpr auto begin = std::begin(str);

if (auto [end, err] = std::to_chars(begin, std::end(str), 3.141592653589793); err == std::errc{}) {
  std::cout << std::string_view{begin, end - begin};  //compile error!
  //こう書くとok
  //std::cout << std::string_view(begin, end - begin);
}

```
これらのエラーは波かっこ初期化時には縮小変換が禁止されていることから発生しています。

しかし、丸かっこによる集成体初期化においてはそのような制限はなく、あらゆる変換が考慮され実行されます。これは同じ丸かっこによる初期化で、コンストラクタ呼び出しと集成体初期化とで挙動が異なることがないようにするためです。

<!-- ただし、このような縮小変換が許可されるのはクラス型の集成体初期化時のみで、配列に対する丸かっこ集成体初期化時は相変わらず禁止されます。配列は元々丸かっこ初期化を持っておらず、挙動が曖昧にはならないためです。 -->

### ネストする波かっこ省略（できない！）
ネストする波かっこ省略とは → [宣言時のメンバ初期化を持つ型の集成体初期化を許可 - cpprefjp](https://cpprefjp.github.io/lang/cpp14/brace_elision_in_array_temporary_initialization.html)

波かっこ初期化時はネストしている内部の型に対する波かっこ初期化時に、一番外側以外の波かっこを省略できます。しかし、丸かっこではできません・・・。  
何故かというと、ネストする丸かっこにはすでに意味があるからです。

```cpp
//この二つは同じ意味
int arr1[2][2]{{1, 2}, {3, 4}}; //ok
int arr2[2][2]{1, 2, 3, 4};     //ok

//丸かっこはこうするしかない
int arr3[2][2]({1, 2}, {3, 4}); //ok

//できない・・・
int arr4[2][2](1, 2, 3, 4);   　//ng
int arr5[2][2]((1, 2), (3, 4)); //ng
```
おそらく3次元以上の配列の場合は2番目の波かっこの内側では省略できます。そんなこと普通しないのであまり意味は無いですが・・・

クラス型の集成体の場合
```cpp
//この二つは同じ意味
std::array<int, 3> arr1{{ 1, 2, 3 }}; //ok
std::array<int, 3> arr2{ 1, 2, 3 };   //ok

//丸かっこはこうするしかない
std::array<int, 3> arr3({ 1, 2, 3 }); //ok

//できない・・・
std::array<int, 3> arr4( 1, 2, 3 );   //ng
```

### 一時オブジェクトの寿命延長（されない！）

### 引数の評価順序

### この変更の目的

この様になんだか複雑さを増した上に影響範囲がでかそうな変更をなぜ行ったのかというと、STLにおける`make_~`系や`emplace`系の関数に代表される、内部で要素を構築するような関数において、集成体初期化が行われないことをどうにかするためです。

### 参考文献
- [P0960R3 : Allow initializing aggregates from a parenthesized list of values](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0960r3.html)