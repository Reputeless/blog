# ［C++］WG21月次提案文書を眺める（2020年4月）

C++標準化委員会の論文（提案文書）公開がコロナウィルスの影響もあって月1になり量がお手頃になったので、提案文書を総覧してみます。

- [mailing2020-04 - JTC1/SC22/WG21 - Papers 2020](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-04)

提案文書で採択されたものは今回はありません。


### N4858 : Disposition of Comments: SC22 5415, ISO/IEC CD 14882

- [N4858 : Disposition of Comments: SC22 5415, ISO/IEC CD 14882](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4858.pdf)

C++20 CD (committee draft)の投票時に各国委員会およびそのメンバーから寄せられたコメントとその対応および理由の総覧です。

### N4859/N4860/N4861

- [N4859 : Editors' Report - Programming Languages - C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4859.html)

N4860/N4861の[N4849](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4849.pdf)との差分を記したEditors' Report。新たに採択された提案文書の一覧、解決されたIssueの一覧、Github上での軽微な修正コミットの一覧、などが載っています。

- [N4860 : Draft International Standard - Programming Languages - C++](http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n4860.pdf)

C++20のDIS (draft international standard)。この後FDIS (final draft international standard)を経てIS (international standard)へと至ります。

残念ながら委員会のメンバーしか見られないようです・・・

- [N4861 : Working Draft, Standard for Programming Language C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4861.pdf)

C++23のWD (working draft)第一弾。でもC++23向けに導入されたものはないはず。

N4860との差異は、表紙とヘッダ、フッダ、C++17規格とのクロスリファレンスの有無（無い）だけのようで、内容としてはFDISと同一とのこと。

### P0533R6 : constexpr for `<cmath>` and `<cstdlib>`



### P0870R2 : A proposal for a type trait to detect narrowing conversions 

### P1255R6 : A view of 0 or 1 elements: `views::maybe`

### P1315R5 : `secure_clear`

### P1641R3 : Freestanding Library: Rewording the Status Quo

### P1654R1 : ABI breakage - summary of initial comments

### P1949R3 : C++ Identifier Syntax using Unicode Standard Annex 31

### P2011R1 : A pipeline-rewrite operator

### P2013R1 : Freestanding Language: Optional ::operator new

### P2034R1 : Partially Mutable Lambda Captures

### P2044R2 : Member Templates for Local Classes

### P2096R1 : Generalized wording for partial specializations

### P2098R1 : Proposing std::is_specialization_of

### P2138R1 : Rules of Design`<=>`Wording engagement 

### P2146R0 : Modern `std::byte` stream IO for C++

- [P2146R0 : Modern `std::byte` stream IO for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2146r0.pdf)

`std::byte`によるバイナリシーケンスのIOのための新ライブラリ、`std::io`の提案。

エンディアン変換も可能でテキストストリームを考慮しないコンセプトとCPOベースのモダンな設計

### P2149R0 : Remove `system_executor`

Networking TSから`system_executor`と`​system_context`を削除する提案。

良く分からない。

### P2150R0 : Down with typename in the library! 

- [P2150R0 : Down with typename in the library!](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2150r0.html)

標準ライブラリのパートから不用な`typename`を消し去る提案。

C++20からいくつかの場所で`typename`が不用になったのに伴って（[P0634R3 : Down with typename!](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0634r3.html)）、標準ライブラリの規定部分からも取り除こうという話です。

どこで不要になるかは下記参照。
- [型名であることが明らかな文脈で`typename`を省略可能に (P0634R3) - cppmap](https://cppmap.github.io/standardization/cpp20/#typename-p0634r3)

### P2155R0 : Policy property for describing adjacency

- [P2155R0 : Policy property for describing adjacency](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2155r0.pdf)

進行中のExecuter（簡単に言えばスレッドプールサポートライブラリ）に関するもので、NUMAアーキテクチャ向けに、スレッドとそこで使用するメモリを同じノード内で確保しバインドするように指示するポリシーを追加する提案。

NUMAでは1つのプロセッサとそこに接続されたローカルメモリを1ノードとして、複数のノードで構成されることになりますが、そのシステム上での論理スレッド（OS上プロセスのスレッド）はOSによって任意のノードの物理スレッド（CPUコア）に割り当てられる可能性があり、また、そのスレッド内で確保し使用しているメモリはそのスレッドを実行している物理スレッドの属するノードとは別のノードに属するメモリを使用している可能性があります。

OSのスケジューリングによってこれはほとんど予測不可能となりえますが、ノードを超えたスレッドスケジュールやメモリアクセスは当然ノード内で行われるよりも高コストになり、全体のパフォーマンスに影響を及ぼします。

この様な実行スレッドに対する割り当てメモリの位置の事をメモリアフィニティ（*memory afinity*）、あるいは単にアフィニティと呼びます。

このようなことが起こりえる場合にもパフォーマンスを向上させるための1つの方法は、ある論理スレッドを物理スレッドとそのローカルメモリにバインドしスケジューリングやメモリ割り当てをあるノード内で完結するように強制してしまう事です。

NUMAの様なシステムにおいてC++開発者が、現在および将来のアーキテクチャに渡って最高のパフォーマンスを得るためには、この様なスレッドとメモリの配置の制御をC++標準機能としてネイティブサポートする必要があるので、Executer初期化時にアフィニティ制御をどのように行うかを指定するポリシーを渡すようにインターフェースを変更しよう、というのがおおよその内容です。


提案文書よりサンプルコード（Executer分からないから読めない

```cpp
// bulk algorithmの各インデックスについて、そこで使用されるメモリ領域用のポインタ列
std::vector<std::unique_ptr<float>> data{}; data.reserve(SIZE); 
 
// NUMA対応Executerの作成
numa_executor numaExec; 
 
// Create an iota view to represent the iteration space of the bulk algorithm. 
auto indexRng = ranges::iota_view{SIZE}; 
 
// Create a new execution policy which requires the adjacency.constructive 
// property on the std::par execution policy so that it provides a hint to the 
// executor that the algorithm would benefit from constructive interference in 
// the mapping of work-items to execution resources. 
auto adjacencyPar = std::execution::require(std::par, adjacency.constructive); 
 
// Define a callable that will be invoked for each work-item in the bulk 
// algorithm and perform first touch initialization. 
auto initialize = [=](size_t idx, std::vector<unique_ptr<float>> &value) {   value[idx] = std::make_new<float>(0.0f); } 

// Define a callable that will be invoked for each work-item in the bulk
// algorithm abd perform some computation. 
auto compute = [=](size_t idx, std::vector<unique_ptr<float>> &value) {     do_something(value[idx]); } 
 
// Compose a sender that takes the input data, schedules using the NUMA-aware 
// executor and then calls the indexed_for algorithm twice, once to initialize 
// and then again to perform the computation. 
auto sender = std::execution::just(data)             | std::execution::via(numaExec)             | std::execution::indexed_for(indexRng, adjacencyPar, initialize)             | std::execution::indexed_for(indexRng, adjacencyPar, compute); 
 
// Submit the sender and wait on the result. 
std::execution::sync_wait(sender, std::execution::sink_receiver{}); 
```

インターフェースとしては、C++17での並列アルゴリズムに対する実行ポリシー指定の方法と同じ形になっています。

- [NUMAについて - so tired](http://sasaki.hateblo.jp/entry/2017/07/18/152427)
- [std::execution::実行ポリシー - cpprefjp](https://cpprefjp.github.io/reference/execution/execution/execution_policy.html)
- [P0443R13 : A Unified Executors Proposal for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r13.html)
- [P1897R2 : Towards C++23 executors: A proposal for an initial set of algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1897r2.html)


### P2156R0 : Allow Duplicate Attributes

- [P2156R0 : Allow Duplicate Attributes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2156r0.pdf)

属性指定時に同じ属性を重複して指定しても良いようにする提案。

現在の規定では、一つの属性指定`[[]]`の中で同じ属性が複数回現れることは出来ません。しかし、属性指定を複数に分割すれば同じ属性が何回重複してもokです。

```cpp
// ng
[[noreturn, carries_dependency, deprecated, noreturn]]
void f();

// ok
[[noreturn]] [[carries_dependency]] [[deprecated]] [[noreturn]]
void g();
```
[[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ](https://wandbox.org/permlink/5rCNuRtKSPmtZKGL)

この挙動は一貫していないので、属性指定の重複を認める（上記NGの例`f()`を適格にする）方向に変更すべし、という提案です。

EWGの見解としては、属性指定を分ければ重複可能なのはマクロによって属性を条件付きで追加していくことをサポートするためのもので、一つの属性指定のなかでそれを行う事はレアケースなのでこの制限を解除する必要はない、という事。

しかし、これをそのままにしておくと、重複不可能な属性を標準に追加するたびにその旨を一々記述しておく必要があり、逆に重複可能な属性に対しては重複した時の振る舞いを記述しておく必要が生じます。これは明らかに標準を太らせ望ましくないので重複可能をデフォルトにするべき、というのが筆者の主張です。また、これは欠陥として過去のバージョンにさかのぼって適用されるのが望ましいとも述べています。