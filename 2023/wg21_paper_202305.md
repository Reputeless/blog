# ［C++］WG21月次提案文書を眺める（2023年05月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-05](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-05)

SG22のWG14からのものを除いて、全部で122本あります。

[:contents]

### [N4946 2024-03 Tokyo meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4946.pdf)

2024年3月に東京で開催される、WG21全体会議のインフォメーション。

開催期間翌週の月火（2023/03/25-26）には、C++ to Japanというカンファレンスイベントが開催される予定です。

- [C++と日本 ・ C++ to Japan](https://cppto.jp/)
- [C++と日本 - twitter](https://twitter.com/cpptojp)

### [N4947 INCITS C++/WG21 agenda: 12-17 June 2023, Varna, Bulgaria](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4947.html)

2023年6月にブルガリアのヴェルナで開催される、WG21全体会議のアジェンダ。

ここからは、C++26に向けた作業となります。

### [N4948 Working Draft, C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4948.html)

Library Fundamental TS v3のワーキングドラフト。

### [N4949 Editor's Report: C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4949.html)

↑の変更点をまとめた文書。

新しく追加された機能などはなく、編集上の修正のみのようです。

### [N4950 Working Draft, Standard for Programming Language C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4950.pdf)

C++23のワーキングドラフト第10弾。

これはC++23の最後のドラフトであり、おそらくC++23 標準規格文書と同等なものとなります。

### [N4951 Editors' Report - Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4951.html)

↑の変更点をまとめた文書。

今回は新しく採択された提案はなく、編集上の修正のみです。

### [N4953 Concurrency TS2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4953.pdf)

Concurrency TS v2のワーキングドラフト。

### [N4954 2023 WG21 admin telecon meetings, rev. 1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4954.pdf)

2023年（今年）のWG21管理者ミーティングの予定表。

### [P0342R2 pessimize_hint](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0342r2.html)
### [P0447R22 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0447r22.html)
### [P0843R6 static_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0843r6.html)
### [P1000R5 C++ IS schedule](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1000r5.pdf)
### [P1028R5 SG14 status_code and standard error object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1028r5.pdf)
### [P1061R5 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1061r5.html)
### [P1068R7 Vector API for random number generation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1068r7.pdf)
### [P1112R4 Language support for class layout control](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1112r4.pdf)
### [P1144R8 std::is_trivially_relocatable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1144r8.html)
### [P1684R5 mdarray: An Owning Multidimensional Array Analog of mdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1684r5.html)
### [P1759R6 Native handles and file streams](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1759r6.html)
### [P1885R12 Naming Text Encodings to Demystify Them](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1885r12.pdf)
### [P1901R2 Enabling the Use of weak_ptr as Keys in Unordered Associative Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1901r2.html)

`std::weak_ptr`を非順序連想コンテナのキーとして使用できるようにする提案。

この提案の目指すところは、`std::shared_ptr/std::weak_ptr`を所有権ベースで区別し、それを非順序連想コンテナ（特に、`std::unordered_set`）で管理できるようにすることです。順序付き連想コンテナは比較方法をカスタマイズするだけでそれを達成でき、そのために[`std::owner_less`](https://cpprefjp.github.io/reference/memory/owner_less.html)が用意されています。

現在の標準ライブラリにはそのサポートが無く、自前で用意しようとすると、所有権ベース同値比較は`owner_before()`で行えても`std::shared_ptr/std::weak_ptr`の（所有権ベースの）ハッシュを求めるポータブルな方法がありませんでした。

この提案は、標準ライブラリにそのためのユーティリティを用意することで、ポータブルかつ簡易に`std::shared_ptr/std::weak_ptr`を所有権ベースで非順序連想コンテナのキーとして使用可能にするものです。

この提案では、非順序連想コンテナが使用する`std::hash`と`std::equal_to`に対応するものとして、`std::owner_hash`と`std::owner_equal`を標準ライブラリに追加します。これは、既存の`std::owner_less`を参考にしたAPIです。

```cpp
namespace std {
  struct owner_hash {
    template <class T>
    size_t operator()(const shared_ptr<T>&) const noexcept;

    template <class T>
    size_t operator()(const weak_ptr<T>&) const noexcept;

    using is_transparent = unspecified;
  };

  struct owner_equal {
    template <class T, class U>
    bool operator()(const shared_ptr<T>&, const shared_ptr<U>&) const noexcept;

    template <class T, class U>
    bool operator()(const shared_ptr<T>&, const weak_ptr<U>&) const noexcept;

    template <class T, class U>
    bool operator()(const weak_ptr<T>&, const shared_ptr<U>&) const noexcept;

    template <class T, class U>
    bool operator()(const weak_ptr<T>&, const weak_ptr<U>&) const noexcept;
    
    using is_transparent = unspecified;
  };
}
```

この2つのクラスは`operator()`に渡された型の`owner_hash()/owner_equal()`メンバ関数を使用して所有権ベースのハッシュ計算/同値比較を行います。そのために、`std::shared_ptr/std::weak_ptr`のメンバ関数としてハッシュを求める`owner_hash()`、所有権ベース同値比較を行う`owner_equal()`を追加します。

非順序連想コンテナのデフォルトの比較関数型/ハッシュ型をこれらによって置き換えることで、`std::shared_ptr/std::weak_ptr`オブジェクトを所有権ベースで非順序連想コンテナに格納することができるようになります。

```cpp
template<typename T>
using weak_ptr_hashset = std::unordered_set<std::weak_ptr<T>, std::owner_hash, std::owner_equal>;

int main() {
  weak_ptr_hashset<int> set{};

  auto sp1 = std::make_shared<int>(10);
  set.insert(sp1);

  auto sp2 = std::make_shared<int>(20);
  set.insert(sp2);

  auto sp3 = sp1;
  set.insert(sp3);

  asset(set.size() == 2);
}
```

この提案は既にLWGのレビューを終えており、C++26に向けて次の全体会議で投票にかけられる予定です。

- [`std::shared_ptr::owner_before` - cpprefjp](https://cpprefjp.github.io/reference/memory/shared_ptr/owner_before.html)
- [`std::owner_less` - cpprefjp](https://cpprefjp.github.io/reference/memory/owner_less.html)
- [P1901 進行状況](https://github.com/cplusplus/papers/issues/649)

### [P1928R4 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r4.pdf)
### [P2019R3 Thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2019r3.pdf)
### [P2022R2 Rangified version of lexicographical_compare_three_way](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2022r2.pdf)
### [P2141R1 Aggregates are named tuples](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2141r1.html)
### [P2300R7 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2300r7.html)
### [P2447R4 std::span over an initializer list](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2447r4.html)
### [P2495R3 Interfacing stringstreams with string_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2495r3.pdf)
### [P2500R1 C++ parallel algorithms and P2300](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2500r1.html)
### [P2546R4 Debugging Support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2546r4.html)
### [P2548R5 copyable_function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2548r5.pdf)
### [P2552R2 On the ignorability of standard attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2552r2.pdf)
### [P2561R2 A control flow operator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2561r2.html)
### [P2621R3 UB? In my Lexer?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2621r3.pdf)
### [P2637R2 Member visit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2637r2.html)
### [P2641R3 Checking if a union alternative is active](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2641r3.html)
### [P2643R1 Improving C++ concurrency features](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2643r1.html)
### [P2654R0 Modules and Macros](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2654r0.pdf)

標準ライブラリで提供されるマクロを、標準ライブラリモジュール（`std.compat`）からエクスポートするようにする提案。

C++23から`std/std.compat`モジュールが提供されるようになり、標準ライブラリの全体をモジュールとしてインポートできるようになります。ただし、これには標準ライブラリ（特に、C互換ヘッダ）でマクロとして提供される機能が含まれていません。

これはモジュールの仕様に基づくもので、名前付きモジュールからはマクロをエクスポートすることができないためです。この制限がないヘッダユニットと呼ばれる、従来のヘッダファイルをモジュールとして`import`する方法もありこちらはマクロもエクスポートされますが、標準ライブラリのC互換ヘッダはヘッダユニットとして`import`可能であるかは実装定義です。

結局、標準のマクロ機能を使用しようとすると、従来のヘッダファイルのインクルード以外に手段がありません。

この提案は、モジュールにおけるマクロの扱いに変更を加えることなくこの制限を取り除くために、標準ライブラリ中でマクロとして提供される機能の代替提供手段を検討するものです。

この提案では、その対象として次のものを挙げています

- リテラル値に置換されるマクロ
    - これらは`#if`ディレクティブで多用されるため、`constexpr`変数で置換できない
    - テキスト置換を行わない新しいプリプロセッシングディレクティブにより解決（別提案）
- `assert`
    - このマクロはC++においては様々な問題を抱えている
    - P2884R0では、`assert`をキーワード化して演算子として使用するようにすることを提案しており、懸念事項が取り上げられている
- `offsetof`
    - P2883R0で議論
- `setjmp/longjmp`
    - C++オブジェクトモデル及びオブジェクト生存期間の概念と直接関わるもの
    - キーワード化して動作を提供することを提案
- `va_arg`
    - 言語の基礎的な機能であり、`import`で使用可能であるべき
    - キーワード化して動作を提供することを提案
- `errno`
    - 現在解決案はない
- `ATOMIC_XXX_LOCK_FREE`
    - これらのマクロはサポートされる場合にコンパイラによって定義される（モジュールからエクスポートする必要がない）
- `ATOMIC_FLAG_INIT`
    - C23ライブラリで削除されているため、削除すれば解決

この提案では必ずしも個別の解決策全てを提案しておらず、他の提案に委ねている部分があります。

- [モジュール - cpprefjp](https://cpprefjp.github.io/module.html)
- [P2654 進行状況](https://github.com/cplusplus/papers/issues/)

### [P2662R1 Pack Indexing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2662r1.pdf)
### [P2663R2 Proposal to support interleaved complex values in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2663r2.html)
### [P2663R3 Proposal to support interleaved complex values in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2663r3.html)
### [P2664R2 Proposal to extend std::simd with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2664r2.html)
### [P2664R3 Proposal to extend std::simd with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2664r3.html)
### [P2685R1 Language Support For Scoped Objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2685r1.pdf)
### [P2686R1 constexpr structured bindings and references to constexpr variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2686r1.pdf)
### [P2689R2 atomic_accessor](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2689r2.html)
### [P2717R1 Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2717r1.html)
### [P2727R2 std::iterator_interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2727r2.html)
### [P2728R1 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2728r1.html)
### [P2728R2 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2728r2.html)
### [P2728R3 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2728r3.html)
### [P2741R2 user-generated static_assert messages](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2741r2.pdf)
### [P2746R2 Deprecate and Replace Fenv Rounding Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2746r2.pdf)
### [P2748R1 Disallow Binding a Returned Glvalue to a Temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2748r1.html)
### [P2752R2 Static storage for braced initializers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2752r2.html)
### [P2757R2 Type checking format args](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2757r2.html)
### [P2767R0 flat_map/flat_set omnibus](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2767r0.html)

`flat_map`/`flat_set`の仕様にあるいくつかの問題点とその解決策について報告する提案。

この提案は、libc++における`flat_map`/`flat_set`とそのファミリを実装する過程で明らかになった問題をまとめ、解決が可能なものはその解決策について報告するものです。

この提案で報告されている大きなものは次のような事項です

1. 編集上の変更
    - 主に、アロケータを受け取るコンストラクタの調整
2. 一部のデフォルト引数を持つ`explicit`コンストラクタの分離
3. `flat_set::insert_range()`において、要素をムーブするようにする
4. `flat_set::insert_range()`において、要素をムーブするようにする
5. `insert()`が`emplce()`を使用しないようにする
    - 挿入位置決めのために、まず最初に挿入予定の要素をスタック上に構築する必要があるが、引数で渡されているオブジェクトを使用することでこれを回避できる
    - 同じ理由から、`falt_multiset`においてヘテロジニアスな`insert()`が有用となるため追加する（これは、他の`multi`な連想コンテナと異なる性質）
    - `emplace()`の制約を削除
    - `flat_set::insert()`に制約を追加し、イテレータペアを渡した時にヘテロジニアス`insert()`と曖昧にならないようにする
6. `sorted_unique`をとる`insert()`のオーバーロードに、`range`をとるものを追加
    - `insert(sorted_unique, args...)`は、複数の要素がソート済で一意であることを前提に1操作で挿入するAPI
    - `insert(first, last)`に対して`insert(sorted_unique, first, last)`、`insert(il)`に対して`insert(sorted_unique, il)`はあった
    - しかし、`insert(range)`に対して`insert(sorted_unique, range)`が欠けていたため、これを追加する
7. ソートが必要なコンストラクタの計算量の指定の修正
    - 一部のソート済みを仮定しないコンストラクタにおける計算量が`O(N)`と指定されている
    - これを達成するのは容易ではなく、そのような規定を`ranges::sort()`と同等になるように修正
8. `replace()`が右辺値参照ではなく値で受けるようにする
    - `replace(key_container_type&&, mapped_container_type&&)`はキーと対応する値の配列を受けて、内部の配列をそれによって置換するAPI
    - 引数としては、内部コンテナ型の右辺値参照を受けていた
    - `replace()`は常に右辺値を渡さなければならないが、似た他の場所のAPIではこのような用法ではなかった
    - 値で受け取るようにすることで、コピーして渡すことを容易にしつつムーブして渡す場合の使用感を維持する
9. `flat_set::keys()`の追加
    - `flat_map`には、そのキーと値の配列を参照するための`keys(), values()`が用意されているが、`flat_set`にはない
    - 利便性向上と一貫性のために、`flat_set`に`keys()`（だけ）を追加する

他にも、解決策が提案されていないIssueがいくつか報告されています。

- [P2767 進行状況](https://github.com/cplusplus/papers/issues/)

### [P2769R1 get_element customization point object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2769r1.html)
### [P2771R1 Towards memory safety in C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2771r1.html)
### [P2774R0 Scoped thread-local storage](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2774r0.pdf)

ローカル変数に束縛されたスレッドローカルストレージを簡易に扱うためのクラス、`std::tls<T>`の提案。

C++17の並列アルゴリズムなどによってFork-Joinモデルのような並列化を行い、各スレッド毎に結果を出力する必要がある場合、その出力先の同期を取る必要があります。スレッド1つにつき1つ（単一のオブジェクト）の出力であれば`std::atomic`等を用いることで同期を効率化できますが、出力が多数（コンテナなど）の場合、`std::mutex`等による明示的なロックが必要となります。

そのような場合にスレッドローカルストレージ（`thread_local`）を使用すると見た目はシンプルになりますが、全てのスレッドに対して隠れたコストが発生するなどローカルな問題をグローバル化してしまう等の欠点があります。

そこで、次のようなローカルオブジェクトに束縛されたスレッドローカルな領域を使用するとスレッドローカルストレージの欠点を回避することができます。ただ、これは多数のライブラリ機能を複合させた複雑なものであり、使用も煩雑になりがちです。

```cpp
// 入力データ
std::span<Triangle> input = …;
double max_area = …;

// スレッドローカルな領域を提供する
std::mutex m;
std::unordered_map<std::thread::id, std::vector<Triangle>> tmp;

// メインの並行処理
std::for_each(std::execution::par, input.begin(), input.end(),
  [&](const auto & tria) {
    // スレッド固有の領域を初期化し、取得
    // スレッドIDによって隔離されているため、取得して以降はロックなしで使用できる
    auto& ref{[&] -> std::vector<Triangle> & {
      const auto tid{this_thread::get_id()};

      const lock_guard lock{m};
      const auto it{tmp.find(tid)};

      if (it != tmp.end()) return it->second;

      return *tmp.emplace(tid, {}).first;
    }()};

    // 結果（複数）をスレッドローカルな領域へ出力
    for (const auto & t : split(tria, max_area)) {
      ref.emplace_back(t);
    }
  }
);

// 後処理、シングルスレッド
for(const auto & tria : tmp | std::views::join) {
  process(tria);
}

// 以降の処理のために、スレッドローカルな領域をクリア
tmp.clear();
```

この提案は、このような非`thread_local`なスレッドローカルストレージのためのラッパークラスを提供することで、このような用途（1スレッドが複数の出力を行う場合）におけるより効率的で使いやすいスレッドローカルストレージを提供しようとするものです。

提案されている`std::tls`はまさに上記のコード例における`m`と`tmp`およびその初期化部分をラップするようなクラスで、次のようなものです。

```cpp
namespace std {
  template<typename T, typename Allocator = allocator<T>>
  class tls {
    mutex m;
    unordered_map<thread::id, T, hash<thread::id>, key_equal<thread::id>, Allocator> storage;
    // NOTE: 現在標準ライブラリにはアロケータサポートをもつ関数ラッパは存在しない
    unmovable_function<Allocator, T() const> init_func;
  public:
    // (1) constructors
    tls(Allocator alloc = Allocator{}) noexcept requires is_default_constructible_v<T>;
    tls(T value, Allocator alloc = Allocator{}) requires is_copy_constructible_v<T>;
    tls(auto func, Allocator alloc = Allocator{}) requires is_convertible_v<T, invoke_result_t<decltype(func)>>;

    // (2) not copy- nor moveable
    tls(const tls &) =delete;
    auto operator=(const tls &) -> tls & =delete;
    ~tls() noexcept;
    
    // (3) modifiers
    [[nodiscard]]
    auto local() -> tuple<T &, bool>; //thread-safe!
    void clear() noexcept;
    
    // (4) iteration support
    class iterator { … };
    static_assert(forward_iterator<iterator>);

    auto begin() -> iterator;
    auto end() -> iterator; 
  };
}
```

`init_func`は最初に領域を取得しようとする場合にその領域を初期化するための関数であり、`std::mutex`は領域の取得時に同期をとるために必要となります。領域の取得は`local()`関数で行いますが、これはメンバで持っている`std::mutex`により保護されたスレッドセーフな関数となります。そして、`local()`によって取得される領域はスレッドIDによって管理されているため、一度取得してしまえば以降はロックなしで使用することができます。

ただし、この例は単純なものであり、並行ハッシュマップを使用するなどより効率的な実装が考えられます。

`std::tls`を使用すると、先程のサンプルコードは次のように単純化されます

```cpp
// 入力データ
std::span<Triangle> input = …;
double max_area = …;

// スレッドローカルな領域を提供する
std::tls<std::vector<Triangle>> tmp;

// メインの並行処理
std::for_each(std::execution::par, input.begin(), input.end(),
  [&](const auto & tria) {
    // スレッド固有の領域を初期化し、取得
    auto [ref, _] = tmp.local();

    // 結果（複数）をスレッドローカルな領域へ出力
    for (const auto & t : split(tria, max_area)) {
      ref.emplace_back(t);
    }
  }
);

// 後処理、シングルスレッド
for(const auto & tria : tmp | std::views::join) {
  process(tria);
}

// 以降の処理のために、スレッドローカルな領域をクリア
tmp.clear();
```

`std::tls`はこのように、`thread_local`の利点（見た目の単純さ）と明示的ロックによる利点（`thread_local`に比べて低コスト）を両立し、なおかつロックの粒度を最小化しようとするクラス型です。

- [P2774 進行状況](https://github.com/cplusplus/papers/issues/1540)

### [P2775R0 2023-05 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2775r0.html)

2023年5月にLEWGで行われるLEWG全体投票の予定表。

次の提案が、C++26導入を目指してLWGに転送することを決定するために投票にかけられます。

- [P1673R12 BLAS Linear Algebra](https://wg21.link/P1673R12)
- [P2630R3 submdspan](https://wg21.link/P2630R3)
- [P1383R1 More constexpr For <cmath> And <complex>](https://wg21.link/P1383R1)
- [P2546R3 Debugging Support](https://wg21.link/P2546R3)
- [P2548R5 copyable_function](https://wg21.link/P2548R5)
- [P2714R0 Bind Front And Back To NTTP Callables](https://wg21.link/P2714R0)
- [P2637R2 Member visit](https://wg21.link/P2637R2)
- [P2757R2 Type-Checking Format Args](https://wg21.link/P2757R2)
- [P2641R3 Checking If A Union Alternative Is Active](https://wg21.link/P2641R3)
- [P1759R6 Native Handle And File Streams](https://wg21.link/P1759R6)
- [P2697R0 Interfacing bitset With string_view](https://wg21.link/P2697R0)
- [P2248R7 Enabling List-Initialization For Algorithms](https://wg21.link/P2248R7)
- [P2734R0 Adding The New 2022 SI Prefixes](https://wg21.link/P2734R0)


### [P2781R1 std::constexpr_v](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2781r1.html)
### [P2781R2 std::constexpr_v](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2781r2.html)
### [P2786R1 Trivial relocatability options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2786r1.pdf)
### [P2811R2 Contract Violation Handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r2.pdf)
### [P2811R3 Contract Violation Handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r3.pdf)
### [P2811R4 Contract Violation Handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r4.pdf)
### [P2814R0 Trivial Relocatability --- Comparing P1144 with P2786](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2814r0.pdf)

オブジェクトの再配置（*relocation*）という操作に関する2つの提案を比較する文書。

*relocation*についての2つの提案については以前の記事を参照

- [P1144R6 Object relocation in terms of move plus destroy - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1144R6-Object-relocation-in-terms-of-move-plus-destroy)
- [P2786R0 Trivial relocatability options - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2786R0-Trivial-relocatability-options)

2023年2月のIssaquah会議において、*relocation*に関する2つの提案（P1146R7とP2786R0）がEWGIにてレビューされました。結果、この2つの提案には重複する部分が多くあることから、EWG/EWGIがC++における*relocation*操作についてのよりよい方針を決定するために、2つの提案の重複する部分をまとめ、また異なる部分を明確にすることで2つの提案を比較検討する必要性が示されました。

この文書はそれを受けて、P1146R7とP2786R0が提案する*relocation*（特に、*trivially relocatable*）に関しての設計や構文等の差異を比較しまとめるものです。

2つの提案の主要な違いは次のような事項です

|事項|P1144R7|P2786R0|
|---|---|---|
|*relocation*について|ムーブ+破棄に相当|ムーブ+破棄とは異なる|
|ムーブ代入の扱い|考慮する|考慮しない|
|正しい利用について|ユーザーを信頼するアプローチ|間違っている可能性のある用法はエラー|
|提供するもの|ユーザーが利用するための汎用アルゴリズム群を提供する|コア言語の変更に焦点を当てている|
|オプトアウト方法|提供しない|提供する|

2つの提案のいう*relocation*という操作とその利点等は共通していますが、P2786R0がその中でも*trivially relocatable*に特化したものであることによって、これらの差異が生まれています。

- [P2814 進行状況](https://github.com/cplusplus/papers/issues/1542)

### [P2821R1 span.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2821r1.html)
### [P2828R1 Copy elision for direct-initialization with a conversion function (Core issue 2327)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2828r1.html)
### [P2829R0 Proposal of Contracts Supporting Const-On-Definition Style](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2829r0.pdf)

契約プログラミングにおける事後条件の条件式から参照される関数引数が`const`でなければならないことをサポートする関数宣言・定義スタイルの提案。

契約プログラミングにおける事後条件特有の問題として、事後条件から関数引数が参照される場合に事後条件で評価する値がいつキャプチャされるのかが重要になるというものがあります。

```cpp
// ユーザーが見る宣言
int generate(int lo, int hi)
  [[pre lo <= hi]]
  [[post r: lo <= r && r <= hi]];

// 開発者が見る定義
int generate(int lo, int hi) {
  int result = lo;
  while (++lo <= hi) // loが更新される
  {
    if (further())
      ++result;      // loよりもゆっくりとインクリメントされる
  }
  return result;
}
```

この例では、`generate()`の戻り値は呼び出し時点の`lo`よりも大きくなりますが、関数終了時点の`lo`よりも小さくなる場合があります。呼び出し側からみると、関数宣言はコピー渡しであるので変更されず、また事後条件は渡した時点での`lo`の値で評価されるように読み取れます。しかし、関数定義からみるとそうではなく、事後条件は関数の終了直後に評価されることから呼び出し側の期待と異なる結果を生じてしまいます。

この問題は、事後条件から参照される関数引数のうち、非参照（参照引数なら呼び出し側から見ても変更されうることがわかる）であり非`const`（`const`引数なら関数実行中に変更されない）な関数引数に問題があります。

SG21ではこの問題の対策として、事後条件から参照される関数引数は非参照ならば`const`でなければならないことを決定しました。したがって、上記の例のようなコードはコンパイルエラーとなります。

```cpp
int generate(int lo, int hi)              // error: loとhiはconstでなければならない
  PRE(lo <= hi)
  POST(r: lo <= r && r <= hi);
	
int generate(int& lo, const int& hi)      // ok: loとhiは参照
  PRE(lo <= hi)
  POST(r: lo <= r && r <= hi);
	
int generate(int lo, int hi)              // ok: loとhiは事後条件から参照されていない
  PRE(lo <= hi)
  POST(r: r >= 0);
	
int generate(const int lo, const int hi)  // ok: loとhiはconst
  PRE(lo <= hi)
  POST(r: lo <= r && r <= hi);
```

一方、C++は関数型を決定する場合、関数宣言の解析後に引数型のトップレベル`const`を削除してから関数型を形成します。これはすなわち、次のような関数宣言と定義は同じ関数に対する宣言と定義として有効であるということです

```cpp
void f(int x);

void f(const int x) { /*...*/ }
```

別の言い方をすると、関数引数を`const`にする場合それは定義でだけ行えば良いということで、関数引数の`const`は関数のインターフェースの一部ではないということです。

この提案では、このような関数宣言・定義スタイルのことを「const-on-definition style」と呼んでいます。そして、この提案は契約プログラミングにおいて事後条件から関数引数を参照する場合に、このconst-on-definition styleを言語サポートしようとするものです。

具体的には、関数引数がその関数の事後条件内から参照されている場合

- 定義ではない関数宣言では、コンパイラによってその引数は暗黙`const`とみなされる
- 関数定義では、明示的に`const`としなければならない

というようにします。

```cpp
// 関数宣言
void f(int x) // <-- xは暗黙的にconst
  POST(is_const_v<decltype(x)>); // true

// 関数定義
void f(const int x) // <-- xは明示的にconstでなければならない
{
  /*...*/
}
```

現状の契約仕様では、事後条件内から関数引数を参照している場合、その関数の全ての宣言におけるその変数に対して明示的に`const`を付加する必要がありますが、このconst-on-definition styleのサポートによってそれは関数定義だけでよくなります。

- [P2388R2 Minimum Contract Support: either Ignore or Check_and_abort - WG21月次提案文書を眺める（2021年09月）](https://onihusube.hatenablog.com/entry/2021/10/03/193523#P2388R2-Minimum-Contract-Support-either-Ignore-or-Check_and_abort)
- [P2829 進行状況](https://github.com/cplusplus/papers/issues/1543)

### [P2831R0 Functions having a narrow contract should not be noexcept](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2831r0.pdf)

標準ライブラリの`noexcept`指定に関する設計について、現在のLakos Ruleを維持すべきとする提案。

Lakos Ruleとは、標準ライブラリの関数に`noexcept`を指定する際のルールのことです。Lakos Ruleでは関数に関する契約（*Contract*）を定義し、その契約に基づいて`noexcept`指定がされるかどうかを決めます。

Lakos Ruleにおける契約には2種類あり、事前条件を持たない関数は広い契約（*Wide Contracts*）がなされており、それ以外の関数（何かしらの事前条件を持つ）は狭い契約（*Narrow Contracts*）がなされているとします。そして、広い契約がなされている関数で例外をスローしない関数に関しては無条件で`noexcept`を指定し、それ以外の関数（特に狭い契約がなされている関数）に関しては`noexcept`を指定しない、とします。

現在の標準ライブラリ関数の`noexcept`指定はこのLakos Ruleに基づいて行われており、これによって"Throws: Nothing"のように指定されているのに`noexcept`指定はない関数が存在しています。

より積極的な`noexcept`指定を目的として、このルールを見直そうという動きがLEWGにおいてあるようで、現在のLEWGのガイドライン（[P2148R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2148r0.pdf)）では、狭い契約がなされている関数であってもLWGで例外を投げないという合意が取れれば無条件で`noexcept`を指定することになっています。他にも、P1656R2ではLakos Ruleを標準ライブラリ設計原則から外すべきだと主張されています。

この提案はそのような動きに反対し、Lakos Ruleが現在でも必要かつ有用であり標準ライブラリ設計原則として維持されるべき理由を解説するものです。

主にライブラリ関数のテスト（特にネガティブテスト）における有用性が主張されている他、`noexcept`を指定することがコンパイラの最適化にとって有利であることを示した報告はなく（むしろ低下させることを示した報告はある）、パフォーマンス向上を目的としてライブラリ関数に片っ端から`noexcept`をつけて回ることは間違っているとも述べられています。

- [広い契約(Wide Contracts)とnoexcept指定 - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20180127/p1)
- [The Lakos Rule - Arthur O’Dwyer](https://quuxplusone.github.io/blog/2018/04/25/the-lakos-rule/)
- [P2831 進行状況](https://github.com/cplusplus/papers/issues/1514)

### [P2834R0 Semantic Stability Across Contract-Checking Build Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2834r0.pdf)

契約プログラミングにおいて、契約述語の存在がビルドモードによって異なる影響を他の言語機能に及ぼさないようにする提案。

契約条件がその評価に伴って例外を投げる場合、その契約がなされている関数が`noexcept`指定されているとすると、その関数に対する`noexcept`演算子はどのように振る舞えばいいのかが問題になります。あるいは、契約条件が満たされない場合に例外を投げるような場合（ビルドモードもしくは例外ハンドラによる）にも同様の問題が発生します。

まだこの問題の結論は出てはいませんが、1つの方針として、契約（事前条件）の評価は関数の呼び出し前に行われるため、契約条件が例外を投げるかどうかはその関数の例外仕様の一部では無い、とするものがあります。その場合、関数の`noexcept`指定は契約の有無や内容によらず常に有効であり、その関数に対する`noexcept`演算子は`true`を返すことになります。

```cpp
void my_func(int i) [[pre: i >= 0]];
void your_func(int i) noexcept [[pre: i >= 0]];

int x; // Value is not used.
static_assert( false == noexcept(my_func(x)) );   // 常に成り立つ
static_assert( true == noexcept(your_func(x)) );  // 常に成り立つ？
```

しかし、契約条件（事前条件）の評価に伴う例外（契約条件式からのものであれ、契約が破られた時のものであれ）は全て、関数が呼び出される前にスローされます。例外が発生するのが関数の呼び出し前なのか後なのかを判断する仕組みはなく（そしておそらくそのような仕組みは意味がなく）、上記の`your_func()`は契約条件を評価するビルドモードでは常に例外をスローする可能性があります。そのため、事前条件のチェックが関数の例外仕様の外側にある場合に契約条件を評価するビルドモードでは、`noexcept`演算子は契約がなされている関数に対しては`false`を返す以外の選択肢がありません。

```cpp
int x; // Value is not used.
static_assert( true == noexcept(your_func(x)) );  // 契約条件をチェックしないビルドモードでは成り立つ
static_assert( false == noexcept(your_func(x)) ); // 契約条件をチェックするビルドモードでは成り立つ
```

すなわち、`noexcept`演算子の振る舞いはビルドモードによって変化してしまいます。

このようなビルドモードによる例外仕様の意図しない変化は、`noexcept`演算子によって関数の例外仕様をチェックしそれによって処理を分岐させている（これは`noexcept`の正しい用法です）コードに対して、静かにバグを埋め込んでしまう可能性があります（例は提案を参照）。

結局、契約条件を評価するビルドモードにおける関数の例外仕様の問題を回避するためだけに、事前条件を関数呼び出し前（または事後条件を呼び出し後）に評価するという戦略は、有効性が疑わしく実行可能ではありません。実行可能な唯一の選択肢は、関数の宣言から観測可能な例外仕様が`noexcept`演算子やその他のコンパイル時クエリの動作を、全ての契約チェックビルドモードで同じになるように制御することです。

この提案ではまず、次のような原則を提示しています

1. ビルドモードの独立性
    - 契約がなされている関数は、`noexcept`演算子をはじめとするコンパイル時のクエリについて、コンパイル時のセマンティクスが契約チェックのビルドモードによって変化することはない
    - 契約がなされている関数がその契約条件がコンパイルされwell-formedだったならば、`noexcept`演算子は全てのビルドモードで（すなわち契約が評価されるかどうかに関わらず）同じ動作をする
2. Lakos Rule
    - `noexcept`指定された関数の例外仕様と狭い契約は、本質的に互換性がなく、矛盾している
    - つまり、何かしらの契約がなされている関数は狭い契約を持つ（引数等に関して事前条件を持つ）ため、`noexcept`指定されるべきではない
3. 無視される契約条件のオーバーヘッドをゼロにする
    - 契約条件が無視された（ビルドモードによって）場合、その契約がなされている関数等付近のコードは、あたかもその契約条件がコメントアウトされたかのように振る舞う
    - ただし、ビルドモードに関わらず、契約条件から参照されているものはODR-useされる

その上で、Lakos Ruleを言語機能として組み込み強制させること（つまり、`noexcept`指定されている関数に対する契約の指定をコンパイルエラーとすること）は回避します。テストのためなど、`noexcept`指定と契約チェックを両立したいユースケースは想定され、また、嘘の`noexcept`指定（実際は例外を投げうるが開発者が追加の情報からそれを考慮しなくて良いと判断している場合など）にも有効なユースケースがあります（例外を投げうるムーブコンストラクタを持つ型をラップして、ムーブコンストラクタを`noexcept`にするなど）。そのように、関数の持つプロパティの一部をコンパイラが強制することはC++プログラマに利益をもたらしません。

これらのことをベースに、この提案では契約プログラミング導入後の`noexcept`に関して次のことを提案しています

- 関数の引数を初期化した後、未処理の例外をスローする`noexcept`関数のそれ以降のステップは、 [except.spec]/5に従って`std::terminate()`を呼び出す

すなわち、`noexcept`指定されている関数に契約を付与することができ、`noexcept`関数ではその契約は評価及び破られた時にも例外を投げないとみなされます。もしその仮定が裏切られ、その契約が評価中に例外を投げるか、契約が満たされなかった時に例外を投げた場合、現在の`noexcept`関数から例外を投げた時と同様に`std::terminate()`を呼び出してプログラムを終了させます。

この提案は、契約条件が例外を投げるかどうかはその関数の例外仕様の一部では無いとする方針の特別なケースであり、この方針によって示された利点（契約が評価されるか否かを翻訳単位の外で決定できるなど）を享受しつつ、ビルドモードによるコンパイル時プロパティの変化という欠点を回避することができます。

- [P2834 進行状況](https://github.com/cplusplus/papers/issues/1544)

### [P2835R0 Expose `std::atomic_ref`'s object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2835r0.html)

`std::atomic_ref`が参照しているオブジェクトのアドレスを取得できるようにする提案。

一部のハードウェアには、同じコア上で実行され同じプログラムステップを実行している、同じプログラムの異なるスレッドを検出するための命令が備わっています。

そのようなハードウェアではその命令を使用して、複数のスレッドで実行されるアトミック操作を1つのスレッドでだけ実行される単一の操作に集約することができます。そのようなパターンを用いると、複数スレッド間での同期のコストを削減し、パフォーマンスを向上させられる可能性があります。

単純なコードで記述すると、次のようなコードパターンになります

```cpp
// この関数は複数のスレッドで同時実行される
void unsynchronized_aggregated_faa(atomic<int>& acc, int upd) {
  // `acc`と`upd`の同じ値を使用して実行している空間的に近いスレッドを特定する
  auto thread_mask = __discover_threads_with_same(acc, upd);
  auto thread_count = popcount(thread_mask);
  
  // それらスレッドグループのリーダーを選出し、更新操作を集約する
  // スレッドごとに1つではなくこのスレッドでだけ、アトミックRMW操作を実行する
  if(__pick_one(thread_mask))
     acc.fetch_add(thread_count * upd, memory_order_relaxed);
}
```

そのようなハードウェアにはたとえばNVIDIAのGPUが該当し、同じWarpに所属しているスレッドが空間的に近いスレッドとなります。NVIDIAのGPU（CUDA）では、そのような命令として`__match_any_sync()`（と`__activemask()`）が提供されています。

そのような組み込みの命令（上記例の`__discover_threads_with_same()`）では、スレッドグループが共有している変数のポインタを受け取って、同じポインタを渡してきたスレッドを同じスレッドグループだと判定するものがあります。複数のスレッドで共有する変数なので`std::atomic`を使用するのは自然で、そのような命令には`std::atomic`変数のアドレスを渡すことになります。

この時に、`std::atomic_ref`を用いているとそのような命令を使用することができなくなります。なぜなら、`std::atomic_ref`はそもそも参照セマンティクスを持つ型なので関数には値渡しをするはずで、そうすると、各スレッドが持っている`std::atomic_ref`オブジェクトはローカルのものになり、そのアドレスはおそらく一致の保証がありません。

```cpp
// atomic_refを使用する場合の宣言
void unsynchronized_aggregated_faa(atomic_ref<int> acc, int upd) {
  ...
}

int main() {
  int n = 0;
  std::atomic_ref<int> ar{n};

  unsynchronized_aggregated_faa(ar, 0); // 例えばこのように呼ばれる
}
```

`std::atomic_ref`を参照渡しすれば解決できるかもしれませんが、それは無意味な二重参照であり、ともすれば間接参照のコストがかかってきます。あるいは、`std::atomic`の参照/ポインタを用いても解決できますが、提案によるとそれが必ずしもできない場合があるとのことです。

`std::atomic_ref`を使用している時でも、複数のスレッドで同じ1つのオブジェクトをアトミックに共有しているということは変わっておらず、この場合に欲しいのは`std::atomic_ref`が参照しているオブジェクトのアドレスです。しかし、現在の`std::atomic_ref`はそれを完全に隠蔽しており、取得する方法がありません。

この提案は、このような目的のために`std::atomic_ref`に`.data()`を追加して、その参照先のアドレスを取得できるようにしようとするものです。

```cpp
namespace std {
  template<class T>
  struct atomic_ref {
    ...
    
    // 追加するdate()関数
    T const* data() const noexcept;
    
    ...
  };
}
```

- [`std::atomic_ref` - cpprefjp](https://cpprefjp.github.io/reference/atomic/atomic_ref.html)
- [Using CUDA Warp-Level Primitives - NVIDIA Technical Blog](https://developer.nvidia.com/blog/using-cuda-warp-level-primitives/)
- [P2835 進行状況](https://github.com/cplusplus/papers/issues/1545)

### [P2837R0 Planning to Revisit the Lakos Rule](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2837r0.pdf)

Lakos Ruleの見直しを、契約プログラミング機能が固まるまで延期する事を推奨する提案。

Lakos Ruleは標準ライブラリの関数に`noexcept`を付加する際の基本的なルールです。C++11で導入されて以来10年以上経過しており、最近のライブラリ設計者はこのルールを改定することを頻繁に提案しているようです。

一方、現在契約プログラミング機能のC++26への導入に向けて活発な作業が続いています。もしそれが標準入りした場合、標準ライブラリ実装に対して契約を適用する事を許可するかどうかという事が議論され、それを許可する場合は現在文書で指定されている契約条件がどのように契約コードにエンコードされるべきかのガイドライン（ルール）を策定する必要があります。

契約プログラミングの事前・事後条件が必要になる関数というのは、Lakos Ruleでいうところの狭い契約を持つ関数であり、そのような契約プログラミングに関するガイドラインにはLakos Ruleが密接にかかわってくることは明らかです。

Lakos Ruleは標準ライブラリの上に構築されるプログラムが外的要因などによって標準ライブラリ機能の使用を制限されることが無いように、意図的に保守的なルールになっています。そのため、Lakos Ruleを順守するライブラリの上にLakos Ruleに従わないプログラムを書くことができる一方で、Lakos Ruleを順守しないライブラリの上にLakos Ruleに従うプログラムを書くことはできません。

契約プログラミングの機能がまだあまり固まっていないこともあり、契約プログラミングを標準ライブラリに適用する際のルールや原則がどのようになるかはまだ明らかではありません。しかし、そこにはLakos Ruleが関わってくることは明らかです。

そのため、この提案は、C++標準ライブラリの基礎的な設計指針としてのLakos Ruleを少なくとも契約プログラミングの準備が整うまでは現状を維持する（改訂を延期する）ことを提案するものです。

- [広い契約(Wide Contracts)とnoexcept指定 - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20180127/p1)
- [The Lakos Rule - Arthur O’Dwyer](https://quuxplusone.github.io/blog/2018/04/25/the-lakos-rule/)
- [P2837 進行状況](https://github.com/cplusplus/papers/issues/1515)

### [P2839R0 Nontrivial relocation via a new "owning reference" type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2839r0.html)

リロケーション（*relocation*）の言語サポートのための、新しい参照型の提案。

リロケーションについての2つの提案については以前の記事を参照

- [P1144R6 Object relocation in terms of move plus destroy - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1144R6-Object-relocation-in-terms-of-move-plus-destroy)
- [P2786R0 Trivial relocatability options - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2786R0-Trivial-relocatability-options)

リロケーション、特にトリビアルなリロケーション操作は、ムーブを効率化（オブジェクト全体の`memcpy`）しムーブ後オブジェクトの問題を解決することができます。

この提案は、トリビアルなリロケーション操作の背景を解説することを目的とし、上の2つの提案のようなライブラリサポートではなくムーブとよく似た機構による言語サポートを提案するものです。

この提案では、型`T`に対する*owning reference*`T~`をまず導入します。これは、リロケーションされようとしているリロケーション元のオブジェクトを指す参照であり、そのような状態のオブジェクトの値カテゴリは*rlvalue*となります。

*owning reference*型の値は*engaged*と*disengaged*のどちらかの状態にあり、*engaged*状態の*owning reference*はオブジェクトを所有しています。*engaged*状態の*owning reference*がその生存期間を終えると、所有している（参照している）オブジェクトは破棄されます。なお、プログラムの特定の地点で*owning reference*が*engaged*であるか否かは後述するルールに従って静的に決定されます。

この提案ではリロケーション（*rlvalue*あるいは`T~`へのキャスト）は`reloc`演算子によって行います。左辺値のオブジェクトはは`reloc`演算子によって*rlvalue*に変換され、その後元のオブジェクトを参照しようとする式は全てコンパイルエラーとなります。なお、`T~`型の変数名自体は左辺値です（右辺値参照型の変数が左辺値なのと同様）。

```cpp
struct T {
  int m;
};

void g(T& x);

void f(T~ ref) {  // `ref`はengaged状態、何かオブジェクトを所有している
  g(ref);  // OK; `ref`は左辺値

  T~ ref2 = reloc ref;
   // `ref`はdisengaged状態
   // `ref2`はengaged状態、以前に`ref`が所有していたオブジェクトを所有している

  g(ref);   // ill formed; `ref`はdisengaged状態
  ++ref.m;  // 同様にエラー
  g(ref2);  // OK

  if (rand() % 2) {
    {
      T~ ref3 = reloc ref2;
      // `ref3`はengaged状態、`ref2`はdisengaged状態
      // `ref3`の生存期間が終了し、`ref3.~T()`が呼ばれる
    }
    g(ref2);  // error
  } else {
    g(ref2);  // OK
    // `ref2`は暗黙的にはdisengaged状態へ移行、`ref2.~T()`が呼ばれる
  }

  g(ref2);  // error
}
```

このように、制御フローが分岐する場合にその分岐の一端で*owning reference*が*disengaged*状態になった場合、その制御フローが合流する地点（*disengaged*になってない分岐パスの終了地点）で同じ*owning reference*は*disengaged*状態に移行します。

このような関数と同様に、`T~`を引数にとるコンストラクタを定義することができます。それはリロケーションコンストラクタ（*relocation constructor*）と呼ばれ、上記の`T~`及び*rlvalue*の性質からムーブコンストラクタよりも強く所有権を引き取るコンストラクタです。コンストラクタから値を返すことは（例外を除けば）できないので、リロケーションコンストラクタに渡した*owning reference*（及びその参照元オブジェクト）の寿命は、そのコンストラクタが終了する時に終了することになります。

ある特定の型では、リロケーションコンストラクタが暗黙定義されます。暗黙定義されたリロケーションコンストラクタは既存の特殊メンバ関数と同様のルールに従いますが、常に無条件`noexcept`である点だけが異なります。あるいは、明治的に`default`定義しておくこともでき、その場合も暗黙定義された時と同じ性質を持ちます。そのようなデフォルトリロケーションコンストラクタはクラス型によって次のように動作します

- トリビアルにリロケーション可能な型では、`memcpy`によってオブジェクト表現をコピーしたかのようにオブジェクトを初期化する、トリビアルリロケーションコンストラクタが定義される
    - トリビアルリロケーションコンストラクタでは、ソースオブジェクトの生存期間を終了させるもののそのデストラクタを呼び出さない
- そうではなく、自身の*xvalue*から直接初期化が可能で有効なデストラクタを持つような型（`C`とする）の場合
    - `C`の*xvalue*から`C`を直接初期化するために選択されたコンストラクタと`C`のデストラクタの両方が`default`宣言されているならば
      - `C`の基底クラス及びメンバ変数の再起的なリロケーションを行う
    - それ以外の場合、`C`のムーブコンストラクタに委譲する
      - `C(C~ source) : C(static_cast<C&&>(source)) {}`
        - ソースオブジェクトはこのコンストラクタの完了後に破棄される
- それ以外の場合、リロケーションコンストラクタは`delete`される
    - この場合、ムーブコンストラクタ/代入演算子と同様に、オーバーロード解決時に無視される

型`T`の*rlvalue*は例えば次のような変換が可能です

- *rlvalue*（`T~`）が`.`もしくは`.*`の左辺のオペランドである時、*rvalue*（`T&&`）に暗黙変換される
- *prvalue*（`T`）は*rlvalue*（`T~`）に暗黙変換できる
    - オーバーロード解決において、この変換は右辺値参照または`const`左辺値参照（`T&&`/`const T&`）への束縛よりも良い変換とみなされる（優先順位が上になる）
- *glvalue*（`T&`/`T&&`）は`static_cast`によって明治的に*rlvalue*（`T~`）へ変換できる
    - この場合でも、*owning reference*型は参照先オブジェクトの所有権を引き取り、その生存期間の終わりに*engaged*状態だったらそのオブジェクトを破棄する

オブジェクトの一部（サブオブジェクト）だけをリロケーションするのは危険なため、継承関係にある型（基底クラス`B`と派生クラス`D`）の間で`B~ -> D~`のような変換は禁止されています。

この提案ではまた、`reloc`演算子を使用して自動変数をリロケーションできるようにするために、この*owning reference*の観点から自動変数のモデルと定義し直します。*owning reference*の導入後、自動変数`x`に対して暗黙的に所有参照`__x~`が定義されます。`__x~`は`x`を所有しているため、`reloc`演算子によって他の関数やコンストラクタ、*owning reference*に所有権が移されない場合、そのスコープの終了時に`__x~`が`x`を破棄することになります。その後、`x`を指名するid式はill-formedとなります。

```cpp
struct T {
  int m;
};

int main() {
  T x = {0};
  T y;
  T~ r = reloc x;  // `__x~`はdisengaged状態になり、`r`が`x`の所有権を引き取る
  ++x.m;  // ill formed `__x~`はdisengaged状態
  ++r.m;  // OK `rは左辺値

  // `r`のスコープ終端、`x`を破棄
  // `__y~`のスコープ終端、`y`を破棄
  // `y`のスコープ終端、`~T()`は呼ばれない
  // `__x~`のスコープ終端、disengaged状態のため何もしない
  // `x`のスコープ終端、`~T()`は呼ばれない
}
```

`reloc`演算子の振る舞いは、このようなモデルをベースとして定義されます。`reloc`演算子はid式（変数名）に対して適用できて、結果としてその変数名に結び付けられているオブジェクトの*owning reference*を取得し、値カテゴリは*rlvalue*の式となります。

`reloc`演算子は次のように動作します

- オペランドが、直接囲んでいる関数定義に関連するブロックスコープまたは関数パラメータスコープに属する`T~`型の自動変数`x`である場合
    - `reloc x`の結果は`x`が参照しているオブジェクトを指す*rlvalue*であり、`x`はそれによって*disengaged*となる
- オペランドが、直接囲んでいる関数定義に関連するブロックスコープに属するオブジェクト型の自動変数`x`である場合
    - `reloc x`の結果は`reloc __x~`

ABIによっては、関数引数のオブジェクト型の破棄責任が呼び出し先（関数内）ではなく呼び出し側にあるものがあり、それを考慮すると`T~`型ではない関数引数を`reloc`することはできないため、2番目の動作ではそれを除いています。ただし、コピー/ムーブコンストラクタを持たずリロケーションコンストラクタだけを持つようなリロケーション専用の型ではこれを認めることも提案しています。

提案では、これらのこと以外にも既存のムーブや右辺値/転送参照周りの仕様を参考にしながら、*owning reference*とリロケーションサポートのための言語機能について解説されています。提案は大きく4つのパートに分かれており、それぞれのパートはそれ以前のパートに依存するようになっているため、この提案の内容は全てを一気に導入するのではなく一部を少しづつ導入していくことができます。

- [P2839 進行状況](https://github.com/cplusplus/papers/issues/1570)

### [P2841R0 Concept Template Parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2841r0.pdf)

コンセプトを受け取るためのテンプレートテンプレートパラメータ構文の提案。

現在テンプレートテンプレートパラメータで渡すことができるのは型のみで、変数テンプレートやコンセプトを渡すことはできません。

この提案は、より高レベルの構成を可能とするために、テンプレートテンプレートパラメータ構文を拡張してコンセプト（と変数テンプレート）を渡せるようにしようとするものです。

これによって例えば、コンセプトアダプタのようなものが可能になったり

```cpp
// 参照型はregularではない
// 実質、右辺値を渡した時にしか制約が満たされない
template<std::regular T>
void f1(T&&);

// decayしてからコンセプトに渡すようにする
template<typename T>
  requires std::regular<std::decay_t<T>>
void f2(T&&);

// TをdecayしてCに通す、コンセプトアダプタ
template<typename T, template <typename concept C>>
concept decay_to = C<std::decay_t<T>>;

template<std::decay_to<std::regular> T>
void f3(T&&);

int main() {
  int n;

  f1(n);  // ng
  f2(n);  // ok
  f3(n);  // ok
}
```

あるいは複数のコンセプトを用いる制約を1つにまとめることができたり

```cpp
// range型Rの要素はCである
template<typename R, template <typename> concept C>
concept range_of = std::ranges::range<R> && C<std::ranges::range_value_t<R>>;

// 整数範囲を受けとりたい
auto f(range_of<std::integral> auro&& r);
// 浮動小数点数範囲を受けとりたい
auto f(range_of<std::floating_point> auro&& r);


// Tが全てのCを満たす
template<typename T, template<typename>... concept Cs>
concept all_of = (Cs<T> && ...);

// regularかつintへ変換可能
auto g(all_of<std::regular, std::convertible_to<int>> auto v);

// viewかつforward_range
auto g(all_of<std::ranges::view, std::ranges::forward_range> auto v);
```

現在の標準ライブラリにも見られるコンセプト内の制約の重複を共通化して括り出せたり

```cpp
// 現在イテレータヘッダにもある間接的に呼び出し可能系のコンセプトの例
// 共通する制約が多く含まれている
namespace now {
  template<class F, class I>
  concept IndirectUnaryInvocable =
    Readable<I> &&
    CopyConstructible<F> &&
    Invocable<F&, iter_value_t<I>&> &&
    Invocable<F&, iter_reference_t<I>> &&
    Invocable<F&, iter_common_reference_t<I>> &&
    CommonReference<
      invoke_result_t<F&, iter_value_t<I>&>,
      invoke_result_t<F&, iter_reference_t<I>>>;

  template<class F, class I>
  concept IndirectRegularUnaryInvocable =
    Readable<I> &&
    CopyConstructible<F> &&
    RegularInvocable<F&, iter_value_t<I>&> &&
    RegularInvocable<F&, iter_reference_t<I>> &&
    RegularInvocable<F&, iter_common_reference_t<I>> &&
    CommonReference<
      invoke_result_t<F&, iter_value_t<I>&>,
      invoke_result_t<F&, iter_reference_t<I>>>;

  template<class F, class I>
  concept IndirectUnaryPredicate =
    Readable<I> &&
    CopyConstructible<F> &&
    Predicate<F&, iter_value_t<I>&> &&
    Predicate<F&, iter_reference_t<I>> &&
    Predicate<F&, iter_common_reference_t<I>>;

  template<class F, class I1, class I2 = I1>
  concept IndirectRelation =
    Readable<I1> && Readable<I2> &&
    CopyConstructible<F> &&
    Relation<F&, iter_value_t<I1>&, iter_value_t<I2>&> &&
    Relation<F&, iter_value_t<I1>&, iter_reference_t<I2>> &&
    Relation<F&, iter_reference_t<I1>, iter_value_t<I2>&> &&
    Relation<F&, iter_reference_t<I1>, iter_reference_t<I2>> &&
    Relation<F&, iter_common_reference_t<I1>,
      iter_common_reference_t<I2>>;

  template<class F, class I1, class I2 = I1>
  concept IndirectStrictWeakOrder =
    Readable<I1> && Readable<I2> &&
    CopyConstructible<F> &&
    StrictWeakOrder<F&, iter_value_t<I1>&, iter_value_t<I2>&> &&
    StrictWeakOrder<F&, iter_value_t<I1>&, iter_reference_t<I2>> &&
    StrictWeakOrder<F&, iter_reference_t<I1>, iter_value_t<I2>&> &&
    StrictWeakOrder<F&, iter_reference_t<I1>,
      iter_reference_t<I2>> &&
    StrictWeakOrder<F&, iter_common_reference_t<I1>,
      iter_common_reference_t<I2>>;
}

// コンセプトテンプレートパラメータによって、共通部分を括り出す
namespace future {

  template <template <typename...> concept Direct,
      typename F, typename... Is>
  concept Indirect = 
    (Readable<Is> && ...) &&
    CopyConstructible<F> &&
    Direct<F&, iter_value_t<Is>&...> &&
    Direct<F&, iter_reference_t<Is>...> &&
    Direct<F&, iter_common_reference_t<Is>...> &&
    CommonReference<
      invoke_result_t<F&, iter_value_t<I>&...>,
      invoke_result_t<F&, iter_reference_t<Is>...>>;
  
  template<class F, class I>
  concept IndirectUnaryInvocable =
    Indirect<Invocable, F, I>;

  template<class F, class I>
  concept IndirectRegularUnaryInvocable =
    Indirect<RegularInvocable, F, I>;

  template<class F, class I>
  concept IndirectUnaryPredicate =
    Indirect<Predicate, F, I>;

  template<class F, class I1, class I2 = I1>
  concept IndirectRelation =
    Indirect<Relation, F, I1, I2>;

  template<class F, class I1, class I2 = I1>
  concept IndirectStrictWeakOrder =
    Indirect<StrictWeakOrder, F, I1, I2>;
}
```

などの利点があります。

この例を見ればわかるように、コンセプトテンプレートパラメータは通常のテンプレートテンプレートの構文（`template<template<typename> typename T>`）をベースに、最後の`typename`（もしくは`class`）のところを`concept`（コンセプト）もしくは`auto`（変数テンプレート）で置き換えることで記述します。

```cpp
template<
  typename T, // テンプレートパラメータの宣言
  auto V,     // NTTPの宣言
  template<typename> typename TT, // テンプレートテンプレートパラメータの宣言
  template<typename> auto VT,     // 非型テンプレートテンプレート パラメータの宣言
  template<typename> concept C,   // コンセプトテンプレートパラメータの宣言
>
void f();
```

この提案の内容はclangのフォークにて実装されており、Compiler Explorerで試すことができます。実装にあたっては特に困ったことは起こらなかったようです。

- [Concept template parameters - Barry's C++ blog](https://brevzin.github.io/c++/2019/01/09/concept-templates/)
- [P2841 進行状況](https://github.com/cplusplus/papers/issues/1546)

### [P2842R0 Destructor Semantics Do Not Affect Constructible Traits](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2842r0.pdf)

コンストラクタに関する型特性がデストラクタのセマンティクスに影響を受けないようにする提案。

例えば、`is_nothrow_copy_constructible`型特性は`noexcept`演算子を用いて次のようにコンパイラマジックなしで実装でき（そうに思え）ます。

```cpp
template<typename T>
struct is_nothrow_copy_constructible<T> {
  static constexpr bool value = noexcept(T{declval<T const &>()});
};
```

この時問題になるのは`noexcept`演算子の内部には`T`のデストラクタの実行（一時オブジェクトの破棄）も含まれてしまっていることで、`T`のコピーコンストラクタが`noexcept`な時でも、デストラクタがそうではない場合にこれは`false`になってしまいます。

C++11規格完成前にはこの問題は把握されており、標準の文言はこの問題を回避するために巧妙な言葉遣いをしています。`is_nothrow_copy_constructible`の場合はまず`is_nothrow_constructible<T, const T&>`に委譲したうえで、`is_nothrow_constructible`ではその結果がどうなるかは次のように指定されています（[[meta.unary.prop]/4](https://timsong-cpp.github.io/cppwp/n4861/meta.unary.prop#4.sentence-105)）

> `is_­constructible_­v<T, Args...>` is `true` and the variable definition for `is_­constructible`, as defined below, is known not to throw any exceptions ([expr.unary.noexcept]).

ここで重要なのは「variable definition (for `is_­constructible`)」という言葉であり、これはこのチェックのために変数を定義した場合にその定義に当たって例外を投げないということが言いたいらしく、その際例外を投げないとはどういうことかについてコア言語の`noexcept`演算子に投げています。

この変数定義については直接書かれていませんが、この文言を導入したN3142によると次のようなものです

```cpp
// こういう関数があったとして
template <class T>
typename add_rvalue_reference<T>::type create();

// これがチェックのための変数定義
T t(create<Args>()...);
```

この変数定義において、変数`t`は一時オブジェクトではなく左辺値であり、この変数定義そのものにはデストラクタの実行は含まれていません。従って、この変数定義が有効であり例外を投げない場合に`is_nothrow_constructible`は`true`になるという事です。

このような文言の意図は同様の問題（判定時にデストラクタの実行が混じってしまう）がある他の型特性についても同じ意図で導入されており、この文言が暗に示しているのはコンパイラマジックによってこれらの型特性を実装する（ただし、個別の式に分解した後でそれぞれの式の例外判定に`noexcept`演算子を用いることを許可する）べき、ということです。

このような巧妙な言いまわしはしかし、標準ライブラリ実装者には伝わらなかったようで、C++11および現在に至るまで標準ライブラリ実装はこの文章（上記変数定義）のことを直接チェックするべき式だと思って実装しているようです。つまり結局、冒頭のサンプルコードのような実装になってしまっているようです。

```cpp
#include <type_traits>

struct Test {
  Test() = default;
  Test(Test const&) = default;
  ~Test() noexcept(false) {} // non-trivial, potentially throwing
};

static_assert(std::is_trivially_copy_constructible<Test>::value, "non-trivial");
static_assert(std::is_nothrow_copy_constructible<Test>::value, "may throw");
```

このコードは、現在の主要な標準ライブラリ実装において失敗します（[godbolt](https://godbolt.org/z/ce7P8v8fs)）。

この提案は、この問題の解決のために、標準の規定のオリジナルの意図と実際の実装のどちらを重視するのかを決定し、それによって標準文書とライブラリ実装のどちらかを修正することを迫るものです。

この提案としては、問題があるのは実装の方だとして、現在標準ライブラリに報告されている関連Issueを欠陥ではない（NAD）として全てクローズし、既存標準ライブラリ実装に対してバグレポートを提出することを推奨しています。また、そのうえで上記のようなチェックすべき変数定義について明確化する事を提案しています。

一方で、既存のライブラリ実装を重視する場合についても考慮されており、いくつかオプションがあるもののその特性の判定にデストラクタの実行が関与することを明確にするように推奨しています。

- [N3142 Adjustments to constructor and assignment traits](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html)
- [P2842 進行状況](https://github.com/cplusplus/papers/issues/1547)

### [P2843R0 Preprocessing is never undefined](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2843r0.pdf)
### [P2845R0 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2845r0.html)
### [P2846R0 size_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2846r0.pdf)
### [P2848R0 std::is_uniqued](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2848r0.html)
### [P2850R0 Minimal Compiler Preserved Dependencies](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2850r0.pdf)

並行処理における処理の進行順序認識のために、コーナーケースにおける順序導出を例示する文書。

並行処理プログラムにおいて何もない場所から値を読み出ししてしまう問題をThin-air(read)問題といいます。Thin-airは現在のC++ではメモリモデルと注釈によって強く禁止されていますが、それでも完全に禁止できない場合があり、あるいはそれを許可したい場合があるようです。

そのようなThin-air問題の解決策として検討されているのが、*semantic dependency*(sdep)と呼ばれるもので、これはプログラム中のデータや制御フロー、アドレスの依存関係に暗黙的に含まれる順序のことで、それをコンパイラが認識できるようにしようとするものです。sdepは、コンパイラが最適化した後にも残らなければならない依存関係でもあり、最適化を禁止する側面と許可する側面を持っています。

この文書は、Thin-airが起こりうるような並行プログラムのコーナーケースのような場合に*semantic dependency*がどのように構築されるかを示すことによって、*semantic dependency*がどのような最適化（Thin-air）を許可し、あるいは最適化（Thin-air）を禁止するのかを示すものです。


この文書の目的は、sdepが無ければコンパイラが最適化を行えないケースとコンパイラが自由に最適化できなければsdepを求められないケースを定義することで、*semantic dependency*を標準に導入するための技術報告書のようなものにつなげようとするものです。

- [メモリモデルとThin-air read - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20120517/p1)
- [The Thin-air Problem](https://www.cl.cam.ac.uk/~pes20/cpp/notes42.html)
- [P2850 進行状況](https://github.com/cplusplus/papers/issues/1550)

### [P2852R0 Contract violation handling semantics for the contracts MVP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2852r0.html)

契約プログラミングの違反ハンドラとそれに伴うセマンティクスに関する提案。

現在C++26に向けて、SG21では契約プログラミングの最小限の設計を確立するための作業が進められています。

最近そこで議論されているのは、契約条件のチェックに伴って起こりうることについて、そのセマンティクス（意味論）をどのように指定するか？ということです。

特に、[P2811R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r1.pdf)では、ユーザー定義の違反ハンドラを許可することで契約違反が起きた場合の振る舞いをカスタマイズできるようにすることを提案しており、それによって契約違反時のセマンティクスをコア言語とビルドモードによる指定からユーザーによるカスタマイズによる指定に、設計を変化させようとしています。

この提案はP2811の方向性を支持し、ユーザー定義の違反ハンドラの振る舞いを確かなものにするために、違反ハンドラが呼ばれる場合と違反ハンドラが呼ばれた後の振る舞いに関するセマンティクスを規定しようとするものです。

この提案は、契約違反と違反ハンドラの振る舞いについて、次のようなことを提案しています

1. P2811R1で提案されている違反ハンドラを必要なら修正を加えて採用する
2. 実装が提供するデフォルトの違反ハンドラは、実装定義のアクション（エラーメッセージ表示など）の後で`std::abort()`を呼び出す実装とする
3. ユーザー定義の違反ハンドラはデフォルトの違反ハンドラを呼び出すことができる
    - これによって、ユーザー定義違反ハンドラで何かした後で、エラーメッセージ表示などデフォルトの動作をデフォルトのハンドラに委任できる
4. 契約条件のチェックおよび違反ハンドラの呼び出しのセマンティクスは次のように指定される

| 動作                                            | 指定されるセマンティクス                                           |
|-----------------------------------------------------|--------------------------------------------------------------|
| 契約条件はチェックされなかった              | well-defined; 実行継続                           |
| 契約条件がチェックされ、`true`を返した           | well-defined; 実行継続                           |
| 契約条件がチェックされ、`false`を返した          | well-defined; 違反ハンドラが呼び出され、それが正常にリターンした場合は実行継続 |
| 契約条件がチェックされ、未定義動作に遭遇した | 未定義動作                                           |
| 契約条件がチェックされ、例外が送出された                       | 未規定の動作                                     |
| 契約条件がチェックされ、`std::longjmp()`が呼ばれた             | well-defined; 呼ばれた`std::longjmp()`に従って実行継続 |
| 違反ハンドラが異常終了した                        | well-defined; プログラムは呼び出されたハンドラの指定に従って終了する |
| 違反ハンドラが正常にリターンした                           | well-defined; 実行継続                           |
| 違反ハンドラが例外を送出した                             | 未規定の動作                                       |
| 違反ハンドラが`std::longjmp()`を呼んだ               | well-defined; 呼ばれた`std::longjmp()`に従って実行継続 |

この提案による設計では、C++標準は契約のビルドモード（契約条件を評価するかしないか）を認識する必要が無くなります。実装は、違反ハンドラがリターンしないことや例外を投げない等の仮定を置いた最適化を実行することができます。

この提案はこれをC++26最終仕様とすることを意図しておらず、コンセンサスが得られている事項については動作と意味論を定義し、そうでない事項については未規定や未定義として別の提案によって詰めていくことを意図しています。

ただし、SG21では別の提案によって検討されている方向性を議論しておくことになったらしく、この提案の追求はストップされています。

- [P2811R1 Contract Violation Handlers - WG21月次提案文書を眺める（2023年4月）](https://onihusube.hatenablog.com/entry/2023/04/23/192236#P2811R1-Contract-Violation-Handlers)
- [P2838R0 Unconditional contract violation handling of any kind is a serious problem - WG21月次提案文書を眺める（2023年4月）](https://onihusube.hatenablog.com/entry/2023/04/23/192236#P2838R0-Unconditional-contract-violation-handling-of-any-kind-is-a-serious-problem)
- [P2852 進行状況](https://github.com/cplusplus/papers/issues/1551)

### [P2853R0 Proposal of std::contract_violation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2853r0.pdf)

契約プログラミングにおける、ユーザー定義可能な違反ハンドラのAPIの提案。

C++26の契約プログラミング導入に向けて、SG21ではP2811の方向性を採用し違反ハンドラをカスタマイズ可能とすることを決定したようです。

この提案は、P2811で提案されいてるAPIをベースに修正を加えるものです。

この提案の修正は次のような点です

- ヘッダは`<contract_violation>`
- `std::contract_violation`（契約違反が起きた条件に関する情報を保持するクラス）は`std::exception`の派生型
- `std::contract_violation`は[`semiregular`](https://cpprefjp.github.io/reference/concepts/semiregular.html)な型
    - デフォルト構築可能
    - コピー/ムーブ構築・代入可能
- `std::contract_violation`はABI安定（インラインpimplイディオムによる）
    - 将来の拡張時にABIを気にせずに済むようにする
- `std::contract_violation`はヒープを使用せず、大きな固定サイズバッファーを持つ
    - そのバッファ先頭にプライベートメンバが配置され、残りはメッセージ（`.what()`で取得するもの）の保持に使用する
- デフォルトの違反ハンドラは、`contract_violation::what()`のメッセージを`stderr`に出力し、`std::contract_resolution::abort_program`列挙値を返す


```cpp
// <contract_violation> ヘッダで定義（以前は<contract> ヘッダ
namespace std/*::contracts*/ {

  // 削除
  // enum class contract_violation_detection_mode : /*unspecified*/ {
  //   unknown,
  //   predicate_false,
  //   predicate_exception,
  //   predicate_undefined_behavior
  // };

  // enum class contract_semantic : /*unspecified*/ {
  //   ignore,
  //   enforce
  // };

  // 追加
  enum class contract_resolution { 
    abort_program
  };

  enum class contract_kind : /*unspecified*/ {
    empty, // 追加
    pre,
    post,
    assert
  };

  class contract_violation : public std::exception {
  public:
    // 追加
    contract_violation() noexcept;
    contract_violation(const contract_violation &) noexcept;
    contract_violation(contract_violation &&) noexcept;
    ~contract_violation();
    contract_violation &operator=(const contract_violation &) noexcept;
    contract_violation &operator=(contract_violation &&) noexcept;

    // 追加
    const char *what() const noexcept override;

    // 破られた契約の条件式のテキスト表現 
    //const char* comment() const noexcept;
    const char* source_code() const noexcept;

    // 契約違反の起こり方
    //contract_violation_detection_mode detection_mode() const noexcept;

    // 破られた契約の種別
    contract_kind kind() const noexcept;

    // 違反を起こした場所の情報
    //source_location location() const noexcept;
    const source_location& source_location() const noexcept;

    // ビルドモードに関する情報
    //contract_semantic semantic() const noexcept;
  private:
    // 説明専用メンバ
    static constexpr size_t size = 512;
    alignas(std::max_align_t) mutable char storage[size];
  };
}
```

そして、違反ハンドラは`contract_resolution`列挙値を返すように変更されます

```cpp
// 違反ハンドラの宣言
//void handle_contract_violation(const std::contracts::contract_violation&);
std::contract_resolution handle_contract_violation(const std::contract_violation &);
```

戻り値型が変更されているのは将来的な違反後継続モードなどをサポートすることを目したもので、将来的な後方互換のためです。現在は`abort_program`列挙値しかないためプログラム中断のみがサポートされており、将来的に別のモードをサポートする場合は列挙値を追加したうえで、ユーザーが自身の違反ハンドラの戻り値を変更することで行います。これによって、後から別のモードを追加したときにもその時点で使用されている違反ハンドラの振る舞いに影響を与えないようにしています。

このAPIを使って、Eval_and_abortモード（つまりデフォルトの違反ハンドラ）は次のように実装でき

```cpp
std::contract_resolution handle_contract_violation(const std::contract_violation& v) {
  std::cerr << v.what() << std::endl;
  return std::contract_resolution::abort_program;
}
```

Eval_and_throwモード（[P2698R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2698r0.pdf)）は次のように実装できます

```cpp
std::contract_resolution handle_contract_violation(const std::contract_violation& v) {
  throw v;
}
```

`std::contract_violation`が`std::exception`の派生クラスになっていることから、このような単純な実装によってEval_and_throwモードを実装可能です。

その他の例。

```cpp
// 例外再送出の検出
std::contract_resolution handle_contract_violation(const std::contract_violation& v) {
  if (std::exception_ptr e = std::current_exception())
    std::rethrow_exception(e);
  else
    /*...*/;
}

// Eval_and_spinモードとカスタムエラーメッセージ
std::contract_resolution handle_contract_violation(const std::contract_violation& v) {
  std::contract_kind kind = v.kind();
  const char* code = v.source_code();
  std::source_location location = v.source_location();
  
  // カスタムエラーメッセージ作成
  ErrorMessage msg = FormatErrorMessage(kind, code, location);
  
  // エラーメッセージを表示して、スレッドを停止
  DisplayErrorMessageAndWait(msg);
  
  return std::contract_resolution::abort_program;
}
```

`contract_violation_detection_mode`が削除されたのは1つ目の例のように`std::current_exception`で検出することができるため（かつ`unknown`と`undefined_behavior`の使い分けが不明瞭だったため）です。

- [P2811R1 Contract Violation Handlers - WG21月次提案文書を眺める（2023年4月）](https://onihusube.hatenablog.com/entry/2023/04/23/192236#P2811R1-Contract-Violation-Handlers)
- [P2853 進行状況](https://github.com/cplusplus/papers/issues/1552)

### [P2855R0 Member customization points for Senders and Receivers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2855r0.html)

P2300で使用される`tag_invoke`にアダプトするために、非メンバ関数ではなくメンバ関数と専用タグ型を使用するようにする提案。

P2300ではCPOの実装のために`tag_invoke`と呼ばれるユーティリティを使用しています。`tag_invoke`は`tag_invoke`という名前の関数にCPO毎のタグ型（CPOそのものが使用される）と追加の引数を渡して、ADLによって非メンバ関数（Hidden friendがよく使用されている）のユーザー定義`tag_invoke`を探して呼び出します。

従来のCPOではそこにアダプトするために同名の関数（非メンバ/メンバ）を定義する必要があり、その呼び出しはコンセプトでチェックされるものの完全に区別されるわけではなかったため、実質的に名前を占有していました。これによって、ユーザーは標準CPOで使用されている名前の使用を控えざるを得なくなったり、CPOの呼び出しに伴う探索範囲が広く候補関数が増大しやすかったりと言った問題がありました。

`tag_invoke`を使用すると、あるCPOにアダプトするための関数名は全て`tag_invoke`という名前の関数になり、`tag_invoke`はADLオンリーかつタグによって関数を識別するようになるため、それらの課題が解決されます。

```cpp
// 自作スケジューラ実装
struct my_scheduler {

  // schedule CPOにアダプトする例
  friend std::execution::sender auto tag_invoke(std::execution::schedule_t, auto&& self) {
    // schedulerにアクセスするためのsenderを返す
    ...
  }

};
```

とはいえ、`tag_invoke`という名前の関数がどのCPOにアダプトしているのかが視認しづらいことや、CPOにアダプトするための関数定義が複雑になりがち、CPOの型名を露出しなければならないなどの問題があります。

そのため、P2300も含めた将来的なカスタマイゼーションポイントを備えたライブラリを見据えて、C++20のCPOや`tag_invoke`が持つ問題を解決した関数カスタマイゼーションのための仕組みを言語機能で備えようとする動きがあります。

この提案は、（非メンバ関数ではなく）メンバ関数とCPO個別のタグ型を用いることによって、そのような言語機能を必要とせずに`tag_invoke`の持つ問題を改善できる、とするものです。

この提案の利点は次の2点です

- ADLを用いない
- カスタマイゼーションポイントの定義がかなりシンプルになる

この提案前後の`std::execution::schdule`CPOの実装は簡単には次のようになります

```cpp
struct schedule_t {
  
  auto operator()(auto&& s) const {
    // 現在
    return tag_invoke(auto(*this), s);

    // この提案
    return s.schedule(auto(*this));
  }
};
```

新しい定義による`std::execution::schdule`CPOにアダプトするためには、次のようにメンバ関数で`schdule`を実装します

```cpp
// 自作スケジューラ実装
struct my_scheduler {

  // schedule CPOにアダプトする例
  std::execution::sender auto schedule(std::execution::schedule_t) {
    // schedulerにアクセスするためのsenderを返す
    ...
  }

};
```

非メンバ関数ではなくメンバ関数を使用するようにすることで、探索にADLを使用しなくなるため名前が占有される空間をクラススコープに限定することができ、その上でタグ型のチェックを行うことでCPOにアダプトしている関数を区別します。これによって、CPOを定義する側とそれを利用する側のコードが単純化されます。

その他の例

```cpp
struct my_op_state {
  // start CPOへのアダプト宣言
  friend void tag_invoke(std::execution::start_t, recv_op& self) noexcept;

  // この提案
  void start(std::execution::start_t) noexcept;
};

struct my_sender {

  // connect CPOへのアダプト宣言
  template <typename _Self, receiver _Receiver>
    requires sender_to<__copy_cvref_t<_Self, _Sender>, __receiver<_Receiver>>
  friend auto tag_invoke(std::execution::connect_t, _Self&& __self, _Receiver __rcvr);

  // この提案
  template <typename _Self, receiver _Receiver>
    requires sender_to<__copy_cvref_t<_Self, _Sender>, __receiver<_Receiver>>
  auto connect(this _Self&& __self, std::execution::connect_t, _Receiver __rcvr);
}
```

この`connect`関数を呼び出すには次のようにします

```cpp
struct S {

  template<typename Sender, typename Receiver>
  auto operator()(Sender&& s, Receiver r) const {
    // 現在
    return tag_invoke(std::execution::connect, std::forward<Snd>(s), r);

    // この提案
    return std::forward<Snd>(s).connect(std::execution::connect, r);
  }

};
```

ただし、クエリを行うCPOに関してはこのようにせず、`tag_invoke`の代わりに`tag_query`という統一的な名前使用する`tag_invoke`のアプローチ（ただし、非メンバではなくメンバ関数のみを探索）を使用することを提案しています。

```cpp
struct S {
  // get_stop_token CPOへのアダプト宣言
  friend in_place_stop_token tag_invoke(std::execution::get_stop_token_t, const S& __self) noexcept;

  // この提案
  in_place_stop_token tag_query(std::execution::get_stop_token_t) const noexcept;
};
```

クエリの場合は、クエリ呼び出しそのものを転送する場合があるため、このようになっています。例えば、多重にチェーンされた`sender`と`receiver`を接続した`operation_state`に対して何かプロパティをクエリする場合、チェーンされているどこかの`sender`がそのプロパティを提供し、後のものはそれに依存しているようなことが起こり得ます。その場合、依存している`sender`はより内部の`sender`に対してプロパティのクエリを移譲する必要があり、その記述を簡易化

- [［C++］カスタマイゼーションポイントオブジェクト（CPO）概論](https://onihusube.hatenablog.com/entry/2020/06/26/225920)
- [P2221R0 : define P0443 cpos with `tag_invoke` - WG21月次提案文書を眺める（2020年09月）](https://onihusube.hatenablog.com/entry/2020/10/09/221025#P2221R0--define-P0443-cpos-with-tag_invoke)
- [P2855 進行状況](https://github.com/cplusplus/papers/issues/1518)

### [P2857R0 P2596R0 Critique](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2857r0.html)

P2596（`std::hive`の容量モデルを修正する提案）への反対を表明する提案。

P2596は`std::hive`の容量モデルが複雑で意図しない振る舞いをするとして、それを単純化することを提案するものです。P2596に関しては以前の記事を参照

- [P2596R0 Improve `std::hive::reshape` - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P2596R0-Improve-stdhivereshape)

この文書はP2596を添削する形でその間違いを指摘し、主張のまとめを行うものです。

提案による、現状維持（容量モデルを変更しない）ことを指示するポイント

1. ライブラリ/実装はキャッシュラインサイズを知らないため、ユーザーは参照局所性向上のために要素ブロックをキャッシュラインサイズの倍数にしたい場合がある
2. ライブラリ/実装はユーザーがどのようにデータを消去/挿入パターンを知らず、`std::hive`のイテレートの効率とメモリ消費はブロック容量に影響される
    - 固定量で挿入/削除を行うユーザーはそのサイズに一致するブロックサイズを設定するだろう
3. 要素の削除があるため、最大ブロックサイズが大きいことは良いことでばない
    - ブロックはその全ての要素が削除されるまでは有効であり続けるため、要素の削除が行われブロックの空室率が高まると要素間のギャップが大きくなる
    - これは統計的にみて、ブロックサイズが大きいほど無駄なメモリが増えることになる
    - 要素間のギャップは参照局所性を低下させ、メモリの浪費は組み込みや性能が求められる環境で問題となる可能性がある
4. キャッシュ制限のため、最大ブロックサイズが大きいことは良いことでばない
    - ブロックサイズがキャッシュラインサイズより大きくなっても参照局所性が向上することはなく、挿入/削除時のメモリ確保/解放が少なくなるだけ
5. 過剰なメモリ確保を防ぐために最大ブロックサイズが必要
    - 特に、ゲームエンジンなどのようにメモリ需要の高い環境では次のアロケーションサイズをコントロールできないものは選択肢に入らない
6. アロケータによっては、その内部の特定のチャンクで割り当てを行うものがあり、`std::hive`の容量モデルをはそれを支援するもの
7. 必ずしも全てのユーザーのニーズを予測できるわけではないため、合理的な範囲で柔軟な使い方を目指すべき
8. `std::hive`は特定条件下でSIMD処理で使用できる
9. ブロックの制限はユーザーが指定するかどうかに関係なく実装に存在する
    - 最小値側では、最初のブロックのメタデータのサイズよりも大きな妥当な最小値を持つことが理にかなっている
    - 最大値側では、ジャンプカウントのスキップフィールドのビット深度によって決定される。例えば16ビットのスキップフィールドではブロック内で最大65535要素のジャンプが可能なので、ブロックの最大サイズ制限は65536になる
      - スキップフィールドのビット深度が大きいほどメモリを浪費し性能向上につながるとは限らない。そのため、ユーザーのブロックサイズ制限をサポートするためのコードはほとんど付随的なもの
10. この容量モデルとそのAPIは、実際のユーザーから好評だった機能であり、個人的な美学を理由に削除を選択する人がいるのは奇妙なこと

一方で、変更を指示するポイントは次のような点です

1. 他のコンテナに同様のものがない
    - `deque`と`vector`には`capacity()`があるが、`list`にはない。`map`と`set`にはキーがあるが`deque`、`vector`、`list`にはない。
    - `std::hive`には容量制限があり、他のコンテナにはない
2. 制限があるとコンストラクタが増加する
    - 追加されたコンストラクタは全て委譲によって実装できるため、コードが肥大化することはない
3. 実装負荷の増加
    - 前述（現状維持ポイント9）したように、これによって実装負荷は増加しない。実際の作業は全て、コンテナの仕様と3つの中核的な設計面に費やされる。
    - 2つの主要ベンダーがリファレンス実装をフォークすると表明しており、もう1つのベンダーも参考にする可能性があるため、最小限の追加負荷は既に完了している

この提案の著者は`std::hive`実装者かつ提案者の方です。

- [P2857 進行状況](https://github.com/cplusplus/papers/issues/1519)

### [P2858R0 Noexcept vs contract violations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2858r0.html)

事前/事後条件をもつ`noexcept`関数における、契約違反時の例外送出に関する設計上の問題点を指摘する文書。

現在の契約プログラミング議論では、契約違反時の振る舞いの一つとして*Eval_or_throw*モードが提案されたことで`noexcept`関数の事前/事後条件の評価に伴って例外が送出されうる場合の`noexcept`プロパティの扱いが問題となっています。

```cpp
// noexceptだが、事前条件違反が起こる
void fun() noexcept [[pre: false]];

constexpr bool mystery = noexcept(fun());  // この値は何になる？

using nothrow_callback_t = void(*)() noexcept;
nothrow_callback_t p = fun;                // コンパイルが通る？

void overload(void(*)());                  // #1
void overload(void(*)() noexcept);         // #2

overload(&fun);                            // どちらのオーバーロードが呼ばれる？
```

この問題解決のために、すでにいくつかの実装論や意味論に関する提案が提出されています。この提案はそれらの議論を踏まえつつ、`noexcept`の考え方などを説明し、それらの提案にある問題点について報告するものです。

- 契約チェックから例外を投げられるようにするには、`noexcept`に関する全ての静的なプロパティについて明確な意味論を定義する必要がある
    - そのために、`noexcept`とは何かを明確に説明する必要がある
    - オーバーロードを制御するための表明と、事前条件を充足することによる失敗しない保証を混同することは有益でない場合がある
- あるいは、違反ハンドラからの例外送出をひとまず禁止しておき、`noexcept`関連の議論に時間をかける
- 契約違反時に停止することを回避するアプリケーションにおいて、契約違反を検知してから例外によってそれを報告することは間違っている
    - 例外それ自体が早期終了の原因となる
    - `noexcept`関数からの例外送出は無条件終了となり、例外は契約と関係の無い場所からでも投げられるため

直接的には主張されて位はいませんが、雰囲気的には契約違反時に例外を投げること（*Eval_or_throw*モード）に反対しているようです。

### [P2861R0 The Lakos Rule: Narrow Contracts And `noexcept` Are Inherently Incompatible](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2861r0.pdf)

標準ライブラリの関数に`noexcept`を付加する基準であるLakos Ruleを維持すべき理由を解説する文書。

この文書は非常に長いですが、次のような構成になっています

1. 契約について議論する前に用語を定義する
    - ライブラリUBと言語UBを区別する
    - 例外を投げないという例外指定を持つ関数は、狭い契約（*Narrow Contracts*）を持つことができない
2. ある特定の狭い契約をを持つライブラリ関数を考え、それを複数のバージョンにわたって拡張していくことの価値をC++の側面から検討する
    - 最初のバージョンで`noexcept`を追加していたらどう（ひどいことに）なっていたかを調べる
3. 狭い契約と契約チェック（言語機能）がどのように相互作用するかを見る
    - 契約違反ハンドラが例外をスローすることの必要性を、いくつか正当化する
    - 特に、完全な回復ではないにせよ一時的な継続、およびネガティブテストの手段として、契約違反時に例外をスローすることを検討する
4. `noexcept`指定の自由な使用が例外を使用して稀なエラーや予期しないエラーを伝達するソフトウェア設計に及ぼす悪影響について検討する
    - `noexcept`演算子を広く利用することでコードサイズを削減することができるが、実行時のパフォーマンスが大幅に改善されることやそれが測定可能であることを示す理論や経験則は存在しない
5. Lakos Ruleの再検討
    - Lakos Ruleの例外とはどのようなものなのかについて、仮説を立ててそれが4つの基準を満たすかを調べる
    - 最後に、Lakos Ruleの唯一の例外を紹介する
6. 標準ライブラリの仕様、その具体的な実装、サードパーティライブラリ、エンドユーザーライブラリに対して、`noexcept`指定を有効に活用するための推奨事項とその正当性を示す

最終的にこの文書の主張するところは、「技術的にやむを得ない正当な理由がない限り、Lakos Ruleから外れることは常に非常に悪いアイデアである。特に、標準ライブラリの仕様内でそうすることは絶対に避けるべき」というものです。

なお、この文書の筆者の方はLakos Ruleを提唱した方です。

- [広い契約(Wide Contracts)とnoexcept指定 - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20180127/p1)
- [The Lakos Rule - Arthur O’Dwyer](https://quuxplusone.github.io/blog/2018/04/25/the-lakos-rule/)

### [P2862R0 text_encoding::name() should never return null values](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2862r0.html)

`std::text_encoding` の提案（[P1885R12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1885r12.pdf)）に含まれる `text_encoding::name()` の仕様を変更する提案。

具体的には、`text_encoding::name()` が名前を返すことができない場合、ヌルポインタではなく空の文字列を返すように仕様を変更することを提案しています。

P1885R12 の設計では、ICU や iconv のような広く導入されているライブラリと互換性を持たせることを目指しています。それらのライブラリでは、エンコード名をヌルポインタとして扱うことをサポートしていない場合があります。次のコードはその一例で、セグメンテーション違反を引き起こします。

```cpp
iconv_open(nullptr, "utf-8"); // NG
```

同様に、次のようなシンプルな C++ コードでも、`text_encoding::name()` がヌルポインタを返す場合、容易に未定義動作となります。

```cpp
std::cout << te.name();             // Violates [ostream.inserters.character] p3
std::format("Name: {}", te.name()); // Violates [format.arg] p5
""sv == te.name();                  // Violates [string.view.cons] p2 since traits::length doesn't accept null values
```

`text_encoding::name()` がヌルポインタを返すべき強い理由が見あたらなかったため、戻り値の型が `const char*` である `source_location::file_name()` が常に null 終端文字列を返す、という既存事例にならい、`text_encoding::name()` についても空の文字列を返すようにすることを提案しています。

- [P1885R12 Naming Text Encodings to Demystify Them](https://wg21.link/P1885R12)
- [P2862 進行状況](https://github.com/cplusplus/papers/issues/1521)

### [P2863R0 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2863r0.html)

現在非推奨とマークされている機能について、C++26で削除/復帰を検討する提案。

C++23までの間に非推奨とされたコア言語/ライブラリの機能は、必ずしも削除されずに残されており、規格書のAnnex Dセクションにまとめられています。

現在そのような機能は29個（コア言語9, ライブラリ20）あり、この提案はそれらの機能を取り巻く環境や非推奨化の背景を検討したうえで、非推奨のままにしておくのか、非推奨を取り消すのか、削除するのか、を決定しようとするものです。

ただし、この提案はそれらのまとめとインデックスのような文書で、個々の機能それぞれについては個別の提案で詳しく検討されます。C++23では1つの提案にまとめて同じことを行おうとしていましたが、複数のフィードバックが寄せられた結果処理がパンクし提案の改訂が間に合わず、結局C++23設計サイクル中にほとんど議論できなかったためのようです。

現在非推奨となっているコア言語機能の一覧

| 機能 | 導入時期 | 非推奨時期 |
| --- | --- | --- |
| Arithmetic conversion on enumerations | C++98 | C++20 |
| Implicit capture of *this by reference | C++11 | C++20 |
| Array comparisons | C++98 | C++20 |
| Deprecated use of volatile | C++98 | C++20 |
| Redeclare static constexpr members | C++11 | C++17 |
| Non-local use of TU-local entities | C++98 | C++20 |
| Implicit special members | C++98 | C++11 |
| Some literal operator declarations | C++11 | C++23 |
| template keyword before qualified names | C++98 | C++23 |

現在非推奨となっているライブラリ機能の一覧

| 機能 | 導入時期 | 非推奨時期 |
| --- | --- | --- |
| Requires: clauses | C++98 | C++20 |
| has_denorm members in numeric_limits | C++98 | C++23 |
| Deprecated C macros | C++98 | C++23 |
| relops | C++98 | C++20 |
| char * streams | C++98 | C++98 |
| Deprecated error numbers | C++11 | C++23 |
| The default allocator | C++17 | C++23 |
| polymorphic_allocator::destroy | C++17 | C++23 |
| Deprecated type traits | C++11 | C++20 |
| volatile tuple API | C++11 | C++20 |
| volatile variant API | C++17 | C++20 |
| std::iterator | C++98 | C++17 |
| move_iterator::operator-> | C++11 | C++20 |
| C API to use shared_ptr atomically | C++11 | C++20 |
| basic_string::reserve() | C++98 | C++20 |
| \<codecvt> | C++11 | C++17 |
| wstring_convert et al. | C++11 | C++17 |
| Deprecated locale category facets | C++11 | C++20 |
| filesystem::u8path | C++17 | C++20 |
| atomic operations | C++11 | C++20 |

- [Annex D (normative) Compatibility features [depr] - eel.is](http://eel.is/c++draft/depr)
- [P2863 進行状況](https://github.com/cplusplus/papers/issues/1570)

### [P2864R0 Remove Deprecated Arithmetic Conversion on Enumerations From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2864r0.pdf)

C++20の一貫比較仕様に伴って非推奨とされた、列挙値から算術型への暗黙変換を削除する提案。

C++20の宇宙船演算子では`enum`値と浮動小数点数型や異なる列挙型間の比較を禁止していますが、従来の比較演算子ではそれは暗黙変換によって可能となっており、異なる列挙型の間では算術演算すら可能です。それらの挙動はバグであると思われるため、C++20で非推奨とされました。

ただ、列挙型から浮動小数点数型への暗黙変換は、比較以外の場所では元々禁止されていました。

この提案は、C++26にてそれらの非推奨化されている暗黙変換を削除しようとするものです。この提案が削除しようとしているのは次の2つのものです

- 列挙型から浮動小数点数型への暗黙変換
- 異なる列挙型の値から同じ整数型への暗黙変換

```cpp
int main() {
  enum E1 { e };
  enum E2 { f };

  bool b = e <= 3.7;  // C++20で非推奨、削除を提案
  int k = f - e;      // C++20で非推奨、削除を提案
}
```

この仕様はC++98にて導入されたもののようで、削除する事は破壊的変更となります。しかし、このような変換はそのメリットを意図せず起こしてしまう場合のデメリットの方が大きいため、削除することを提案しています。また、C++26で削除するとするとC++20で非推奨とされてから6年経過しており、その間に主要な実装はこの変換に警告を出すようになっています。

なお、列挙型と整数型の間の演算（列挙型から整数型への暗黙変換）は非推奨とされていないためC++20以降も影響を受けておらず、異なる列挙型間の演算や比較については単項`+`演算子を使用して片方を整数昇格させることで回避することができたりします。

```cpp
int main() {
  enum E1 { e };
  enum E2 { f };

  int k =  f - e; // C++20で非推奨
  int x = +f - e; // OK
}
```

- [C++20 一貫比較 - cpprefjp](https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html)
- [P2864 進行状況](https://github.com/cplusplus/papers/issues/1554)

### [P2865R0 Remove Deprecated Array Comparisons from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2865r0.pdf)

C++20の一貫比較仕様に伴って非推奨とされた、配列間の比較を削除する提案。

従来の比較演算子では配列型と配列型の比較が可能で、それは配列の先頭ポインタの比較をおこなっていました。C++20の宇宙船演算子はそれを禁止しており、それに倣って従来の比較演算子では非推奨とされました。  

すなわち、配列と配列の等価比較を行っていてもそれは要素ごとの比較ではなく配列の先頭アドレスの比較になっており、`true`となるのは同じ配列同士を比較した時だけです。順序付比較（`<`など）はより悪く、特定の条件下を除いてほとんどの場合結果は未規定です。

オブジェクトの同一性チェックはそのアドレスを明示的に取得して行うのが一般的かつ最良です。このような暗黙的な変換に頼ることは非常に稀であると思われ、その意味を知らないプログラマがそのコードを見てもその意図を見抜くことはできないでしょう。

したがって、この提案はC++20で非推奨とされた配列同士の比較をC++26で削除することを提案するものです。

より正確には、比較演算子のオペランドの型変換の際に、片方のオペランドが配列の場合は他方のオペランドがポインタの場合にのみ配列からポインタへの変換を適用する、というように修正します。

そのため、C++20及びこの提案採択後でも、配列とポインタの間の比較（配列オペランドのポインタへの減衰）は非推奨ではなく合法的な動作です。

```cpp
int main() {
  int arr1[5];
  int arr2[5];

  bool same = arr1 ==  arr2; // C++20で非推奨、削除を提案
  bool idem = arr1 == +arr2; // OK、アドレスの比較、ただし結果は未規定
}
```

- [C++20 一貫比較 - cpprefjp](https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html)
- [P2865 進行状況](https://github.com/cplusplus/papers/issues/1555)

### [P2866R0 Remove Deprecated Volatile Features From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2866r0.pdf)

C++20で非推奨とされた`volatile`関連の機能を削除する提案。

C++20では、無意味だったり危険な`volatile`関連の使用法がコア言語・ライブラリ両方において非推奨とされ、その後C++23にて、このうち複合代入演算子の非推奨化は解除されました。

この提案は、C++20で非推奨化されC++23で残っているすべての`volatile`の用法について、削除しようとするものです。

複合代入演算子を除いては、非推奨化に反対するフィードバックは寄せられていないようで、これらの用法を削除することで誤解を招くようなコードを書けないようにすることができます。

- [C++20 ほとんどの`volatile`を非推奨化 - cpprefjp](https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html)
- [CWG Issue 2654. Un-deprecation of compound volatile assignments](https://cplusplus.github.io/CWG/issues/2654.html)
- [P2327R0 De-deprecating volatile compound assignment - WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P2327R0-De-deprecating-volatile-compound-assignment)
- [P2866 進行状況](https://github.com/cplusplus/papers/issues/1556)

### [P2867R0 Remove Deprecated strstreams From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2867r0.pdf)

長く非推奨となっていた、`std::strstream`を削除する提案。

`std::strstream`は生配列をラップする文字列ストリームであり、`std::stringstream`が`std::string`をラップする文字列ストリームであるのと比較すると、こちらは`char[N]`をラップするストリームです。

`std::strstream`のメンバ関数`.str()`は`char*`を返しますが、こうして返された領域をユーザーが解放すべきなのか気にしなくていいのか、どのように管理すべきかが不透明でした。コンストラクタでの構築時はユーザーがその領域を指定することも`std::strstream`に確保させることもでき、`std::strstream`に確保させた場合はその領域がどのように確保されたのかはどこにも記載がありません。

正解は、構築時に領域を渡していない場合に`.str()`で文字列を取得した場合はデストラクタ実行までの間に`.freeze(false)`を呼び出すことで`std::strstream`のデストラクタがその領域を解放してくれます。しかし、この挙動は分かりづらく、実際あまり周知されていなかったようで、簡単に間違って使うことができてしまっていました。

```cpp
#include <strstream>

int main() {
  {
    // 動的なバッファを確保してもらう
    std::strstream s1;
    s1 << "dynamic buffer";
    s1 << std::ends;  // 手動null終端

    std::cout << "Contents : " << s1.str() << '\n';
    
    s1.freeze(false); // 忘れるとメモリリーク
  }
  
  {
    // 静的なバッファを渡す
    char buffer[20];
    std::strstream s2{buffer, std::size(buffer)};
    s2 << "static buffer";
    s2 << std::ends;  // 手動null終端

    std::cout << "Contents : " << s2.str() << '\n';
    // freeze()はいらない
  }
}
```

他にも、`.str()`のnull終端のためにはユーザーがそれを（`std::ends`を利用するなどして）ストリームに入力しなければならないなどやはり使いづらいところがあり、これらの問題からC++98で非推奨とされました。

代替としては`std::stringstream`を用いることができるのですが、こちらはこちらで内部文字列をいつもコピーして返すなどの問題があり、`std::strstream`のようにあらかじめ用意した静的な領域を渡すことで動的確保を避けたいような用途としては代替機能がなく、削除されずに残されていました。

C++20では、`std::stringstream`に`.view()`が追加されたり、`.str()`がムーブして返すことができるようになるなど、文字列の取得に伴うコピー回避の手段が提供されたほか、`std::spansstream`が`std::strstream`の完全かつ安全な代替機能として提供されました。

この提案は、`std::strstream`を削除する準備が整ったとして、C++26で`std::strstream`と関連する機能を削除しようとするものです。

- [`std::strstream` - cppreference](https://en.cppreference.com/w/cpp/io/strstream)
- [strstream クラス - Microsoft Learn](https://learn.microsoft.com/ja-jp/cpp/standard-library/strstream-class?view=msvc-170)
- [Why was std::strstream deprecated? - stackoverflow](https://stackoverflow.com/questions/2820221/why-was-stdstrstream-deprecated)
- [P0448R3 A strstream replacement using span as buffer - WG21月次提案文書を眺める（2021年02月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P0448R3-A-strstream-replacement-using-span-as-buffer)
- [P2867 進行状況](https://github.com/cplusplus/papers/issues/1523)

### [P2868R0 Remove Deprecated `std::allocator` Typedef From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2868r0.pdf)

`std::allocator`にある非推奨化された入れ子型定義を削除する提案。

`std::allocator`は`size_type`や`pointer`等の入れ子型を持っていましたが、これは`std::allocator_traits`によって自動で導出可能であったため、C++17で非推奨とされました。これらについてはC++20で削除されています。

その後、C++23にて`is_always_equal`も非推奨とされました。この提案は、これはC++26で削除しようとするものです。

`std::allocator::is_always_equal`は、アロケータがステートレスであるかを調べる入れ子型で、デフォルトでは`std::true_type`が使用されます。`std::allocator`から派生して独自のアロケータを実装しようとする時にそのアロケータがステートレスではない場合、`is_always_equal`を上書きしない場合デフォルトの`is_always_equal`（ステートレスであると表明）が使用されてしまい、静かなバグを埋め込むことになります。

このような誤用を防止し、またわざわざその必要性などを説明する必要をなくすために、この提案では`std::allocator::is_always_equal`を削除しようとしています。

- [`std::allocator` - cpprefjp](https://cpprefjp.github.io/reference/memory/allocator.html)
- [P2868 進行状況](https://github.com/cplusplus/papers/issues/1524)

### [P2869R0 Remove Deprecated `shared_ptr` Atomic Access APIs From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2869r0.pdf)

C++20で非推奨とされた、`std::shared_ptr`のアトミックフリー関数を削除する提案。

`std::shared_ptr`には、そのポインタ値そのもの（not参照先）にアトミックアクセスするためのフリー関数が用意されていました。しかし、これらはフリー関数であるため、アトミックアクセスしたい対象の`std::shared_ptr`オブジェクトはプログラマが区別する必要がありました。そのため、直接対象の`std::shared_ptr`オブジェクトにアクセスすれば非アトミックアクセスとなり、それが複数スレッド間で同時に起きればデータ競合として未定義動作となります。


```cpp
// アトミックにアクセスしたいshared_ptrオブジェクト
std::shared_ptr<int> atomic_ptr{};

void thread_f() {
  // アトミックにshared_ptrを更新
  std::atomic_store(&atomic_ptr, std::make_shared<int>(20));

  // ポインタへのアクセスがアトミックになっていない
  auto n = *atomic_ptr;

  // こうすると、ポインタへのアクセスがアトミックになる
  auto ptr = std::atomic_load(&atomic_ptr);
  auto m = *ptr;
  // 一行で書いても良い
  // auto m = *std::atomic_load(&atomic_ptr);
}

void f() {
  // アトミック操作関数を経由しなければ非アトミックアクセス
  atomic_ptr = std::make_shared<int>(20);
  auto n = *atomic_ptr;
}
```

このように、`std::shared_ptr`のアトミックアクセス用フリー関数は簡単に誤って使用することができ危険だったためC++20で非推奨とされ、代わりに`std::shared_ptr`（と`std::weak_ptr`）の`std::atomic`特殊化が追加されました。こちらを用いると、どこからアクセスした時でも`std::shared_ptr`のポインタ値にアトミックにアクセスすることができます。

安全かつ完全に代替できる機能がすでに追加されており、削除することで危険な利用をコンパイルエラーとして報告することができるようになります。また、コードの変更も対象の`std::shared_ptr`を`std::atomic<std::shared_ptr>`に書き換えるだけで済みます。この提案はこれらの理由から`std::shared_ptr`のアトミックアクセス用フリー関数を削除しようとする提案です。

ただし、以前にこれらの関数を使用していたコードは`std::shared_ptr`を`std::atomic<std::shared_ptr>`に書き換えた後で`std::atomic*`を引数に取るフリー関数を呼び出すようになります。これそのものに問題はないのですが、これは`<atomic>`ヘッダで定義されているためヘッダ依存関係が変更されます。これを回避するために、削除対象の関数と同名の`std::atomic*`を引数に取るフリー関数を`<memory>`ヘッダで宣言しておくことも提案されています。

- [`std::atomic` - cpprefjp](https://cpprefjp.github.io/reference/memory/atomic.html)
- [P2869 進行状況](https://github.com/cplusplus/papers/issues/1525)

### [P2870R0 Remove `basic_string::reserve()` From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2870r0.pdf)

C++20で非推奨とされた`std::string::reserve()`をC++26に向けて削除する提案。

`std::string::reserve()`は元々、キャパシティを増大させるだけではなく減少させることもサポートしていました。これは`std::vector::reserve()`の挙動とは異なっており、引数の値によってはパフォーマンス低下を引き起こすなどの問題がありました。

このため、C++20にて`std::string::reserve()`はキャパシティを減少させないことが規定され、それに伴ってデフォルト引数（`0`）を取っていたオーバーロードが非推奨とされました（このオーバーロードは減少しかしないため）。

この提案は、`std::string::reserve()`のデフォルト引数を持つオーバーロードを削除する提案です。

元々C++20での非推奨時に、その後のLEWGのレビューまでの間に重大な懸念が明らかにならなければこのオーバーロードを削除することに合意されていました。削除を急ぐ理由は特にないようですが、この提案ではその以前の合意に従って削除することを推奨しています。

- [`std::string::reserve()` - cpprefjp](https://cpprefjp.github.io/reference/string/basic_string/reserve.html)
- [C++ の string と vector の reserve() の挙動 - bkブログ](http://0xcc.net/blog/archives/000206.html)
- [P2870 進行状況](https://github.com/cplusplus/papers/issues/1526)

### [P2871R0 Remove Deprecated Unicode Conversion Facets From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2871r0.pdf)

C++17で非推奨とされた`<codecvt>`ヘッダをC++26で削除する提案。

`<codecvt>`ヘッダではユニコードとの間で文字コードの変換を行う機能が提供されていましたが、不正なユニコード文字列を入力されるような攻撃を受けた際にそれをエラーとして安全にハンドルする方法がなく、細かい仕様も曖昧だったりで、その必要性に反して文字コード変換のための機能としては不適当なものでした。

そのため、`<codecvt>`はヘッダごとC++17で非推奨とされ、SG16はこの議論を契機としてC++により適切なユニコードサポートをもたらすための作業を開始しました。そこでは`<codecvt>`ヘッダの機能に代わる文字コード変換機能も目標に入っていますが、C++23時点ではまだそのようなものは利用可能ではありません。

SG16がこれを改善する計画や余裕を持たないこと、C++26出荷時点で非推奨期間の方が長くなることなどの理由から、この提案では、`<codecvt>`をC++26でヘッダごと削除することを提案しています。ただし、その名前（`codecvt_utf8`など）を規格書のゾンビ名セクションに追加しておくことで、標準ライブラリ実装がC++26以降もそれを提供し続けることを許可する（ゾンビ名セクションはこのためにあるようです）ようにしておくことを提案しています。

- [`<codecvt>` - cpprefjp](https://cpprefjp.github.io/reference/codecvt.html)
- [Zombie names [zombie.names] - eel.is](https://eel.is/c++draft/zombie.names)
- [⚰️C++的ゾンビのお名前🧟 - Qiita](https://qiita.com/yohhoy/items/443e81c576949ed64916)
- [P2870 進行状況](https://github.com/cplusplus/papers/issues/1526)

### [P2872R0 Remove `wstring_convert` From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2872r0.pdf)

C++17で非推奨とされた`wstring_convert`をC++26で削除する提案。

1つ前の`<codecvt>`と同様の理由によって、`wstring_convert`をC++26で削除しようとする提案です。

`wstring_convert`は`<codecvt>`にある機能を使用する窓口のようなもので、C++26で非推奨とされたのもついでだったようです。`<codecvt>`を削除したとしてもユーザーが代替のものを提供して使い続けることは可能であり、また標準でそれを提供することができる可能性もあるとして、C++23サイクル中のSG16での議論では削除に慎重な意見が聴かれていたようですが、一方で削除に反対する意見はなかったようです。

ここでは削除を提案していますが、`<codecvt>`とは異なりそれをゾンビ名セクションに入れとくことは提案されていないようです。

- [`wstring_convert` - cpprefjp](https://cpprefjp.github.io/reference/locale/wstring_convert.html)
- [P2872 進行状況](https://github.com/cplusplus/papers/issues/1528)

### [P2873R0 Remove Deprecated locale category facets for Unicode from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2873r0.pdf)

C++20で非推奨とされたロケールカテゴリファセットをC++26で削除する提案。

ロケールカテゴリファセットとは`std::codecvt`/`std::codecvt_byname`の特殊化のことで、この提案の対象となっているのは次の4つのものです

```cpp
codecvt<char16_t, char, mbstate_t>
codecvt<char32_t, char, mbstate_t>
codecvt_byname<char16_t, char, mbstate_t>
codecvt_byname<char32_t, char, mbstate_t>
```

削除の理由や経緯に関しては、前の`<codecvt>`、`wstring_convert`と同じです。

- [`std::codecvt` - cppreference](https://en.cppreference.com/w/cpp/locale/codecvt)
- [P2873 進行状況](https://github.com/cplusplus/papers/issues/1529)

### [P2874R0 Mandating Annex D](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2874r0.pdf)

Annex Dセクションにある機能の規定について、標準の他の部分と記法を合わせる提案。

Annex Dには過去に非推奨とされまだ削除されていない機能が移動されています。C++20で事前条件や適格要件の書き方が変更（P0788R3）された際、議論時間の都合からAnnex Dの内容はその変更が適用されず、古い記法のまま記述されました。その後、変更が適用された機能が非推奨とされて移動されたことで新旧の記述が入り混じっています。

この提案はAnnex DセクションにもP0788R3を適用し、標準の書き方を完全に統一しようとするものです。

この提案はすでに、2023年6月の全体会議でC++26に適用されることが決まっています。

- [C++20標準ライブラリ仕様：Constraints／Mandates／Preconditions - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20200605/p1)
- [P2874 進行状況](https://github.com/cplusplus/papers/issues/1557)

### [P2875R0 Undeprecate `polymorphic_allocator::destroy` For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2875r0.pdf)

C++20で非推奨とされた`polymorphic_allocator::destroy`の非推奨化を解除する提案。

`polymorphic_allocator::destroy()`は与えられた領域にあるオブジェクトのデストラクタ呼び出しを行う関数です。これは、`std::allocator_traits::destroy()`が提供するデフォルト実装と全く同じであり、`polymorphic_allocator`がアロケータとして使用されることを考えると冗長なものです。そのため、C++20で非推奨とされました。

しかし、`polymorphic_allocator`は語彙型として設計されており、必ずしも従来のアロケータのようにコンテナで`std::allocator_traits`を介して使用されるだけのものではありません。そのような場合、`std::allocator_traits`が提供している関数を単体で提供する必要があります。

この提案は、それらの理由と`construct()`との対称性を確保するためにも`polymorphic_allocator::destroy()`を非推奨としないようにする提案です。

- [`std::pmr::polymorphic_allocator::destroy` - cpprefjp](https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/destroy.html)
- [P0339R6 polymorphic_allocator<> as a vocabulary type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0339r6.pdf)
- [P2875 進行状況](https://github.com/cplusplus/papers/issues/1530)

### [P2876R0 Proposal to extend std::simd with more constructors and accessors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2876r0.html)

`std::simd`に対して、利便性向上のために標準ライブラリにあるデータ並列型等のサポートを追加する提案。

`std::simd`クラスは、SIMDレジスタとそれに対する演算・操作をラップするようなクラス型で、`std::simd`のオブジェクトに対してC++コードとして記述した計算をそのまま（自動で）SIMD演算に落とし込むことを目的とするものです。

`std::simd`は現在、C++26導入を目指して作業が進められています（P1928）。

この提案は、`std::simd`オブジェクトの入出力の利便性を向上させるために、P1928の`std::simd`クラスに欠けている標準ライブラリのクラス型との相互変換を追加しようとするものです。対象となるものは次のものです

- `std::bitset`
    - `simd_mask`型に`std::bitset`を受け取るコンストラクタを追加
    - `simd_mask`型に`std::bitset`への変換（変換演算子or明示的な変換関数）
- 整数値のビット表現の利用
    - `simd_mask`型に符号なし整数値を受け取るコンストラクタを追加
        - `constexpr simd_mask(auto std::unsigned_integral bits) noexcept;`
    - `simd_mask`型に、マスクを整数値のビット表現として取得する`.to_ullong()`を追加
- `std::initializer_list`
    - `std::simd`に`std::initializer_list`を受け取るコンストラクタを追加
- `contiguous_range`
    - `std::simd`に`contiguous_range`を受け取って初期化するコンストラクタを追加
      - `constexpr simd(std::ranges::contiguous_range auto x);`
    - `std::array`、`std::span`に対しては推論補助も追加

これによって、`std::simd`及び`std::simd_mask`はそれと意味的に同一視できるものから変換する形で構築したり、逆に変換することで値をストアすることができるようになります。

- [P2876 進行状況](https://github.com/cplusplus/papers/issues/1531)

### [P2878R0 Reference checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2878r0.html)

↓

### [P2878R1 Reference checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2878r1.html)

プログラマが明示的に関数の戻り値に関するライフタイム注釈を行えるようにする提案。

ここで提案されているのは、Rustのexplicit lifetimeと呼ばれる機能に近いものです

```rust
// 戻り値の生存期間（参照の有効期間）は、引数であるa, bの生存期間を超えないという注釈
fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 {
  x
}
```

このような機能は静的解析のような外部のツールによっても達成できるかもしれませんが、それはユーザーがかなりの手間をかけて導入し使用した場合にのみ機能するものでしかありません。このような機能を限定的であったとしても言語機能として持つことで、ライフタイムにまつわる問題を警告ではなくコンパイル時のエラーとして検出できるようになり、より効果的に言語の安全性を高めることができます。

この提案では、コンパイル時に参照に対して4つの生存期間に関するプロパティを付加します。

1. （生存期間が）グローバル
2. ローカル
3. 一時的（一時オブジェクト）
4. その他（不明）

参照は初期化が必須であるため、これらのプロパティは初期化時に確定する性質です。

```cpp
const int GLOBAL = 42;

void f(int* ip, int& ir/*生存期間不明*/) {
  int local = 42;

  int& r1 = *ip;    // 生存期間不明
  int& r2 = ir;     // 生存期間不明
  int& r3 = GLOBAL; // 生存期間はグローバル
  int& r4 = local;  // 生存期間はローカル
}
```

そして、参照がコピーされるときはこのプロパティも同時にコピーされます。

```cpp
const int GLOBAL = 42;

void f(int* ip, int& ir/*生存期間不明*/) {
  int local = 42;

  int& r1 = *ip;    // 生存期間不明
  int& r2 = ir;     // 生存期間不明
  int& r3 = GLOBAL; // 生存期間はグローバル
  int& r4 = local;  // 生存期間はローカル

  // 参照のコピー
  int& r5 = r1;     // 生存期間不明
  int& r6 = r2;     // 生存期間不明
  int& r7 = r3;     // 生存期間はグローバル
  int& r8 = r4;     // 生存期間はローカル
}
```

このプロパティだけでも、ローカル変数の参照を`return`する関数をエラーにすることができます

```cpp
const int GLOBAL = 42;

int& f(int* ip, int& ir/* unknown lifetime */)　{
  int local = 42;

  int& r1 = *ip;    // 生存期間不明
  int& r2 = ir;     // 生存期間不明
  int& r3 = GLOBAL; // 生存期間はグローバル
  int& r4 = local;  // 生存期間はローカル

  // 参照のコピー
  int& r5 = r1;     // 生存期間不明
  int& r6 = r2;     // 生存期間不明
  int& r7 = r3;     // 生存期間はグローバル
  int& r8 = r4;     // 生存期間はローカル

  return r8;  // error! ローカル参照を返している
}
```

たとえば次のようにして、ある参照の生存期間を別の参照の生存期間に関連付けることができるようにします

```cpp
const int GLOBAL = 42;

// 戻り値の参照の有効期間は引数left/right（のより短い方）の有効期間より長くない
[[dependson(left, right)]]
const int& f1(const int& left/* unknown lifetime */, const int& right/* unknown lifetime */) {
  if (randomBool()) {
    return left;
  } else {
    return right;
  }
}
```

この時、先程のプロパティは`temporary < local < global`の順で生存期間が短いとされます。この順序によって、この関数の戻り値の参照の生存期間は引数`left/right`の生存期間のより短いものに制限されます。

これによってさらに次のチェックが可能となります

- 一時オブジェクトへの参照を返すとエラー
- 一時的な生存期間を持つ参照（一時オブジェクトへの参照）を初期化した後、別の行（別の完全式）で使用するとエラー

```cpp
int& f2() {
  int local = 42;

  const int& r1 = f1(local, local);   // local
  const int& r2 = f1(GLOBAL, GLOBAL); // global
  const int& r3 = f1(42, 42);         // temporary
  const int& r4 = f1(local, GLOBAL);  // local
  const int& r5 = f1(local, 42);      // temporary
  const int& r6 = f1(GLOBAL, 42);     // temporary
  
  if (randomBool()) {
    return r1;  // error: local参照を返せない
  }
  if (randomBool()) {
    return r2;  // OK、r2はglobal参照
  }
  if (randomBool()) {
    return r3;  // error: temporary参照を返せない
  }
  if (randomBool()) {
    return r4;  // error: local参照を返せない
  }
  if (randomBool()) {
    return r5;  // error: temporary参照を返せない
  }
  if (randomBool()) {
    return r6;  // error: temporary参照を返せない
  }

  int x1 = r3 + 43; // error: temporary参照を使用できない
  int x2 = r5 + 44; // error: temporary参照を使用できない
  int x3 = r6 + 45; // error: temporary参照を使用できない
  return f1(f1(GLOBAL, 4), f1(local, 2)); // error: temporary参照を返せない
}
```

これによって、ローカル変数の間接的なダングリングだけでなく、一時オブジェクトの間接的なダングリングも修正されます。

さらに、クラス型が参照を`public`メンバとして持っている場合も、同様の事を行うことができます。

```cpp
// 参照をpublicメンバとして含むクラス型
struct S {
  int& first;
  const int& second;
};

int& f2() {
  int local = 42;

  S s1{GLOBAL, local};
  S s2{local, f1(GLOBAL, 24)};
  
  const int& r1 = s1.first;   // global
  const int& r2 = s1.second;  // local
  const int& r3 = s2.first;   // local
  const int& r4 = s2.second;  // temporary
  
  if (randomBool()) {
    return r1;  // OK: r2はglobal参照local参照を返せない
  }
  if (randomBool()) {
    return r2;  // error: local参照を返せない
  }
  if (randomBool()) {
    return r3;  // error: local参照を返せない
  }
  if (randomBool()) {
    return r4;  // error: temporary参照を返せない
  }

  int x = r4 + 43;  // error: temporary参照を使用できない

  return 42;  // error: temporary参照を返せない
}

S f3() {
  int local = 42;

  S s1{GLOBAL, local};
  S s2{local, f1(GLOBAL, 24)};
  
  if (randomBool()) {
    return s1;  // error: local参照を含んでいる
  }

  return s2;  // error: localとtemporary参照を含んでいる
}
```

また、言語組み込み機能であれば`public`ではなくても同様の事を検出できます

```cpp
// local/temporaryなものをキャプチャもしくは`return`するラムダを返せないようにする
auto lambda() {
  int local = 42;
  
  const int& ref_temporary = f1(GLOBAL, 24);

  return [&local, &ref_temporary]() -> const int& {
      if(randomBool()) {
        return local; // error: local参照を返せない
      }

      return ref_temporary; // error: temporary参照を返せない
    };
  // error: localとtemporary参照を含んでいる
}

// local/temporaryなものをキャプチャもしくは`return`するコルーチンを返せないようにする
auto coroutine() {
  int local = 42;
  
  const int& ref_temporary = f1(GLOBAL, 24);

  return [&local, &ref_temporary]() -> generator<const int&> {
      if(randomBool()) {
        co_return local;  // error: local参照を返せない
      }

      co_return ref_temporary;// error: temporary参照を返せない
    };
  // error: localとtemporary参照を含んでいる
}
```

クラス型が非`public`な形で参照を内部に含む場合、それを取得しようとするメンバ関数に対してそのオブジェクトそのものに依存するライフタイムを注釈する追加の構文によって同様の検出を行います

```cpp
namespace std {
  template <class charT,
            class traits = char_traits<charT>,
            class Allocator = allocator<charT> >
  class basic_string {
    ...

    // 戻り値の参照（likeなオブジェクト）はthisに依存する
    constexpr std::string::operator [[dependson(this)]] std::basic_string_view<CharT, Traits>() const noexcept;
  }
}

int main() {
  std::string_view sv = "hello world"s; // temporary

  sv.size();  // error: temporary参照を使用できない
}
```

これは`std::span`や`std::function_ref`などの他の参照セマンティクスを持つ型でも使用できます。ただし、`reference_wrapper`のように再束縛できる（あとから参照先を切り替えられる）ものについてはこれを適用できません。他にもポインタ型や`std::unique_ptr`当のポインタセマンティクスを持つ型が該当します。

ただし、そのような型でも`const`であれば初期化時に非`null`で初期化されていると推定でき、また後から参照先が変化しないため同様のことが行えます。

```cpp
[[dependson(left, right)]]
const std::reference_wrapper<const int> f(const int& left/* unknown lifetime */, const int& right/* unknown lifetime */) {
  if(randomBool()) {
    return std::cref(left);
  } else {
    return std::cref(right);
  }
}
```

最後に、これらのチェックは`new`式による初期化時にも適用できます

```cpp
struct S { int mi; const std::pair<int,int>& mp; };

S a { 1, {2,3} };
S* p = new S{ 1, {2,3} }; // error: オブジェクトはtemporaryに依存する
```

もし参照が`public`ではない場合は、そのコンストラクタでその依存関係を指定する追加の構文が必要になります

```cpp
class S {
  int mi;
  const std::pair<int,int>& mp;

public:
  [[parameter_dependency(dependent{"this"}, providers{"mp"})]]
  S(int mi, const std::pair<int,int>& mp);
};

S a { 1, {2,3} };         // error: オブジェクトはtemporaryに依存する
S* p = new S{ 1, {2,3} }; // error: オブジェクトはtemporaryに依存する
```

この提案では構文の説明のために属性構文が使用されていますが、属性として採用すべきか別の言語機能として採用すべきかは提案しておらず、むしろその能力を獲得することを目的としています。

この提案はSG23でレビューされ、引き続き議論されないことが決定しています。

- [明示的アノテーション - Rust By Example 日本語版](https://doc.rust-jp.rs/rust-by-example-ja/scope/lifetime/explicit.html)
- [［C++］暗黙ムーブの副作用による安全性](https://onihusube.hatenablog.com/entry/2023/01/29/192054)
- [P2724R0 constant dangling - WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2724R0-constant-dangling)
- [P2740R0 Simpler implicit dangling resolution - WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2740R0-Simpler-implicit-dangling-resolution)
- [P2742R0 indirect dangling identification - WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2742R0-indirect-dangling-identification)
- [P2878 進行状況](https://github.com/cplusplus/papers/issues/1558)

### [P2880R0 Algorithm-like vs std::simd based RNG API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2880r0.html)

複数の乱数の効率的な生成のためのAPIとして、提案中のベクターAPIと`std::simd`によるAPIを比較する提案。

P1068では大量の乱数を効率的に生成するための高レベルなベクターAPを提案しており、そこでは範囲に対して乱数を充填するAPIによって実装が効率的な乱数生成方法を選択できるようにしています。その実装には例えばSIMD演算によるものが想定されています。

一方で、P1928で議論されている`std::simd`はSIMDレジスタと命令のラッパクラスであり、`std::simd`そのものの操作あるいはAPIによって直接的にそのような大量乱数生成の効率実装を行うことができます。そのため、`std::simd`導入を見据えた場合にP1068の高レベルAPIによる複数乱数生成は必要なのか？あるいは`std::simd`に乱数生成のためにどのようなAPIを持たせるべきか？と言ったことが疑問として浮かんできます。

この提案はそのような疑問に答えるために、両者のAPIによるコードを比較することで利点欠点を洗い出し、`std::simd`の乱数生成APIのいくつかの可能性を示すものです。

この提案では、"European options pricing"というベンチマーク中から複数の乱数を生成しているコードを抽出し、それをP1068と`std::simd`を用いて実装してみるとどうなるかを示すことで比較を行なっています。

```cpp
// "European options pricing"中の複数の乱数を生成し利用するコード

std::mt19937 engine(777); // 乱数エンジン
std::normal_distribution distribution(0., 1.);  // 分布生成器

double v0 = 0, v1 = 0;

// ループ（npath）の分乱数を生成する
for (std::size_t p = 0; p < npath; ++p) { //e.g., npath=1,000,000
  // 乱数の生成
  double rand = distribution(engine);

  // 乱数の利用
  double res = std::max(0., S * exp(sqrt(T) * vol * rand + T * mu) - X);
  v0 += res;
  v1 += res * res;
}

// 結果出力
result     = v0 / npath;
confidence = v1 / npath;
```

#### P1068R7の高レベルAPI

まずP1068R7では`std::ranges::generate_random`という関数（正確にはCPO）を用いて、範囲に対して指定されたエンジンと分布によって生成した乱数を充填します。それによって、先ほどのコードは次のようになります

```cpp
std::mt19937 engine(777);
std::normal_distribution distribution(0., 1.);

// 生成した乱数を受けるための範囲
std::array<double, npath> rand; // npath=1,000,000 -> sizeof(rand)=8 MB

// 複数の乱数を一括生成し範囲に詰め込む
std::ranges::generate_random(rand, engine, distribution);

double v0 = 0, v1 = 0;

// 乱数の利用
for(std::size_t p = 0; p < npath; ++p) {
  double res = std::max(0., S * exp(sqrt(T) * vol * rand[p] + T * mu) - X);
  v0 += res;
  v1 += res * res;
}

result     = v0 / npath;
confidence = v1 / npath;
```

`std::ranges::generate_random`によってループ前に使用予定の乱数を全て生成しているため、ループの中は乱数利用コードのみになります。前述のように、これはSIMD命令等を用いて効率的に乱数生成を行う実装がなされるはずなので、ループで生成しながら利用するコードよりも効率的になることが期待されます。

ただし、この場合生成した乱数を受けるためにそこそこ巨大な配列を最初に用意しなければなりません。これはキャッシュヒット率を低下させることが予想されるため、最適なコードとは言えません。そこで効率化のために、バッファリングを行います

```cpp
std::mt19937 engine(777);
std::normal_distribution distribution(0., 1.);

// 乱数を受けるバッファ
std::array<double, nbuffer> rand; // e.g., nbuffer=128

double v0 = 0, v1 = 0;

// nbuffer分づつ乱数を生成して利用するループ
for(std::size_t p = 0; p < npath; p += nbuffer) {
  // 末尾の調整（npathはnbufferの倍数とは限らない）
  std::size_t local_size = (p + nbuffer <= npath) ? nbuffer : (npath - p); // dealing with tail
  // nbuffer分乱数を生成
  std::ranges::generate_random(std::span(rand.begin(), local_size), engine, distribution);

  // 乱数の利用
  for(std::size_t b = 0; b < local_size; ++b) {
    double res = std::max(0., S * exp(sqrt(T) * vol * rand[p] + T * mu) - X);
    v0 += res;
    v1 += res * res;
  }
}

result     = v0 / npath;
confidence = v1 / npath;
```

`nbuffer`分づつ処理を分けることで、1度に生成する乱数とそれを保存するためのストレージサイズを`nbuffer`に減らします。その代わり乱数生成を一括で行う単位も減ってしまいますが、キャッシュミスによるペナルティよりも一度の乱数生成オーバーヘッドの方が小さい間はこちらの方が効率的になります。

#### `std::simd`のAPI

次に、`std::simd`でも同じことを考えます。ただし、`std::simd`はまだそのようなAPIを持たないため、その可能な設計として幾つかのパターンが考えられます。この設計で重要なことは、ユーザーが要求する`std::simd`型に関する情報をどのレベルで取得するか？ということです

##### 1. エンジンのテンプレートパラメータ

1つ目の例は、エンジンと分布生成器の両方が`std::simd`型に関する情報を持って構築されるものです。

```cpp
std::mt19937<std::fixed_size_simd<std::uint_fast32_t, 16>> E(777);    // 乱数エンジン
std::normal_distribution<std::fixed_size_simd<double, 16>> D(0., 1.); // 分布生成器

// 乱数の生成
auto rand = D(E);
```

エンジンと分布生成器の数値型が異なっており、既存の実装はこのような場合`normal_distribution`の`double`値1つに対してエンジンの`uint_fast32_t`値を2つ消費します（全体では、乱数16個に対してエンジン出力32個を消費する）。そのため、実装によっては次のように定義した方が効率的である場合があります

```cpp
// 32 SIMD size passed to engine
std::mt19937<std::fixed_size_simd<std::uint_fast32_t, 32>> E(777);
// 16 SIMD size passed to distribution
std::normal_distribution<std::fixed_size_simd<double, 16>> D(0., 1.);

auto rand = D(E);
```

より洗練された分布生成器では結果値ごとに異なった個数の入力エンジン値を消費する分布の実装が一般的となるため、分布生成器とSIMD幅が与えられた時にそれに最適なエンジンのSIMD幅の適切なサイズの普遍的な解答はありません。

そのような分布生成器において、エンジンが生成した固定幅の乱数配列の一部しか消費しない場合、使用しなかった残りの部分について選択肢が生まれます

1. 残りの部分は分布オブジェクトが内部に保存する
    - 保存する領域のオーバーヘッドやどう使用されるかが問題となる
    - 残りの部分が次の生成に使用されるとすると、分布のランダム性に残った値の利用という要素が追加される
2. 残りの部分は廃棄する

このことを念頭に置いて、最初のコードをこのAPIで書き直したのが次のコードです

```cpp
// SIMD幅
constexpr std::size_t size = 16;

// エンジンと分布生成器
std::mt19937<std::fixed_size_simd<std::uint_fast32_t, size>> E(777);
std::normal_distribution<std::fixed_size_simd<double, size>> D(0., 1.);

double v0 = 0, v1 = 0;
std::size_t p = 0;

for(; p + size <= npath; p += size) {
  // 複数乱数（size個分）の一括生成
  auto rand = D(E); // std::fixed_size_simd<double, size>

  // 乱数の利用（自動SIMD化）
  auto res = std::max(0., S * exp(sqrt(T) * vol * rand + T * mu) - X);
  v0 += std::reduce(res);
  v1 += std::reduce(res * res);
}

// 処理数（npath）が16（size）の倍数ではない場合の端数の処理
if (p != npath) {
  // 複数乱数（size個分）の一括生成
  auto rand_tail = D(E);

  // 乱数の利用
  auto res = std::max(0., S * exp(sqrt(T) * vol * rand_tail + T * mu) - X);
  for(std::size_t i = 0; p + i < npath; ++i) {
      v0 += res[i];
      v1 += res[i] * res[i];
  }
  // resには使用されない部分があり、捨てられる
}

result     = v0 / npath;
confidence = v1 / npath;
```

このコードでは、`npath`が`size`（16）の倍数ではない場合に必要以上の数の乱数を生成してしまうため最初のコードど完全に同じことをしているわけではありませんが近いコードではあります。そして、端数の処理の際に生成した乱数（`rand_tail`）の一部を捨ててしまうことになりますが、その捨て方が問題となる可能性があります（エンジンや分布生成器を再利用する場合など）。

#### 2. エンジンのテンプレートパラメータ + 再バインドコンストラクタ

それらの問題を念頭に置いて次のAPI設計案では、異なるSIMD幅やスカラ型を持つエンジンの再バインド構築によって未使用部分の問題を回避します。再バインドによって以前のエンジンの内部状態を引き継ぐことで、余分な乱数の生成を防止し、捨てられる値や目に見えない状態を回避します。

```cpp
constexpr std::size_t size = 16;

std::mt19937<std::fixed_size_simd<std::uint_fast32_t, size>> E(777);
std::normal_distribution<std::fixed_size_simd<double, size>> D(0., 1.);

double v0 = 0, v1 = 0;
std::size_t p = 0;

for (; p + size <= npath; p += size) {
  // 複数乱数（size個分）の一括生成
  auto rand = D(E);

  // 乱数の利用
  auto res = std::max(0., S*exp(sqrt(T) * vol * rand + T * mu)-X);
  v0 += std::reduce(res);
  v1 += std::reduce(res * res);
}

// 処理数（npath）が16（size）の倍数ではない場合の端数の処理
if (p != npath) {
  // エンジンの再バインド
  std::mt19937 E_tail(E); // rebinding to scalar type
  std::normal_distribution D_tail(0., 1.); // getting scalar distribution

  for (; p < npath; ++p) {
    // 乱数の生成（スカラAPI）
    auto rand_tail = D_tail(E_tail);

    // 乱数の利用
    auto res = std::max(0., S * exp(sqrt(T) * vol * rand_tail + T * mu) - X);
    v0 += res;
    v1 += res * res;
  }

  // 元のエンジンに状態を返す
  E = E_tail;
}

result     = v0 / npath;
confidence = v1 / npath;
```

乱数エンジンの再バインド機構によって、乱数エンジンの生成値の型を変更しつつエンジンの内部状態を引き継ぐことができるようにしています。

この場合、ユーザーレベルの柔軟性が得られる一方で余計なコピーが追加されており、状態の大きなエンジンではそのオーバーヘッドが問題となる可能性があります。

#### 3. アルゴリズムlikeな関数のテンプレートパラメータ

更なる代替案として、`std::simd`型の情報を受け取る点をエンジン/分布生成器からその使用地点に移すAPIが考えられます。これによって、エンジンはその使用モードを意識することなく、内部のレイアウトは実装によってスカラ/ベクターどちらの生成も可能とするバランスの取れた形に選択されます。

```cpp
std::mt19937             E(777);
std::normal_distribution D(0., 1.);

// 乱数生成
auto rand = std::generate_random_simd<std::fixed_size_simd<double, 16>>(E, D);
```

エンジンレイアウトの厳密な（環境のSIMD幅に合わせた）最適化が制限される代わりに、標準ライブラリに実装の自由が与えられ、エンジンからベース乱数を消費する方法はプラットフォームによって異なる可能性があリます。

```cpp
constexpr std::size_t size = 16;

std::mt19937 E(777);
std::normal_distribution D(0., 1.);

double v0 = 0, v1 = 0;
std::size_t p = 0;

for (; p+size <= npath; p += size) {
  // 複数乱数（size個分）の一括生成
  auto rand = std::get_random_simd<std::fixed_size_simd<double, size>>(E, D);

  // 乱数の利用
  auto res = std::max(0., S * exp(sqrt(T) * vol * rand + T * mu) - X);
  v0 += std::reduce(res);
  v1 += std::reduce(res * res);
}

// 処理数（npath）が16（size）の倍数ではない場合の端数の処理
for (; p < npath; ++p) {
  // 乱数の生成（スカラAPI）
  auto rand_tail = D(E);

  // 乱数の利用
  auto res = std::max(0., S * exp(sqrt(T) * vol * rand_tail + T * mu) - X);
  v0 += res;
  v1 += res * res;
}

result     = v0 / npath;
confidence = v1 / npath;
```

この例は最初のコードと完全に一致しており、余分な乱数を生成してエンジン状態が不明になったり、それを回避するためにエンジン状態をコピーするなどの問題を回避しています。

これらの比較と観察から得られる結論は次のようなものです

- 高レベルのAPIは通常のC++開発者が作成する乱数利用アプリケーションの大部分をサポートすることを目的としている
    - APIを実装するベンダがHWアクセラレータを有効にする実装をとれば、そのようなアプリケーションのパフォーマンスを向上できる
    - SIMDを利用した実装はその一種であり、同じAPIを使用して利用可能となる
- 低レベルの（`std::simd`による）APIはC++の慣習に則った上でよりHWに近いコーディングを必要とする上級開発者を対象としている
    - ただし、`std::simd`によるAPIではエンジンと分布生成器の概念に基づいた乱数生成アルゴリズムのSIMD実装の詳細を開発者に理解させることは避けるべき

従って、P1068の高レベルのAPIと`std::simd`によるAPIはターゲットが異なるため排他的なものではなく、両方を標準ライブラリに持つことは合理的であると考えられます。

- [P1068R6 Vector API for random number generation - WG21月次提案文書を眺める（2021年02月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P1068R6-Vector-API-for-random-number-generation)
- [P2880 進行状況](https://github.com/cplusplus/papers/issues/1532)

### [P2881R0 Generator-based for loop](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2881r0.html)

範囲`for`文に新しいループカスタマイゼーションポイントを追加する提案。

`<ranges>`のRangeアダプタなどに見られるようにイテレータの定義は複雑で、何か処理を範囲`for`文でループさせるように書き直そうとするとその対象の状態を`operator*`と`operator++`に分割してエンコードしてやる必要があり、これによって処理のイテレータ（`range`）への移行は非常に難しくなっています。

C++20のコルーチンとC++23`std::generator`の利用によってそれは劇的に簡単になります。例えば`std::generator`を使用すると`views::filter`、`views::join`、`views::concat`は次のように簡単に定義できます

```cpp
template <typename Rng, typename Predicate>
auto filter(Rng&& rng, Predicate predicate) -> std::generator<…> {
  for (auto&& elem : rng) {
    if (predicate(elem)) {
      co_yield std::forward<decltype(elem)>(elem);
    }
  }
}

template <typename Rng>
auto join(Rng&& rng_of_rng) -> std::generator<…> {
  for (auto&& rng : rng_of_rng) {
    co_yield std::ranges::elements_of(std::forward<decltype(rng)>(rng));
  }
}

template <typename ... Rng>
auto concat(Rng&& ... rng ) -> std::generator<…> {
  ((co_yield std::ranges::elements_of(std::forward<decltype(rng)>(rng))), ...);
}
```

ただし`std::generator`もいいとこづくめではなく、いくつかデメリットがあります

1. パフォーマンスでイテレータに劣る
    - コルーチンステート保存のためのメモリ確保や、関数の中断のサポート、例外機構などによるオーバーヘッドが回避できない
2. ネストした文脈で`co_yield`を使用できない
    - スタックレスコルーチンはその内部で呼び出した関数内などのスタックフレームの異なる場所で中断できない

2つ目の問題は、ツリー構造のようなネストした構造に対して`std::generator`を直接適用できない場合がある問題で、次のようなものです

```cpp
struct tree {
  using leaf = int;
  // ノードの途中か末端かのどちらか
  std::variant<leaf, std::vector<tree>> impl;
};

// ツリー構造を辿って末端の値を出力していく
std::generator<int> tree_data(const tree& t) {
  std::visit(
    overloaded(
      [&](int data) {
        co_yield data; // error
      },
      [&](const std::vector<tree>& children) {
        for (auto& child : children)
        co_yield std::ranges::elements_of(tree_data(child)); // error
      }),
    t.impl);
}
```

これは、コルーチンがその内部で呼び出した関数で中断（`co_yield`や`co_await`）できないというスタックレスコルーチンの特性によるものです。ネストした部分を別のコルーチンにすることで回避はできます

```cpp
std::generator<int> tree_data(const tree& t) {
  auto sub =
      std::visit(
        overloaded(
          [&](int data) -> std::generator<int> {
            co_yield data;
          },
          [&](const std::vector<tree>& children) -> std::generator<int> {
            for (auto& child : children) {
              co_yield std::ranges::elements_of(tree_data(child));
            }
          }),
        t.impl);

  co_yield std::ranges::elements_of(sub);
}
```

この提案は、コルーチンによる`generator`の利点を享受しつつこれらのデメリットを回避するような、`generator`にちかい記述によって処理をループに落とし込むための仕組みを提案し、それを範囲`for`文のカスタマイゼーションポイントとして追加しようとするものです。

この提案による`generator`は*generator ranges*（ジェネレータ範囲）と呼ばれており、それは、範囲`for`文の処理本体をラムダ式として受け取ってそれを適宜呼び出しながら処理を実行する関数オブジェクト的な何かです。ジェネレータ範囲による範囲`for`文は、`begin()/end()`を使用したイテレータループを行う代わりに、そのループ本文をラムダ式としてジェネレータ範囲のオブジェクトの関数呼び出し演算子として渡して、ジェネレータ範囲のオブジェクトの関数呼び出し演算子では、そうして受け取ったループ本文に適宜各要素を渡して呼び出すことでループを実行します。

```cpp
// 1, 2, 3を生成するジェネレータ範囲
struct generator123 {

  // sinkには、呼ばれた範囲forの本体処理をcallableとして受ける
  auto operator()(auto&& sink) const {
    // 範囲forの本体がループを継続しているかを判定する
    std::control_flow flow;

    // 範囲forの本体処理に1を入力し（xに1が代入され）て実行
    flow = sink(1);
    if (!flow) return flow;

    // 範囲forの本体処理に1を入力し（xに2が代入され）て実行
    flow = sink(2);
    if (!flow) return flow; // この例ではここで終わる

    // 範囲forの本体処理に1を入力し（xに3が代入され）て実行
    return sink(3);
  }
};

for (int x : generator123{}) {
  std::print("{}\n", x);
  if (x == 2) {
    break;
  }
}
// 1
// 2
```

`std::control_flow`はジェネレータ範囲による範囲`for`文の本体内の`break/continue`の結果を表現するクラス型です。これは基本的に強く型付けされた`bool`型で、次のように定義されます

```cpp
namespace std {

  /// `continue`に対応するタグ型とそのオブジェクト
  struct continue_t {
    // Empty.

    constexpr operator std::true_type() const noexcept {
      return {};
    }

    constexpr std::false_type operator!() const noexcept {
      return {};
    }

    friend std::strong_ordering operator<=>(continue_t, continue_t) noexcept = default;
  };
  inline constexpr continue_t continue_;

  /// `break`に対応するタグ型とそのオブジェクト
  struct [[nodiscard("need to forward break")]] break_t {
    // Empty.

    constexpr operator std::false_type() const noexcept {
      return {};
    }

    constexpr std::true_type operator!() const noexcept {
      return {};
    }

    friend std::strong_ordering operator<=>(break_t, break_t) noexcept = default;
  };
  inline constexpr break_t break_;


  /// `continue/break`または実装定義の`break`に似た状態を表す制御フローオブジェクト
  class [[nodiscard("need to forward control flow")]] control_flow {
  public:
      /// `continue`状態で構築
      constexpr control_flow(continue_t) noexcept;
      constexpr control_flow() noexcept : control_flow(continue_) {}

      /// `break`状態で構築
      constexpr control_flow(break_t) noexcept;

      /// Trivially copyable.

      /// `continue`の時true, それ以外の場合は`false`を返す
      constexpr explicit operator bool() const noexcept;

      constexpr friend bool operator==(control_flow, control_flow) noexcept;
      constexpr friend std::strong_ordering operator<=>(control_flow, control_flow) noexcept;
  };
}
```

`std::continue_`と`std::break_`は`std::true_type/std::false_type`への定数変換演算子を持つ個別のタグ型として定義されており、これによって常に継続や常に中断といった一般的なケースを型システムにエンコードして最適化を保証することができます。

ジェネレータ範囲による範囲`for`文は通常の範囲`for`と同様に言語組み込みマクロのようなもので、次のように展開されます

```cpp
for (T binding : object)
{
  body
}

{
  auto __body = [&](T&& __element) -> see-below {
    T binding = std::forward<T>(__element);
    body
    return std::continue_;
  };

  auto __flow = object(__body);
  
  see-below // body内のreturn/gotoがここに配置される
}
```

関数本体である`body`で特に終了（`return`や`break`）をしなければ、デフォルトで`std::continue_`が返されることで処理を継続させます。`body`に何か制御文を書くとそれは`std::control_flow`の値を返すように変換されます

- `continue;`
    - `return std::continue_;`
- `break;`
    - `return std::break_;`
- `return;`
    - `return implementation-defined`
    - `std::break_;`と同じ効果となるが、コンパイラはループの後ろに`return`を配置する
- `return expr;`
    - `expr`を実行してその結果をどこかに保存してから、`return implementation-defined`
    - `std::break_;`と同じ効果となるが、コンパイラはループの後ろに`return`を配置し戻り値を返す
- `goto`
    - `return implementation-defined`
    - `std::break_;`と同じ効果となるが、コンパイラはループの後ろに`goto`を配置する
- `throw` 
    - そのまま
- `co_await/co_yield/co_return`
    - ill-formed

これによって、ジェネレータ範囲による範囲`for`文は利用者から見ると通常の`for`文とほとんど透過的に使用することができます。

```cpp
// このジェネレータ範囲によるループは
for (int x : generator123{}) {
  if (x == 0)
    continue;
  
  if (x == 2)
    break;
  
  std::printf("%d\n", x);
}

// こう展開される
{
  auto __body = [&](int&& __element) -> std::control_flow {
    int x = __element;
    
    if (x == 0)
      return std::continue_;
    
    if (x == 2)
      return std::break_;

    std::printf("%d\n", x);
    
    return std::continue_;
  };

  auto __flow = generator123{}(__body);
  (void)__flow;
}
```

この新しい範囲`for`文では、`co_yield`の代わりに関数呼び出し演算子を通してループ本体に要素（値）を提供することで擬似的な関数の中断と値の生成を実現し、ループの処理が終わると自動的に再開されます。それはコルーチンのような複雑な仕組みを全く用いておらず、そのために導入されていたオーバーヘッドも全くありません。そのため、パフォーマンスではイテレータと同等かそれ以上のものを達成でき、コルーチンあるいは`std::generator`の制約によるデメリットも回避されます。

`views::filter`の例

```cpp
template <typename Rng, typename Predicate>
auto filter(Rng&& rng, Predicate predicate) {
  // ループ処理本体を受け取るジェネレータ範囲を返す
  return [=](auto sink) {
    for (auto&& elem : rng) {
      if (predicate(elem)) {
        auto result = sink(std::forward<decltype(elem)>(elem));
        if (result == tc::break_) {
          return result;
        }
      }
    }

    return tc::continue_;
  };
}
```

ネストした構造に対しても、ほぼそのまま適用できます

```cpp
auto tree_data(const tree& t) {
  return [&](auto sink) {
    auto flow =
      std::visit(
        overloaded(
          [&](int data) {
            // Forward break/exit.
            return sink(data);
          },
          [&](const std::vector<tree>& children) {
            for (auto& child : children) {
              auto flow = tree_data(child)(sink);
              if (flow == tc::break_) {
                // Forward early break and do actually break.
                return flow;
              }
            }
            return tc::continue_;
          }),
        t.impl);

    return flow;
  }
}
```

- [`std::generator` - cpprefjp](https://cpprefjp.github.io/reference/generator/generator.html)
- [P2881 進行状況](https://github.com/cplusplus/papers/issues/1559)

### [P2882R0 An Event Model for C++ Executors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2882r0.html)

実行コンテキスト間でやりとりするための標準的な方法を提供するための設計や問題点について探るための文書。

P2300では実行コンテキストを`scheduler`コンセプトによって抽象化しており、そこでは`scheduler`を提供する以外のことを要求していません。そのため、異なる実行コンテキストから制御を移すためのインターフェースが欠けており、それを行うための`transfer()`アルゴリズムのようなものの実装が難しくなっています。

例えば、次のようなネットワークから音源をダウンロードしてきて、それをデコードし再生（再生デバイスへ転送）するような処理を考えます

```cpp
// 音源のダウンロード
void receive() {
  SnapClient srv{srvAddr, srvPort};

  while (true) {
    // データを受信し
    std::span<uint8_t> buf = srv.receiveWireChunk(); // blocks

    // キューに入れる
    opusQueue.wait_push(buf);
  }
}

// PCMへのデコード
void decode() {
  while (true) {
    std::span<uint8_t> inBuf;
    // 受信データをキューから取り出し
    opusQueue.wait_pop(inBuf);

    // デコードし
    int samples = opus_decode(decoder,
                              inBuf.data(), inBuf.size(),
                              decodeBuf.data(), maxFrameSamples,
                              0);

    std::span outBuf(decodeBuf.data(), samples);
    // キューに入れる
    pcmQueue.wait_push(outBuf);
  }
}

// PCMの再生（デバイスへの転送）
void play() {
  while (true) {
    std::span<uint8_t> inBuf;
    // PCMデータをキューから取り出し
    pcmQueue.wait_pop(inBuf);
    
    uint32_t const *start = inBuf.data();
    size_t offset = 0;

    // 再生デバイスへ転送する
    while (offset < size) {
      size_t bytesDone;

      // i2s_channel_write blocks
      i2s_channel_write(tx,
                        start + offset,
                        size - offset,
                        &bytesDone,
                        noTimeout);
      
      offset += bytesDone;
    }
  }
}
```

この3つの関数はそれぞれ別のスレッドで実行されます。この時、各スレッド（実行コンテキスト）間のやりとりにはキューが使用されています。

これをP2300の`sender/receiver`によって実装すると例えば次のようになります

```cpp
void network_speaker() {
  // デコードと再生を行うための実行コンテキストのschedulerを取得
  exec::scheduler auto sched0 = cppos::ContextCore0::LoopScheduler();
  exec::scheduler auto sched1 = cppos::ContextCore1::LoopScheduler();

  AudioServer srv(sched0, srvAddr, audioPort);

  srv.readPacket()                              // データ受信
      | bufferedTransfer<netBufferSize>(sched1) // 結果をバッファにつめて実行コンテキスト遷移
      | then(soundDecode)                       // 受信データのデコード
      | bufferedTransfer<pcmBufferSize>(sched0) // 結果をバッファにつめて実行コンテキスト遷移
      | then(sendI2sChunk())                    // PCMを再生デバイスへ転送
      | runForever();                           // これらの一連の処理を繰り返す
}
```

この`bufferedTransfer`は内部的にキューを使用しているものとすると、この場合も実行コンテキスト間のやりとりにはキューが使用されています。

また、コルーチンを使用しても実装できます

```cpp
CoHandle receive() {
  while (true) {
    std::span<uint8_t> buf = co_await srv.coReceiveWireChunk(); // blocks
    co_await opusQueuePush.wait_push(buf);
  }
}

CoHandle decode() {
  while (true) {
    std::span<uint8_t> inBuf;
    co_await opusQueuePull.wait_pop(inBuf);

    int samples = opus_decode(decoder,
                              inBuf.data(), inBuf.size(),
                              decodeBuf.data(), maxFrameSamples,
                              0);
    std::span outBuf(decodeBuf.data(), samples);

    co_await pcmQueuePush.wait_push(outBuf);
  }
}

CoHandle play() {
  while (true) {
    std::span<uint8_t> inBuf;
    co_await pcmQueuePull.wait_pop(inBuf);

    uint32_t const *start = inBuf.data();
    size_t offset = 0;
    
    while (offset < size) {
      size_t bytesDone;

      co_await co_i2s_channel_write(tx,
                                    start + offset,
                                    size - offset,
                                    &bytesDone,
                                    noTimeout);

      offset += bytesDone;
    }
  }
}

// 例えばこのように実行
void network_speaker() {
  while (true) {
    co_await receive();
    co_await decode();
    co_await pray();
  }
}
```

他にもファイバーによる実装も考えることができ、それはスレッド版とほぼ同じようなコードになります。

現在のC++はこれらの実装方法のうち最初のスレッド版だけをサポートしています。ただし、スレッド間で共有可能な並行キューはありません。とはいえ、コルーチンはすでに利用可能であり、P2300やファイバーも程なく利用可能になる予定なので、残りのコードも近いうちにサポートされます。すると、そこに欠けているのは実行コンテキスト間同期に使用している並行キューのようなものです。

この文書は、このキューのような実行コンテキスト間で通信（同期）を取るための標準的なメカニズムに必要な要件や設計について検討し、それに伴って浮かんだいくつかの疑問についてSG1に問うものです。まだ何かを提案しているわけではありません。

実行コンテキストに特化した同期メカニズムを提供するのは簡単ですが、全ての実行コンテキストでうまく動作するものを提供するのは困難です。例えば、上記例のキューはスレッド版とコルーチン版で異なるメンバ関数を提供しなければならないほか、動機を取る方法についても実行コンテキストによって最適なものが変わるでしょう。

それぞれの実装に特化したものを用意しても、複数の実行コンテキストを組み合わせて使用する場合にうまくいかなくなります。例えば、コルーチンによる実行においてその処理の一部（デコード）を別のスレッドで行おうとすると、コルーチンとスレッドという異なる実行方法にまたがって動作する同期方法（例ではキュー）が必要になります。

P0073R2ではそのような同期のためのキューではなく`event`というクラス型を提案しています。

```cpp
class event {
  // イベント通知
  void signal();
}

// イベント通知を待機
void block(event until);
```

このような抽象化は有用であると思われますが、異なる実行コンテキスト間で動作しようとするとき、`signal()`はイベントを受信する（送信先の）実行コンテキストを、`block()`は現在の実行コンテキストを知っていなければならないようです。そのために、`event`クラスはそのオブジェクトでブロック中の全てのタスクのリストを保持する必要があります。実行コンテキストが静的にわかっていれば問題はないですが、動的にしかわからない場合が想定されるようで、その場合には実行時に現在の実行コンテキストを知る手段が必要となります

並行キューについては、キュー本体とキューのインターフェースを分離することで実装を効率化できる可能性が見出されました。その場合、キューは実行コンテキストによってテンプレート化され、実行コンテキストはそのブロッキングと通知のためのAPI（上記`event`クラスのインターフェースと同様のもの）を提供する必要があります。

すなわち、`event`クラスのようなAPIの設計はそれそのものやキューに限らず、同様の目的の同期メカニズムに対して一般化することができるはずです。すると、それらのものは実行コンテキストを知っている必要がありますが、これは必ずしも静的に検出可能ではない場合があります。

また、そのようなメカニズムでは`signal()`に相当するイベント通知処理がブロック中のタスクとその実行コンテキストを覚えておく必要があります。そのリストを保持するために追加のメモリ確保は許容されるのか、あるいは回避されるべきでしょうか。また、そのようなリストはおそらく型消去されることになります。すると型消去そのもののために動的確保が必要となる可能性があります。

この文書では、このようなまず浮かび上がった疑問をSG1に投げかけています。

1. SG1はこのような汎用同期APIにより力を入れるべきか？
2. P0073R2の`event`は使用可能な抽象であるか？
3. あるスレッドで実行中の処理内から、それを包含する最上位の実行コンテキスト（スレッドに対するスレッドプールなど）を検出するような実装を要求できるか？
4. 実行コンテキストの完全なチェーンは必要か？
5. 標準ライブラリにあるブロックする可能性がある関数のリストは必要か？
6. 実行エージェントのペアのためのカスタマイズを許可するか？

この文書はこれらの解答を受けて、さらなる検討や作業を進めるつもりのようです。

- [P0073R2 On unifying the coroutines and resumable functions proposals](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0073r2.pdf)
- [P2881 進行状況](https://github.com/cplusplus/papers/issues/1533)

### [P2883R0 `offsetof` Should Be A Keyword In C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2883r0.pdf)

`offsetof`をキーワード化し、`offsetof`マクロの機能を言語機能とする提案。

この提案には、上の方のP2654R0の項も関連しています。

`offsetof`はマクロなのでモジュールからエクスポートすることができず、`std`モジュールからもエクスポートされません。そのため、使用する場合は引き続き`#include <cstddef>`が必要となりますが、このヘッダはインポート可能であると指定されてはいないため、ヘッダユニットとしてインポートすることもできません。

この提案は、主にこの問題の解消のために、`offsetof`をキーワードとしてその機能を言語機能に昇格することでヘッダのインクルードによらず使用可能にしようとするものです。

これによって、`offsetof`の他の問題点の解決を図ることができます

- マクロ引数に`,`が含まれていると展開がバグる
- `offsetof`の第一引数に標準レイアウトクラス型以外を指定した場合、もしくは第二引数にデータメンバ以外を指定した場合のUB
- 結果をポインタ演算に使用するとUBとなる

この提案によって解消される問題の例

```cpp
import std.compat;  // offsetofはエクスポートされない
import <cstddef>;   // ポータブルではない
#include <cstddef>  // ok、これが最善

template <typename A, typename B>
struct Test {
  int data;
};

using TestInts = Test<int, int>;
static_assert(offsetof( TestInts, data) == 0); // ok

static_assert(offsetof( Test<int, int> , data) == 0); // error、型名にカンマが含まれる
static_assert(offsetof((Test<int, int>), data) == 0); // error、()で括ることをサポートしていない

class S1 {
  int data;
public:
  S2(int n) : data{n} {}
};

struct S2 {
  int data;
  void f();
};

static_assert(offsetof(S1, data) == 0); // UB
static_assert(offsetof(S2, f) == 0);    // UB

struct T {
  int i;
  double j;
  short k;
  void *p;
};

int main() {
  using namespace std;

  T x = {};
  size_t y = offsetof(T, k);
  short *p = (short*)((byte*)&x + y); // このx + yのポインタ演算はUB

  *p =123;
  printf("%d", x.k);
}
```

この提案では、キーワード化された`offsetof`は演算子となり、上記のUBをエラーにしたり結果をポインタ演算に使用できるようにするなどの意味論が整備されます。

- [`offsetof` - cpprefjp](https://cpprefjp.github.io/reference/cstddef/offsetof.html)
- [モジュール - cpprefjp](https://cpprefjp.github.io/module.html)
- [P2883 進行状況](https://github.com/cplusplus/papers/issues/1560)

### [P2884R0 `assert` Should Be A Keyword In C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2884r0.pdf)

`assert`をキーワード化し、`assert`マクロの機能を言語機能とする提案。

この提案には、1つ前のP2883及び上の方のP2654R0の項も関連しています。

`assert`はマクロなのでモジュールからエクスポートすることができず、`std`モジュールからもエクスポートされません。そのため、使用する場合は引き続き`#include <cassert>`が必要となりますが、このヘッダはインポート可能であると指定されてはいないため、ヘッダユニットとしてインポートすることもできません。

この提案は、主にこの問題の解消のために、`assert`をキーワードとしてその機能を言語機能に昇格することでヘッダのインクルードによらず使用可能にしようとするものです。

1つ上の`offsetof`と同様にキーワード化された`assert`は演算子となり、それによって式に`,`が含まれている場合に展開がバグる問題が解消されます。

この提案によって解消される問題の例

```cpp
import std.compat;  // assertはエクスポートされない
import <cstddef>;   // ポータブルではない
#include <cassert>  // ok、これが最善

int main() {
  assert( std::is_same_v<int, int> );         // ng、マクロ引数が多い（カンマが含まれている）
  assert((std::is_same_v<int, int>));         // ok
  assert( std::vector{1, 2, 3}.size() == 3 ); // ng、マクロ引数が多い（カンマが含まれている）
  assert((std::vector{1, 2, 3}.size() == 3)); // ok

  int x = 0;
  int y = 0;

  assert( [x, y]{ return test(x, y);}() ); // ng、マクロ引数が多い（カンマが含まれている）
  assert(([x, y]{ return test(x, y);}())); // ok
}
```

この`assert`とよく似た機能は、関数中の不変条件の表現とチェックのための構文としてC++26予定の契約プログラミング機能においても議論されています。ただし、契約プログラミングにおいては契約の構文をどうするかまだ決定されていないため、その検討の一環としても`assert`のキーワード化をここで議論してSG21（契約プログラミング作業グループ）にフィードバックすることもこの提案の目的の一つです。

また、`assert`を演算子化した場合には、その有効無効の切り替え（`NDEBUG`マクロによるなど）の方法の可否や、ビルドモードのよる構文評価の有無などの問題と向き合う必要がありますが、それらの細かい議論はSG21で提案されている実行時アサーションの機能の議論と合流させる（ここでは取り扱わない）ことを推奨しています。

- [P2884 進行状況](https://github.com/cplusplus/papers/issues/1561)

### [P2886R0 Concurrency TS2 Editor's report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2886r0.pdf)

Concurrency TS v2の最新のドラフト（N4953）の変更点をまとめた文書。

次の提案と編集上の修正が適用されているようです。

- [P2396R1 Concurrency TS 2 fixes](https://wg21.link/P2396R1)
- [P1478R8 Byte-wise atomic memcpy](https://wg21.link/P1478R8)
- [P1202R5 Asymmetric Fences](https://wg21.link/P1202R5)
- [P0290R4 `apply()` for `synchronized_value<T>`](https://wg21.link/P0290R4)

### [P2887R0 SG14: Low Latency/Games/Embedded/Finance/Simulation virtual meeting minutes to 2023/05/11](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2887r0.pdf)

2023年5月11日に行われたSG13の議事録。

### [P2888R0 SG19: Machine Learning Virtual Meeting Minutes to 2023/05/12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2888r0.pdf)
### [P2889R0 Distributed Arrays](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2889r0.html)

複数の翻訳単位で分散している配列を1つの配列として扱う機能の提案。

C++のリンカには、複数の翻訳単位からシンボルを取り出してそれを1つの配列にまとめる機能があります。それは例えば、ある同じ名前の外部リンケージを持つ配列に対して各翻訳単位でそれぞれ初期化した後、リンカが最終的なプログラムを出力する際にそれぞれの翻訳単位（オブジェクトファイル）で初期化されている配列要素を何かしらの方法でマージします。

この機能はC++の単体テストフレームワークにおいて活用されており、各翻訳単位で定義されている単体テストを集めて管理するグローバルなシングルトンの実装に使用されます。このようなグローバルな分散配列の初期化は、コンパイル時（リンク時）にはその初期化子は判明していますが、言語サポートなどはないのでその初期化は実行時に行われます。

`register`というキーワードでこの分散配列を指定することにすると、例えば次のコードのような雰囲気のことが行われています

```cpp
/// test_framework.h
using test_func = bool (*)();

// 分散配列g_testsの宣言
extern const test_func g_tests[register];
```
```cpp
/// always_pass.cpp
#include "test_framework.h"

bool always_pass() {return true;}

// 分散配列に要素を追加
const test_func g_tests[register] = {always_pass};
```
```cpp
/// always_fail.cpp
#include "test_framework.h"

bool fail1() {return false;}
bool fail2() {return false;}

// 分散配列に要素を追加
const test_func g_tests[register] = {fail1, fail2};
```
```cpp
/// main.cpp
#include "test_framework.h"

int main() {
  // 分散配列g_testsは次の要素を含む : {always_pass, fail1, fail2}
  // ただし、その順序は不定
  for (test_func f : g_tests) {
    if(!f()) return 1;
  }

  return 0;
}
```

この機能は他のところでは、C++の実装（コンパイラ）が静的初期化子やスレッドローカルストレージ、例外処理テーブルなどの実装に使用されるほか、動的リフレクションの実装にも使用されているようです。

単体テストフレームワークにおける利用例はこの機能が有効に利用されている大きな例であり、その他の利用例もこの機能の有用性を物語っています。また、この機能をポータブルかつ簡易に利用できるようにすることで、static initialization order fiascoとして知られる問題をプログラマの希望に沿った初期化を確実に行われるように解決することができます。例えば、初期化関数と優先順位のペアからなる分散配列を用意しておき、プログラムの任意のタイミングでそれを優先順位でソートして対応する初期化を実行する、などの方法が可能となります。さらに、この方法は動的ライブラリの初期化にも活用できます。

既存の幅広い利用例や想定される利用法など、分散配列を言語サポートしてポータブルかつ簡易に利用可能にすることにはかなりの価値があり、この提案はそれを提案するものです。

この提案ではまだ具体的な構文が固まっていないようですが`__distributed_array`に分散配列の名前を渡して配列宣言に指定することで、分散配列であることを明示し、その初期化子は1つの配列にリンク時に統合されます。

```cpp
/// テストフレームワークのヘッダ
using test_case_callback = void();

// テストケースを登録する分散配列
extern test_case_callback* const test_cases[];
```
```cpp
/// テストフレームワークを使用するユーザーコード

// 分散配列への単一要素追加
__distributed_array(test_cases)
test_case_callback* const my_test_case = my_test_case_function_1;

// 分散配列への複数要素追加
__distributed_array(test_cases)
test_case_callback* const my_test_case_array[] = {
  my_test_case_function_2,
  my_test_case_function_3,
};
```
```cpp
/// テストフレームワークのソース
void run_unit_tests() {
  test_case_callback* const* const test_data = ::test_cases;

  // 分散配列の要素数取得
  size_t const test_count = std::distributed_array_size(test_data);

  // 分散配列をspanで参照
  std::span const tests = std::span(test_data, test_count);

  // 分散配列のイテレーション
  for (test_case_callback* const test : tests) {
    test();
  }
}
```

分散配列そのものの宣言は`extern`による要素数不明の配列であり、これは新しい構文やキーワードを追加する負担を避けたものです。別の提案（P2268）で提案されていたように（最初の例のように）`register`キーワードを使用するなど、別の構文を妨げるものではありません。

分散配列の型に関しては、普通の配列型と区別しておくとコンパイル時の診断が行いやすくなったり、既存の範囲のためのユーティリティを直接分散配列で利用できるようになるなどのメリットがあるため、分散配列専用の配列型を追加することを提案しています。具体的には決まっていませんが、`register`キーワードを用いる場合は`T[register]`や`T(&)[register]`のようなものが考えられます。

静的な変数（配列）の定義に対して`__distributed_array(A)`のように指定すると、その配列は分散配列`A`の部分定義として機能します。最終的なプログラムでは、それら部分定義は全てマージされて`A`の定義となります。分散配列が`extern cv T A[];`のように定義されている時、その部分定義は`cv T`型の変数もしくは`cv T`型の要素を持つ配列宣言であり、かつ名前空間スコープもしくは静的メンバ変数である必要があります。

分散配列のサイズを取得するためには、ここでは`std::distributed_array_size()`というライブラリ関数を利用していますが、`sizeof`や専用言語機能による取得方法も考慮されており、まだ決定していません。

分散配列の要素の順序はほぼ不定ですが、1つの翻訳単位で定義された（非`inline`）部分定義はその定義の順番で順序づけされます。

有効な利用例を見出せないため現在のところは`thread_local`な分散配列は提案されていません。

動的ライブラリにおいて実行時にそれらに含まれる分散配列を統合することはおそらくほぼ不可能であり、動的リンクはC++標準の範囲外のことであるため提案されていません（Windowsでは問題とならないとのことです）。ここではあくまで、静的なリンク時点で定義される分散配列を提案しており、静的ライブラリでは同じ分散配列定義は統合されますが、動的ライブラリにおいてはそれらシンボルは競合するとみなすことにすることを提案しています。言い換えると、動的リンカは分散配列を扱う必要はありません。これは既存のリンカの動作と一致しているようです。

この提案は、EWGIの初期レビューで好意的に受け止められており、さらなる作業が続行される予定です。

- [P2268R0 Freestanding Roadmap](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2268r0.html#link_time_arrays)
- [P2889 進行状況](https://github.com/cplusplus/papers/issues/1564)

### [P2891R0 SG16: Unicode meeting summaries 2023-01-11 through 2023-05-10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2891r0.html)
### [P2892R0 `std::simd` Types Should be Regular](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2892r0.pdf)

提案中の`std::simd`が[`regular`](https://cpprefjp.github.io/reference/concepts/regular.html)であるようにする提案。

C++26に向けて提案中の`std::simd`型は`operator==`が要素ごとの比較を行った結果を`bool`ではなく要素ごとの比較結果を`1/0`で保存した`simd_mask`型として返します。そのため、`regular`コンセプトを満たしません。

これは例えば、`std::simd`型をメンバとして保持するクラスに`operator==`をデフォルト実装しようとした時に問題となります。

```cpp
using uint32_4v = std::fixed_size_simd<std::uint32_t, 4>;

class Color {
public:
  bool operator==(const Color &) const = default;
private:
  uint32_4v data_;
};

void f() {
  Color a, b;
  
  ...
  
  if ( a == b ) // ERROR: operator==は削除されている
}
```

`std::simd`は値セマンティクスを持つ値型として設計されており、その演算をSIMD演算にエンコードする以外の部分では組み込み型と同様に動作することを意図しています。`regular`コンセプトはそのような値型が満たすべき基本的な性質です。また、`regular`な型には次のような関係があることが期待されます

1. `T a = b; assert(a == b);`
2. `T a; a = b;`と`T a = b;`は同値
3. `T a = c; T b = c; a = d; assert(b == c);`
4. `T a = c; T b = c; zap(a); assert(b == c && a != b);`
    - `zap`はつねに引数の値を変更する

これらの性質は例えば`std::find`のように内部で比較を行うような処理が暗黙的に要求していることでもあり、標準ライブラリの中でも一般のライブラリにおいても広く活用されています。

また、在野のライブラリでは多くのSIMD型が提供されており、そこではSIMDレジスタをラップするものから、より大きな数学的なベクトル・行列を表現するもの（DSL）まであります。そこでも`operator==`による比較が提供されており、多くの場合は要素ごとの比較を行いその結果を（非`bool`で）返します。

そのようなライブラリのうち、DSLを目的とするライブラリは`std::simd`とは目的が異なっているため、そこから`std::simd`へ移行することはまずないと思われるため`std::simd`の比較がどう選択されてもそのユーザーにはあまり関係ないでしょう。それ以外のライブラリのユーザーやDSLの実装者は`std::simd`へ移行することにはかなりの利点があり、その場合の`std::simd`の比較は他のC++の場合と同じ意味論が自然に要求されるでしょう。

C++の標準ライブラリには`std::simd`のようなデータ並列型は存在していませんが、値のシーケンスを表す型はいくつかあり（`bitset, vector, array, valarray`など）、`std::valarray`を除いて全ての型が`bool`を返す`operator==`を持っています。

この提案はこれらの背景から、`std::simd`の`operator==`をマスクではなく`bool`を結果として返すように変更し、結果をマスクで取得するのは別のフリー関数によって行うようにすることを提案するものです。

- [`std::regular` - cpprefjp](https://cpprefjp.github.io/reference/concepts/regular.html)
- [P2892 進行状況](https://github.com/cplusplus/papers/issues/1513)

### [P2893R0 Variadic Friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2893r0.pdf)

`friend`宣言でのパック展開を許可する提案。

クラステンプレート定義内でテンプレートパラメータに対して`friend`指定を行う際、そこにパラメータパックを指定することはできません。

```cpp
template <typename T>
class Foo1 {
  friend T; // ok
public:
  // ...
};

template <typename... Ts>
class Foo2 {
  friend Ts...; // ng
public:
  // ...
}
```

この提案は`friend`宣言でのパック展開を許可し、パラメータパックに含まれるそれぞれのクラス型に対して`friend`を適用するようにするものです。

この提案のモチベーションの一つとして、Passkeyイディオムというテクニックのサポートが挙げられています。

あるクラス`C`の定義内で他のクラス`D`を`frined`指定すると、`D`は`C`の全てのプライベートメンバへアクセスすることができます。この時、アクセスしたいのがある1つのプライベートメンバだけだったとしても、その公開範囲を制限する方法はありません。

```cpp
class D;

class C {
  friend D; // DはCの全てのメンバにアクセスできる

  ...
};
```

Passkeyイディオムは、この時に別のクラスPasskeyを間に挟むことでプライベートメンバの公開範囲を制限するものです。

```cpp
class D;

class Passkey {
  friend D;
  Passkey() = default;  // PasskeyはDからしか生成できない
};

class C {
  ...

public:
  // Passkeyを生成できないとこの関数を呼べない
  auto do_something(Passkey) {
    // 必要なメンバにだけアクセスする
    ...
  } 
};
```

プライベートアクセスは関数経由にはなりますが、これによって必要なプライベートメンバだけにプライベートアクセス範囲を絞ることができます。

Passkeyイディオムにおける`Passkey`クラスはテンプレートにすることで使いまわすことができ、そうすると`Passkey`を使用する場所でアクセス可能なクラス名が明示されるようになります。

```cpp
class D;

template<typename T>
class Passkey {
  friend T;
  Passkey() = default;  // PasskeyはTからしか生成できない
};

class C {
  ...

public:
  // Dからのみ呼べる
  auto do_something(Passkey<D>) {
    // 必要なメンバにだけアクセスする
    ...
  } 
};
```

この場合でも`do_something()`には`D`からしかアクセスできません。

さらに、複数のクラスに対してアクセスを許可したい場合のために`Passkey`クラスのテンプレートパラメータを可変にすることが考えられます。

```cpp
class D;
class E;
class F;

template<typename... Ts>
class Passkey {
  friend Ts...; // 現在これができない
  Passkey() = default;  // PasskeyはTからしか生成できない
};

class C {
  ...

public:
  // D, E, Fからのみ呼べる
  auto do_something(Passkey<D, E, F>) {
    // 必要なメンバにだけアクセスする
    ...
  } 
};
```

ただし、現在は`friend`宣言におけるパック展開が不可能であるため、これはできません。

提案では他にも、CRTPにおいて基底クラスから派生クラスのプライベートメンバアクセスを許可する場合に派生クラスで可変長テンプレートを使用する場合の例を挙げています。

- [継承を使わずに特定のクラスにのみ実体作成を許可する方法 - teratail](https://teratail.com/questions/330941)
- [P2893 進行状況](https://github.com/cplusplus/papers/issues/1567)

### [P2895R0 noncopyable and nonmoveable utility classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2895r0.html)
### [P2897R0 `aligned_accessor`: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2897r0.html)

`mdspan`のアクセサポリシークラスに、参照する領域ポインタに`std::assume_aligned`を適用してアクセスする`aligned_accessor`の提案。

`mdspan`のアクセサポリシーとは、領域へのポインタとインデックスを受け取ってどのようにその領域へアクセスするか（要素を引き当てるか）を指定するポリシークラスです。デフォルトのアクセサ（`std::default_accessor<T>`）は要素型`T`のポインタ`ptr`とインデックス`idx`に対して`ptr[idx]`のようにアクセスしてその結果を返します。

この提案は、この場合に領域ポインタ`ptr`を`std::assume_aligned`に通してからアクセスすることで、`mdspan`に対してアライメント要件を宣言しつつコンパイラの最適化を適用する能力を与えるものです。

提案しているのは`aligned_accessor<T, N>`というクラスで、次のようなものです

```cpp
namespace std {

  // aligned_accessor
  template<class ElementType, size_t the_byte_alignment>
  struct aligned_accessor {
    // オフセット結果に対するアクセサ
    // 領域先頭がアライメントされていても、オフセット結果までそうであるとは限らない
    using offset_policy = default_accessor<ElementType>;
    // 要素型
    using element_type = ElementType;
    // アクセス結果の型
    using reference = ElementType&;
    // データハンドル（参照領域を指定するもの）の型、ほとんどの場合ポインタのこと
    using data_handle_type = ElementType*;

    // 要求（仮定）するアライメント
    static constexpr size_t byte_alignment = the_byte_alignment;

    constexpr aligned_accessor() noexcept = default;

    // 非const ElementTypeからconst ElementTypeへの変換と
    // より大きなアライメントから小さいアライメントへの変換を行うコンストラクタ
    template<class OtherElementType, size_t other_byte_alignment>
    constexpr aligned_accessor(aligned_accessor<OtherElementType, other_byte_alignment>) noexcept;

    constexpr operator default_accessor<element_type>() const {
      return {};
    }

    // 指定したインデックスで要素を引き当てる
    constexpr reference access(data_handle_type p, size_t i) const noexcept {
      // assume_alignedを通して要素アクセス
      return assume_aligned<byte_alignment>(p)[i];
    }

    // 指定したインデックスでオフセットしたデータハンドル（ポインタ）を得る
    constexpr typename offset_policy::data_handle_type
      offset(data_handle_type p, size_t i) const noexcept {
        // pの指す領域はbyte_alignmentでアラインされている（はず）だが
        // その要素p + iの領域はそうとは限らない
        return p + i;
      }

    // 少なくともbyte_alignmentでアラインされているかを取得する
    constexpr static bool is_sufficiently_aligned(data_handle_type p);
  };
}
```

アクセサクラスは`mdspan`に指定すると内部で勝手によしなにしてくれるので、通常これを直接扱う必要はないはずです（`is_sufficiently_aligned()`はアライメントチェックのために使うことがあるかもしれません）。

簡単な使用例

```cpp
#include <mdspan>
#include <ranges>

// nx4行列でアライメント要求をとるmdspan
template<typename T, size_t byte_alignment>
using aligned_mdspan_Nx4 = std::mdspan<T, std::extents<size_t, std::dynamic_extent, 4>, std::layout_right, std::aligned_accessor<T, byte_alignment>>;

int main() {
  using namespace std::views;

  // float配列を16バイトアライメントにアラインする
  alignas(16) float array1[] = {...};
  alignas(16) float array2[] = {...};

  // 4x4行列として参照
  aligned_mdspan_Nx4<float, 16> mat44_1{array1, 4};
  aligned_mdspan_Nx4<const float, 16> mat44_2{array2, 4};

  // assume_alignedを通していることで、このような計算は最適化されやすくなる
  for (auto [y, x] : cartesian_product(iota(0, 4), iota(0, 4))) {
    mat44_1[y, x] *= mat44_2[y, x];
  }
}
```

提案文書より、サンプルコード

```cpp
// float要素の1次元動的mdspan
template<size_t byte_alignment>
using aligned_mdspan =
  std::mdspan<float, std::dextents<int, 1>, std::layout_right, std::aligned_accessor<float, byte_alignment>>;

// 32バイトアライメントを要求するインターフェース
// 例えば、floatで幅8のSIMDを使用するなど
extern void vectorized_axpy(aligned_mdspan<32> y, float alpha, aligned_mdspan<32> x);
extern float vectorized_norm(aligned_mdspan<32> y);

// 16バイトアライメントを要求するインターフェース
// 例えば、floatで幅4のSIMDを使用するなど
extern void fill_x(aligned_mdspan<16> x);
extern void fill_y(aligned_mdspan<16> y);

// Helper functions for making overaligned array allocations.

template<class ElementType>
struct delete_raw {
  void operator()(ElementType* p) const {
    std::free(p);
  }
};

template<class ElementType>
using allocation = std::unique_ptr<ElementType[], delete_raw<ElementType>>;

template<class ElementType, std::size_t byte_alignment>
allocation<ElementType> allocate_raw(const std::size_t num_elements) {
  const std::size_t num_bytes = num_elements * sizeof(ElementType);
  void* ptr = std::aligned_alloc(byte_alignment, num_bytes);
  return {ptr, delete_raw<ElementType>{}};
}

float user_function(size_t num_elements, float alpha) {
  // 32バイトアライメントでメモリを確保
  constexpr size_t max_byte_alignment = 32;
  auto x_alloc = allocate_raw<float, max_byte_alignment>(num_elements);
  auto y_alloc = allocate_raw<float, max_byte_alignment>(num_elements);

  // 32バイトアライメントで領域を参照
  aligned_mdspan<max_byte_alignment> x(x_alloc.get(), num_elements);
  aligned_mdspan<max_byte_alignment> y(y_alloc.get(), num_elements);

  fill_x(x); // 32バイトアライメントから16バイトアライメントへの変換
  fill_y(y); // 32バイトアライメントから16バイトアライメントへの変換

  vectorized_axpy(y, alpha, x);
  return vectorized_norm(y);
}
```

- [`std::mdspan` - cppreference](https://en.cppreference.com/w/cpp/container/mdspan)
- [`std::assume_aligned` - cpprefjp](https://cpprefjp.github.io/reference/memory/assume_aligned.html)
- [`std::mdspan` - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20230303/p1)
- [P2689R0 `atomic_accessor` - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2689R0-atomic_accessor)
- [データ型のアラインメントとは何か，なぜ必要なのか？](http://www5d.biglobe.ne.jp/~noocyte/Programming/Alignment.html)
- [P2897 進行状況](https://github.com/cplusplus/papers/issues/1568)

### [P2898R0 Importable Headers are Not Universally Implementable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2898r0.pdf)
### [P2901R0 Extending linear algebra support to batched operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2901r0.html)
