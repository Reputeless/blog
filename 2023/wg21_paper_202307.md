# ［C++］WG21月次提案文書を眺める（2023年07月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-07](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-07)

全部で106本あります。

### [N4955 WG21 2023-06 Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4955.pdf)

2023年6月に行われた、WG21管理者ミーティングの議事録

### [N4957 WG21 February 2023 Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4957.pdf)

2023年6月に行われた、WG21全体会議の議事録

### [P0260R6 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0260r6.html)
### [P0260R7 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0260r7.html)
### [P0543R3 Saturation arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0543r3.html)
### [P0843R7 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0843r7.html)
### [P0843R8 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0843r8.html)
### [P0901R11 Size feedback in operator new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0901r11.html)
### [P1030R6 std::filesystem::path_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1030r6.pdf)
### [P1324R1 RE: Yet another approach for constrained declarations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1324r1.html)

制約付きの`auto`による関数宣言構文において、そのテンプレートパラメータ名を直接導入できる構文の提案。

この提案のモチベーションは以前に紹介したP2677R0と共通なので、以前の記事を参照

- [P2677R0 Reconsidering concepts in-place syntax - ［C++］WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2677R0-Reconsidering-concepts-in-place-syntax)

P2677では`auto:T`のような構文でテンプレートパラメータ名を導入しようとしていましたが、この提案は`void sort(Sortable auto& c);`を`void sort(Sortable S& c);`のように書けるようにすることで、`auto`の代わりに直接テンプレートパラメータ名を導入しようとするものです。

```cpp
namespace current {
  // 現在の制約付きauto関数テンプレート
  void f(Sortable auto&& x) {
    using S = decltype(x); // テンプレートパラメータ名Sを取り出す
    // use S
  }
}

namespace p2677 {
  // P2677提案の制約付き関数テンプレート
  void f(Sortable auto:S&& x) // テンプレートパラメータ名Sが導入される
  {
    // use S
  }
}

namespace p1324 {
  // この提案による制約付き関数テンプレート
  void f(Sortable S&& x) // テンプレートパラメータ名Sが導入される
  {
    // use S
  }
}
```

この提案ではさらに、この構文を戻り値型制約や変数宣言に対する制約にまで広げています

```cpp
// 現在
void f(Sortable auto x);
Sortable auto f(); 
Sortable auto x = f(); 
template <Sortable auto N>void f();

// この提案
void f(Sortable S x);             // 関数引数のテンプレートパラメータ導入
Sortable S f();                   // 関数戻り値型のテンプレートパラメータ導入
Sortable S x = f();               // 変数宣言時の型名エイリアス導入
template <Sortable S N> void f(); // NTTP宣言時のテンプレートパラメータ導入
```

ただし、コンセプト パラメータ名 変数名、のような宣言であるため、変数名を省略するとコンパイルエラーになります。

```cpp
// Numberはコンセプトとする

void f(Number N);     // ng、Numberが型名ではない
void f(Number auto);  // ok、テンプレートパラメータ名も変数名も導入されない
void f(Number N __);  // 別の提案（P1110）で提案されていたプレースホルダ
```

この制限によって、通常の関数とジェネリックな関数が混同されることが無くなります

```cpp
void f(Foo V)     // 2id: 常に通常の関数宣言
void f(Foo F V)   // 3id: ジェネリック関数（この提案）
void f(Foo auto)  // 1id + auto: ジェネリック関数
```

この宣言によって導入されたテンプレートパラメータ名は以降の引数宣言のために使用できるほか、別のコンセプトのために使用することもできます

```cpp
// Number, Concept, AnotherConceptは何かコンセプトとする

// 1つのテンプレートパラメータで2つの引数を宣言する
void f(Number N x, N y) { }

// 複数のコンセプトでそれぞれ変数を宣言し、テンプレートパラメータ名を別のコンセプトで使用する
Concept R f(Number N a, AnotherConcept<R> U b); 
```

- [P2677R0 Reconsidering concepts in-place syntax - ［C++］WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2677R0-Reconsidering-concepts-in-place-syntax)
- [P1324 進行状況](https://github.com/cplusplus/papers/issues/68)

### [P1383R2 More constexpr for cmath and complex](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1383r2.pdf)
### [P1729R2 Text Parsing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1729r2.html)

`std::format`の対となるテキストスキャン機能の提案。

C++20で`std::format`が追加されたことで、いくつか問題を抱えていた従来のテキスト書式付き出力機能である`std::ostream`や`printf`等に代わるものをC++は手に入れました。しかし、テキスト入力面では改善はなく、同様に問題を抱えている従来の`std::istream`や`scanf`等を利用するしかありません。`std::format`の対となるものを欠いているということでもあり、このことは標準ライブラリの一貫性を損ねてもいます。

この提案は、`std::format`の対となる書式付きテキスト入力機能`std::scan`を提供し、その欠けている部分を補おうとするものです。

基本的な使用法

```cpp
if (auto result = std::scan<std::string, int>("answer = 42", "{} = {}")) {
  //                        ~~~~~~~~~~~~~~~~   ~~~~~~~~~~~    ~~~~~~~
  //                          output types        input        format
  //                                                           string

  const auto& [key, value] = result->values();
  //           ~~~~~~~~~~
  //           読み取られた値

  // result == true
  // result.begin() points to the end of the given input (the null terminator)
  // key == "answer"
  // value == 42
} else {
  // エラーが起きた場合
  // result.error()からエラー情報を取得できる
}
```

基本的には、`std::scan<Types...>(input, format)`のようにして、入力文字列`input`に対するフォーマット文字列を`format`、型指定を`Types`に渡して使用します。フォーマット文字列の構文はほぼ`std::format`のものと共通しており、入力文字列とフォーマット文字列をマッチして、フォーマット文字列中の置換フィールド`{}`のある位置に対応する入力文字列中の文字列を`Types`の対応する位置にある型の値として読み取ります。

```cpp
auto input = "25 54.32E-1 Thompson 56789 0123";

auto result = std::scan<int, float, string_view, int, float, int>(
  input, "{:d}{:f}{:9}{:2i}{:g}{:o}");

// resultはstd::expected、 operator->は失敗時に例外をスローする
auto [i, x, str, j, y, k] = result->values();

// i == 25
// x == 54.32e-1
// str == "Thompson"
// j == 56
// y == 789.0
// k == 0123
```

`std::scan<Types...>(...)`の結果は`std::expected`で返されており、成功時は`std::scan_result`という型の値に対して`.value()`関数を呼ぶことでスキャン結果を`std::tuple<Types...>`オブジェクトとして得ることができます。

スキャン対象の入力は文字列に限らず、スキャン可能な範囲をとることができます。この要件は`scannable_range`コンセプトで表現されています。

```cpp
// scannable_rangeの定義例
template <class Range, class CharT>
concept scannable_range =
  ranges::forward_range<Range> && same_as<ranges::range_value_t<Range>, CharT>;
```

`forward_range`でありその要素型が`CharT`（文字型）であるような範囲であれば読み取ることができ、文字列の範囲となっている多くのものを対象にしています。

```cpp
// views::reverseからの読み取り例

std::string input{"123 456"};
if (auto result = std::scan<int>(std::views::reverse(input), "{}")) {
  // 読み取り対象の値が1つなら、result->value()はそのオブジェクトを直接返す
  // result->value() == 654
}
```

`std::scan`においては`scannable_range`に与えられる`CharT`はフォーマット文字列の文字型から取得されるため、入力文字列とフォーマット文字列の文字型は一致している必要があります。

```cpp
std::scan<int>("42", "{}");   // OK
std::scan<int>(L"42", L"{}"); // OK
std::scan<int>(L"42", "{}");  // Error: wchar_t[N] is not a scannable_range<char>
```

エラー時は`scan_error`という専用のエラー型（列挙型ではない）の値が得られ、`.code()`からエラーコードが取得できるほか`.msg()`からエラーメッセージを取得することができます。

```cpp
if (auto result = std::scan<std::string, int>("answer = 42", "{} = {}")) {
  ...
} else {
  // エラーが起きた場合
  auto err = result.error();

  auto ec = err.code(); // エラーコードの取得
  std::println("Error! : {:s}", err.msg()); // エラーメッセージの出力
}
```

フォーマット文字列は`std::format`にほとんど準じていますが、数値型に対する一部のオプションは無効化されます

- *sign* : `+ -`およびスペース
  - 符号の指定
- *alt* : `#`
  - 代替表示形式、整数型の場合は基数プリフィックス、浮動小数点数型の場合は小数点を常に表示する
- *pad* : `0`
  - 先頭のゼロフィル
- *precision* : `.`+数値
  - 浮動小数点数型の精度指定

これらのオプションは読み取り時には意味がなく、スキャン時は全ての可能性を考慮しどれかの形式をデフォルトにしたり無効化することを回避しています。

そのほかのオプションは利用可能となりますが、出力ではなく読み取りに使用するものであるため`std::format`からその意味が少し変わっています。

また、`std::scan`でのみ利用できるオプションも追加されています

- `i` : プリフィックスから基数を検出する（デフォルトは10進数）
  - 整数型のみ
- `u` : `-`を考慮しない10進整数値
  - 整数型のみ
- `c` : 入力文字（列）をそのままコピーする
  - 文字列型/文字型/数値型で有効

`std::formatter`と同様に`std::scanner`クラステンプレートを特殊化することで、ユーザー定義型をスキャン可能な型として登録することができます。

```cpp
// tmのスキャンを有効化する際の宣言の例

template <>
struct std::scanner<tm, char> {
  constexpr auto parse(scan_parse_context& ctx)
    -> expected<scan_parse_context::iterator, scan_error>;

  template <class ScanContext>
  auto scan(tm& t, ScanContext& ctx) const
    -> expected<typename ScanContext::iterator, scan_error>;
};
```

ロケールはデフォルトでは考慮せず、`L`オプションとともに`std::locale`オブジェクトを渡すことでロケール依存の読み取りを行うことができます。その際、ロケールオブジェクトは引数の先頭で渡します。

この提案の内容は、[scnlib](https://github.com/eliaskosunen/scnlib)（特にdevブランチ）および`{fmt}`ライブラリにおいて試験実装されているようです。

- [`std::expected` - cpprefjp](https://cpprefjp.github.io/reference/expected/expected.html)
- [eliaskosunen/scnlib - Github](https://github.com/eliaskosunen/scnlib)
- [P1729 進行状況](https://github.com/cplusplus/papers/issues/493)

### [P1928R5 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r5.pdf)
### [P1928R6 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r6.pdf)
### [P2169R4 A Nice Placeholder With No Name](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf)
### [P2407R4 Freestanding Library: Partial Classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2407r4.html)
### [P2487R1 Is attribute-like syntax adequate for contract annotations?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2487r1.html)
### [P2521R4 Contract support -- Record of SG21 consensus](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2521r4.html)
### [P2542R3 views::concat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2542r3.html)
### [P2546R5 Debugging Support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2546r5.html)
### [P2548R6 copyable_function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2548r6.pdf)
### [P2552R3 On the ignorability of standard attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2552r3.pdf)
### [P2591R4 Concatenation of strings and string views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2591r4.html)
### [P2630R4 Submdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
### [P2637R3 Member visit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2637r3.html)
### [P2641R4 Checking if a union alternative is active](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2641r4.html)
### [P2642R3 Padded mdspan layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2642r3.html)
### [P2662R2 Pack Indexing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2662r2.pdf)
### [P2689R2 atomic_accessor](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2689r2.html)
### [P2697R1 Interfacing bitset with string_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2697r1.pdf)
### [P2714R1 Bind front and back to NTTP callables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2714r1.html)
### [P2717R2 Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2717r2.html)
### [P2727R3 std::iterator_interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2727r3.html)
### [P2728R4 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2728r4.html)
### [P2728R5 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2728r5.html)
### [P2741R3 user-generated static_assert messages](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2741r3.pdf)
### [P2752R3 Static storage for braced initializers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2752r3.html)
### [P2757R3 Type checking format args](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2757r3.html)
### [P2767R1 flat_map/flat_set omnibus](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2767r1.html)
### [P2776R0 2023-05 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2776r0.html)

2023年5月に行われたLEWGの全体投票の結果を報告する文書。

次の13本の提案が投票にかけられ、否決されたものはありませんでした。

- [P1673R12 BLAS Linear Algebra](https://wg21.link/P1673R12)
- [P2630R3 submdspan](https://wg21.link/P2630R3)
- [P1383R1 More constexpr For <cmath> And <complex>](https://wg21.link/P1383R1)
- [P2546R3 Debugging Support](https://wg21.link/P2546R3)
- [P2548R5 copyable_function](https://wg21.link/P2548R5)
- [P2714R0 Bind Front And Back To NTTP Callables](https://wg21.link/P2714R0)
- [P2637R2 Member visi](https://wg21.link/P2637R2)
- [P2757R2 Type-Checking Format Args](https://wg21.link/P2757R2)
- [P2641R3 Checking If A Union Alternative Is Active](https://wg21.link/P2641R3)
- [P1759R6 Native Handles And File Streams](https://wg21.link/P1759R6)
- [P2697R0 Interfacing bitset With string_view](https://wg21.link/P2697R0)
- [P2248R7 Enabling List-Initialization For Algorithms](https://wg21.link/P2248R7)
- [P2734R0 Adding The New 2022 SI Prefixe](https://wg21.link/P2734R0)

全て、C++26に向けてLWGに転送するための投票です。これらのうちのいくつかは、2023年6月の全体会議でC++26 WDに導入されています。

### [P2779R1 Make basic_string_view's range construction conditionally explicit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2779r1.html)
### [P2781R3 std::constexpr_v](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2781r3.html)
### [P2785R0 Relocating prvalues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2785r0.html)

↓

### [P2785R1 Relocating prvalues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2785r1.html)

↓

### [P2785R2 Relocating prvalues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2785r2.html)

↓

### [P2785R3 Relocating prvalues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2785r3.html)

*prvalue*からのリロケーションを可能とするための機能を導入する提案。

リロケーションについてと提案のモチベーションは以前の同種提案と共通しているのでそちらを参照

- [P1144R6 Object relocation in terms of move plus destroy - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1144R6-Object-relocation-in-terms-of-move-plus-destroy)
- [P1144R8 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P1144R8-stdis_trivially_relocatable)
- [P2786R0 Trivial relocatability options - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2786R0-Trivial-relocatability-options)
- [P2839R0 Nontrivial relocation via a new "owning reference" type - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2839R0-Nontrivial-relocation-via-a-new-owning-reference-type)

この提案では特に、構築後に動かせなくなるオブジェクトの扱いを改善するためにもリロケーション操作が有効であると述べています。

例えば、`gsl::not_null`というクラスは`nullptr`状態を取り得るクラスのムーブコンストラクタ等を無効化することでそのクラスが`nullptr`ではないことを保証するクラスです。`gsl::not_null<std::unique_ptr<T>>`のように使用する場合、この型のオブジェクトはムーブもコピーもできなくなります。

このようなオブジェクトは`nullptr`ではないことが保証されていることからコードの正確性やパフォーマンスを向上させるために有効ですが、現在のC++コードでは扱うのが現実的ではありません。コピーもムーブもできないため構築後にメモリ上を移動できなくなり、関数に渡したりコンテナに保存したりすることやクラスのメンバとなることを妨げます。

しかし、リロケーション操作が可能になればそのようなオブジェクトは、そのクラスの不変条件を保ったままリロケーションによってメモリ上を移動することができるようになり、その取り扱いのしやすさが改善します。

同様の問題は定数（`const`）オブジェクトにもあります。定数オブジェクトはその生存期間を通じて変化しないため、人間にとっても機械（コンパイラ）にとってもプログラムの状態に関する推論がしやすくなります。そのため、自動変数はさまざまなガイドラインで可能なら`const`とすることが推奨されています。

しかし、`const`オブジェクトはムーブすることができず、そのため後でムーブすることを意図するオブジェクトは`const`にすることができません。生存期間中は`const`でありながらも、その終わりに所有するリソースを手放すことができれば、より安全で読みやすいコードが可能になります。

この提案のリロケーション操作はこれらの2点を改善することを主目的としており、その点が以前の提案と大きく異なる部分です。

この提案が導入しようとしているのは次のものです

- 2つの特殊メンバ関数
    - リロケーションコンストラクタ : `T(T)`
    - リロケーション代入演算子 : `T& operator=(T)`
- 新しいキーワード`reloc`
- オーバーロード解決ルールの若干の変更
- 一部の関数にABI破壊が生じる可能性がある
- リロケーション操作のサポートのためのライブラリ関数

この提案では、リロケーションのために新しい型を導入することを避け、代わりに*prvalue*（修飾なしの素の型）をそのために利用しようとしています。

提案より、サンプルコード

```cpp
void foo(std::string str);
auto get_string() -> std::string;
auto get_strings() -> std::pair<std::string, std::string>;

std::string gStr = "static string";

void bar(void) {
	std::string str = "test string";
	foo(reloc str);   // OK: std::stringにリロケーションコンストラクタがあればリロケーションされる
	foo(reloc gStr);  // ill-formed: gStrはローカル変数ではない

	std::pair p{std::string{}, std::string{}};
	foo(reloc p.first); // ill-formed: p.firstは完全なオブジェクトではなく、変数名でもない

	foo(reloc get_string());        // ill-formed: 変数名ではない
	foo(reloc get_strings().first); // ill-formed: 完全なオブジェクトではなく、変数名でもない

  foo(auto(str));   // ill-formed: リロケーション後の変数名は使用できない
}

void foobar(const std::string& str) {
	foo(reloc str); // OK: 参照をリロケーションする
                  // strの参照先オブジェクトの生存期間は影響を受けない
}

void foobar(std::string* str) {
	foo(reloc *str); // ill-formed: *strは変数名ではない
}

void foobar2(std::string* str) {
	foobar(reloc str); // OK, ポインタをリロケーションする
                     // strの参照先オブジェクトの生存期間は影響を受けない
} 

class A {
	std::string _str;
public:
	void bar() {
		foo(reloc _str); // ill-formed: _strは完全なオブジェクトではなく、ローカル変数でもない
	}
};
```

- [P2785 進行状況](https://github.com/cplusplus/papers/issues/1579)

### [P2786R2 Trivial relocatability options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2786r2.pdf)
### [P2795R0 Correct and incorrect code, and &quot;erroneous behaviour&quot;](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2795r0.html)

↓

### [P2795R1 Erroneous behaviour for uninitialized reads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2795r1.html)

↓

### [P2795R2 Erroneous behaviour for uninitialized reads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2795r2.html)

未初期化変数の読み取りに関して、Erroneous Behaviourという振る舞いの規定を追加する提案。

未初期化変数の読み取りに関するErroneous BehaviourとはP2754R0で導入された概念で、未初期化変数を実装定義の値に初期化した上でその値の（ユーザーが書き込む前の）読み取りに対して指定される標準で定義された動作の1つです。

P2754R0については以前の記事を参照

- [P2754R0 Deconstructing Avoiding Uninitialized Reads of Auto Variables  - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2754R0-Deconstructing-Avoiding-Uninitialized-Reads-of-Auto-Variables)

Erroneous Behaviour（誤った動作、EB）は未定義動作ではなく、実装はユーザーによって初期化されていない変数を特定の値で変数を初期化しているためそれが起きたとしても安全であり、初期化する値を調整することでテストやデバッグに役立てることができます。また、EBを未定義動作として扱えば現状維持になり、EB/UBのまま維持しておくことで将来のさらなる大胆な改善（デフォルト初期化仕様の値初期化への完全な置き換えなど）のための門戸を開いておくこともできます。

未初期化変数の読み取りという問題の解決策としてEBの導入は最善（実現可能性、後方互換性、表現力の保護の観点で最善）であると認識されていますが、現在のC++標準ではEBという概念は定義されておらず、その導入そのものがハードルだとされていました。

この提案は、そのErroneous Behaviourという概念を標準に導入し、未初期化変数読み取り問題の解決を図るものです。

この提案では、自動変数のデフォルト初期化を次のように変更することを提案しています

> 自動変数のデフォルト初期化は、実装によって定義された固定値で変数を初期化する。  
> 実装はこのエラーを診断することが許可されており、また推奨されているが、エラーを無視して読み取りを有効なものとして扱うことも許可されている。

Erroneous Behaviourというワードが直接出現するわけではありませんが、この文章の後半部分（2行目）がそれを意図しています。すなわち、初期化されていない値を読むことは意図したものではなく間違いなくバグではあり修正する必要があるものの、それを含むコードはwell-definedでありその点について診断されないとしてもプログラムは予測可能である（未定義動作ではない）、とするものです。

言い換えると、未初期化の値を読み取ることは誤りではあるものの、実装がそれを止めなければプログラムはその読み取りの結果として（未定義ではない）何らかの特定の値を得ることになります。実装は診断をしてもいいが、してもしなくてもそれについてwell-definedであることを保証する必要があり、誤った振る舞いが実行された場合に未定義動作及びそれに起因する結果（ソースコードからは予測できない命令の実行、タイムトラベルなど）をもたらすことはありません。

```cpp
extern void f(int);

int main() {
  int x;     // default-initialized, value of x is indeterminate
  f(x);      // glvalue-to-prvalue conversion has undefined behaviour
}
```

この現在UBとなるコードについて、現在及びP2723R1（強制ゼロ初期化）とこの提案によるコンパイル結果の違いは次のようになります

|動作について|C++23|P2723R1|この提案|
|---|---|---|---|
|未定義動作？|UB|well-defined|EB|
|それはバグ？|確実にバグ|意図的に0初期化しているのか忘れているのかわからない|確実にバグ|
|コンパイラの診断は可能か？|コンパイラはこれを拒否することが許可されている|適合するコンパイラは診断できない|適合するコンパイラは受け入れなければならないが、QoIによって拒否することが許可されている|

この提案の下での動作においては、`x`の値は何か特定の値に初期化されていますがその値は必ずしも0ではありません。デバッグやテストに役立てるために特定の値を設定することを許可することと、特定の固定値にプログラマが依存してしまうことを回避することを意図しています。

この提案による標準の他の部分への影響は次のようなものが想定されます

- 自動変数は全て何かしら初期化されるため、パフォーマンスに影響を与える可能性がある
    - このコストに関する分析はP2723R1でなされている
    - また、このコストは非クラス型だけではなく、パディングを持たずデフォルトコンストラクタが全てのメンバを初期化するようなクラス型にもかかってくる
- 特に、共用体は完全に初期化される
    - 一般に、共用体をコピーしても誤りではなくパディングビットをコピーしても誤りではない
    - これは、誤りのある値の*glvalue*から*prvalue*への変換自体は誤りではないものの、その値をコピー以外のことに使用するのは誤りであることを意味する
- この提案は初期化のセマンティクスのみに影響し、不定値の使用の全般に影響するわけではない
    - 例えば、初期化された変数に不定値をコピーすることができ、その値を読み取ると未定義動作となる可能性がある
- この提案は単一操作としての自動変数のデフォルト初期化にのみ影響する
    - 自動変数をplacement newでデフォルト初期化するような場合はこの提案の保証はない

この提案の実装に関しては、ほぼ同様のことを行うことがgcc/clangにおいて`ftrivial-auto-var-init=zero`というオプションによって利用可能となっています（ただしこれは診断を意図したものではないようです）。この提案の変更は主に標準内の動作仕様に関する変更であり、実装の負担は軽微だと思われます。

この提案の採択によって未初期化変数読み取りに関する未定義動作が誤った動作に変更される場合、コードベースに対する影響は次のようになるでしょう

- 今日の正しいコード : パフォーマンスが低下する可能性がある他は観測可能な変化はない
- 今日の正しくないコード : UBをEBに変更した場合（診断しない場合）、そのコードは依然として正しくはないもののその振る舞いは未定義動作ではなくなり、特定の振る舞いするようになる

また、EBはこの提案では未初期化変数の読み取りのために導入しようとしていますが、同様に現在未定義動作となっているもののバグと意図的なものを弁別でき、バグについてのみ診断が可能な未定義動作についてもこれと同様にEBとして指定することで未定義動作やそれに伴う意図しない動作を回避しながら安全な動作をさせるようにすることができる可能性があり、その候補リストも示されています。

- [P2723R1 Zero-initialize objects of automatic storage duration - WG21月次提案文書を眺める（202年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2723R1-Zero-initialize-objects-of-automatic-storage-duration)
- [P2795 進行状況](https://github.com/cplusplus/papers/issues/1460)

### [P2809R1 Trivial infinite loops are not Undefined Behavior](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2809r1.html)
### [P2810R1 is_debugger_present is_replaceable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2810r1.html)
### [P2811R5 Contract-Violation Handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r5.pdf)
### [P2811R6 Contract-Violation Handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r6.pdf)
### [P2811R7 Contract-Violation Handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r7.pdf)
### [P2814R1 Trivial Relocatability --- Comparing P1144 with P2786](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2814r1.pdf)
### [P2819R1 Add tuple protocol to complex](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2819r1.pdf)
### [P2821R2 span.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2821r2.html)
### [P2821R3 span.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2821r3.html)
### [P2828R2 Copy elision for direct-initialization with a conversion function (Core issue 2327)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2828r2.html)
### [P2834R1 Semantic Stability Across Contract-Checking Build Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2834r1.pdf)
### [P2835R1 Expose std::atomic_ref's object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2835r1.html)
### [P2836R1 std::basic_const_iterator should follow its underlying type's convertibility](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2836r1.html)
### [P2845R1 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2845r1.html)
### [P2865R1 Remove Deprecated Array Comparisons from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2865r1.pdf)
### [P2872R1 Remove `wstring_convert` From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2872r1.pdf)
### [P2874R1 Mandating Annex D](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2874r1.pdf)
### [P2874R2 Mandating Annex D](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2874r2.pdf)
### [P2877R0 Contract Build Modes and Semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2877r0.pdf)

現在の契約プログラミングの仕様を、現在明らかなユースケースをサポートし将来の拡張に対して開いているようにする提案。

現在SG21で議論されている契約プログラミング仕様では、No_evalとEval_and_abortの2つのビルドモードのみが提供されており、翻訳単位間でのビルドモードの混合は実装定義のセマンティクスによって条件付きでサポートされています。

No_evalビルドモードでは全ての契約アノテーション（1つの関数に指定されている契約条件の全体）は*ignore*セマンティクスを持ち、契約アノテーションに含まれる各条件式は評価されず契約違反が起こることはありません。そのため、このビルドモードでは他のセマンティクスに影響を与えません。

Eval_and_abortビルドモードでは全ての契約アノテーションは*enforce*セマンティクスを持ち、契約アノテーションに含まれる各条件式が評価されそれが`true`を返さない場合は契約違反処理プロセスが発生し、その終了後にプログラムは終了されます。

これによってC++の実装には制限が課されており、2つのビルドモードのプロパティはすなわちC++コントラクト機能のプロパティであるとみなされ、プラットフォーム固有のビルドモードまたは将来のビルドモードの追加によってこの2つのビルドモードのプロパティや前提に反するようなセマンティクスを持つビルドモードを追加することが妨げられます。これらのプロパティの重要な特徴は、翻訳単位内の全ての契約アノテーションが同じセマンティクスを持つことです。

この提案は、契約アノテーションのセマンティクスとビルドモードの制限を取り払い実装の自由度を最大化することを目指し、それによってC++契約プログラミング機能が満たすべき現在明らかなニーズを満足しつつ、将来のニーズに適応するための拡張の余地を残しておくようにしようとするものです。

提案で挙げられている現在明らかなニーズとは次のようなものです

- パッケージマネージャ
    - 現在利用可能なパッケージマネージャの多くは、各パッケージについて単一のビルドのみを提供する。つまり、デバッグとリリースの両方を提供したりしない
    - 契約アノテーションのセマンティクスがビルド時に決定しなければならない設計は、パッケージマネージャにとって大きな負担となる
    - パッケージマネージャの管理者が契約機能のビルドモードのどちらを選択するにせよ、その決定はパッケージの作成者の契約機能の使用意欲にネガティブな影響を与える可能性がある
    - パッケージマネージャの管理者がビルドモードの決定を各プロジェクトのビルドモードまで遅延する場合、エコシステム内での契約機能の使用は一貫性がなくなる可能性がある
      - ことなるオブジェクトファイルが異なるビルドモードでビルドされている場合、条件付きサポートとなる
- パッケージとして配布されるソフトウェア
    - 歴史的に、一部のパッケージ提供者はアサーションを有効にしたパッケージを配布することを選択し、そうではない提供者はアサーションを含むテストをパスしていることを根拠として品質とサポートの目標を達成しているとみなしてアサーションを無効化したパッケージを配布することを選択している
    - C++契約機能はこのような選択肢をサポートし続ける必要がある。すなわち、契約アノテーションが評価されないことを許可しない設計は実行可能ではない
- 契約の解除
    - 運用環境で契約チェックを利用する際の最も難しい問題の1つは、既存のコードに契約チェックを導入すること。
    - 契約違反によるプログラムの終了のコストが高くつくため、契約違反によってプログラムが終了する場合、現在動作しているプログラムに契約チェックを導入する意欲が失われる
    - 現在の2つのセマンティクス（ビルドモード）だけではこの問題を解消できない
- [REPL](https://ja.wikipedia.org/wiki/REPL)
    - REPL環境ではプログラムはコンパイルされないため、ビルドモードが存在しない
    - 契約の評価が有効かどうか、及び違反時の振る舞いについては、ユーザーがいつでも変更できる動的なプロパティとなる
- デバッグ
    - 契約条件式はプログラムの本質的な動作に影響を与える副作用を持つべきではないが、それを検出するメカニズムが存在しないため、副作用が混入する可能性を受け入れなければならない
    - 副作用が発生しているかを判断するテクニックの一つは、契約アノテーションの評価を無効化した時と有効化した時の間で同じプログラムの動作を比較すること
    - 現在の2つのビルドモードではこれをサポートできない（この場合、契約違反を検出したいわけではないため）

これらのニーズは全て、現在のC++契約プログラミング仕様ではサポートできていません。これらのニーズを満たすには少なくとも次の要件を満たしている必要があります

- 標準に準拠した契約実装では、リビルドを必要とせずにを必要とせずに契約アノテーションの評価の有効/無効を切り替えられなければラナイ
- 標準に準拠した契約実装では、ユーザーが契約アノテーションごとに、もしくは違反ハンドラの動作を通して、契約違反後に実行を継続するかを選択可能である必要がある

また、これらの要件がユーザーベースに適さない場合、実装はこれらの要件をサポートしないことも選択できるべきです。この提案の意図は、全てのC++実装や実行環境が全て同じ機能セットをサポートする必要があることではなく、それらの実装が全て標準に実装しwell-definedであり、他のC++プログラムに適用可能な動作に関するトレーニングと推論の対象になり続けるように維持することにあります。

その上でこの提案の変更は、大きく分けて次の2つです

1. 契約アノテーションが評価される場合、その評価は*ignore*、*observe*、*enforce*のいずれかのセマンティクスを持つ
    - *ignore* : 契約アノテーションは各契約条件を評価しないため、契約違反を起こさない
    - *observe* : 契約アノテーションは各契約条件を評価し、そのいずれかが`true`を返さない場合は契約違反処理プロセスが発生する
    - *enforce* : 契約アノテーションは各契約条件を評価し、そのいずれかが`true`を返さない場合は契約違反処理プロセスが発生する。契約違反処理プロセスの終了後、プログラムは実装定義の方法で終了する
2. 契約アノテーションの個々の評価において、それがどのようなセマンティクスを持つかは実装定義とする
    - プログラム内の全てのアノテーションが同じセマンティクスを持つように強制される場合がある
    - 異なる評価で異なるセマンティクスを持つことにより、同じ関数の異なるインライン版で異なるセマンティクスをコンパイル時に選択することができ、それはODR違反ではなくなる
    - 実装は、その選択をどのように行うかを指定する仕組みがユーザーに公開されていれば、契約アノテーションのセマンティクスをコンパイル時・リンク時・実行時のいずれかのタイミングで選択できる

この提案は、（ビルドモードの）セマンティクスとして*observe*を1つ追加するとともに、契約アノテーションの評価のセマンティクスを契約アノテーション全体からその個々のプロパティとすることで、契約アノテーションを持つもののコンパイル時プロパティが契約アノテーションのセマンティクスに依存しない（できない）ようにするものです。

これによって、P2834R0で提案されている契約アノテーションに関する三原則の1つ目（契約アノテーションがビルドモードによって他の言語機能に影響を与えないこと）が満たされ、翻訳単位間で契約アノテーションのセマンティクスが混合していることも許可されます。

この提案の後でも、実装は現在の2つのビルドモードだけをサポートすることを選択することができ、また、コンパイラはリンク時やコンパイル時、実行時で契約アノテーションのセマンティクスを選択できるようなビルドオプションを提供することもできます。

この提案の内容はどうやらSG21の合意のもとで契約仕様に導入（Contratcts MVPにマージ）されたようで、P2811R6の採用と相まって、C++契約プログラミング仕様はビルドモードの概念から解き放たれることになります。そこでは、この提案で解説されているように、契約条件のセマンティクス（評価されるかどうか、評価された時にどうなるかなど）は*ignore*・*observe*・*enforce*のいずれかが契約アノテーションごとに決定され、その決定は実装定義となります。さらに、*observe*の場合に契約違反を起こした場合の振る舞い（即終了するのか、例外を投げるのか、継続するのか）は違反ハンドラの差し替えによってユーザーがカスタマイズすることができます。

- [P2834R0 Semantic Stability Across Contract-Checking Build Modes - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2834R0-Semantic-Stability-Across-Contract-Checking-Build-Modes)
- [P2811R4 Contract Violation Handlers - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2811R4-Contract-Violation-Handlers)
- [2023-06 Varna ISO C++ Committee Trip Report — First Official C++26 meeting! : r/cpp - reddit](https://www.reddit.com/r/cpp/comments/14h4ono/202306_varna_iso_c_committee_trip_report_first/)
- [P2877 進行状況](https://github.com/cplusplus/papers/issues/1586)

### [P2878R2 Reference checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2878r2.html)
### [P2878R3 Reference checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2878r3.html)
### [P2878R4 Reference checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2878r4.html)
### [P2885R0 Requirements for a Contracts syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2885r0.pdf)

C++契約プログラミング機能の構文の選択のための評価基準や要件をまとめる文書。

少し上のP2877R0などの採択によって、契約プログラミング機能の意味論の部分はほぼ固まりつつあります。残っている大きな問題は構文の選択に関するものです。

現在のContratcts MVPでは属性likeな構文を採用しており、これはC++20の契約プログラミング機能から受け継いでいるものです。それに対して、クロージャベースの構文（P2461R1）や条件中心構文（P2737R0）が提案され、また他の構文を考えることもできます。しかし、現在のところこれらの構文提案を統一的に比較し評価するためのフレームワークが存在しません。

この提案は、契約構文の選択のために、契約構文に求められる要件をまとめその比較基準を提供しようとするものです。ただし、この提案は構文を選択することを意図しておらず、既存提案の詳細な分析を行おうとするものではなく、あくまで契約機能の構文に求められる要件やその比較基準を確立することを目的としたものです。

提案されている要件の概要は次のようなものです

- 基本要件
    - 美学
      - 読みやすく、目立ちすぎない
    - 簡潔さ
      - なるべく短いトークンで記述できる
    - アクセシビリティ
      - 学びやすく、教えやすい
    - 既存プラクティスとの一貫性
      - 契約プログラミングに関する既存の文献やコミュニティの知識との相関がある
    - 残りのC++の部分との一貫性
      - 既存のC++言語の構文に自然に適合する
- 互換性の要件
    - C++言語の一部としての有効性
      - 既存の言語機能に対して、曖昧さ、混乱、非一貫性、意図しない相互作用を起こさない
    - 破壊的変更がない
      - 既存のC++コードを壊さない
    - マクロなし
      - マクロないしプリプロセッサの使用は最小限
    - パースしやすさ
      - C++コードをパースするために新たなハードルを生み出してはならず、既存文法を不必要に複雑化させない
    - 実装経験
      - 構文をC++コンパイラで実装した経験が必要
    - 後方互換生
      - 後方互換性があれば、既存のコードにアノテーションを追加しても従来のコンパイラはエラーではなく無視するだけで済むのではないかという提案がある
    - ツールによる利用が可能であること
      - 契約アノテーションはコンパイラと人間だけではなく、静的アナライザやリンター、IDEなど他のツールの入力として有用である可能性がある
    - C互換性
      - Cで別の意味を持つ既存構文と同じものを追加すべきではない
- 機能性の要件
    - 述語を受けられる
      - 文脈的に`bool`変換可能な任意のC++における式を受けられる必要がある
    - 契約種別
      - 事前条件・事後条件・アサーションという3種類のアノテーションを明確に区別できること
    - 位置と名前探索
      - 事前/事後条件は関数宣言の一部である必要がある
      - アサーションは関数定義内部でのみ現れる
    - 複数の事前/事後条件
      - 同じ関数に対して複数の事前/事後条件を追加できる
    - 戻り値
      - 事後条件においては、戻り値を参照する方法を提供しなければならない
- 将来の進化に備えた要件
    - 非参照非`const`引数の参照
      - 事後条件において、非参照非`const`引数を参照する拡張が可能である
    - 明示的なキャプチャ
      - 契約アノテーションで使用する変数を明示的にキャプチャする拡張が可能である
    - 戻り値の構造化束縛
      - 事後条件において、戻り値を構造化束縛して参照する拡張が可能である
    - 契約アノテーションの再利用
      - 同じ事前/事後条件の集合を共有する関数の間で、それを抽出してまとめて再利用できるようにする拡張が可能である
    - メタアノテーション
      - 契約アノテーションにさらにアノテーションを付加することで、コンパイラに対して判断が難しい契約アノテーションに関するプロパティを伝達することを可能にする拡張が可能である
    - 引数をとるメタアノテーション
      - メタアノテーション構文はさらに、引数をとることができるように拡張可能である
    - ユーザー定義メタアノテーション
      - 標準で定義されるものと競合しない、ユーザー定義のメタアノテーションを可能にする拡張が可能である
    - 無視できないメタアノテーション
      - 標準属性の無視可能性ルールに適合しないようなメタアノテーションを可能にする拡張が可能である
    - 一次情報と二次情報の識別
      - メタアノテーションのような契約アノテーションに対する二次情報と、契約種別や契約条件式などの一次情報を識別可能であること
    - クラス不変条件
      - クラス不変条件を表現するための新しい構文を導入可能であること
    - 手続き型インターフェース
      - P0465R0で提案されている手続き型インターフェースに対応可能であること
    - `requires`節
      - 契約アノテーションを`requires`節で制約できるようにする拡張が可能であること
    - より一般的な拡張性
      - ここの要件のリストは大量だが、これでも将来的に契約機能に必要になる可能性のある拡張を網羅していない

これらの要件は排他的なものもあるため必ずしも全てを満たす必要はなく、それはトレードオフとして比較することを意図しています。

- [P2461R0 Closure-based Syntax for Contracts - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2461R0-Closure-based-Syntax-for-Contracts)
- [P2737R0 Proposal of Condition-centric Contracts Syntax - WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2737R0-Proposal-of-Condition-centric-Contracts-Syntax)
- [P2487R0 Attribute-like syntax for contract annotations - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P2487R0-Attribute-like-syntax-for-contract-annotations)
- [P2885 進行状況](https://github.com/cplusplus/papers/issues/1587)

### [P2898R1 Build System Requirements for Importable Headers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2898r1.pdf)
### [P2902R0 constexpr 'Parallel' Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2902r0.pdf)

並列アルゴリズムを定数式で使用できるようにする提案。

並列アルゴリズムとはC++17で追加された実行ポリシーを受け取るオーバーロードの事で、これれらのものは並列化やベクトル化によってアルゴリズムの実行時パフォーマンスを向上させることが目的であるため、`cosntexpr`指定はされておらず定数式では使用できません。

並列アルゴリズムも含めたアルゴリズムは他の処理や他のアルゴリズムと組み合わせて使用するものであり、他のアルゴリズムや標準ライブラリの多くのものが`constexpr`対応を果たしている中で並列アルゴリズムが`constexpr`対応しない場合、そのような並列アルゴリズムと組み合わされた一連の処理を定数式で実行することができなくなります。

その場合でも、`std::is_constant_evaluated()`や`if consteval`を使用して分岐をすればとりあえず対応はさせられますが、そもそも並列アルゴリズムが`constexp`であればより単純に目的を達成できます。

この提案はそのような目的のために並列アルゴリズムを`constexpr`対応させることを目指すものです。ただし、コンパイル時にも並列化を要求するものではありません。

この提案では、全ての実行ポリシーを定数式で指定可能とすることを提案しており、その実装はコンパイル時に対応する通常のアルゴリズム関数に処理を委譲することでコンパイル時実行することを意図しています。

- [P2902 進行状況](https://github.com/cplusplus/papers/issues/1593)

### [P2904R0 Removing exception in precedence rule(s) when using member pointer syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2904r0.pdf)

メンバポインタ構文で`()`の使用を許可する提案。

クラス`C`のメンバ`Bar`のメンバポインタを取得する構文は`&C::bar`のように書きますが、この時`&(C::bar)`のように括弧で括る形式は明確に禁止されており、コンパイルエラーとなります。

なぜこのような制限があるのかは不明ですが、この制限は不要のものと思われ他の場合と一貫していないため、この提案はこの制限を取り払うことを提案するものです。

```cpp
struct C {
  void Bar(int);
};

int main() {
  void (C::*ptr)(int) = &(C::Bar); // MSVCはok、clang/gccはng
}
```

また、これは実装間で挙動の相違を生み出してしまっているようで、MSVCでは意図通り（この提案の提案通りに）になるようです。

- [P2904 進行状況](https://github.com/cplusplus/papers/issues/1594)

### [P2905R0 Runtime format strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2905r0.html)

↓

### [P2905R1 Runtime format strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2905r1.html)

[`std::make_format_args()`](https://cpprefjp.github.io/reference/format/make_format_args.html)が左辺値でフォーマット対象の値を受け取るようにする提案。

`std::format`はフォーマット文字列のコンパイル時チェックを行うため、フォーマット文字列はコンパイル時に決定していなければなりません。そのため、フォーマット文字列を実行時に与えたい場合は`std::vformat()`を使用します。

```cpp
std::string str = translate("The answer is {}."); // gettextライブラリによる翻訳後文字列をフォーマット文字列として使う
std::string msg = std::vformat(str, std::make_format_args(42));
```

ただ、この`v`系の型消去APIはテンプレートの肥大化を回避するためのAPIであり、エンドユーザーではなくフォーマット内部実装や独自のフォーマット関数を作成する場合などに使用するものであるため、実行時のフォーマット文字列指定のために使用するのは本来の用途ではありません。

特に、`std::make_format_args()`は簡単に間違った使い方ができてしまいます。

```cpp
std::string str = "{}";
std::filesystem::path path = "path/etic/experience";
auto args = std::make_format_args(path.string()); // path::string()はprvalueを返す

std::string msg = std::vformat(str, args);  // UB、argsの参照するstd::stringオブジェクトは寿命が尽きている
```

`std::make_format_args()`はフォーマット対象の値を型消去して渡すためのものであり、内部でその値を保持するわけではなく、一時オブジェクトを渡してもその寿命は延長されません。このことは、関数のインターフェースや効果などから読み取ることは難しく、これはあくまで内部実装のための関数です。

この提案は`std::make_format_args()`のこの問題を改善するために、引数型を非`const`左辺値参照をとるように変更することで一時オブジェクトを渡すとコンパイルエラーになるようにしようとするものです。

```cpp
namespace std {

  // make_format_args()の現在の宣言例
  template<class Context = format_context, class... Args>
  format-arg-store<Context, Args...> make_format_args(Args&&... fmt_args);

  // この提案による変更
  template<class Context = format_context, class... Args>
  format-arg-store<Context, Args...> make_format_args(Args&... fmt_args);
}
```

これによって、先ほどのようなコードはコンパイルエラーとして弾かれるようになります。

これは破壊的変更となりますが、この提案はC++23へのDRとすることがLEWGによって承認されています。

`std::make_format_args()`の利用率は低いと思われ、コンパイルエラーとなるのは一時オブジェクトか右辺値を渡した場合なので、正しい使用法のほとんどはこの提案の後でも変更の必要はありません。エラーとなる場合は`std::forward()`してしまっているか、一時オブジェクトを直接渡しているかの場合のどちらかのはずで、前者は`std::forward()`を削除する修正が必要となり、後者は一時オブジェクトの寿命を延長する変更が必要となります。

この提案のR0では、実行時のフォーマット文字列指定のためのAPI（`std::runtime_format`）も同時に提案していましたが、それは別の提案に分離されました。

- [P2418R2 Add support for `std::generator`-like types to `std::format` - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2418R2-Add-support-for-stdgenerator-like-types-to-stdformat)
- [P2905 進行状況](https://github.com/cplusplus/papers/issues/1578)

### [P2906R0 Structured bindings for `std::extents`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2906r0.html)

`std::extents`に構造化束縛サポートを追加する提案。

`std::extents`は`std::mdspan`に対してその要素数を指定するためのクラステンプレートです。

```cpp
// double型の3x3行列を表すmdspan
using mat33d = std::mdspan<double, std::extents<std::size_t, 3, 3>>;

// double型の3xN行列を表すmdspan（Nは実行時に決定）
using mat3nd = std::mdspan<double, std::extents<std::size_t, 3, std::dynamic_extante>>;

// double型の2次元行列を表すmdspan（サイズは実行時に決定）
using matd = std::mdspan<double, std::dextents<std::size_t, 2>>;
```

`std::mdspan`のメンバ関数`.extents()`からこの`std::extents`オブジェクトは取得できて、`std::extents`の`.extent(n)`から`n + 1`次元の要素数を取得できます。特に実行時にその要素数が決まる場合はこれを用いてループを回す必要があります。

```cpp
// 3次元mdspanを出力する関数
template<typaname D, typename E, typename L, typename A>
void print_3d_mdspan(std::mdspan<D, E, L, A> mat) {
  using I = std::mdspan<D, E, L, A>::index_type;

  // 要素数情報の取得
  const auto e = mat.extents();

  // 全要素の走査
  for (I z = 0; z < e.extent(2); ++z) {
    for (I y = 0; y < e.extent(1); ++y) {
      for (I x = 0; x < e.extent(0); ++x) {
        // 要素取得
        const auto v = mat[z, y, x];

        // 出力
        std::print("[{}, {}, {}] = {}\n", z, y, x, v);
      }
    }
  }
}
```

現在の`std::extents`のAPIは限定されており、次元ごとの要素数の取得はこうするしかありません。

この提案は、`std::extents`を構造化束縛対応させることで、各次元の要素数取得をより簡易に行えるようにしようとするものです。

先ほどの例は例えば次のように書き直せます

```cpp
// 3次元mdspanを出力する関数
template<typaname D, typename E, typename L, typename A>
void print_3d_mdspan(std::mdspan<D, E, L, A> mat) {
  using I = std::mdspan<D, E, L, A>::index_type;

  // 要素数情報の取得
  const auto [depth, height, width] = mat.extents();  // 👈 構造化束縛によって直接要素数を取得する

  // 全要素の走査
  for (I z = 0; z < depth; ++z) {
    for (I y = 0; y < height; ++y) {
      for (I x = 0; x < width; ++x) {
        // 要素取得
        const auto v = mat[z, y, x];

        // 出力
        std::print("[{}, {}, {}] = {}\n", z, y, x, v);
      }
    }
  }
}
```

さらに、P1061にて提案されている構造化束縛でパラメータパックを導入する機能を加味すると、このコードはさらに簡易に書くことができます

```cpp
// 3次元mdspanを出力する関数
template<typaname D, typename E, typename L, typename A>
void print_3d_mdspan(std::mdspan<D, E, L, A> mat) {
  using I = std::mdspan<D, E, L, A>::index_type;

  // 要素数情報の取得
  const auto [...es] = mat.extents();

  // 全要素の走査
  for (const auto [...is] : std::cartesian_product(std::views::iota(0, es)...)) {
    // 要素取得
    const auto v = mat[is...];

    // 出力
    std::print("[{}, {}, {}] = {}\n", is..., v);
  }
}
```

このことを実装するにあたって、静的エクステントをどう扱うかについて選択肢があります。静的エクステントはコンパイル時に定まっている定数値であるため、構造化束縛でそのことを維持するかどうかで少し実装が異なります（構造化束縛は`constexpr`指定できない）。

1. 静的エクステントを実行時の値に降格する
2. `std::integral_constant`などを利用して、コンパイル時定数であることを維持する

オプション1に比べてオプション2では実装の複雑さが増大し、定数値の扱いが難しくなります（`std::integral_constant`の暗黙変換によって容易に定数性が失われるため）。

この選択に関してはLEWGの投票において決定される予定で、（この記事を書いてる時点では）まだその投票は行われていません。

- [std::mdspan - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20230303/p1)
- [P1061R2 Structured Bindings can introduce a Pack - WG21月次提案文書を眺める（2022年04月）](https://onihusube.hatenablog.com/entry/2022/05/08/195618#P1061R2-Structured-Bindings-can-introduce-a-Pack)
- [P2906 進行状況](https://github.com/cplusplus/papers/issues/1595)

### [P2910R0 C++ Standard Library Ready Issues to be moved in Varna, Jun. 2023](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2910r0.html)
### [P2911R0 Python Bindings with Value-Based Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2911r0.pdf)

提案中の値ベースリフレクションによってPythonバインディングの作成を簡素化できることを示す文書。

この文書は、pybind11によるPythonバインディングの作成に値ベースリフレクション（P1240R2）を活用することでその作業を簡素化できることを示し、その利点と課題についての議論を行おうとするものです。

例えば次のような列挙型があるとき

```cpp
struct Execution {
  enum class Type {
    new_,
    fill,
    partial,
    cancelled,
    rejected
  };
};
```

これのPythonバインディングを作成するコードは次のようになります

```cpp
py::enum_<Execution::Type>(/*binding scope*/, "Type")
  .value("new_" , Execution::Type::new_)
  .value("fill" , Execution::Type::fill)
  .value("partial" , Execution::Type::partial)
  .value("cancelled", Execution::Type::cancelled)
  .value("rejected" , Execution::Type::rejected);
```

これは列挙型のメンバを手動で展開しているため、繰り返し同じようなコードを書かなければならず、`Execution::Type`が更新されるとこちらも手動で更新しなければならないなど、不便な面があります。

対して、値ベースリフレクションを利用すると同等のバインディングは次のようなコードで完結させられます。

```cpp
bind_enum<Execution::Type>(/*binding scope*/);
```

`bind_enum()`はこの目的に書かれた汎用的なコードであり、ライブラリなどとして提供されることを意図しています。そして、この`bind_enum()`は次のように実装できます

```cpp
// 型名だけを取り出す関数
template<typename T>
std::string basename() {
  auto name = std::string{name_of(^T)}; // ^T reflects type T

  if (size_t pos = name.rfind(':'); pos != std::string::npos) {
    return name.substr(pos + 1);
  }
  
  return name;
}

template<typename EnumT, typename Scope>
void bind_enum(Scope& s) {
  auto enum_ = py::enum_<EnumT>(s, basename<EnumT>().c_str());

  // 列挙型EnumTの全てのメンバに対してイテレートする
  template for (constexpr auto e : members_of(^EnumT)) {
    enum_.value(name_of(e), [:e:]); // [:e:] un-reflects e
  }
}
```

このように、値ベースリフレクションを用いると、型のメンバなどを列挙しその名前を取得してそれを特定の関数に投げることを繰り返すような処理をかなり自動化して書くことができ、現在手動で書かざるをえずに不便やバグの元となっている部分をより簡易かつ安全に記述することができます。

提案には、そのほかにもクラスメンバや継承、関数オーバーロードなどの同様の例が記載されています。

これらの試みによって得られた利点と課題は次のようなものです

- 利点
    - ボイラープレートの大幅（~95%）な削減
    - リフレクションを使用すると多くの場合にエラーの可能性を軽減しうる
        - 元のC++コード変更への追随忘れなどを回避できるなどによる
    - ほとんどのバインディングは慎重に選択されたデフォルトの動作を使用して合理的に自動化できる
        - この提案では、pybind11で指定されたデフォルトを活用している
- 課題
    - バインディングのカスタマイズ機能はPythonとC++の言語機能の違いをカバーする必要がある
        - そのサポートのために、ユーザー定義属性があると便利だと思われる
    - パラメータ名リフレクションなど、いくつかのリフレクション機能は危険
        - Pythonの名前付き引数をサポートさせるために、C++の関数引数名をリフレクトしイテレートする方法が考えられるが
        - C++においては関数引数名はそのシグネチャの一部ではなく、宣言/定義によって変わりうる
    - いくつかのコーナーケースでは、リフレクションに基づく自動化は問題を隠蔽し、誤った安心感を与える可能性がある
    - `range`のリフレクションをその要素名のリストに展開する機能があると便利な場合があった

この文書はこのようなことを行うライブラリを提案しているのではなく、値ベースリフレクションの利点を示すとともに足りないものやあった方がいい機能などを示し、その議論を前進させようとするものです。

- [P1240R2 Scalable Reflection - WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P1240R2-Scalable-Reflection)
- [P2320R0 The Syntax of Static Reflection - WG21月次提案文書を眺める（2021年02月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P2320R0-The-Syntax-of-Static-Reflection)

### [P2912R0 Concurrent queues and sender/receivers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2912r0.html)

P1958R0で提案されている`buffer_queue`にP2300の`sender/receiver`モデルをベースとしたAPIを拡張する提案。

P1958R0の`buffer_queue`は、内部の固定長バッファをリングバッファとして使用して同期/非同期の両方のAPIを提供することで並行プログラミングで使用可能な並行キューを提供しようとするものです。

この提案は、この`buffer_queue`をP2300の`sender/receiver`に適応可能なように拡張しようとするものです。また、それに伴ってAPIのスタイルも変更されています。

提案及び実装より、`buffer_queue`の概要

```cpp
template <typename T, typename Alloc = std::allocator<T>>
class buffer_queue {
public:
  using value_type = T;

  explicit buffer_queue(size_t max_elems, Alloc alloc = Alloc());
  ~buffer_queue() noexcept;

  // observers
  bool is_closed() noexcept;
  size_t capacity() const noexcept;

  // modifiers
  void close() noexcept;

  // 同期pop
  T pop();
  std::optional<T> pop(std::error_code& ec);
  std::optional<T> try_pop(std::error_code& ec);

  // 同期push（コピー）
  void push(const T& x);
  bool push(const T& x, error_code& ec); // used to be wait_push
  bool try_push(const T& x, error_code& ec);

  // 同期push（ムーブ）
  void push(T&& x);
  bool push(T&& x, error_code& ec); // used to be wait_push
  bool try_push(T&& x, error_code& ec);

  // 非同期push/pop
  sender auto async_push(const T& x) noexcept(is_nothrow_copy_constructible_v<T>);
  sender auto async_push(T&& x) noexcept(is_nothrow_move_constructible_v<T>);
  sender auto async_pop() noexcept;
};
```

この提案で追加されたのは、`async_~`という名前の3つの操作です。これらは非同期的に`push/pop`を行う関数で戻り値として`sender`を返します。これによって、非同期操作の待機や継続はP2300の`sender`アルゴリズムを利用して行うことができます。

また、同期操作のインターフェースも変更されており、操作の成否を判定できるインターフェースが`std::error_code`を受け取るようになり、`pop()`操作では戻り値が`std::optional`を返すようにされています。

- [P1958R0 C++ Concurrent Buffer Queue](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1958r0.html)
- [GorNishanov/conqueue - Github](https://github.com/GorNishanov/conqueue)
- [P2912 進行状況](https://github.com/cplusplus/papers/issues/1588)

### [P2915R0 Proposed resolution to CWG1223](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2915r0.pdf)

後置戻り値型関数宣言との曖昧さを解消するために、`auto`の存在を構文的に扱うようにする提案。

後置戻り値型関数宣言は`auto`を戻り値型に持つ関数宣言でのみ考慮されますが、この制限は意味的なものであり構文的なものではありませんでした。それによって、C++11以前は有効だった変数宣言や式が関数宣言として扱われてしまう場合がありました。

```cpp
struct A {
  A(int *);
  A *operator()(void);
  int B;
};

int *p;
typedef struct BB { int C[2]; } *B, C;

void foo() {
  A (p)()->B;  // ng、関数宣言として扱われる（C++11以降

  A a(B ()->C);       // ng、関数宣言 or 変数宣言
  sizeof(B ()->C[1]); // ng、関数宣言に対するsizeof or 式に対するsizeof
}
```

この提案は、この場合に`auto`の存在を構文的にもチェックし制限することでこの問題を解決しようとするものです。この提案後、上記コードは次のようにコンパイルされるようになります

```cpp
void foo() {
  A (p)()->B;  // ok、式（A::Bへのメンバアクセス）

  A a(B ()->C);       // ok、変数宣言
  sizeof(B ()->C[1]); // ok、式に対するsizeof
}

提案文書より、その他の例

```cpp
struct M;
struct S {
  S* operator()();
  int N;
  int M;

  void mem(S s) {
    auto(s)()->M; // S::Mは::Mを非表示にし、これは式とみなされる
  }
};

void f(S s) {
  {
    auto(s)()->N; // 式
    auto(s)()->M; // 関数宣言（::Mが見えているため）
  }
  {
    S(s)()->N; // 式（autoがないため関数宣言とはみなされない）
    S(s)()->M; // 式（autoがないため関数宣言とはみなされない）
  }
}
```

この問題はIssue1223としてC++11に対して2010年に提出されて以降放置されていましたが、C++23にて`auto(x)`のdecay-copy構文が導入されたことによって影響が大きくなることがわかったため、この提案で迅速に解決されました（既に2023年6月の会議で承認され、C++26WDに取り込まれています）。

- [CWG Issue 1223. Syntactic disambiguation and trailing-return-types](https://cplusplus.github.io/CWG/issues/1223.html)
- [P2915 進行状況](https://github.com/cplusplus/papers/issues/1596)

### [P2917R0 An in-line defaulted destructor should keep the copy- and move-operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2917r0.pdf)

↓

### [P2917R1 An in-line defaulted destructor should keep the copy- and move-operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2917r1.pdf)

クラス定義内で`default`宣言されたデストラクタがある場合に、コピー/ムーブコンストラクタ及び代入演算子を暗黙`default`宣言するようにする提案。

C++11以降、`default`含むユーザー宣言デストラクタが存在する場合、そのクラスのコピーコンストラクタは暗黙的に`default`定義されますがそれは非推奨とされます。また、そのようなクラス型のムーブコンストラクタ及び代入演算子は暗黙定義されません。

```cpp
class Apple {
public:
  ~Apple() = default;
  // コピーコンストラクタ及び代入演算子は暗黙default定義される（非推奨の振る舞い）
  // ムーブコンストラクタ及び代入演算子は暗黙定義されていない
};
```

この`Apple`のようなクラスをコピー/ムーブ可能にしたければ、全てのメンバ関数を明示的に宣言しなければなりません。

```cpp
class Apple {
public:
  ~Apple() = default;
  
  // コピーを有効化
  Apple(const Apple&) = default;
  Apple& operator=(const Apple&) = default;

  // ムーブを有効化
  Apple(Apple&&) = default;
  Apple& operator=(Apple&&) = default;
};
```

このことは、特殊メンバ関数のデフォルト宣言というボイラープレートコードを量産しており、また、デストラクタは他の特殊メンバ関数とは独立しているべきだとして、この提案はこの制限を解除しようとするものです。

この提案では、クラスの最初のデストラクタの宣言が`default`宣言である時、コピー/ムーブコンストラクタ及び代入演算子を暗黙`default`宣言するようにします。それによって、上記の`Apple`のようなクラスは追加の特殊メンバ関数の宣言なしでコピーとムーブが可能になります。

```cpp
class Apple {
public:
  ~Apple() = default;
  // コピーコンストラクタ及び代入演算子は暗黙default定義される（非推奨の振る舞い）
  // ムーブコンストラクタ及び代入演算子は暗黙定義されていない
};
```

ただし、最初のデストラクタの宣言が`default`ではない場合、すなわちクラス定義外で`default`宣言されている場合は現行通りにムーブコンストラクタ/代入演算子は定義されず、コピーコンストラクタ/代入演算子の暗黙`default`定義は非推奨です。

```cpp
class Apple {
public:
  ~Apple();
  // コピー/ムーブコンストラクタ及び代入演算子暗黙default定義される
};

Apple::~Apple() = default;
```

この提案の内容は、以前のコードには快適変更をもたらします。

```cpp
// 現在このクラスはムーブ可能ではないが、この提案の後ではムーブ可能となる
struct A {
  std::unique_ptr<int> pi;
  virtual ~A() = default;
};


// 現在このクラスはムーブ可能ではないが、この提案の後ではムーブ可能となる
struct B {
  std::string s;
  virtual ~B() = default;
};

void f() {
  B b1;
  B b2;

  b2 = std::move(b1); // 現在はコピーされているが、この提案の後ではムーブされる
}


// 現在このクラスはムーブ可能ではないが、この提案の後ではムーブ可能となる
struct C {
  // ムーブ操作を無効化することを意図するデストラクタ宣言
  ~C() = default;
};


struct Base {
  int x{};
  
  virtual ~Base() = default;

  // その他virtualメンバ関数
};

struct Derived : Base {
  int y{};
};

void g() {
  Base b{};
  Derived a = b;  // スライスが発生する、この提案後は気付きづらくなる可能性がある
}
```

- [C++0xにすごい変更が来た - 本の虫](https://cpplover.blogspot.com/2010/11/c0x.html)
- [特殊メンバ関数とコンパイラによる暗黙宣言 - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20140704/p1)
- [コンストラクタが暗黙に宣言されるとき、されないとき - Qiita](https://qiita.com/rinse_/items/1ac008fe3aea7c0887fc)
- [Tutorial: When to Write Which Special Member - foonathan::​blog()](https://www.foonathan.net/2019/02/special-member-functions/)
- [P2917 進行状況](https://github.com/cplusplus/papers/issues/1597)

### [P2918R0 Runtime format strings II](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2918r0.html)

↓

### [P2918R1 Runtime format strings II](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2918r1.html)

`std::format()`の実行時フォーマット文字列のためのAPIを追加する提案。

モチベーションの一部は少し上のP2905R1と共通しているのでそちらもご覧ください。

`std::format()`のフォーマット文字列はコンパイル時検査される関係上、コンパイル時に確定している文字列でなければなりません。実行時文字列によってフォーマット文字列を指定したい場合は`std::vformat`などを使用することになるのですが、これは内部実装用のもので利用しやすいAPIではありませんでした。

この提案は、実行時文字列による`std::format`のための専用のAPIを追加することで、実行時フォーマット文字列による`std::format`の利便性を改善しようとするものです。

提案では、`std::runtime_format()`という関数に実行時フォーマット文字列を渡し、この関数の戻り値を`std::format()`のフォーマット文字列（第一引数）として渡すことで実行時フォーマット文字列によるフォーマットを`std::format()`に組み込みます。

```cpp
void f(std::string_view str) {
  // 現在の実行時文字列によるフォーマット文字列指定
  auto rfmt1 = std::vformat(str, std::make_format_args(42));

  // この提案
  auto rfmt2 = std::format(std::runtime_format(str), 42);
}
```

`std::runtime_format()`は受け取った文字列をラップする専用の型を返し、`std::basic_format_string`がその型を受け取れるようにすることでこのサポートを行えるようにしており、フォーマット文字列の検証はコンパイル時と同様に`std::basic_format_string`のコンストラクタで（実行時に）行われます。

- [`std::basic_format_string` - cpprefjp](https://cpprefjp.github.io/reference/format/basic_format_string.html)
- [P2918 進行状況](https://github.com/cplusplus/papers/issues/1598)

### [P2920R0 Library Evolution Leadership's Understanding of the Noexcept Policy History](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2920r0.pdf)
### [P2921R0 Exploring std::expected based API alternatives for buffer_queue](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2921r0.html)
### [P2922R0 Core Language Working Group "ready" Issues for the June, 2023 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2922r0.html)
### [P2925R0 inplace_vector - D0843R7 LEWG presentation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2925r0.pdf)
### [P2926R0 std::simd types should be regular - P2892R0 LEWG presentation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2926r0.pdf)
### [P2929R0 simd_invoke](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2929r0.html)
### [P2930R0 Formatter specializations for the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2930r0.html)
### [P2931R0 WG21 February 2023 Meeting Record of Discussion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2931r0.pdf)
### [P2937R0 Freestanding: Remove strtok](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2937r0.html)
### [P2940R0 switch for Pattern Matching](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2940r0.html)
### [P2941R0 Identifiers for Pattern Matching](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2941r0.html)
### [P2944R0 Comparisons for reference_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2944r0.html)
### [P2945R0 Additional format specifiers for time_point](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2945r0.html)
### [P2946R0 A flexible solution to the problems of `noexcept`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2946r0.pdf)
### [P2947R0 Contracts must avoid disclosing sensitive information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2947r0.pdf)
### [P2949R0 Slides for P2861R0: Narrow Contracts and `noexcept` are Inherently Incompatable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2949r0.pdf)
### [P2950R0 Slides for P2836R1: std::basic_const_iterator should follow its underlying type's convertibility](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2950r0.pdf)
### [P2951R0 Shadowing is good for safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2951r0.html)
### [P2951R1 Shadowing is good for safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2951r1.html)
