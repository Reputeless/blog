# ［C++］ 呼び出される例外ハンドラの決定について

C++の`throw`式はどんな型のオブジェクトであっても投げることができます。この是非は置いておいて、ある`throw`式に対して適切に`catch`節（例外ハンドラ）が用意されている場合に、呼び出される例外ハンドラは厳密にどのように決まるのでしょうか？なんとなく`throw`式の引数と同じような型ならマッチする気はしますが、そのルールは関数のオーバーロード解決時のものとは異なる気がします。

[:contents]

### `catch`節での型マッチング

例外オブジェクトの型を`E`とすると、対応する例外ハンドラの決定はその`catch`節の宣言型（以下、ハンドラの型）と`E`をマッチングすることによって行われます。マッチングとはオーバーロード解決のような複雑な処理とは異なり、単純な型の比較によって行われます。

マッチングの前にまず、ハンドラの型が配列型（`T[]`）もしくは関数型（`R(Args...)`）である場合そのハンドラの型はdecayされ、`T`の配列型は`T`のポインタ型（`T[] -> T*`）、関数型は関数ポインタ型（`R(Args...) -> R(*)(Args...)`）としてマッチングされます。

その上で、例外オブジェクトの型`E`とハンドラの型は次のいずれかの場合にマッチしているとみなされます

- ハンドラの型が`cv T`もしくは`cv T&`で、`E`と`T`が（トップレベルのCV修飾を無視して）同じ型の場合
- ハンドラの型が`cv T`もしくは`cv T&`で、`T`が`E`の曖昧でない`public`な基底クラスである場合
    - すなわち、`std::derived_from<E, T>`が`true`となる場合
- ハンドラの型が`cv T`もしくは`const T&`で、`T, E`が共にポインタ/メンバポインタ型かつ、`E`が次のどれかの変換によって`T`に変換可能である場合
    - `private/protected`もしくは曖昧な（基底）クラスへの変換を含まない、標準ポインタ変換
    - 関数ポインタ変換
    - 修飾変換
- ハンドラの型が`cv T`もしくは`const T&`で、`T`が共にポインタ/メンバポインタ型かつ、`E`が`std::nullptr_t`の場合
- ハンドラの型が`...`で宣言されている場合

ここでの`cv`とは省略可能な`const/volatile`修飾を表しています。とはいえポインタや参照型の参照先に対するもの（非トップレベルのCV修飾）以外に`volatile`が意味を持つとは思えないので、ここでは`const`だと考えればいいでしょう。

トップレベルのCV修飾はポインタ型の場合`T const * const`（=`const T * const`）のような宣言における`*`の右側にくるCV修飾がトップレベルのCV修飾となります。したがって、1つ目の条件では例えば、`int*`と`int* const`が同じ型とみなされ、`int*`と`const int*`は同じ型だとはみなされないことになります。参照型ではトップレベルのCV修飾を行えないため`int&`と`const int&`は異なる型とみなされ、その他の型の場合はCV修飾があればそれがトップレベルのものなので、`int`と`const int`は同じ型とみなされます。これらのマッチングは、ハンドラの型で例外オブジェクトの型を受けることを考えると納得できると思います。

3つ目の条件における各種ポインタ変換は前提条件を満たした上で、おおよそ`E -> T`の暗黙変換が通る場合と言い換えることができます（基底クラスへの変換は制限がありますが）。ここではそのようにお茶を濁して複雑な暗黙変換の世界へは深入りしません、cppreferenceの暗黙変換ページをご参照ください・・・

- [Implicit conversions - cppreference](https://en.cppreference.com/w/cpp/language/implicit_conversion)

そして、このようなマッチングは、実行時に`try`ブロック中で例外が投げられた場合にそれに付属する`catch`節に対して実行時に行われ、例外ハンドラに対するマッチングの順序はソースコード上で現れている順番通りに行われます。このため、例外ハンドラの順番によっては必ずしも最適なマッチングとならない場合や決して呼ばれない例外ハンドラが存在することになりますが、例えコンパイル時にそれがわかっていたとしても並べ替えられたりはしません（コンパイラが優しいと警告はしてくれるかもしれません）。

```cpp
#include <stdexcept>
#include <exception>

void f() noexcept(false);

int main() {
  try {
    f();
  }
  catch (int) {}  // #1
  catch (const char*) {}  // #2
  catch (const std::exception&) {}    // #3
  catch (const std::logic_error&) {}  // #4
}
```

- [[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ](https://wandbox.org/permlink/JCrAmGiPg8NVIZ9U)

この例の場合、`f()`から例外が投げられると対応する例外ハンドラのマッチングは`#1 -> #2 -> #3 -> #4`の順で行われます。そして、`#4`のハンドラは決して呼ばれることがありません。

この関数`f()`が別の翻訳単位（特にビルド済のdll/so）で定義されている場合、ここから投げられる例外は予測不可能となります。したがって、例外ハンドラのマッチングは実行時にしか行うことができず、実行時に（しかも例外発生時というクリティカルな状況で）それを行うためにオーバーロード解決のような複雑な手順をとることも憚られるため、上記のような比較的簡易なマッチングによって例外ハンドラを決定しているのだと思われます。

#### 例外ハンドラで使えない型

例外ハンドラの型として次のものとを指定するとコンパイルエラーとなります

- 不完全型
- 抽象クラス型
- 右辺値参照型
- 不完全型へのポインタ/参照
    - `cv void*`を除く

```cpp
void f() noexcept(false);

// 不完全型
struct S;

// 抽象クラス型
struct A {
  virtual void f() = 0;
  virtual ~A = default;
};

int main() {
  try {
    f();
  }
  catch (S) {}        // ng
  catch (A) {}        // ng
  catch (int&&) {}    // ng
  catch (const S*) {} // ng
  catch (const S&) {} // ng
  catch (A*) {} // ok
  catch (A&) {} // ok
}
```

### 例外オブジェクトの型

ハンドラの型のマッチング方法は分かりましたが、それを考えようとするともう一つよく分からないことが出てきます。それは、例外オブジェクトの型`E`がどう決まるのかです。それは当然`throw`式のオペランドの型から決まりますが、オペランドの型そのものではなく少し減衰されます。

例外オブジェクトの型`E`は、`throw`式のオペランドの型（コンパイル時の静的型）を`T`とすると次のような変換を受けます

- `T`のトップレベルのCV修飾を除去する
- `T`が型`U`の配列型もしくは関数型`U`である場合、`T`を`U`のポインタ型へdecayする

この時、`E`が次のいずれかの型に該当する場合、コンパイルエラーとなります

- 不完全型
- 抽象クラス型
- 不完全型へのポインタ
    - `cv void*`を除く

このようにして決定された型`E`が例外オブジェクトの型となり、例外ハンドラのマッチングにおいてはこの`E`がそのまま使用されます。

変換をまとめると次のようになります

|`throw`式のオペランドの型|例外オブジェクトの型|
|---|---|
|`T`|`T`|
|`const T`|`T`|
|`T*`|`T*`|
|`T* const`|`T*`|
|`T const *`|`T const *`|
|`T const * const`|`T const *`|
|`T&`|`T&`|
|`T&&`|`T&&`|
|`T const &`|`T const &`|
|`R(Args...)`|`R(*)(Args...)`|
|`T[]`|`T*`|

#### 決して選択されない例外ハンドラ

### 例外ハンドラにおけるコピー

### 参考文献

- [throw expression - cppreference](https://en.cppreference.com/w/cpp/language/throw#The_exception_object)
- [try-block - cppreference](https://en.cppreference.com/w/cpp/language/try_catch)
- [14.4 Handling an exception[except.handle] - eel.is](http://eel.is/c++draft/except#handle)
- [Implicit conversions - cppreference](https://en.cppreference.com/w/cpp/language/implicit_conversion)