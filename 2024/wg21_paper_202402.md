# ［C++］WG21月次提案文書を眺める（2024年01月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-02](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-02)

全部で112本あります。

もくじ

[:contents]

### [P0493R5 Atomic maximum/minimum](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
### [P0843R10 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0843r10.html)
### [P0876R15 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0876r15.pdf)
### [P1061R7 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1061r7.html)
### [P1144R10 std::is_trivially_relocatable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1144r10.html)
### [P1729R4 Text Parsing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1729r4.html)
### [P2047R7 An allocator-aware optional type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2047r7.html)
### [P2075R4 Philox as an extension of the C++ RNG engines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2075r4.pdf)
### [P2249R5 Mixed comparisons for smart pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2249r5.html)
### [P2249R6 Mixed comparisons for smart pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2249r6.html)
### [P2299R4 `mdspan`s of All Dynamic Extents](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2299r4.html)

これはどうやら間違って公開されたようで、内容はR3と同一です。

- [P2299R3 mdspans of All Dynamic Extents - WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P2299R3-mdspans-of-All-Dynamic-Extents)

### [P2389R0 `dextents` Index Type Parameter](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2389r0.html)

`std::dextents`から、整数型の指定を省略する提案。

`std::dextents`は`std::mdspan`のインデックス指定のためのもので、次元数だけを静的に指定しておいて、次元ごとの要素数は動的に指定するものです。

```cpp
import std;

// int型2x2行列
using imat22 = std::mdspan<int, std::extents<std::size_t, 2, 2>>;

// int型4x3行列
using imat43 = std::mdspan<int, std::extents<std::size_t, 4, 3>>;

// int型2次元行列
using imatnn = std::mdspan<int, std::dextents<std::size_t, 2>>;

int main() {
  int data[] = { ... };

  // 2x2行列
  imatnn mat22{data, 2, 2};
  // 4x3行列
  imatnn mat43{data, 4, 3};
}
```

すなわち、`dextents<size_t, 2>`は`extents<size_t, dynamic_extent, dynamic_extent>`の略記です。

当初の`mdspan`では`extents/dextents`の使用する整数型（インデックス型）は`std::size_t`で固定でしたが、P2533によってそれが変更可能となり、それに伴って`extents/dextents`はテンプレートパラメータリストの最初で使用する整数型を受け取るようになりました。

特に`dextents`ではこれによって、本来できていた`dextents<2>`を`dextents<std::size_t, 2>`のように書かなければならなくなり、わずらわしさが増加しています。

インデックス型のカスタマイズは重要な機能ですが、多くのユーザーはその変更を考慮する必要が無いため、`dextents`はデフォルトで`std::size_t`を使用するようにしておこうとする提案です。

```cpp
// これを
using imatnn = std::mdspan<int, std::dextents<std::size_t, 2>>;

// こう書けるようにする
using imatnn = std::mdspan<int, std::dextents<2>>;
```

この実現方法としては、ソースの破壊的変更を受け入れて`std::dextents`のテンプレートパラメータを入れ替えることを提案しているようです。

```cpp
namespace std {
  // 現在の宣言
  template <typename IndexType, std::size_t Rank>
  using dextents = ...;
}
```

これは、現在`std::dextents<std::size_t, 2>`と書いているところを`std::dextents<2, std::size_t>`と書くようにしなければならなくなるので、破壊的変更となります。

LEWGのレビューでは、破壊的変更を回避して`std::dims`という新しいエイリアステンプレート？を追加してこの問題の解決とすることで合意が取れているようです。

```cpp
namespace std {

  template <typename IndexType, std::size_t Rank>
  using dextents = ...;

  // 追加
  template <std::size_t Rank, typename IndexType = std::size_t>
  using dims = dextents<IndexType, Rank>
}
```

- [`std::extents` - cpprefjp](https://cpprefjp.github.io/reference/mdspan/extents.html)
- [P3086 進行状況](https://github.com/cplusplus/papers/issues/1743)

### [P2422R0 Remove nodiscard annotations from the standard library specification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2422r0.html)

規格署における標準ライブラリの関数から、`[[nodiscard]]`を取り除く提案。

`operator new`等をはじめとして、現在の標準ライブラリの一部の関数にはその戻り値を捨てることが望ましくないことから`[[nodiscard]]`が付加されています。この提案は、標準ライブラリの規定としてそれを取り除くとともに、今後も追加しないことを提案するものです。

その理由としては

- その注釈を行うかどうかは、実装品質の問題
- 何も指定しないため、規格書にあるべきかは疑問
- 委員会の時間を消費することなく、一律的に利用可能にすることができる
- 一律的に利用可能にするためには、実装の分析と経験が必要
- この注釈を付加することが適切であるかの判断は場合によって困難であり、実装後の経験によって変更される可能性がある

としています。

`[[nodiscard]]`の注釈を付加することを決定するためには想像よりも多くの作業と時間を必要とする一方で、それによるメリットはあまり大きくなく、規格書に対してではなく各実装に対してその検討を促してほしい、という事のようです。

この提案では現在標準ライブラリの関数に付加されている`[[nodiscard]]`をすべて取り除くとと主に今後も付加しないことを基本とし、代わりに別の文書で`[[nodiscard]]`を付加することを推奨する標準ライブラリ中の関数をまとめておくことを提案しています。

- [P2422 進行状況](https://github.com/cplusplus/papers/issues/1744)

### [P2643R2 Improving C++ concurrency features](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2643r2.html)
### [P2686R3 constexpr structured bindings and references to constexpr variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2686r3.pdf)
### [P2688R1 Pattern Matching: `match` Expression](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2688r1.pdf)
### [P2721R0 Deprecating function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2721r0.pdf)
### [P2727R4 std::iterator_interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2727r4.html)
### [P2746R4 Deprecate and Replace Fenv Rounding Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2746r4.pdf)
### [P2758R2 Emitting messages at compile time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2758r2.html)
### [P2781R4 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2781r4.html)
### [P2786R4 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r4.pdf)
### [P2822R0 Providing user control of associated entities of class types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2822r0.pdf)

ADLにおいて考慮される関連名前空間を制御する言語機能提案。

ADLでは、非修飾名（名前空間指定なし）の関数呼び出しに際して、関数に渡されている引数の型の情報を用いてその関数を見つけようとします。

```cpp
template<typename T>
void adl_example(T a) {
  NS::f(a); // 修飾名呼び出し、ADLは行われない
  f(a);     // 非修飾名呼び出し、ADLが行われる
}
```

この例では、`adl_example()`内部から`f`という名前を探索する必要があり、`f(a)`の呼び出しでは非修飾名探索が行われます。ここで何も見つからない場合、次にADLによって引数`a`の型`T`の関連情報から`f`という推定関数名を探索します。

ADLは関数オーバーロードの探索のために必須であり、同時に関数によるカスタマイゼーションポイントを提供する役目も担っています。

この時、ADLによって探索が行われる場所のことを関連エンティティ（*associated entities*）と呼びます。これは、ADLによって関数呼び出しに渡されている引数型（クラス型）`T`に対して、次のもので構成される集合です

- `T`自身
- `T`の直接/間接の基底クラス
    - それらの関連エンティティは含まれない
- `T`がネストしたクラス型ならば、`T`を直接囲んでいるクラス型
    - 直接のもののみで、その外側のクラス型は含まれない
    - 囲んでいるクラス型の関連エンティティは含まれない
- `T`がクラステンプレートの特殊化であれば
    - そのテンプレート引数を`A`とすると、`A`の関連エンティティ
    - そのテンプレートテンプレート引数として使用されているテンプレート

ここでのエンティティとはほぼクラス型のことです。

これらの関連エンティティのそれぞれごとに、そのエンティティのフレンドとして宣言されたADL対象の名前を持つ関数を探索し、さらにエンティティの関連名前空間（そのエンティティを囲う最も内側の非インライン名前空間とそのエンティティを囲う最も内側のインライン名前空間の集合）でもADL対象の名前を持つ関数を探索します。

この時、関連エンティティ及び関連名前空間の定義が複雑かつ予測しづらいことによって予期しない関数が呼び出される場合があり、長年問題になってきました（C++ ADLとかでググれば事例をいくつも見つけられるでしょう）。特に、クラステンプレートのテンプレート引数が関連エンティティに含まれてしまうというのが驚きの呼び出しに繋がります。そのほかにも

- 関連エンティティが増加することによるコンパイル時間増大
- 同名の候補がいくつも見つかる場合にエラーメッセージが膨大になる
- 予期しないテンプレートのインスタンス化が起こる
    - 関連エンティティとして`T`の基底クラスを見に行くため、`T`がインスタンス化される

などの問題があります。これらの解決のための提案もいくつか出されたものの、後方互換の問題や実装経験の乏しさなどもあり、解決策は確立されませんでした。

この提案ではADLによる問題の解決のために、クラス型の宣言ごとに関連名前空間を明示的に指定できるオプトイン構文を用いることによって、ADLの関連エンティティを制御することができるようにしようとするものです。

提案しているのは、`namespace(...)`というものをクラス型宣言内でクラス名の後においておくものです。`...`にはADLの関連エンティティもしくは関連名前空間として含めたいものを指定し、空にすることもできます。

```cpp
// 関連エンティティは自身のみ
template<typename T>
class example namespace()
{ /* ... */ };

// some_containerの関連エンティティとして、要素型Tを追加
template<typename T, typename Alloc>
class some_container namespace(T)
{ /* ... */ };

// 関連エンティティのルールは現在と同様
class normal_adl
{};
```

`namespace(...)`に指定することのできるエンティティは型名とクラステンプレート名、および名前空間名の3つのみです。

あるクラス型`C`に対して、`namespace(Ts...)`によって指定された型/テンプレート名`Ts...`は`C`の関連エンティティの設定を上書きし、`C`および`Ts...`のみが関連エンティティとして扱われるようにします。ただし、何かを追加した時でも`namespace()`のように空として指定した時でも、それが指定されているクラス型`C`自身は常に関連エンティティであり続けます。

`namespace(...)`に名前空間名が指定されている場合、ADL探索対象の関連名前空間に指定した名前空間が追加されます。こちらは関連名前空間を上書きせず、関連名前空間は指定したものに加えて、通常通りに関連エンティティの関連名前空間が含まれます。

クラス宣言時に`namespace(...)`を指定しなければ、関連エンティティの設定を現在と同じになります。すなわち、既存のコードの動作を変更しません。

このように、関連エンティティの決定を上書きしなおかつ限定することによって、ADL時の探索対象を限定するとともに、基底クラスやテンプレートパラメータなどの含まれてほしくないものが自動で含まれてしまうのを防ぐことができます。これにより、関連エンティティの検出の手間が減るとともに関連エンティティの削減によってコンパイル負荷を減らすことができ、いたずらに同名候補が増えないことでエラーメッセージを削減でき、意図しないインスタンス化も回避することができます。

`namespace(...)`には型名など指定可能なものをリストとして複数指定することができます。

```cpp
// 複数の型を関連エンティティに追加
template<typename First, typename Second>
struct pair namespace(First, Second)
{ /* ... */ };

// Ts...に含まれる型だけを関連エンティティに追加（基底クラスは含まれない）
template<typename... Ts>
struct tuple namespace(Ts...) : detail::tuple_base<Ts...>
{ /* ... */ };
```

また、本来は関連エンティティとして扱われないような型を関連エンティティに含まれるようにすることもできます。

```cpp
namespace std {
  // NTTP Xの型を関連名前空間に追加する
  template<auto X>
  struct constexpr_v namespace(decltype(X)) {
    ...

    constexpr operator decltype(X) const { return X; }

    ...
  }
}

template<typename T>
void f(T t) {
  std::cout << t << '\n'; // ok

  auto cv = std::c_<T{...}>;

  std::cout << cv << '\n';  // ok、Tを関連エンティティとするADLでTの関数を検出し
                            //     暗黙変換によってTの関数が使用できる
}
```

提案中の`std::constexpr_v`では、ラップしているコンパイル時定数の型が関連エンティティに含まれないことから、ラップしているNTTP値のインターフェースを使用できない問題が指摘されています。これを回避するために、テンプレートパラメータを増やしてNTTP値の型を関連名前空間に入れようとしていますが、この提案ならよりスマートにそれを解決できます。

- [P2781R2 `std::constexpr_v` - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2781R2-stdconstexpr_v)

また、全く関係の無い型を指定することもできます。

```cpp
struct string_like namespace(std::string_view)
{
  
  ...

  operator std::string_view() const noexcept;
  
  ...
};

void f(string_like mystr, std::string_view strv) {
  std::cout << mystr; // ok、string_viewの<<がADLによって発見され暗黙変換によって使用される
  
  // mystrには比較演算子が定義されていないとしても
  bool b = strv == mystr; // ok、string_viewの==が使用される
}
```

この`string_like`は文字列を保持する簡単な型であるとして、現在は`string_like`の値に対するADLからでは`std::string_view`のために定義されている`std`の関数を発見することはできません。この提案の後、このように`std::string_view`を関連エンティティとして追加することで、ADLによってそれを発見し、暗黙変換によって利用することができます。

- [P2822 進行状況](https://github.com/cplusplus/papers/issues/1746)

### [P2835R3 Expose std::atomic_ref's object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2835r3.html)
### [P2845R6 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2845r6.html)
### [P2863R4 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2863r4.html)
### [P2875R3 Undeprecate `polymorphic_allocator::destroy` For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2875r3.pdf)
### [P2893R2 Variadic Friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2893r2.html)
### [P2900R5 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r5.pdf)
### [P2927R1 Observing exceptions stored in exception_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2927r1.html)
### [P2964R0 Allowing user-defined types in `std::simd`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2964r0.html)

現在の`std::simd<T>`の`T`は算術型や複素数型など標準にある数値型に限られています。この提案は、それを少し緩和してユーザー定義型（プログラム定義型）をSIMD要素として使用可能にする提案です。

用途としては、特定の型に保存された信号データや動画像データ、あるいは飽和整数型や固定小数点数型などの特殊な数値型を`std::simd`上で取り扱えるようにすることを目的としています。

この提案のアプローチは、カスタマイゼーションポイントを通して必要な場所に特別な動作を注入するものです。ただし、`std::simd`で使用可能な型としてはトリビアルコピー可能であることを要求しています。

この提案ではまず、`std::simd`のAPIのうち、ユーザー定義型で動作させるためにカスタムが必要なものとそうでないものなどを次の4つに分類します

1. Basic
    - 要素型を使用するために提供されなければならない関数
    - 四則演算など
2. Custom
    - 汎用的に実装できるが、より効率的な実装のためにカスタマイズを提供することもできる関数
    - 符号反転（0から引くというデフォルトを提供できるが、浮動小数点数型の符号ビット反転のように効率実装が可能）など
3. Copy
    - ビット列が何を表しているかを知らなくても、`std::simd`の値間で要素を移動することができる
    - トリビアルコピー可能を要求することで実現
4. Algorithm
    - 何らかの処理を実現するために他の関数（上記3つ）を利用するもの
    - 必要な関数をユーザー定義型が提供していない場合は使用できなくなる
    - アルゴリズムはカスタマイゼーションポイントを提供しない

この中で、カスタマイゼーションポイントの用意が必要なものは上2つのBasicとCustomに分類される関数です。`std::simd`については次の関数群が該当しています

1. Basic
    - 単項演算子
      - `operator~`
    - 二項演算子
      - `+,-,*,/,%,<<,>>,&,|,^`
    - 複合代入演算子
      - `+=,-=,*=,/=,%=&=,|=,^=,<<=, >>=`
    - 比較演算子
      - `operator==`
      - `<,<=,>, >=`
2. Custom
    - コンストラクタ
      - `basic_simd(basic_simd<U>)` : `T`と`U`が異なる場合変換のためのカスタマイゼーションポイントが必要
    - 単項演算子
      - `operator-`
      - `operator!`
    - 比較演算子
      - `operator!=`
    - フリー関数
      - `min`
      - `max`
      - `clamp`
      - 数学関数

この提案では、これらの関数に対してカスタマイゼーションポイントを用意しておくことでユーザー定義型でも`std::simd`が動作可能なようにしようとしています。カスタマイズが提供されていない場合、Basicな関数はコンパイルエラーとなり、Customな関数はデフォルトの実装が使用され実行されます。

上記関数群とは少し性質が異なりますが、そもそも`std::simd`でユーザー定義型を扱うためにはそのストレージをどう用意したらいいのかについての知識が必要となります。この提案では、`std::simd_custom_type_storage<T>`というクラステンプレートを用意して、これをユーザー定義型で特殊化したうえでその入れ子型でストレージ型を指定することを提案しています。

```cpp
namespace std {
  // stdで提供
  template<typename T>
  struct simd_custom_type_storage;
}

// ユーザー定義型に対しては特殊化して使用
template<>
struct std::simd_custom_type_storage<user-defined-type> {
  using value_type = /* some bit container */;
};
```

あるいは（もしくは追加で）、ユーザー定義型が直接これを提供するようにする方法も考えられます

```cpp
struct user-defined-type {
  using simd_storage_type = /* some container */;
};
```

この`simd_storage_type`はユーザー定義型（ここでの`user-defined-type`）と同じサイズであり、相互に`std::bit_cast`可能である必要があります。すなわち、`simd_storage_type`は`user-defined-type`の範囲となるものではなく、`user-defined-type`を表現できる何らかのストレージ型です（ユーザー定義型自身でもok）。例えば、8bit数値8個分のデータに対して64bit整数型を使用する、ようなことが可能です。

このストレージ型のカスタマイズは`std::simd`でユーザー定義型を利用可能にするための必須の操作です。

そのうえで、先程上げた各種単項/二項演算のカスタマイズは、演算子オーバーロードではなく特定の名前付き関数テンプレートのカスタマイズによって行われます。

```cpp
// std::simdに定義されている二項operator+オーバーロード
constexpr friend 
  basic_simd operator+(const basic_simd& lhs, const basic_simd& rhs)
    requires (details::simd_has_custom_binary_plus || details::element_has_plus)
{
    if constexpr (details::simd_has_custom_binary_plus)
      return simd_binary_op(lhs, rhs, std::plus<>{});    // ユーザー定義型を呼び出す
    else
        /* impl-defined */
}
```

`simd_binary_op()`は二項演算のカスタマイズを受ける統一的な名前の関数テンプレートです。このように二項演算でまとめてしまうことで、二項演算の種類ごとに別名のカスタマイゼーションポイントが生えてしまうことを抑止しています。二項演算の種類は第三引数に透過二項演算ファンクたオブジェクトを渡すことで識別します。

単項演算に対しても同様に、`simd_unary_op()`という名前のカスタマイゼーションポイントを提供できます（こちらはタグ型を用意する必要がありますが）。

シフト演算子に関しては対応する既存のファンクタ型が定義されておらず、何かしら対応が必要ですが、この提案（intel内部での実装）では専用のファンクタ型（`std::simd_shift_left<>`など）を追加することを採用しています。

残ったフリー関数については、ADLを利用した単純な関数オーバーロードによってカスタマイズすることを提案しています。

```cpp
template<typename Abi>
constexpr auto abs(const basic_simd<user-defined-type, Abi>& v) {
  return /* special-abs-impl */;
}
```

これは既存の`std::complex`等と共通することです。

この提案の内容はまだ、intelにおける社内実装における設計選択を説明する側面が強く、カスタマイゼーションポイントの提供方法あるいは提供する対象についてはは固まっていません。

- [P2422 進行状況](https://github.com/cplusplus/papers/issues/1748)

### [P2988R2 `std::optional<T&>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r2.pdf)
### [P2988R3 `std::optional<T&>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r3.pdf)
### [P2989R1 A Simple Approach to Universal Template Parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2989r1.pdf)
### [P2992R1 Attribute [[discard("reason")]]](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2992r1.html)
### [P2994R1 On the Naming of Packs](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2994r1.html)
### [P2996R2 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r2.html)
### [P3002R1 Policies for Using Allocators in New Library Classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3002r1.html)
### [P3004R0 Principled Design for WG21](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3004r0.pdf)

原則に基づいた設計のプロセスを紹介する文書。

標準化委員会での議論プロセスにおいて、事前に確認しておくべき設計原則の見落としや軽視による議論の手戻りなどの問題の発生を防止し、提案に関する作業のための時間を節約するために新しい提案が事前に確認しておくべきポリシーを文書としてまとめておこうとする活動が現在なされています。

この文書は、そのようなポリシーを含めて事前に定められた原則に従って提案の内容を評価し設計を進めていく作業プロセスを紹介するものです。

この提案は

- 4章 : 企業イベントにおける会場選択という作業を例にして、プロセスの使用方法を紹介する
- 5章 : 4で紹介したプロセスの詳細な手順の説明
- 6章 : 委員会においてそのプロセスを適用する例を紹介
- 7章 : プロセスに基づいて提案の作業を進めるために、WG21の標準化会議がどのように開催されるべきかについての説明
- 付録 : C++における実際の問題についてプロセスを適用する例をいくつか紹介

のような内容で構成されています。

- [P2267R0 Library Evolution Policies - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2267R0-Library-Evolution-Policies)


### [P3005R0 Memorializing Principled-Design Policies for WG21](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3005r0.pdf)
### [P3008R1 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3008r1.html)
### [P3016R2 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3016r2.html)
### [P3019R4 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r4.html)
### [P3019R5 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r5.html)
### [P3019R6 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r6.html)
### [P3032R0 Less transient constexpr allocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3032r0.html)
### [P3045R0 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3045r0.html)
### [P3047R0 Remove deprecated namespace `relops` from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3047r0.html)

`std::relops`を削除する提案。

`std::relops`はクラス型に`< ==`の演算子を定義しておけば残りの比較演算子を自動で実装するものです。しかし、これは同等以上のものがC++20で一貫比較として言語機能に組み込まれたことで非推奨とされていました。

この提案は、これはC++26に向けて削除しようとするものです。

```cpp
#include <cassert>
#include <utility>

struct Test {
  int data = 0;

  friend bool operator==(Test a, Test b){return a.data == b.data;}
  friend bool operator <(Test a, Test b){return a.data <  b.data;}
};

int main() {
  Test x{};
  Test y{2};

  assert(x == x);
  assert(x != y);

  // std::rel_opsをusingする
  using namespace std::rel_ops;

  // rel_opsによって利用可能になる
  assert(x <  y);
  assert(x <= y);
  assert(x >= y);
  assert(x >  y);
}
```

現在はMSVCのみ`rel_ops`の使用に対して非推奨である警告を発するようです。

現在のこのようなコードは

1. `<utility>`ではなく`<compare>`をインクルード
2. `<`の代わりに`<=>`を定義する
    - 典型的な実装であれば`default`指定で良い
3. 利用側で、`std::rel_ops`の`using`を削除する

の3ステップで移行できます。

- [`std::rel_ops` - cpprefjp](https://cpprefjp.github.io/reference/utility/rel_ops.html)
- [P3047 進行状況](https://github.com/cplusplus/papers/issues/1753)

### [P3052R1 view_interface::at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3052r1.html)
### [P3055R1 Relax wording to permit relocation optimizations in the STL](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3055r1.html)
### [P3060R1 Add std::views::upto(n)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3060r1.html)
### [P3068R0 Allowing exception throwing in constant-evaluation.](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r0.pdf)

定数式において`throw`式による例外送出を許可する提案。

現在定数式においては例外送出が許可されていません。そのほかに定数式におけるエラー報告を行うメカニズムが用意されているわけでもないため、定数式におけるエラー処理は省略されるか、`optional`などを使用して侵入的にハンドリングされています。いずれにせよ、エラーを報告するメカニズムを欠いていることで、定数式におけるエラーメッセージ出力はコンパイラに頼るほかなく、ほとんどの場合わかりづらいメッセージが出力されます。

また、P2996で提案中の値ベース静的リフレクションにおいては、エンティティから反射して（`^`によって）取得した鏡像（`std::meta::info`値）に対して作用する`consteval`メタ関数が用意されており、入力が不正であることによってそれらの処理がエラーを返す場合のエラー報告メカニズムとして、例外が最もふさわしいものであることが示唆されています。

この提案は、これらの理由から定数式における例外の送出（`throw`式の評価）およびハンドリング（`try - catch`の実行）を許可するものです。

提案では、定数式における`throw`式の評価を許可し、1つの定数式の評価内において送出された例外がその評価内でキャッチされない場合にコンパイルエラーとするようにしています。

```cpp
constexpr auto just_error() {
  throw my_exception{"this is always an error"};
}

constexpr void foo() {
  try {
    auto v = just_error(); // ok、foo()が定数式で実行される場合、すぐにキャッチされるのでエラーにならない
  } catch (my_exception) { }

  try {
    constexpr auto v = just_error(); // ng、constexpr変数の初期化は別の定数評価コンテキストを構成するが、その評価内でキャッチされない
  } catch (my_exception) { }
}
```

また、この提案では例外を定数式で許可するような言語機能の変更のみを提案していて、`<stdexcept>`にあるような関連するライブラリ機能を定数式で使用可能にすることは提案していません。

- [P2996R1 Reflection for C++26 - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2996R1-Reflection-for-C26)
- [P3068 進行状況](https://github.com/cplusplus/papers/issues/1754)

### [P3072R1 Hassle-free thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3072r1.html)
### [P3073R0 Remove evaluation_undefined_behavior and will_continue from the Contracts MVP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3073r0.pdf)
### [P3074R1 std::uninitialized<T>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3074r1.html)
### [P3074R2 std::uninitialized<T>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3074r2.html)
### [P3085R0 `noexcept` policy for SD-9 (throws nothing)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3085r0.html)
### [P3088R0 Attributes for contract assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3088r0.pdf)
### [P3088R1 Attributes for contract assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3088r1.pdf)
### [P3090R0 std::execution Introduction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3090r0.pdf)
### [P3091R0 Better lookups for `map` and `unordered_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3091r0.html)
### [P3092R0 Modules ABI requirement](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3092r0.html)
### [P3093R0 Attributes on expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3093r0.html)
### [P3094R0 std::basic_fixed_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3094r0.html)
### [P3095R0 ABI comparison with reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3095r0.pdf)
### [P3096R0 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3096r0.pdf)
### [P3101R0 Differentiating potentially throwing and nonthrowing violation handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3101r0.pdf)
### [P3102R0 Refining Contract Violation Detection Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3102r0.pdf)
### [P3103R0 More bitset operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3103r0.html)
### [P3104R0 Bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3104r0.html)
### [P3105R0 constexpr std::uncaught_exceptions()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3105r0.html)
### [P3106R0 Clarifying rules for brace elision in aggregate initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3106r0.html)
### [P3107R0 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r0.html)
### [P3109R0 A plan for std::execution for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3109r0.html)
### [P3110R0 Array element initialization via pattern expansion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3110r0.html)
### [P3112R0 Specify Constructor of std::nullopt_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3112r0.html)
### [P3113R0 Slides: Contract assertions, the noexcept operator, and deduced exception specifications](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3113r0.pdf)
### [P3114R0 noexcept(contract_assert(_)) -- slides](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3114r0.pdf)
### [P3115R0 Data Member, Variable and Alias Declarations Can Introduce A Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3115r0.pdf)
### [P3116R0 Policy for explicit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3116r0.html)
### [P3117R0 Extending Conditionally Borrowed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3117r0.html)
### [P3122R0 [[nodiscard]] should be Recommended Practice](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3122r0.html)
### [P3123R0 2024-02 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3123r0.html)
### [P3126R0 Graph Library: Overview](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3126r0.pdf)
### [P3127R0 Graph Library: Background and Terminology](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3127r0.pdf)
### [P3128R0 Graph Library: Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3128r0.pdf)
### [P3129R0 Graph Library: Views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3129r0.pdf)
### [P3130R0 Graph Library: Graph Container Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3130r0.pdf)
### [P3131R0 Graph Library: Graph Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3131r0.pdf)
### [P3133R0 Fast first-factor finding function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3133r0.html)
### [P3135R0 Hazard Pointer Extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3135r0.pdf)
### [P3136R0 Retiring niebloids](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3136r0.html)
### [P3137R0 views::to_input](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3137r0.html)
### [P3138R0 views::cache_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r0.html)
### [P3140R0 std::int_least128_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3140r0.html)
### [P3142R0 Printing Blank Lines with println](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3142r0.pdf)
### [P3143R0 An in-depth walk through of the example in P3090R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3143r0.pdf)
### [P3144R0 Deprecate Delete of Incomplete Class Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3144r0.pdf)
### [P3146R0 Clarifying std::variant converting construction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3146r0.html)
### [P3147R0 A Direction for Vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3147r0.pdf)
### [P3148R0 Formatting of chrono Time Values](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3148r0.pdf)
### [P3149R0 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r0.pdf)
### [P3150R0 SG14: Low Latency/Games/Embedded/Financial Trading virtual Meeting Minutes 2023/12/13-2024/2/14](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3150r0.pdf)
### [P3151R0 SG19: Machine Learning virtual Meeting Minutes to 2023/12/14-2024/02/8](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3151r0.pdf)
### [P3153R0 An allocator-aware variant type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3153r0.html)
### [P3154R0 Deprecating signed character types in iostreams](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3154r0.html)
### [P3155R0 noexcept policy for SD-9 (The Lakos Rule)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3155r0.pdf)
### [P3156R0 empty_checkable_range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3156r0.html)
### [P3157R0 Generative Extensions for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3157r0.pdf)
### [P3158R0 Headless Template Template Parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3158r0.html)
### [P3160R0 An allocator-aware `inplace_vector`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3160r0.html)
### [P3300R0 C++ Asynchronous Parallel Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3300r0.html)



- [ ] P2299R4 `mdspan`s of All Dynamic Extents
- [ ] P2389R0 `dextents` Index Type Parameter
- [ ] P2422R0 Remove nodiscard annotations from the standard library specification
- [ ] P2721R0 Deprecating function
- [ ] P2822R0 Providing user control of associated entities of class types
- [ ] P2964R0 Allowing user-defined types in std::simd
- [ ] P3004R0 Principled Design for WG21
- [ ] P3005R0 Memorializing Principled-Design Policies for WG21
- [ ] P3032R0 Less transient constexpr allocation
- [ ] P3045R0 Quantities and units library
- [ ] P3047R0 Remove deprecated namespace `relops` from C++26
- [ ] P3068R0 Allowing exception throwing in constant-evaluation.
- [ ] P3073R0 Remove evaluation_undefined_behavior and will_continue from the Contracts MVP
- [ ] P3085R0 `noexcept` policy for SD-9 (throws nothing)
- [ ] P3088R0 Attributes for contract assertions
- [ ] P3088R1 Attributes for contract assertions
- [ ] P3090R0 std::execution Introduction
- [ ] P3091R0 Better lookups for `map` and `unordered_map`
- [ ] P3092R0 Modules ABI requirement
- [ ] P3093R0 Attributes on expressions
- [ ] P3094R0 std::basic_fixed_string
- [ ] P3095R0 ABI comparison with reflection
- [ ] P3096R0 Function Parameter Reflection in Reflection for C++26
- [ ] P3101R0 Differentiating potentially throwing and nonthrowing violation handlers
- [ ] P3102R0 Refining Contract Violation Detection Modes
- [ ] P3103R0 More bitset operations
- [ ] P3104R0 Bit permutations
- [ ] P3105R0 constexpr std::uncaught_exceptions()
- [ ] P3106R0 Clarifying rules for brace elision in aggregate initialization
- [ ] P3107R0 Permit an efficient implementation of std::print
- [ ] P3109R0 A plan for std::execution for C++26
- [ ] P3110R0 Array element initialization via pattern expansion
- [ ] P3112R0 Specify Constructor of std::nullopt_t
- [ ] P3113R0 Slides: Contract assertions, the noexcept operator, and deduced exception specifications
- [ ] P3114R0 noexcept(contract_assert(_)) -- slides
- [ ] P3115R0 Data Member, Variable and Alias Declarations Can Introduce A Pack
- [ ] P3116R0 Policy for explicit
- [ ] P3117R0 Extending Conditionally Borrowed
- [ ] P3122R0 [[nodiscard]] should be Recommended Practice
- [ ] P3123R0 2024-02 Library Evolution Polls
- [ ] P3126R0 Graph Library: Overview
- [ ] P3127R0 Graph Library: Background and Terminology
- [ ] P3128R0 Graph Library: Algorithms
- [ ] P3129R0 Graph Library: Views
- [ ] P3130R0 Graph Library: Graph Container Interface
- [ ] P3131R0 Graph Library: Graph Containers
- [ ] P3133R0 Fast first-factor finding function
- [ ] P3135R0 Hazard Pointer Extensions
- [ ] P3136R0 Retiring niebloids
- [ ] P3137R0 views::to_input
- [ ] P3138R0 views::cache_last
- [ ] P3140R0 std::int_least128_t
- [ ] P3142R0 Printing Blank Lines with println
- [ ] P3143R0 An in-depth walk through of the example in P3090R0
- [ ] P3144R0 Deprecate Delete of Incomplete Class Type
- [ ] P3146R0 Clarifying std::variant converting construction
- [ ] P3147R0 A Direction for Vector
- [ ] P3148R0 Formatting of chrono Time Values
- [ ] P3149R0 async_scope -- Creating scopes for non-sequential concurrency
- [ ] P3150R0 SG14: Low Latency/Games/Embedded/Financial Trading virtual Meeting Minutes 2023/12/13-2024/2/14
- [ ] P3151R0 SG19: Machine Learning virtual Meeting Minutes to 2023/12/14-2024/02/8
- [ ] P3153R0 An allocator-aware variant type
- [ ] P3154R0 Deprecating signed character types in iostreams
- [ ] P3155R0 noexcept policy for SD-9 (The Lakos Rule)
- [ ] P3156R0 empty_checkable_range
- [ ] P3157R0 Generative Extensions for Reflection
- [ ] P3158R0 Headless Template Template Parameters
- [ ] P3160R0 An allocator-aware `inplace_vector`
- [ ] P3300R0 C++ Asynchronous Parallel Algorithms