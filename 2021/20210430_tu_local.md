# TU-local Entityの漏洩の禁止


### モジュールと内部リンケージ名

内部リンケージをもつエンティティ（関数、クラスや変数）は、外部リンケージをもつ関数など、翻訳単位のインターフェースの実装詳細をある粒度で分解して表現するために使用されています。それによって、プログラムの保守性や再利用可能性の向上が見込めます。

従来のヘッダファイルとソースファイルからなる一つの翻訳単位の構成においては、内部リンケージ名はソースファイル内に隠蔽されているか、ヘッダファイルに書かれていてもヘッダをインクルードした翻訳単位それぞれで内部リンケージを持つ別のものとして扱われるため、内部リンケージを持つエンティティが翻訳単位外部から参照されることはありませんでした。

```cpp
/// header.h

#include <iostream>

int external_f(int);

// 翻訳単位毎に定義される
// それぞれの定義が翻訳単位を超えて参照されることはない
static void internal_f(int n) {
  std::cout << n << std::endl;
} 
```

```cpp
/// source.cpp

#include "header.h"

namespace {
  // この翻訳単位の外から呼ぶことはできない
  int internal_g() {
    return 10;
  }
}

int external_f(int n) {
  internal_f(n);
  return n + internal_g();
}
```

しかしC++20以降のモジュールにおいては、そのインターフェース単位で定義されている内部リンケージ名がそのモジュール（インターフェース単位）をインポートした先の翻訳単位からも参照できてしまいます。

ヘッダファイルとは異なり、モジュールのインターフェース単位は一つの翻訳単位であり、そのインポートはインターフェース単位にあるすべての宣言を（インポートした側から）到達可能にし、エクスポートされている宣言を可視（名前探索で見えるように）にします。この到達可能性は、内部リンケージを持つ名前であってもインポートした側の翻訳単位の宣言に影響を及ぼす可能性があります。

また、モジュールで定義されたテンプレートがインスタンス化されたとき、インスタンス化が発生した地点から定義に至る一連のインスタンス化経路上で可視になっている宣言を参照することができます。このインスタンス化経路は翻訳単位を超えて定義され、そこでは内部リンケージを持つ名前を参照することができます。

```cpp
/// mymodule.cpp
module;
#include <iostream>
export module mymodule;

// 内部リンケージ名を翻訳単位外から参照できないのは変わらないが
// インポートした側から宣言は到達可能となる
static void internal_f(int n) {
  std::cout << n << std::endl;
}

namespace {
  int internal_g() {
    return 10;
  }
}

// エクスポートされている、外部リンケージ
export int external_f(int n) {
  // 外部リンケージを持つ定義内での内部リンケージ名の使用
  // 例えばこの関数がインライン展開されたとき、何が起こる・・・？
  internal_f(n);
  return n + internal_g();
}
```

どちらの場合も、直接的に別の翻訳単位にある内部リンケージを持つ名前を参照できるわけではありませんが、間接的に内部リンケージを持つ名前が翻訳単位から露出してしまっています。例えばエクスポートされた関数が使われた先でインライン展開されるとき、内部リンケージの名前が参照されていたらどうするべきでしょうか・・・？

そのため、最終的なC++20モジュール仕様では、内部リンケージを含めた翻訳単位ローカルのエンティティ（*TU-local Entities*）が翻訳単位の外から間接的にも直接的にも参照されることが禁止されました。

内部リンケージ名は実装の整理や分割のために用いられるものであり、そのような実装詳細はモジュールの外部に公開されるべきではない、という判断です。このことを規格書では、*TU-local Entities*とその暴露（*exposure*）として表現しています。

### TU-local Entityの暴露（*exposure*）

宣言は次の場合に暴露（*exposure*）しています。

1. TU-localな値によって初期化された`constexpr`変数を定義する場合
2. 次の場合を除いて、TU-localエンティティを指名（参照）する場合
      1. 非`inline`関数または関数テンプレートの本体
      2. 変数または変数テンプレートの初期化子
      3. クラス定義内フレンド宣言
      4. 非`volatile`な`const`オブジェクトへの参照、またはodr-useでない定数式で初期化された（内部リンケージかリンケージの無い）参照。


### TU-local Entities？

TU-localとなるエンティティは次のものです。

1. 内部リンケージ名をもつ関数、型、変数、テンプレート
2. TU-localエンティティの定義内で、ラムダ式によって導入または宣言された、リンケージ名を持たない関数、型、変数、テンプレート
3. クラスの宣言・定義、関数本体、初期化子、の外側で定義されている名前のない型
4. TU-localエンティティを宣言するためだけに使用される、名前のない型
5. TU-localテンプレートの特殊化
6. TU-localテンプレートを実引数として与えられたテンプレートの特殊化
7. 宣言が暴露（*exposure*）されている、（インスタンス化されている可能性のある）テンプレートの特殊化

基本的には1と3が1次TU-localエンティティであり、他のものはそれによって副次的にTU-localとなっています。つまり、ほとんどの場合に気にすべき対象は内部リンケージ名を持つものです。

また、値やオブジェクトは次の場合にTU-localとなります

1. TU-local関数またはTU-local変数に関連付けられているオブジェクトであるか、そのポインタ型の場合
2. クラスか配列のオブジェクトであり、そのサブオブジェクト（メンバ、基底クラス、要素）のいずれかがTU-localである場合
3. クラスか配列のオブジェクトであり、その参照型の非静的データメンバが参照するオブジェクトまたは関数のいずれかがTU-localである場合

ややこしいですが、TU-localなものの中にある変数や値はTU-localで、TU-localなものを参照しているものも、それを含むものもTU-localという事です。

### 宣言が暴露された場合



### 例

### 参考文献
- [P1815R2: Translation-unit-local entities](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1815r2.html)
- [P1779R3: ABI isolation for member functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1779r3.html)
- [P1498R1 Constrained Internal Linkage for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1498r1.html)