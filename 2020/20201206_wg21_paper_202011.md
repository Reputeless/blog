# ［C++］WG21月次提案文書を眺める（2020年10月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2020 mailing2020-11](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-11)

全部で42本あります。

[:contents]

## 採択された文書

この2つの提案はC++23入りが確定したものです。

### [P0943R6 Support C atomics in C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0943r6.html)

Cとの相互運用性を高めるために、Cのアトミック操作に関するヘッダ（`<stdatomic.h>`）をC++としてもサポートする提案。

C11で`_Atomic`と言うキーワードを用いてアトミック型が定義できる様になり、`<stdatomic.h>`には組み込み型に対するアトミック型のエイリアスやアトミック操作のための関数などが用意されています。その名前はおそらく意図的にC++の`<atomic>`にあるものと同じ名前になっており、少し手間をかけると一応はコードの共通化を図れます。

```cpp
#ifdef __cplusplus
  #include <atomic>
  using std::atomic_int;
  using std::memory_order;
  using std::memory_order_acquire;
  ...
#else /* not __cplusplus */
  #include <stdatomic.h>
#endif /* __cplusplus */
```

しかし、この様なコードはCとC++のアトミックなオブジェクトの表現や保証について互換性があることを前提としていますが、その様な保証はありません。

この提案は、C++でも`<stdatomic.h>`をインクルードできる様にし、そこで提供されるものについてCとC++で同じ保証が得られることを規定するものです。

このヘッダの実装は`<atomic>`をインクルードし、その中身をグローバル名前空間へ展開することで行われます。また、Cの`_Atomic`は関数マクロとして提供されます。  
ヘッダ名が`<cstdatomic>`ではないのは、このヘッダの目的が`<stdatomic.h>`の中身を`std`名前空間に導入する事ではなく、アトミック周りのC/C++の相互運用性向上のためにCとC++で同じヘッダを共有できる様にするためのものだからです。

- [Atomic operations library - cppreference](https://en.cppreference.com/w/c/atomic)
- [`<atomic>` - cpprefjp](https://cpprefjp.github.io/reference/atomic.html)

### [P1787R6 Declarations and where to find them](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1787r6.html)

## その他文書

### [N4869 WG21 Pre-Autumn 2020 telecon minutes](WG21 Pre-Autumn 2020 telecon minutes)
### [N4871 WG21 Pre-Autumn 2020 telecon minutes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4871.pdf)


先月初めに行われたC++標準化委員会の全体会議（テレカンファレンス）の議事録。

一部の発言記録と各SGがどの様な提案について議論をしたかなどが記されていて、特筆する所では、Cとの相互運用性について議論するためにC標準化委員会（SC22/WG14）との共同作業グループを設立することや、Networking TSに向けて2つの提案が採択されたことなどが書かれています。

N4869とN4871の違いは不明。

### [N4870 WG21 2020-02 Prague Minutes of Meeting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4870.pdf)

今年2月に行われたプラハでのC++標準化委員会の全体会議の議事録。
先月初めに行われたC++標準化委員会の全体会議（テレカンファレンス）の議事録。

### [N4873 Working Draft, C++ Extensions for Library Fundamentals, Version 3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4873.html)

Library Fundamentals TSの最新の仕様書。

ここでは、将来の標準ライブラリの拡張のうち、広く基礎的なものとして使用されるうる物をまとめて、慎重に検討しています。例えば、`scope_exit`や`observer_ptr`などが含まれています。

- [cplusplus/fundamentals-ts - Github](https://github.com/cplusplus/fundamentals-ts)

### [N4874 Editor's Report: C++ Extensions for Library Fundamentals, Version 3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4874.html)

↑の変更点をまとめた文書。

変更点はLWG Issueへの対応と、Editorialなものだけの様です。

### [N4875 WG21 admin telecon meeting: Winter 2021](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4875.pdf)

2021年02月08日 08:00 (北米時間)に行われるWG21本会議のアジェンダ。

これはC++23のための2回目の会議です。

### [N4876 WG21 virtual meeting: Winter 2021](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4876.pdf)

↑のWG21本会議周知のための文章？

中身は日付とzoomのURLがあるだけです。

### [N4877 WG21 2020-11 Virtual Meeting Minutes of Meeting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4877.pdf)

先月初めに行われたC++標準化委員会の全体会議（テレカンファレンス）の議事録。

ここでは採択された提案についての投票の結果が書かれています。

### [P0447R11 Introduction of std::colony to the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0447r11.html)

要素が削除されない限りそのメモリ位置が安定なコンテナである`std::colony`の提案。

`std::colony`は*bucket array*と呼ばれるデータ構造を改良したもので、いくつかのブロック（配列）の集まりとしてデータ列を保持します。一つのブロックにはメモリ上で連続して要素が並んでおり、要素はその先頭に削除済みかどうかのフラグを持っています。イテレーションの際は削除済みの要素はスキップされ、すべての要素が削除されたブロックはイテレーション対象としてあがらなくなります。

主に次のような特性があります。

- メモリ位置が安定（要素の追加・挿入・削除で変化しない）
- 削除された要素の位置を再利用する
- ブロックサイズは可変
- 一つの要素のイテレートにかかる時間は償却定数
    - イテレーションの際に条件分岐が発生しない
- 非順序、ソート可能
- *bidirectional range*
    - 添え字アクセス（`[]`）は提供されない

`std::vetor`はその要素がメモリ上で連続しており、何も考えずに使っても良いパフォーマンスを得ることができます。しかし、そのシーケンス中にある要素を削除したり、要素を追加したりしようとすると話は変わってきます。  
`std::vetor`は常にその要素がメモリ上で連続しているので、削除された部分は詰めようとし、追加されたときにメモリの再確保が発生すると、すべての要素を新しいメモリ領域に移動させます。この動作はパフォーマンスを大きく損ねます。

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

vec.erase(vec.begin()); // 削除した分詰められる

vec.push_back(6); // メモリ再確保が発生すると、すべての要素の移動が行われる
```

この事が問題になる場合、標準ライブラリ内で代替となるものに`std::list`があります。しかし、`std::list`はメモリの局所性が低く（要素はメモリ上でばらばらに存在している）、イテレーション中のキャッシュパフォーマンスで劣ります。

`std::colony`は要素が削除された部分は単に歯抜けの様な状態になるだけでその他の操作は行われず、追加の際も歯抜け部分か新しいブロックに追加するために要素の大移動も発生しません。  
ブロック内要素はメモリ上で連続しており、歯抜けとなっている部分があるので参照局所性が若干低下しますが、`std::vector/deque`に次いでイテレーションを高速に行うことができます。

`std::colony`は要素の順序が重要ではなく、要素が外部から参照されていて挿入や削除が頻繁に行われるようなシーンで有効です。筆者の方は、特にゲーム開発や数値シミュレーションの世界で頻繁に利用されていると述べています。

```cpp
#include <colony>

int main() {
  std::colony<int> col = {1, 3, 3, 5};

  // 要素の削除（他の要素は移動されない）
  col.erase(col.begin() + 1);

  // 要素の追加（歯抜け部分があれば再利用される）
  col.insert(7);

  for (int n : col) {
    std::cout << n << '\n'; // 要素の順序は実装定義（この場合は多分 1, 7, 3, 5）
  }
}
```

- [PLF C++ Library - plf::colony](https://plflib.org/colony.htm)
- [P0447 進行状況](https://github.com/cplusplus/papers/issues/328)

### [P0849R5 auto(x): decay-copy in the language](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0849r5.html)

### [P0401R4 Providing size feedback in the Allocator interface](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0401r4.html)

アロケータが実際に確保したメモリのサイズをフィードバックすることのできるメモリ確保インターフェースを追加する提案。

説明は次の項で。

- [P0901R7 Size feedback in operator new](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0901r7.html)
- [P0958 進行状況](https://github.com/cplusplus/papers/issues/401)

### [P0901R7 Size feedback in operator new](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0901r7.html)


`::operator new`が実際に確保したメモリのサイズを知ることができるオーバーロードを追加する提案。

例えば次のような`std::vector::reserve()`の呼び出し（一度目）では、使用される`operator new`が実際に37バイト丁度を確保する、という事はほぼありません（アライメントの制約やパフォーマンスの向上など、実装の都合による）。

```cpp
std::vector<char> v;
v.reserve(37);
// ...
v.reserve(38);
```

しかし、それを知る方法は無いため、2回目の`reserve(38)`無くして38バイト目を安全に使用する方法はありません。

`std::vector::reserve()`は典型的には次のような実装になります。

```cpp
void vector::reserve(size_t new_cap) {
  if (capacity_ >= new_cap) return;
  const size_t bytes = new_cap;
  void *newp = ::operator new(new_cap);
  memcpy(newp, ptr_, capacity_);
  ptr_ = newp;
  capacity_ = bytes;
}
```

`capacity_`というのが使用可能なメモリ量を記録している`std::vector`のメンバとなりますが、これはあくまでユーザーが指定した値`new_cap`で更新されます。3行目の`::operator new`が実際に確保している`new_cap`を超える部分の領域サイズを知る方法はありません。

僅かではあるのでしょうが、この余剰部分の量を知ることができればメモリ確保を行う回数を削減することができる可能性があります。

この提案は`::operator new()`にオーバーロードを追加し、戻り値としてその実際に確保した領域サイズとポインタを受け取れるようにするものです。

```cpp
namespace std {
  struct return_size_t {
    explicit return_size_t() = default;
  };

  inline constexpr return_size_t return_size{};

  template<typename T = void>
  struct sized_allocation_t {
    T *p;
    size_t n;
  };

  [[nodiscard]]
  std::sized_allocation_t ::operator new(size_t size, std::return_size_t);
  // その他オーバーロード省略
}
```

`std::return_size_t`というのは単なるタグ型で、`std::return_size`はそのオブジェクトです。

これによって、先ほどの`reserve()`実装は次のように改善できます。

```cpp
void vector::reserve(size_t new_cap) {
  if (capacity_ >= new_cap) return;
  const size_t bytes = new_cap;
  auto [newp, new_size] = ::operator new(new_cap, return_size);  // 実際の確保サイズを受け取る
  memcpy(newp, ptr_, capacity_);
  ptr_ = newp;
  capacity_ = new_size; // 実際に使用可能なサイズでキャパシティを更新
}
```

P0401R4は同じものをアロケータに対しても導入するものです。こちらは`std::allocate_at_least`という関数にアロケータとサイズを渡すことで`new`の時と同じことをします。

- [P0401R4 Providing size feedback in the Allocator interface](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0401r4.html)
- [P0901 進行状況](https://github.com/cplusplus/papers/issues/18)

### [P1012R1 Ternary Right Fold Expression](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1012r1.pdf)

条件演算子（三項演算子）で右畳み込み式を利用できるようにする提案。

例えば次のように利用できます。

```cpp
#include <functional>
#include <stdexcept>

// なんか処理
template<std::size_t i>
int f();

template <std::size_t... is>
int test_impl(std::size_t j, std::index_sequence<is...>) {
  // j >= n の時は例外を投げたいとする

  // この提案による条件演算子に対する右畳み込み式の利用
  return ( (j == is) ? f<is>() : ... : throw std::range_error("Out of range") );
}

template <std::size_t n>
int test(std::size_t j) {
  // 実行時の値jによってf<j>()を呼び出す
  return test_impl(j, std::make_index_sequence<n>());
}
```

これは次のような展開を行うものです。

```cpp
// 展開前
(C ? E : ... : D)

// 展開後
(C(arg1) ? E(arg1)
         : ( C(arg2) ? E(arg2)
                     : (...( C(argN-1) ? E(argN-1)
                                       : D )...)))
```

Cは条件式、Eは格段のCが`true`の場合に実行される式、Dはすべての条件が`false`の時に実行される式になり、CとEがパラメータパックを含むことができます。

またこの提案では同時に、条件演算子の2番目か3番目のオペランドに`[[noreturn]]`な関数を指定したときに`throw`式と同等の扱いを受けるように変更することも提案しています。

- [C++17 畳み込み式 - cpprefjp](https://cpprefjp.github.io/lang/cpp17/folding_expressions.html)
- [P1012 進行状況](https://github.com/cplusplus/papers/issues/302)

### [P1018R7 C++ Language Evolution status - pandemic edition - 2020/03–2020/10](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1018r7.html)
### [P1102R1 Down with ()!](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1102r1.html)
### [P1206R3 ranges::to: A function to convert any range to a container](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1206r3.pdf)
### [P1478R5 Byte-wise atomic memcpy](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1478r5.html)
### [P1885R4 Naming Text Encodings to Demystify Them](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1885r4.pdf)
### [P1950R1 An indirect value-type for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1885r4.pdf)
### [P2012R0 Fix the range-based for loop, Rev0ix the range-based for loop](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2012r0.pdf)
### [P2160R1 Locks lock lockables (wording for LWG 2363)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2160r1.html)
### [P2164R3 views::enumerate](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2164r3.pdf)
### [P2181R1 Correcting the Design of Bulk Execution](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2181r1.html)
### [P2182R1 Contract Support: Defining the Minimum Viable Feature Set](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2182r1.html)
### [P2211R0 Exhaustiveness Checking for Pattern Matching](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2211r0.pdf)
### [P2212R2 Relax Requirements for time_point::clock](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2212r2.html)
### [P2233R1 2020 Fall Library Evolution Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2233r1.html)
### [P2233R2 2020 Fall Library Evolution Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2233r2.html)
### [P2242R0 Non-literal variables (and labels and gotos) in constexpr functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2242r0.html)
### [P2246R0 Character encoding of diagnostic text](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2246r0.pdf)
### [P2247R0 2020 Library Evolution Report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2247r0.html)
### [P2248R0 Enabling list-initialization for algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2248r0.html)
### [P2250R0 Scheduler vs Executor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2250r0.pdf)
### [P2251R0 Require span & basic_string_view to be Trivially Copyable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2251r0.pdf)
### [P2253R0 SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2253r0.html)
### [P2254R0 Executors Beyond Invocables](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2254r0.pdf)
### [P2255R0 A type trait to detect reference binding to temporary](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2255r0.html)
### [P2257R0 Blocking is an insufficient description for senders and receivers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2257r0.html)
### [P2259R0 Repairing input range adaptors and counted_iterator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2259r0.html)
### [P2260R0 WG21 2020-11 Virtual Meeting Record of Discussion](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2260r0.pdf)