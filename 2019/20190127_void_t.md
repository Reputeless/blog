# ［C++］void_tとその周辺

#### std::void_t

void_tとは以下のようなエイリアステンプレートです。[tex:f:Ts... \to void]な感じのメタ関数になります。

```cpp
template<typename Ts...>
using void_t = void;
```

あらゆる型のベクトルを受け取りvoidへ写します。こんなもんが一体何の役に立つというのか？というと、detection idiomと呼ばれる手法に使われます（というかそれ以外の使い方を知らない）。

#### detection idiom

detection idiomとは、void_tを利用してある型が持つ特性や適用可能な操作をコンパイル時に検出する手法です。

```cpp
#include <iostream>
#include <type_traits>
#include <vector>

template<class, template<class> class, class = std::void_t<>>
struct detect : std::false_type {};

template<class T, template<class> class Check>
struct detect<T, Check, std::void_t<Check<T>>> : std::true_type {};

template<class T>
using is_metafunction_checker = typename T::type;

template<class T>
using is_metafunction = detect<T, is_metafunction_checker>;

template<class T>
using is_addable_checker = decltype(std::declval<const T&>() + std::declval<const T&>());

template<class T>
using is_addable = detect<T, is_addable_checker>;


int main()
{
  std::cout << std::boolalpha;

  //::typeを持っているか（メタ関数であるか）の検出
  std::cout << is_metafunction<int>::value << std::endl; //false
  std::cout << is_metafunction<std::add_pointer<int>>::value << std::endl; //true

  //足し算ができるかの検出
  std::cout << is_addable<int>::value << std::endl; //true
  std::cout << is_addable<std::vector<int>>::value << std::endl; //false
}
```
この例だと、入れ子型の::typeを持っているか、同じ型を引数にとるoperator+を実装しているか、を検出しています。

void_tを使っているのは実質一番上のdetectクラスだけです。このdetectクラスにある型TとTを一つ引数にとるメタ関数を渡すことで、そのメタ関数が実行可能かによって任意の性質をチェックします。

このdetectクラスはdetection idiomに頻出するコードをまとめただけのクラスです。

```cpp
template<class, template<class> class, class = std::void_t<>>
struct detect : std::false_type {};

template<class T, template<class> class Check>
struct detect<T, Check, std::void_t<Check<T>>> : std::true_type {};
```

テンプレートの部分特殊化を利用してfalse_typeとtrue_typeの分岐を行っています。

#### int_tあるいはdouble_tもしくは任意のT_t

#### クラステンプレートの部分特殊化

#### 参考文献
- [std::void_t - cpprefjp](https://cpprefjp.github.io/reference/type_traits/void_t.html)
- [Proposing Standard Library Support for the C++ Detection Idiom, v2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf)