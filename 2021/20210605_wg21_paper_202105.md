# ［C++］WG21月次提案文書を眺める（2021年05月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2021 mailing2021-05](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/#mailing2021-05)

全部で44本あり、SG22（C/C++相互互換性に関する研究グループ）のCの提案を除くと37本になります。

[:contents]

### [P0009R11 MDSPAN](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0009r11.html)
↓
### [P0009R12 MDSPAN](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0009r12.html)

多次元配列に対する`std::span`である、`mdspan`の提案。

`mdspan`は、*multi dimensional span*の略で、連続したメモリ領域を多次元配列として参照するものです。

```cpp
int* data = /* ... */

// dataをint要素4つの連続したメモリ領域として参照
auto s = std::span<int, 4>(data);

// dataをint型2x2行列の連続したメモリ領域として参照
auto ms = std::mdspan<int, 2, 2>(data);

// 要素アクセス
ms(1, 1) = 1;
ms(0, 1) = 1;
```

`std::span`と同様に、動的な要素数を指定することもできます。

```cpp
int* data = /* ... */
int size = /* ... */

auto s = std::span<int, std::dynamic_extent>(data, size);

int rows = /* ... */
int cols = /* ... */
auto ms = std::mdspan<int, std::dynamic_extent, std::dynamic_extent>(data, rows, cols);
```

`mdspan`は`std::span`よりも柔軟に設計されており、レイアウトマッピングや要素へのアクセス方法などをポリシークラスによって変更することができます。

```cpp
namespace std {
  template <
    class T,
    class Extents,
    class LayoutPolicy = std::layout_right,
    class Accessor = std::accessor_basic
  >
  class basic_mdspan;

  template <class T, ptrdiff_t... Extents>
  using mdspan = basic_mdspan<T, std::extents<Extents...>>;
}
```

`LayoutPolicy`は多次元インデックス（整数値の列`i0, i1, ..., in`）をメモリ上の一点を指す単一のインデックス（整数値`i`）に変換するもので、`Accessor`は`LayoutPolicy`によって得られたインデックスとメモリを指すポインタを要素1つの参照へ変換するものです。

```cpp
template <
    class T,
    class Extents,
    class LayoutPolicy = std::layout_right,
    class Accessor = std::accessor_basic
  >
  class basic_mdspan {
  public:
    using extents_type = Extents;
    using layout_type = LayoutPolicy;
    using accessor_type = AccessorPolicy;
    using mapping_type = typename layout_type::template mapping_type<extents_type>;

  private:
    accessor_type acc_{};
    mapping_type map_{};
    pointer ptr_{};

  public:

    template<class... SizeTypes>
    constexpr reference operator()(SizeTypes... indices) const noexcept {
      // LayoutPolicyによってインデックス列を連続領域への単一インデックスに変換し
      // Accessorによって、インデックスとポインタから要素を引き当てる
      return acc_.access(ptr_, map_(indices...));
    }
  }
```

例えば`double`の2次元配列ならば、`LayoutPolicy`はインデックス`x, y`と配列の幅`w`を用いて、`i = y * w + x`を返し、`Accessor`はそれと領域へのポインタ`ptr`用いて`ptr[i]`を返すものになります。

また、`submdspan()`という関数によって、`mdspan`からsliceを取得することができます。

```cpp
namespace std {

  // [mdspan.submdspan], submdspan creation
  template<class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
      constexpr basic_mdspan<see below>
      submdspan(const basic_mdspan<ElementType, Extents, LayoutPolicy, AccessorPolicy>& src, 
                SliceSpecifiers... slices) noexcept;
}
```

提案文書より、使用例

```cpp
// メモリ領域へのマッピングを作成（LayoutPolicyの作成）
using Extents3D = extents<3, dynamic_extent, 7>;
layout_right::template mapping<Extents3D> map_right(10);

// メモリ領域確保
int* ptr = new int[3 * 8 * 10];

// mdspanの構築（3x10x7の三次元行列として参照）
basic_mdspan<int,Extents3D,layout_right> a(ptr, map_right);

// mdspnによる領域の初期化
for(int i0 = 0; i0 < a.extent(0); i0++) // i0 = 0 -> 2
  for(int i1 = 0; i1 < a.extent(1); i1++) // i1 = 0 -> 9
    for(int i2 = 0; i2 < a.extent(2); i2++) // i2 = 0 -> 7
      a(i0, i1, i2) = 10000 * i0 + 100 * i1 + i2;

// subspanの取得（あるいは、sliceの取得）
// [1, [4...5], [1...5]]の範囲を参照するmdspanを得る
auto a_sub = submdspan(a, 1, pair<int, int>(4, 6), pair<int, int>(1, 6));

// subspanの内容を出力
for(int i0 = 0; i0 < a_sub.extent(0); i0++) {
  for(int i1 = 0; i1 < a_sub.extent(1); i1++) {
    cout << a_sub(i0, i1) << " ";
  }
  cout << endl;
}

/* Output
10401 10402 10403 10404 10405
10501 10502 10503 10504 10505
*/
```

この提案は線形代数ライブラリ整備の一環として、Liblary Fundamentals v3に向けて議論されています。現在はLWGにて検討中です。

- [std::span - cpprefjp](https://cpprefjp.github.io/reference/span/span.html)
- [A Gentle Introduction to mdspan - kokkos/mdspan](https://github.com/kokkos/mdspan/wiki/A-Gentle-Introduction-to-mdspan)
- [kokkos/mdspan - Github](https://github.com/kokkos/mdspan/)
- [P1478 進行状況](https://github.com/cplusplus/papers/issues/370)

### [P0447R14 Introduction of std::colony to the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0447r14.html)
### [P0493R2 Atomic maximum/minimum](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0493r2.pdf)
### [P0798R6 Monadic operations for std::optional](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0798r6.html)
### [P1018R10 C++ Language Evolution status - pandemic edition - 2021/04](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1018r10.html)
### [P1068R5 Vector API for random number generation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1068r5.pdf)
### [P1122R4 Proposed Wording for Concurrent Data Structures: Read-Copy-Update (RCU)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1122r4.pdf)
### [P1328R1 Making std::type_info::operator== constexpr](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1328r1.html)
### [P1701R2 Inline Namespaces: Fragility Bites](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1701r2.pdf)
### [P2013R4 Freestanding Language: Optional ::operator new](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2013r4.html)
### [P2066R7 Suggested draft TS for C++ Extensions for Minimal Transactional Memory](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2066r7.html)
### [P2093R6 Formatted output](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2093r6.html)
### [P2136R3 invoke_r](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2136r3.html)
### [P2138R4 Rules of Design<=>Specification engagement](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2138r4.html)
### [P2168R3 generator: A Synchronous Coroutine Generator Compatible With Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2168r3.pdf)
### [P2280R2 Using unknown references in constant expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2280r2.html)
### [P2291R1 Add Constexpr Modifiers to Functions to_chars and from_chars for Integral Types in Header](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2291r1.pdf)
### [P2299R1 `mdspan` and CTAD](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2299r1.html)
↓
### [P2299R2 `mdspan` and CTAD](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2299r2.html)
### [P2314R2 Character sets and encodings](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2314r2.html)
### [P2325R3 Views should not be required to be default constructible](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r3.html)
### [P2328R1 join_view should join all views of ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2328r1.html)
### [P2334R1 Add support for preprocessing directives elifdef and elifndef](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2334r1.pdf)
### [P2351R0 Mark all library static cast wrappers as [[nodiscard]]](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2351r0.pdf)
### [P2367R0 Remove misuses of list-initialization from Clause 24](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2367r0.html)
### [P2368R0 2020 Winter Library Evolution Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2368r0.html)
### [P2372R0 Fixing locale handling in chrono formatters](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2372r0.html)
↓
### [P2372R1 Fixing locale handling in chrono formatters](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2372r1.html)
### [P2374R0 views::cartesian_product](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2374r0.html)
↓
### [P2374R1 views::cartesian_product](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2374r1.html)
### [P2375R0 Generalisation of nth_element to a range of nths](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2375r0.pdf)
### [P2376R0 Comments on Simple Statistical Functions (p1708r4): Contracts, Exceptions and Special cases](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2376r0.pdf)
### [P2377R0 [[nodiscard]] in the Standard Library: Clause 23 Iterators library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2377r0.html)
### [P2378R0 Properly define blocks as part of the grammar](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2378r0.pdf)
### [P2380R0 reference_wrapper Associations](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2380r0.pdf)
### [P2381R0 Pattern Matching with Exception Handling](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2381r0.html)
### [P2382R0 Presentation Slides for P2123R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2382r0.pdf)