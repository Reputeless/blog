# ［C++］オブジェクト生存期間とC++のポインタ意味論

この記事は規格書や提案書の様々な部分から感じ取れる規格文書の気持ちについての私の理解をまとめたものであり、必ずしも根拠や出典が明記されていない場合があり、内容も間違っている可能性があります。いわばポエムです。

この記事では変数に対して`&`を適用して得られる何かのことをポインタと呼んでいます。例えば、`T* p = &t;`において、`&t`の結果の事をポインタと呼び、`p`の事はポインタ変数として呼び分けます。さらに、`T*`の事をポインタ型と呼びます。

[:contents]

### `reinterpret_cast`によるpunning

`reinterpret_cast`によるtype punningが未定義となる次のコードをもう一度見てみます。

```cpp
#include <bit>

std::uint64_t punning(double v) {
  auto* p reinterpret_cast<const std::uint64_t*>(&v); // vには当然、double型のオブジェクトが生存期間内にある
  return *p;  // ub、pの参照先ではuint64_tのオブジェクトが生存期間内にない
}
```

このコードから読み取れる事は、ポインタが我々（誰？）の思っているような物ではないのではないか？という事です。

ポインタとはアドレスでありアドレスはメモリ空間のどこか一点を指している整数値、というのがよくあるポインタの認識かと思います。そのようなメンタルモデルに従えば、このコードから問題を見出す事はできないし、生存期間がーと言われても釈然としないものがあります。さらにいえば、`union`による方法が動作するはずという考えはそのようなメンタルモデルの延長線上にあります。

### ポインタはオブジェクトのエイリアスです！

現代（少なくともC++20時点）のC++において、ポインタとはオブジェクトのエイリアス（別名）です。メモリのアドレスを示す整数値ではありません。

そのため、ポインタの有効期間はエイリアス元のオブジェクトの生存期間にリンクしています。ポインタ取得後に取得元オブジェクトの生存期間が終了した場合、そのポインタは無効なポインタとなり、ほぼすべての操作が未定義動作になります。

#### エイリアス？

例えば、ローカルスコープのオブジェクトは初期化されその生存期間が開始する時に、同時に名前が付けられます。

```cpp
int main() {
  int a = 0;  // int型のオブジェクトを0で初期化し作成、aという名前をつける

  // aという名前を介してオブジェクトにアクセスできる
  a = 10;
  int a2 = a; // a2とaは別のオブジェクト
}
```

この名前は一度つけると変更できず、通常名前の有効期間はオブジェクトの生存期間と一致するため、オブジェクトとこの名前は同一視することができます。

一度名付けられたオブジェクトは名前と一対一対応しておりそれを切り離す事はできませんが、オブジェクトには別の名前をつけて扱うことができます。このオブジェクトの別名のことをエイリアスと呼びます。

```cpp
int main() {
  int a = 0;  // int型のオブジェクトを0で初期化し作成、aという名前をつける

  // オブジェクトaのエイリアス（別名）
  int& b = a;
  int* c = &q;

  // エイリアスを介してもオブジェクトにアクセスできる
  b = 10;
  *c = 20;

  int a2 = b;
  int a3 = *c;
}
```

また、ヒープ領域に構築されたオブジェクトには名前をつけることができないため、エイリアスを介してしかアクセスできません。

C++における最も基本的なエイリアスは参照であり、ポインタもまたエイリアスの一種です。

ところで、参照とポインタ以外にC++にはもう一つエイリアスが存在しています。それは限られた状況でしか出現しないのですが、さてそれは何でしょう・・・？

#### ポインタの実装

ポインタとはオブジェクトのエイリアスである、というのはC++の意味論においての話でその実装は多くの場合メモリアドレスによって行われます。その場合でも、C++の意味論におけるポインタはオブジェクトのエイリアスでしかなく、単なるメモリアドレス値だと思って行うことのできる多くの操作には保証がありません。

ただし、先に生まれたのはメモリアドレスとしてのポインタであり、現代の実行環境はほぼその時の実体と互換性があるので、多くの技法は実際には意図通りに動作するでしょう。これがまた、話をややこしくしている原因の一つでもあります・・・

### ストレージのエイリアスとしてのポインタ

ポインタが参照と異なるのは、ポインタがもう一つ役割を持ってしまっていることです。それは、オブジェクトの配置されている領域（以降、単にストレージと呼ぶ）を指すものという役割で、あえてそろえて言えば、ストレージのエイリアスとしての役割を持っていることです。

特に、エイリアス元オブジェクトの生存期間が先に終了し無効となったポインタは、ストレージのエイリアスとしてしか有効に使用できません。

ストレージのエイリアスとしてのぽいんたは多分にメモリアドレス的ですが、ここでは単にストレージのエイリアスとしか言っていません。実装としてメモリアドレスを使用することはできますが（そしてほとんどの場合そうなりますが）、C++意味論としてはこれはメモリアドレスではありません。

この観点からは、参照とはポインタからオブジェクトのエイリアスとしての意味論だけを抽出したもの（ストレージのエイリアスとしての役割を取り払ったもの）と見ることもできます。

#### ストレージの再利用

オブジェクトのストレージはオブジェクトの生存期間後も有効である可能性があり、その場合再利用することができます。このストレージの再利用のルールは、オブジェクトのエイリアスの性質にいくつか例外規定を加えています。

```cpp
int main() {
  int n = 0;    // オブジェクト（o1とする）を作成し、nと名付ける
  int& r = n;   // rはn（o1）のエイリアス
  int* p = &n;  // pはn（o1）のエイリアス

  std::destruct_at(&n); // o1の生存期間が終了、nのストレージは有効

  int* p2 = new(&n) int{10};  // nのストレージを再利用、オブジェクト（o2とする）を作成

  std::cout << n << "\n";   // ok、nはo2を参照する
  std::cout << r << "\n";   // ok、rはo2のエイリアスとなる
  std::cout << *p << "\n";  // ok、pはo2のエイリアスとなる
}
```

同じストレージを再利用して同じ型のオブジェクトを構築すると、元のオブジェクトの名前とエイリアスは自動的にその同じストレージの異なるオブジェクトの名前/エイリアスとなります。

ただし、この場合のplacement `new`の際に`int`型以外のオブジェクトを作成した場合は`n`をそのオブジェクト名として使用できません。なぜなら、`n`の参照先ストレージには`int`型のオブジェクトが生存期間内に無いためです。


### 配列のポインタ？

よく知られているように、配列オブジェクト（の名前及びエイリアス）はかなりの場所で配列の先頭オブジェクトへのポインタに変換されます。また、そのように取得したポインタは整数値との演算によって配列内の別の要素のポインタとして扱うことができ、さらには、配列の最後の要素の1つ後ろのポインタ（オブジェクトが存在しない場所）は特別に存在が許されています。そして、ポインタは順序付け比較が可能だと思われています。これらの性質はポインタがメモリアドレスであることを前提としており、それを雄弁に物語っているように見えるかもしれません。

ポインタのこれらの性質は、生配列に対するイテレータの役割をポインタに担わせてしまった結果の産物であり、歴史的経緯によるものに過ぎません。配列型から取得したポインタはイテレータであり、それはポインタとは異なるものと思うのが良いでしょう。また、ポインタの順序付け比較は通常同じ配列内や同じクラス内のサブオブジェクト間でのみ定義されており、任意のポインタの間で可能ではありません。これもまた、配列のインデックス順序によってイテレータ順序を定義しようとした際にそれをアドレスとしてのポインタ値をベースとして規定し、それをポインタに対する一般的性質に昇格させてしまった結果です。

配列に対する配列ポインタの誕生は、人類がイテレータ概念を獲得した瞬間でもありますが、ポインタとイテレータを同一視してしまったのは後に禍根を残す永遠の失敗です。実装がポインタだったとしても、意味論としてポインタとは区別するべきでした。

もちろん歴史的にはイテレータは配列ポインタを抽象化することで得られたものです。しかしそれは歴史でしかなく、現代のポインタ意味論からすると黒歴史です。

### Strict Aliasing Rule


### `std::launder`

### `reinterpret_cast`

### Pointer lifetime-end zap

### Pointerのprovenance

### pointer interconvertible

### implicitly create objects

### implicit-lifetime types

### 参考文献

- [`std::bit_cast` - cpprefjp](https://cpprefjp.github.io/reference/bit/bit_cast.html)
- [`std::bit_cast` - cppreference](https://en.cppreference.com/w/cpp/numeric/bit_cast)
- [bit_cast 実装イメージと未定義動作の話・ Issue #664 - cpprefjp/site](https://github.com/cpprefjp/site/issues/664)
- [（翻訳）C/C++のStrict Aliasingを理解する または - どうして#$@##@^%コンパイラは僕がしたい事をさせてくれないの！ - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20120220/p1)
- [Lifetime - cppreference](https://en.cppreference.com/w/cpp/language/lifetime)
- [P0593R6 Implicit creation of objects for low-level object manipulation](https://wg21.link/p0593r6)
- [What is the Strict Aliasing Rule and Why do we care? - Github](https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8)
- [旧石器時代のポインタをご利用の皆様へ ～provenance入門～ - Qiita](https://qiita.com/__pandaman64__/items/1788a90ae5be79cc908b)
