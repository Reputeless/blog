# ［C++］カスタマイゼーションポイントオブジェクト（CPO）

C++20以降の必須教養となるであろうカスタマイゼーションポイントオブジェクトですが、その利便性の高さとは裏腹に理解が難しいものでもあります。これはその理解の一助となるべく私の頭の中の理解を書き出したメモ帳です。

### C++17までのカスタマイゼーションポイントの問題点

C++17までにカスタマイゼーションポイントとなっていた関数（例えば`std::begin()/std:::end(), std::swap()`など）にはアダプトして動作をカスタマイズするためのいくつかの方法が用意されており、より柔軟に自分が定義した型でアダプトできるようになっています。しかしその一方、それによって使用するときに少し複雑な手順を必要としていました。例えば`std::begin()`で見てみると

```cpp
// イテレート可能な範囲を受けて何かする関数
template<typename Container>
void my_algo(Container&& rng) {
  using std::begin;

  // 先頭イテレータを得る
  auto first = begin(rng);
}
```

真にジェネリックに書くためにはこのように「`std::begin()`を`using`してから、`begin()`を名前空間修飾なしで呼び出す」という風に書くことで、`std`名前空間のもの及び配列には`std::begin()`が、ユーザー定義型に対しては同じ名前空間内にある`begin()`あるいは`std::begin()`を通してメンバ関数の`begin()`が呼び出されるようになります。しかし、手順1つ間違えただけでその`begin()`の呼び出しはたちまち汎用性を失います。これは`std:::end(), std::swap()`でも同じです。

C++17までのカスタマイゼーションポイントにはこのように、その正しい呼び出し方法が煩雑でそれを理解するにはC++を深めに理解する事が求められるなど、使いづらいという問題があります。

また、このようなカスタイマイゼーションポイントは標準ライブラリをよりジェネリックにするために不可欠な存在ですが、標準ライブラリはそのカスタマイゼーションポイントの名前（関数名）だけに着目して呼び出しを行うため、同名の全く異なる意味を持つ関数が定義されていると未定義動作に陥ります。特に、ADLが絡むとこれは発見しづらいバグを埋め込む事になるかもしれません。したがって、カスマイゼーションポイントを増やすと言う事は実質的に予約されている名前が増える事になり、ユーザーは注意深く関数名を決めなければならないなど負担を負うことになります。

C++20からのコンセプトはそのような問題を解決します。その呼び出しにおいてコンセプトを用いて対象の型が制約を満たしているかを構文的にチェックするようにし、カスタマイゼーションポイントに不適合な場合はオーバーロード候補から外れるようにする事で、ユーザーがカスタマイゼーションポイントとの名前被りを気にしなくても良くなります。結果的に、標準ライブラリにより多くのカスタマイゼーションポイントを設ける事ができるようになります。

しかし、コンセプトによって制約されたC++20カスタマイゼーションポイントの下では、先程のC++17までのカスタマイゼーションポイント使用時のベストプラクティスコードがむしろ最悪のコードになってしまうのです。

```cpp
namespace std {

  // rangeコンセプトを満たす型だけが呼べるように制約してある新しいbegin()関数
  template<std::ranges::range C>
  constexpr auto begin(C& c) -> decltype(c.begin());  // (1)
}

namespace myns {

  struct my_struct {};

  // イテレータを取得するものではないbegin()関数
  bool begin(my_struct&);  // (2)
}


template<typename Container>
void my_algo(Container&& rng) {
  using std::begin;

  // 先頭イテレータを得る、はずが・・・
  auto first = begin(rng);  // my_structに対しては(2)が呼び出される
}

int main() {
  myns::my_struct st{};

  my_algo(st);  // ok、呼び出しは適格
}
```

[[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ](https://wandbox.org/permlink/S5WPo8Oui5NSHOxZ)

このように、せっかくコンセプトで制約したにも関わらずADL経由で制約を満たさない`begin()`が呼ばれています。別の見方をすれば、コンセプトによる制約を簡単に迂回できてしまっています。

これでは結局ユーザーはカスタマイゼーションポイント名を気にしてコードを書かなければならなくなるし、カスタマイゼーションポイントがコンセプトによって制約してあっても意味がなくなってしまいます・・・・

### Customization Point Object(CPO)

カスタマイゼーションポイントオブジェクト（*Customization Point Object*）はこれら2つの問題を一挙に解決しつつ、将来的なカスタマイゼーションポイントの拡張も可能にしている素敵な魔法のようなすごいやつです！

例えば[`begin()`](https://timsong-cpp.github.io/cppwp/n4861/range.access.begin)で言えば次のよう定義されます。

```cpp
namespace std::ranges {
  inline namespace /*unspecified*/ {

    inline constexpr /*unspecified*/ begin = /*unspecified*/;
  }
}
```

`unspecified`なところは名前や型が規定されていない（実装定義である）ことを意味します。そして、この`begin`は関数オブジェクトです。`std::ranges::begin(E)`のように呼び出してさも関数であるかのように使います。

`std::ranges::begin(E)`のように呼ばれた時、その引数の式`E`によって以下のいずれかの処理を実行します（以下、`T`は`E`の型、`t`は式`E`の結果となる左辺値）。上から順番に考量していきます。

1. `E`が右辺値であり、`std::ranges::enable_­borrowed_­range<remove_­cv_­t<T>> == false`ならば、呼び出しは不適格。
2. `T`が配列型であり、 `std::remove_­all_­extents_­t<T>`が不完全型ならば、呼び出しは不適格（診断不要）。
3. `T`が配列型であれば、`std::ranges::begin(E)`は式`t + 0`と*expression-equivalent*
4. `decay-copy(t.begin())`が有効な式であり、その結果の型が[`std::input_or_output_iterator`](https://cpprefjp.github.io/reference/iterator/input_or_output_iterator.html)コンセプトのモデルとなる（満たす）場合、`decay-copy(t.begin())`
5. `T`がクラス型か列挙型であり、`decay-copy(begin(t))`が有効な式であり、その結果の型が`std::input_or_output_iterator`コンセプトのモデルとなり、被修飾の`begin()`に対する名前探索が以下2つの宣言だけを含むコンテキストでオーバーロード解決が実行される場合、`std::ranges::begin(E)`はそのコンテキストで実行されるオーバーロード解決を伴う`decay-copy(begin(t))`と*expression-equivalent*
```cpp
// std::begin()を含まないコンテキストでオーバーロード解決をするということ
void begin(auto&) = delete;
void begin(const auto&) = delete;
```

「式Aは式Bと*expression-equivalent*」というのは簡単に言うと式Aの効果は式Bと等価であり、式Aが例外を投げるかと定数実行可能かどうかも式Bと等価と言うことです。この場合の式Bは引数`E`由来なので、`std::ranges::begin(E)`の呼び出しが例外を投げるかどうかと定数実行可能かどうかは引数の型次第と言うことになります。

詳しく見ていくと、1,2番目の条件はまず呼び出しが適格ではない事が型レベルで分かるものを弾く条件です。`enable_­borrowed_­range`と言うのは右辺値の*range*であってもイテレータを取り出して操作する事が安全に行えるかを示す`bool`値です（たぶん）。  
3番目以降が`begin()`の主たる効果です。3番目は配列の先頭のポインタを返します。`t + 0`となってるのは明示的にポインタであることを表現しているんでしょうか、よくわかりません・・・  
4番目はメンバ関数として定義された`begin()`を呼び出します。標準ライブラリのほとんどの型がこれに当てはまります。
5番目は同じ名前空間にある`begin()`を探して呼び出すものです（*Hidden friends*もここで探し出されます）。この時、`std::begin()`を見つけないようにするためにオーバーロード解決についての指定がなされています。

ユーザーがこの`begin()`にアダプトするときは、4番目か5番目に適合するようにしておきます。つまり、従来とやることは変わりません。一方、この`begin()`を使用する場合は逆に従来のような煩雑コードを書かなくてもよくなります。これまでやっていたことと同等（以上）のことを中で勝手にやってくれるようになります。

```cpp
template<typename Container>
void my_algo(Container&& rng) {
  // using std::beginしなくても、同じことを達成でき、よりジェネリック！
  auto first = std::ranges::begin(rng);
}
```

これによってまず、1つ目の問題（呼び出しが煩雑、使いづらい）が解消されている事がわかるでしょう。

さらに、ユーザー定義型に対しても行われうる4,5番目の処理では、戻り値型にコンセプトによる制約が要求されています。[`std::input_or_output_iterator`](https://cpprefjp.github.io/reference/iterator/input_or_output_iterator.html)はインクリメントや間接参照等イテレータに要求される最小限のことを制約するコンセプトで、これによって使用される`begin()`がイテレータを返さない場合に`std::ranges::begin(E)`の呼び出しが不適格になります。そして、カスタマイゼーションポイントの呼び出しが診断可能な不適格となる場合は単にオーバーロード解決の候補から外れ、他に候補があれば別の適切な関数が呼び出されることになります。

```cpp
namespace myns {

  struct my_struct {};

  // イテレータを取得するものではないbegin()関数
  bool begin(my_struct&);
}

int main() {
  myns::my_struct st{};

  std::ranges::begin(st);  // ng、戻り値型がinput_or_output_iteratorを満たさないためコンパイルエラー
}
```

こうして、2つ目の問題の一部（別の意味を持つ関数も呼び出してしまう）も解決されている事がわかりました。

#### 関数オブジェクトとADL

最後に残ったのは、ADLによってカスタマイゼーションポイント呼び出しをフックできる、あるいは要求される型制約を無視できてしまう問題です。これはCPOが関数オブジェクトである事によって防止されます。

C++における名前探索では修飾名探索と非修飾名探索を行なった後、引数依存名前探索（ADL）によって名前探索を行いオーバーロード候補集合を決定します。この時、非修飾名探索の結果に関数以外のものが含まれているとADLは行われません。逆に言うと、ADLは関数名に対してしか行われません。つまり、関数オブジェクトに対してはADLは発動しません（[6.5.2 Argument-dependent name lookup [basic.lookup.argdep]](https://timsong-cpp.github.io/cppwp/n4861/basic.lookup.argdep#3.3)）。

カスタマイゼーションポイントオブジェクトが関数オブジェクトであることによって、`using`して使った時でも同名の関数によってADLでフックする事は出来なくなります。

```cpp
namespace myns {

  struct my_struct {};

  // イテレータを取得するものではないbegin()関数
  bool begin(my_struct&);
}


template<typename Container>
void my_algo(Container&& rng) {
  using std::ranges::begin;

  // 先頭イテレータを得る
  auto first = begin(rng);  // my_structに対しては呼び出しが不適格
}

int main() {
  myns::my_struct st{};

  my_algo(st);  // ng
}
```
[[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ](https://wandbox.org/permlink/ynCs7ZgrnjfUK29g)

これによって、C++17までのカスタマイゼーションポイントに存在した問題が全て解決されている事が確認できました。

#### *Template Method*

もし未来の世界で、イテレータを取得するのに`begin()`だけではなく別の方法が追加された場合を考えてみます。例えば、`first()`関数が今の`begin()`と同じ意味を持ったとします。その世界で統一的な操作として`std::ranges::begin`を使い続けるにはどうすればいいでしょうか？また、ユーザーは何をすべきでしょう？

答えは簡単です。先ほど5つほど羅列されていた`std::ranges::begin`の条件にもう2つほど加えるだけです。標準ライブラリの実装は修正が必要ですが、それを利用するユーザーが何かする必要はありません。`first()`関数がイテレータを返すようになった世界でも`std::ranges::begin`を使い続けていれば何も変更する事なくイテレータを得る事ができます。

このように、C++20のカスタマイゼーションポイントオブジェクトはカスタマイゼーションポイントを追加する方向の変更に対して閉じています（おそらく削除する変更は行われない）。ユーザー目線で見れば、そのような変更が行われたとしてもカスタマイゼーションポイントオブジェクトのインターフェースは常に安定しています。

このように、カスタマイゼーションポイントオブジェクトはよりジェネリックかつ静的な*Template Method*パターン（あるいはNVI）だと見る事ができます。

#### `inline`名前空間

標準ライブラリのカスタマイゼーションポイントオブジェクトは、先ほど見たようになぜか`inline`名前空間に包まれています。

これはおそらく、将来行われうる変更に対してもABI互換性を維持するために行われています。

`inline`名前空間はC++コード上で見ると省略可能で付けても付けなくてもいい名前空間名ですが、ABI（マングル名）には常に表示されています。`inline`名前空間を切り替える事でC++コード上からデフォルトで使用可能な関数を切り替える事ができます（APIのバージョニングなど）が、この場合新しい`inline`名前空間内の関数名などのABIは変化しています。しかし、以前のバージョンの`inline`名前空間が単に非`inline`になって残っている場合、古いバージョンの関数などもABIレベルではそのまま参照可能であり続けます。

この事は、ビルド済みの静的・動的ライブラリを配布したり利用する時にとても重要になります。ABI互換性がある場合、過去にビルドしたビルド済みバイナリを新しい言語バージョン（それを提供する新しいコンパイラ）を利用した場合も使い続ける事ができます。同時に、C++コード上では言語のアップデートに伴う変更を適用して、新規に書いたコードには新しいバージョンを適用する事が可能です。

例えば、カスタマイゼーションポイントオブジェクトの効果が変更されると内部実装が変更されることになり、場合によってはABI互換性を崩してしまう事になり得ます（カスタマイゼーションポイントオブジェクトの型が変更されるなど）。このような時、古い実装を非`inline`名前空間に（名前空間名はそのままで）残し、新しい`inline`名前空間で変更後のカスタマイゼーションポイントオブジェクトを新規定義する事で、ABI互換性を維持しながらライブラリをアップデートできます。

#### その他の性質

標準ライブラリのカスタマイゼーションポイントオブジェクトは全て、リテラル型かつ[`semiregular`](https://cpprefjp.github.io/reference/concepts/semiregular.html)であると規定されています。これはつまり、`constexpr`にコピー・ムーブ・デフォルト構築/代入可能であると言う事です。

そしてそれら複数のインスタンスのカスタマイゼーションポイントオブジェクトとしての効果は呼び出しに使うインスタンスによって変化しない事も規定されています。

これらの事によって高階関数などでカスタマイゼーションポイントオブジェクトを自由に利用する事ができます。これはまた、従来のカスタマイゼーションポイント関数と比較した時のメリットでもあります。

### 実装してみよう！

### カスタマイゼーションポイントオブジェクトのテンプレ

### 参考文献

- [16.4.2.2.6 Customization Point Object types [customization.point.object] - N4861](https://timsong-cpp.github.io/cppwp/n4861/customization.point.object)
- [Customization Point Object - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20190403/p1)
- [Customization Point Design in C++11 and Beyond - Eric Niebler](http://ericniebler.com/2014/10/21/customization-point-design-in-c11-and-beyond/)
- [［C++］expression-equivalentのお気持ち - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2019/09/12/002550)
- [Use expression-equivalent in definitions of CPOs - Github](https://github.com/ericniebler/stl2/issues/262)
- [実引数依存の名前探索 - cppreference](https://ja.cppreference.com/w/cpp/language/adl)
- [6.5.2 Argument-dependent name lookup [basic.lookup.argdep] - N4861](https://timsong-cpp.github.io/cppwp/n4861/basic.lookup.argdep)