# ［C++］WG21月次提案文書を眺める（2020年5月）

文書の一覧
[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-05:embed:cite]

提案文書で採択されたものはありません。全部で29本あります。

[:contents]

### [P0493R1 : Atomic maximum/minimum](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0493r1.pdf)

`std::atomic`に対して、指定した値と現在の値の大小関係によって値を書き換えるmaximum/minimum操作である`fetch_max()/fetch_min()`を追加する提案。

アトミックな数値演算は既に標準化されていますがmaximum/minimum操作はそうではなく、他フレームワークやハードウェアには既に実装があり、いくつかのマルチスレッドアプリケーションで有用であるため追加しようというものです。

```cpp
#include <atomic>

std::atomic<int> a = 10;

int r1 = a.fetch_max(20);
// r1 == 10, a == 20

int r2 = a.fetch_min(5);
// r2 == 20, a == 5
```

これらの操作はread-modify-writeです。すなわち、現在の値と指定された値の大小関係に関わらず、値は常に更新されます。

```cpp
std::atomic<int> a = 10;

int r = a.fetch_max(5);  // 値の入れ替えは起こらないが、書き込みは行われている

// 例えば、次のように実行される
int v = a.load();
int max = std::max(v, 5);
a.store(max);

int r = v;
```

この提案では今の所、`std::atomic<T>`の整数型とポインタ型の特殊化に対してだけ`fetch_max()/fetch_min()`メンバ関数を追加しています。「[P0020 : Floating Point Atomic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0020r6.html)」が採択されれば浮動小数点型の特殊化についても追加すると書かれていて、これはC++20に対して既に採択されているので、次のリビジョンくらいで浮動小数点型の`std::atomic<T>`特殊化についても同様のものが追加されるかもしれません。

また、他の`atomic`操作に準ずる形で非メンバ関数版も用意されています。ただし、これらも整数型とポインタ型でのみ利用可能です。

```cpp
namespace std {
  template<class T>
  T atomic_fetch_max(atomic<T>*, typename atomic<T>::value_type) noexcept;

  template<class T>
  T atomic_fetch_max_explicit(atomic<T>*, typename atomic<T>::value_type, memory_order) noexcept;

  // それぞれvolatileオーバーロードがある
  // fetch_min()も同様
}
```

### [P0870R3 : A proposal for a type trait to detect narrowing conversions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0870r3.html)

型`T`が別の型`U`へ縮小変換（*narrowing conversion*）によって変換可能かを調べるメタ関数`is_narrowing_convertible<T, U>`を追加する提案。

前回の記事を参照
[https://onihusube.hatenablog.com/entry/2020/05/01/194425#P0870R2--A-proposal-for-a-type-trait-to-detect-narrowing-conversions:embed:cite]

このリビジョンでの主な変更は、機能テストマクロが追加された事と、配列を用いた実装が`void`や参照型、配列型など一部の型で機能しない事が明記された事です。

- [P0870 進行状況](https://github.com/cplusplus/papers/issues/724)

### [P1679R2 : String Contains function](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1679r2.html)

`std::string, std::string_view`に、指定された文字列が含まれているかを調べる`contains()`メンバ関数を追加する提案。

同じことは既にある`find()`を使えばできますが、`find()`関数を使用する方法には少し問題があります。

```cpp
if (str.find(substr) != std::string::npos)
  std::cout << "found!\n";
```

- 含まれているかを調べているのに`!=`を使用する（書きづらい）
- 調べているのは文字の位置なのか、含まれているかどうかなのか、含まれていないかどうかなのか、一見して分かりづらい（読みづらい）

対して、`contains()`というメンバ関数は意図が明確で書くときも読むときもこれらの問題は起こらず、初学者に対しても教えやすく使いやすいものです。また、他の言語の文字列型および、標準外のライブラリには既に対応する関数の実装があるため、標準ライブラリにも追加しよう、と言うのが要旨です。

```cpp
if (str.contains(substr))
  std::cout << "found!\n";
```

オーバーロードは`starts_with/ends_with`を参考に以下の3つが提供されます。

```cpp
constexpr bool contains(basic_string_view x) const noexcept;
constexpr bool contains(charT x) const noexcept;
constexpr bool contains(const charT* x) const;
```

- [P1679 進行状況](https://github.com/cplusplus/papers/issues/457)

### [P1841R1 : Wording for Individually Specializable Numeric Traits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1841r1.pdf)

`std::numeric_limits`に代わる新たな数値特性（*numeric traits*）取得方法を導入する提案。

例えば数値型の最大値や最小値等、数値型の満たしている各種特性を取得するのに現在は`std::numeric_limits`が用意されています。これは少なくとも`<type_traits>`ヘッダにあるような型特性が見出されるよりも以前から存在しており、その設計は古くなっています。

ユーザー定義型に対する特殊化を追加する場合、ジェネリックな利用のために本来必要のない数値特性についてもそれっぽい値を返すように実装する必要があります。あるいは、ある数値特性を提供しているのかどうかを知る方法が提供されていません。  
このことは、新たな数値特性を追加した場合には既存のユーザー定義型に対する特殊化を破壊する事を意味しており、そのために`std::numeric_limits`は拡張可能ではなくなっています。

そこで、`std::numeric_limits`にある各数値特性関数をそれぞれ個別のクラステンプレートと対応する変数テンプレートのペアに分解します。また同時に、一部の数値特性の名前と内容を調整します。

```cpp
// 型Tの有限値のうちの最大値（numeric_limits<T>::max()相当
template <class T>
struct finite_max;

// 型Tの有限値のうちの最小値（numeric_limits<T>::min()相当
template <class T>
struct finite_min;

template <class T>
inline constexpr auto finite_max_v = finite_max<T>::value;

template <class T>
inline constexpr auto finite_min_v = finite_min<T>::value; 
```

ある型について任意の数値特性が定義されているかを調べるものも提供されます。

```cpp
// 任意のTについて、数値特性Traitが定義されているかを調べる
template <template <class> class Trait, class T>
inline constexpr bool value_exists;

// 任意のTについて、数値特性が提供されていればその値を、いなければdefにフォールバックする
template <template <class> class Trait, class T, class R = T>
inline constexpr R value_or(R def = R()) noexcept;
```

これは例えば、次のように実装されます

```cpp
template <template <class> class Trait, class T>
constexpr bool value_exists = requires { Trait<T>::value; };

template <template <class> class Trait, class T, class R = T>
constexpr R value_or( R def = R() ) noexcept {
  if constexpr(value_exists<Trait, T>s)
    return Trait<T>::value;
  else
    return def;
} 
```

これらのものは`<numbers>`ヘッダと`std::numbers`名前空間に追加されます。

このように、数値型に対する数値特性が個別に分かれていることによって新しい数値特性を追加する際に既存のユーザー定義特殊化を壊してしまう事もありません。ユーザーが特殊化を追加する際も必要な数値特性についてだけ特殊化を行えばよくなります。

- [P1370R1 Generic numerical algorithm development with(out) numeric_limits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1370r1.html)
- [P0437R1 Numeric Traits for the Standard Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0437r1.pdf)
- [P1841 進行状況](https://github.com/cplusplus/papers/issues/594)

### [P1861R1 : Secure Networking in C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1861r1.html)

Networking TS（簡単に言えば、ソケット通信ライブラリ）に対して、TLS/DTLSのサポートをデフォルトにする提案。

今日、ネットワークに接続すると言うことは悪意を持った攻撃に曝されることを意味します。それに対処するために、インターネットにおける通信はHTTPS(TLS)等を用いてセキュアにする事がデフォルトとなりつつあります。特に、WEBサーバの中にはHTTPを拒否しHTTPSでしか通信をしないものも増えてきています。  
C++のネットワークライブラリがそれらの現代のWEBシステムと対話するために、また、ネットワークセキュリティの知識のない開発者がそれを意識せずとも一定のセキュリティを確保する事ができるように、そして、C++のネットワークライブラリを用いたプログラムが将来的にもセキュアなインターネットと連携していくために、Networking TSにおいてTLS/DTLSをデフォルトで使用するようにする、と言う提案です。

セキュリテイを確保するために追加のややこしい設定が必要になったりコードとその理解が複雑になることはセキュアなプログラムを書くことを妨げ、安全でない通信の利用を促進しかねないため、この提案では現在のNetworking TSのAPIを変更し、WEBアクセスなども意識した使いやすいAPIセットを提案しています。

コルーチンと[`std::lazy<T>`](https://wg21.link/p1056r1)を用いたHTTPSクライアントのサンプル

```cpp
#include <iostream>
#include <net>

std::lazy<void> run()
{
  net::workqueue queue(net::workqueue::main_queue());
  net::endpoint::host host("www.apple.com", 80);

  // ここの第二引数でTLS/DTLSを使用するかを制御する
  net::connection connection(host, net::parameters::tls(), queue);
  connection.start();

  std::cout << "Sending request" << std::endl;
  net::message message(net::buffer("GET / HTTP/1.1\r\nHost: www.apple.com\r\n\r\n"));
  auto sendResult = co_await connection.send(message);
  if (!sendResult) {
    std::cerr << "failed to send request" << std::endl;
    co_return;
  }

  std::cout << "Sent request, waiting for response" << std::endl;
  auto message = co_await connection.receive();
  if (!message) {
    std::cerr << "failed to receive response" << std::endl;
    co_return;
  }

  std::cout << "Received response" << std::endl;
  message->data().get([](const uint8_t *bytes, std::size_t size) {
    std::cout << std::string(reinterpret_cast<const char *>(bytes), size);
  });
  std::cout << std::endl;
  co_return;
}

int main(int, char**)
{
  auto lazy = run();
  net::workqueue::main();
}
```

この提案は将来的にQUIC等のプロトコルをサポートするための下準備も兼ねています。

- [P1860R0 C++ Networking Must Be Secure By Default.](https://wg21.link/p1860r0)
- [P1861R0 Secure Connections in Networking TS](https://wg21.link/p1861r0)
- [P1861R1 Secure Networking in C++ - reddit](https://www.reddit.com/r/cpp/comments/gm40j0/p1861r1_secure_networking_in_c/)
- [P1861 進行状況](https://github.com/cplusplus/papers/issues/615)

### [P1897R3 : Towards C++23 executors: A proposal for an initial set of algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1897r3.html)

Executorライブラリにいくつかの汎用非同期アルゴリズムを追加する提案。

現在のExecutor提案に含まれている汎用非同期アルゴリズムはバルク処理のための`bulk_execute`だけで、Executorを実用的にするにはもう少し多くの汎用非同期アルゴリズムを追加しよう、と言う提案です。

また、今後さらに多くの汎用非同期アルゴリズムを追加していくにあたって、より洗練された設計や文言を選択するために、個別に議論可能な（相互依存していない）最小のアルゴリズムのセットから提案を始めています。

追加されるもの（引数の`s`は何か処理を示す*sender*オブジェクト）。なおこれらのものは全てカスタマイぜーションポイントオブジェクトです。

- `just(v...)`
    - 値`v...`を表現する*sender*を返す
- `just_on(scheduler, v, ...)`
    - `on`の効果とセットになっている`just()`
    - `scheduler`の実行コンテキスト上で`just(v...)`する*sender*を返す
- `on(s, scheduler)`
    - `scheduler`の実行コンテキスト上で実行される`s`から、結果値かエラーを伝播する*sender*を返す
- `sync_wait(s)`
    - `s`を実行し、処理の結果を返すか、処理中の例外が送出されるか、どちらかによって完了するのを待機する
    - 戻り値は`s`の結果、`s`の実行に際する例外を送出する
- `when_all(s...)`
    - 全ての`s...`の処理が完了するとその処理も完了する*sender*を返す。全ての結果値が伝播される。
- `transform(s, f)`
    - `s`の結果に`f()`を適用するか、エラーかキャンセルを伝播する*sender*を返す。
- `let_value(s, f)`
    - `s`の結果値が、別の非同期処理`f`の実行中利用可能となる非同期スコープを作成する
    - `s`のエラーやキャンセルは変更されずに伝播される
- `let_error(s, f)`
    - `s`のエラー値が、別の非同期処理`f`の実行中利用可能となる非同期スコープを作成する
    - `s`の結果値やキャンセルは変更されずに伝播される
- `ensure_started(s)`
    - 即座に`s`を実行コンテキストへ投入し、その他のコードと並行に実行されている可能性のある*sender*を返す

提案文書より、簡単なサンプル。

```cpp
auto just_sender = just(3); // sender_to<int>

auto transform_sender = transform(
  std::move(just_sender),
  [](int a){return a+0.5f;}
); // sender_to<float>

// ここで処理をExecutorに投げ、結果を待機する
float result = sync_wait(std::move(transform_sender));
// result == 3.5

// パイプライン演算子を用いて中間オブジェクトを隠蔽する
float f = sync_wait(
  just(3) | transform([](int a){return a+0.5f;})
);
```

複数の処理（*sender*）を受けてそれらを直列化する`when_all`のサンプル。

```cpp
auto just_sender = just(std::vector<int>{3, 4, 5}, 10); // sender_to<vector<int>>
auto just_int_sender = just(3); // sender_to<int>
auto just_float_sender = just(20.0f); // sender_to<float>

auto when_all_sender = when_all(
  std::move(just_sender),
  std::move(just_int_sender),
  std::move(just_float_sender)
);

auto transform_sender = transform(
  std::move(when_all_sender),
  [](std::vector<int> vec, int /*i*/, float /*f*/) {
    return vec; // 他の結果は捨てる
  }
);

vector<int> result = sync_wait(std::move(transform_sender));
// result = {3, 4, 5}

// パイプライン演算子の利用
vector<int> result_vec = sync_wait(
  when_all(
    just(std::vector<int>{3, 4, 5}, 10),
    just(3),
    just(20.0f)
  ) |
  transform([](vector<int> vec, int /*i*/, float /*f*/){return vec;})
);
```

- [A Unified Executors Proposal for C++ | P0443R13](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r13.html)
- [P1897 進行状況](https://github.com/cplusplus/papers/issues/645)

### [P1898R1 : Forward progress delegation for executors](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1898r1.html)

Executorにおける処理の前方進行と非同期処理グラフのモデルに関する提案。

Executorライブラリと非同期アルゴリズムによってワークチェーンを構成し実行する際にその実行リソース（実行コンテキスト、*scheduler*）がどのように伝播するのかを明確に定義するものです。

新しく`scheduler_provider`コンセプトと`get_scheduler`CPOの2つを追加します。`scheduler_provider`コンセプトは（*receiver*に対して）`get_scheduler()`によって*scheduler*を取得可能であることを求めます。*sender*は`connect()`された`scheduler_provider`（な*receiver*）からその実行コンテキストである*scheduler*を取得する事で非同期タスクの下流から上流、あるいは上流から下流に向かって*scheduler*を伝播させることが可能になります。

複数の処理をチェーンするとき、個々の処理を示す*sender*オブジェクトもその順番通りに内部で紐づいていき、最後にそれらの処理全体を示す1つの*sender*オブジェクトが得られます。そこにその処理のコールバックとなる*receiver*を接続（`connect()`）して非同期処理の完了（成功、失敗、キャンセル）を待機できるような*operation state*オブジェクトが得られます。そして、最後に*operation state*オブジェクトを`start()`などで明示的に開始します。

*sender*と*receiver*の`connect()`の際は、渡された*receiver*オブジェクトはチェーンされた*sender*列の最後から先頭へ伝播していきます（実装によるかもしれません）。すなわち、チェーンされた処理を示す一連の*sender*オブジェクトは全て同じ一つの*receiver*オブジェクトを受け取ることになります。  

```cpp
// どこかのスレッドプールで実行してもらう
sender auto begin = then(
  std::execution::schedule( pool ),
  []{ return 1; }
);

// senderのチェーン
sender auto task = begin | then([](auto n){ return n + 1;})
                         | then([](auto n){ return n * 2;})
                         | then([](auto n){ return n * n});

receiver auto rec = /*任意のreceiverを取得*/;

// senderとreceiverを接続（コールバックの登録
// taskも含めてチェーンしているすべてのsenderにここで渡したreceiverが浸透する
operation_state auto state = std::execution::connect(task, rec);

// 実行開始！
std::execution::start(state);
```

この例では、最初の*sender*に登録された*scheduler*（どこかのスレッドプールとしている）が処理の上流から下流へ伝播するはずです。ただ、この例のように最初の*sender*にいつも実行コンテキストが指定されるとは限りませんし、チェーンの途中で`on()`などによって*scheduler*を変更することができます。また、非同期アルゴリズムの種類によってはどの*scheduler*で実行するべきか不明な場合もあります。  
そのような時、その一連の*sender*全体に渡っている*receiver*オブジェクトを介してある*sender*から別の*sender*へ*scheduler*をやり取りすることができると、適切な*scheduler*を選択できるかもしれません。

そのために`get_scheduler()`を追加し、それを用いれば`scheduler_provider`（な*receiver*）から*scheduler*をチェーン上の任意の場所から任意の場所へ伝達できるようになります。もちろん、どのように伝達するのかは*sender*の実装によることになります。

```cpp
sender auto pool_sender = then(
  std::execution::schedule( pool ),
  []{ return 1; }
);

// pool_sender以外のsenderはどこで実行する？
// あるいは、後続のthenによる処理は？？
sender auto task = when_all(
  pool_sender,
  just(1.0),
  just("executor")
) | then([](int, double, const char*) { return true; });

// この時、与えられたreceiverを介して適切なschedulerを設定できるかもしれない
operation_state auto state = std::execution::connect(task, rec);
```

- [A Unified Executors Proposal for C++ | P0443R13](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r13.html)
- [P1898 進行状況](https://github.com/cplusplus/papers/issues/646)

### [P1974R0 : Non-transient constexpr allocation using propconst](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1974r0.pdf)

コンパイル時に確保したメモリを実行時にも安全に参照するための要件と、そのためのより深い`const`性を指定する`propconst`の提案。

C++20からは`constexpr`な動的メモリ確保が可能になっていますが、Non-transientなメモリ確保（コンパイル時に確保したメモリを実行時にも参照すること）は許可されませんでした。

```cpp
constexpr void f(std::initilizer_list<int> il) {
  std::vector<int> vec = il;  // これはok
}

int main() {
  constexpr std::vector<int> vec = {1, 2, 3, 4, 5}; // これはできない
}
```

Non-transientなメモリ確保が許可されていた以前の仕様の下では、クラス内部で確保されるメモリで条件を満たした場合にコンパイル時に解放されなかったメモリは実行時に静的ストレージに昇格されて参照可能でした。その際は通常の`constexpr`変数と同様に実行時`const`変数になります。その条件とは以下のようなものでした。

- `T`は非トリビアルconstexprデストラクタを持つ
- そのデストラクタはコンパイル時実行可能
- そのデストラクタ内で、`T`の初期化時に確保されたメモリ領域（Non-transient allocation）を解放する

すなわち、そのクラスの`constexpr`デストラクタによってコンパイル時に確保されたメモリがコンパイル時に解放可能であることです。これはコンパイラによるテスト要件であって、実際に解放が行われるわけではありません。

そして、その仕様の下では次のような問題が発生します。

```cpp
// これはok（だった
constexpr std::unique_ptr<std::unique_ptr<int>> uui 
  = std::make_unique<std::unique_ptr<int>>(std::make_unique<int>());

int main() {
  std::unique_ptr<int>& ui = *uui; // これができてしまう
  ui.reset(); // 静的ストレージの領域をdeleteする？
}
```

このように、デストラクタを実行時に呼び出せてしまいますが、前述のテスト要件だけではこれを検出し防ぐことはできません。そのため、Non-transientなメモリ確保は最終的にリジェクトされました。

これが何故起こるかというと、`std::unique_ptr`は*deep const*な型ではないからです。すなわち、外側の`std::unique_ptr`の`const`性が内部の`std::unique_ptr`まで伝播していません。

そこで、以前のコンパイラによるデストラクタのテスト要件に次の条件を加えます。

- デストラクタ呼び出し中に現れる全ての（メンバ）変数は`const`であり、かつ
- そのデストラクタは実行時に破棄されうるオブジェクトに対して呼び出されていない

これによって、上記の`std::unique_ptr<std::unique_ptr<int>>`のような例をコンパイル時に正しくエラーにすることができます。ただこれにも問題がまだあります。

```cpp
constexpr vector<vector<int>> vvi = {{1}};

int main() {
  vector<int>& vi = vi[0]; // 非const参照への変換になるのでng
  vi = vector<int>{}
}
```

このコードは以前の要件の下でも新たな要件の下でもエラーになります。`std::vector`は`const`修飾されたメンバ関数からその要素への非`const`な参照を取れないように巧妙に設計されているためです。これによって`std::vector`は多重ネストしても`std::unique_ptr`のように内部要素を解放されてしまうことは起こりえません。すなわち、`std::vector`は*deep const*な型です。

しかし、新たな要件によるデストラクタのテストはネストした`std::vector`を許可しません。`const`メンバ関数の慎重な設計によって*deep const*となっているだけでそのメンバは非`const`のままであり、コンパイラはネストした`std::vector`が*deep const*であることを認識できません。

そこで、ユーザーに追加の作業を必要とせずにコンパイラが正しく型の*deep const*性を認識するために、C++の型システムを拡張し新しいCV修飾子である`propconst`を導入することを提案しています。

`propconst`はポインタ型と参照型にのみ適用可能で、ポインタが不変である場合に`const`に変換され、それ以外の場合は何もしません。参照型はポインタ型に置き換えた上で同様です。

非メンバのオブジェクトポインタ型に対して`propconst`修飾している場合、その不変性は`const`修飾の有無で決まります。メンバ変数に対して`propconst`修飾している場合は呼び出すメンバ関数の`const`修飾によってその不変性が決定されます。

```cpp
int propconst* ip1;       // int* ip1;
int propconst* const ip2; // int const * const ip2;

struct S {
  int propconst *ppi;

  void f() const {
    // ここでは、ppiの型はint const * const
    // int const* ppi;と宣言されているように見える
  }

  void f() {
    //ここでは、ppiの型はint *
    // int * ppi;と宣言されているように見える
  }
};
```

最終的には、この`propconst`と以下の条件でもってNon-transientなメモリ確保を許可することが提案されています。

- `constexpr`なデストラクタの呼び出し（テスト）中に現れた全ての変数は、他の*mutable*な（実行時）文脈から到達可能ではない


```cpp
// 共にok
constexpr vector<vector<int>> vvi = {{1}};
constexpr vector<unique_ptr<int>> vui = {std::make_unique<int>()};
```

`propconst`はどこに現れるのかというと、`std::vector`の実装に現れています。`std::vector`の領域管理用のメンバ変数が全て`propconst`修飾されていれば、その要素を外部から変更可能でないことが保証可能であるため、コンパイラは`std::vector`が*deep const*であることを認識可能です。つまり、普通のユーザーは`propconst`を意識せずともNon-transientなメモリ確保を利用できるようになります。

- [［C++］ constexprなメモリの確保と解放のために（C++20） - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2019/03/03/113722)
- [N4388 A Proposal to Add a Const-Propagating Wrapper to the Standard
Library](https://wg21.link/n4388)
- [`std::experimental::propagate_const` - cppreference](https://en.cppreference.com/w/cpp/experimental/propagate_const)

### [P1985R1 : Universal template parameters](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1985r1.pdf)

任意の型、テンプレートテンプレート...、非型テンプレートパラメータなど、テンプレートの文脈で使用可能なものを統一的に受けることのできるテンプレートパラメータ（*Universal template parameter*）の提案。

例えば高階メタ関数を書くときなど、引数として任意のものを受け取りたいことがよくあります。現状ではこれをするためにはそれぞれのテンプレートパラメータの種類毎の特殊化を行う必要があります。

```cpp
// メタ関数Fに引数Argsを適用する
template <template <typename...> typename F, typename... Args>
using apply = F<Args...>;

template<typename X>
struct {using type = X;};

using OK = apply<G, int>;  // ok、G<int>

// 部分適用する
template <template <typename> typename F>
using H = F<int>;

using NG = apply<H, G>; // ng
// applyの引数パラメータArgs...はテンプレートテンプレートパラメータではないため
```

これはまた、`apply`の2番目以降の引数として非型テンプレートパラメータを渡そうとしても同じことが起きます。このような場合に、そのパラメータの種類を指定せずにテンプレートパラメータを宣言できるととても便利です。

提案では、2種類の文法を提案しています。

```cpp
// 簡単かつ使いやすい、template auto
template <template <template auto...> typename F, template auto... Args>
using apply = F<Args...>;

// 数学的に正しい、__ （+template auto）
template <template <__...> typename F, template auto... Args>
using apply = F<Args...>;
```

2番目の方法では同時に1つ目の方法も導入することになります。`__`はパターンマッチにおける制約のないパラメータのようなものであり（`switch`文の`default`ラベルのようなもの）、そのパラメータに名前をつけることが出来ません。  
`template auto`はちょうど、C++17で導入された`auto`によるユニーバーサル非型テンプレートパラメータの宣言と同じようなことをします。

また、この*Universal template parameter*を取るクラステンプレートをプライマリテンプレートとして、テンプレートパラメータの種類毎に特殊化を行えるようにすることも提案されています。

```cpp
// プライマリテンプレート
template <template auto>
struct X;

// 普通の型に対する特殊化
template <typename T>
struct X<T> {
  // T is a type
  using type = T;
};

// 非型テンプレートパラメータに対する特殊化
template <auto val>
struct X<val> : std::integral_constant<decltype(val), val> {
  // val is an NTTP
};

// テンプレートテンプレート（1引数メタ関数）に対する特殊化
template <template <typename> F>
struct X<F> {
  // F is a unary metafunction
  template <typename T>
  using func = F<T>;
};
```

- [C++17 非型テンプレートパラメータのauto宣言 - cpprefjp](https://cpprefjp.github.io/lang/cpp17/declaring_non-type_template_arguments_with_auto.html)
- [P1985 進行状況](https://github.com/cplusplus/papers/issues/735)

### [P2066R2 : Suggested draft TS for C++ Extensions for Transaction Memory Light](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2066r2.html)

現在のトランザクショナルメモリTS仕様の一部だけを、軽量トランザクショナルメモリとしてC++へ導入する提案。

トランザクショナルメモリはDBにおけるトランザクション処理の概念をDBをメモリに対応させ一般化したもので、トランザクション間においてメモリの一貫性を保証し、並行処理を容易に書くことができるようにするためのものです。

あるメモリ領域に対する1連の処理を1つのトランザクションとすると、そのトランザクションは成功するか失敗するかのどちらかであり、成功した場合にだけ結果がアトミックに書き込まれます。失敗した場合は進行中の処理は全てキャンセルされなされた変更はロールバックされるため、メモリ領域は一切変更されません。

このようなトランザクションはそれぞれがプログラム全体で1つの全順序に従うかのように実行され、あるトランザクションの実行中に外から処理中の状態を観測出来ず、1つのトランザクションは不可分の操作であるように実行されます。それによって、ユーザーはトランザクション間のデッドロックや同期などの心配を一切しないで並行処理を書くことが出来ます。

これらを標準機能として提供するために、トランザクショナルメモリTS仕様では2種類のトランザクション処理を定義するためのキーワード（`transaction_relaxed/transaction_atomic`）とトランザクションキャンセル時の挙動を指定する2種類の指定子やある関数がトランザクション中で安全に扱えるかを指定する2種類の関数指定子（`commit_on_escape/cancel_on_escape/transaction_safe/transaction_unsafe`）を定義していました。

2015年に現在のTS仕様が策定されていましたが実装もユーザー経験も少なく、機能がカバーする領域が広すぎると言う指摘もあり、標準への導入は見送られていました。そこでこの提案では、`atomic`トランザクション（以前の`transaction_atomic`相当）とそのために必要な最低限の仕様変更だけをC++に導入することを提案しています。最終的にはTS仕様の全てを含めることを目指すために、まずは実装の負担にならない小さな変更から初めて行くつもりのようです。

導入されるキーワードは`atomic`だけで、上記4つの指定子は全てありません。プログラムの実行に当たって発生するトランザクションはプログラム中で一貫した全順序によって実行され、同じ式を評価する2つのトランザクションは、先に評価が開始されたトランザクションの終了にもう一つのトランザクションの開始が同期します。

```cpp
int f()
{
  static int i = 0;

  // atomicステートメント、atomicトランザクションを定義
  // このブロックは全てのスレッドの間で1つづつ実行される
  atomic {
    ++i;
    return i;
  }
}

int main() {
  std::array<std::thread, 100> threads{};

  // 関数f()の呼び出し毎に一意の値が取得される
  // 同じ値を読んだり、更新中の値を読むことはない
  for (auto& th : threads) {
    th = std::thread([](){
      int n = f();
    });
  }

  for (auto& th : threads) {
    th.join();
  }
}
```

ただし、次のようにスレッド外部から観測可能な操作の`atomic`ステートメント内部での実行は未定義動作とされています。

- I/O操作
- `volatile`領域へのアクセス
- *atomic*操作
    - `std::atomic`など

そして、`atomic`ステートメントの中では次の行いは実装定義です。

- `asm`宣言
- 非`inline`関数以外の関数の呼び出し
- 仮想関数呼び出し
- 関数名を指定しない後置式
    - `a[], a++, a->b()`など
- `throw`式
- コルーチン関連
    - `co_await, co_return`など
- スレッドローカルストレージ及び静的変数の動的初期化

トランザクションのキャンセルはどうやらサポートされず、例外送出=キャンセルと考えればそれは実装定義のようです。また、その実装がハードウェアによるのかソフトウェアによるのかも規定していません。ほとんど実装定義です・・・

- [P1875R0 Transactional Memory Lite Support in C++](http://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p1875r0.pdf)
- [N4514 Technical Specification for C++ Extensions forTransactional Memory](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4514.pdf)
- [トランザクション処理 - wikipedia](https://ja.wikipedia.org/wiki/トランザクション処理)
- [ACID - wikipedia](https://ja.wikipedia.org/wiki/ACID_(コンピュータ科学))
- [コンピュータアーキテクチャの話(201) トランザクションメモリ - マイナビニュース](https://news.mynavi.jp/article/architecture-201/)
- [Boost.勉強会 #10 に参加しました - yohhoyの日記（別館）](https://yohhoy.hatenablog.jp/entry/2012/07/29/002928)
- [C++トランザクショナルメモリ拡張まとめ（ドラフト仕様v1.1） - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20120414/p1)
- [C++トランザクショナルメモリ拡張まとめ（N3718） - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20131005/p1)
- [2013-09 pre-Chicago mailingの簡易レビュー - 本の虫](https://cpplover.blogspot.com/2013/09/2013-09-pre-chicago-mailing.html)
- [P2066 進行状況](https://github.com/cplusplus/papers/issues/793)

この部分は以下の方のご指摘によって構成されています。

- [@yohhoyさん](https://twitter.com/yohhoy/status/1263750938071756800)

### [P2128R1 : Multidimensional subscript operator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2128r1.pdf)

多次元コンテナサポートのために添字演算子（`[]`）が複数の引数を取れるようにする提案。

行列や画像、位置情報など多次元のデータの1要素にアクセスするためには、ぞの次元に応じたインデックスが必要です。現状の添字演算子は1引数しか取ることができず、`mdspan`や`mdarray`などの多次元データ型でその要素にアクセスするためには関数呼び出し演算子（`()`）を使用する必要があります。しかし、添字演算子と比べると明解ではなく少し混乱します。

そこで、添字演算子をオーバーロードする際に1つ以上の任意の数の引数を取れるように変更しよう、と言うのが提案です。この場合、関数呼び出し演算子との差異は引数なしオーバーロードが可能かどうかだけになります。

```cpp
template<class ElementType, class Extents>
class mdpan {

  // 多引数添字演算子オーバーロード
  template<class... IndexType>
  constexpr reference operator[](IndexType...);

  // 他実装略
};

int main() {
  int buffer[2*3*4] = { };
  auto s = mdspan<int, extents<2, 3, 4>> (buffer);

  // 添字演算子による多次元アクセス
  s[1, 1, 1] = 42;
  // 現在は関数呼び出し演算子を使用する必要がある
  s(1, 1, 1) = 42;
}
```

C++20では添字アクセスの際に`[]`の中にカンマを書くことが非推奨とされましたが、この提案の下では配列型の場合はC++17までのようなカンマによる式と常に認識し、クラス型の場合は添字演算子オーバーロードは見つからない場合にカンマによる式にフォールバックすると言う選択を取ることができ、C++17までの振る舞いをサポートし続けることが可能になります。

- [P1161R3 Deprecate uses of the comma operator in subscripting expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1161r3.html)
- [P2128 進行状況](https://github.com/cplusplus/papers/issues/845)


### [P2136R1 : invoke_r](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2136r1.html)

戻り値型を指定する`std::invoke`である`invoke_r`の提案。

C++17以前から、関数呼び出しという操作を規格上で統一的に表現するために`INVOKE`という仮想操作があり、C++17ではそれに対応するライブラリ関数である`std::invoke`が追加されました。  
また、指定した戻り値型`R`で`INVOKE`するという操作もあり、対応するものとして`std::invoke<R>`のような形で提案されていましたが、不要であるとしてドロップされました。

しかし、`INVOKE<void>(f, args...)`のような呼び出しは戻り値を明示的に破棄するために便利です。また、`std::is_invocable_r`や`std::is_nothrow_invocable_r`は指定した戻り値型で呼び出せるかを調べられるようになっており、`std::visit`には戻り値型を指定する`std::visit<R>`が用意されています。

戻り値型を指定する`std::invoke`はあると便利なので追加しようという提案です。`std::invoke_r`は`std::invoke`と比較して次のような利点があります。

- `void`を指定すれば戻り値を破棄できる
- *callable*オブジェクトの戻り値型を変換して呼び出しできる
    - 例えば、`T&&`を返す関数を`T`の*prvalue*を返す関数に変換できる
- 複数の戻り値型を返しうる呼び出しを指定した1つの型を返すように統一できる
    - 例えば、共変戻り値型をアップキャストする

```cpp
namespace std {
  // 宣言
  template <class R, class F, class... Args>
  constexpr R invoke_r(F&& f, Args&&... args)
    noexcept(is_nothrow_invocable_r_v<R, F, Args...>);
}


[[nodiscard]] int f1(int);

// 戻り値の破棄
std::invoke_r<void>(f1, 0);

template<typename T>
T&& f2(T);

// 戻り値型の変換
int pr = std::invoke_r<int>(f2, 0);

struct base{};

template<typename F, typename... Args>
  requires std::derived_from<std::invoke_result_t<F, Args...>, base>
base f3(F&& f, Args&&... args) {
  // 共変戻り値型のアップキャスト
  return std::invoke_r<base>(std::forward<F>(f), std::forward<Args>(args)...);
}
```

効果としては、`R`に`void`が指定されたときは戻り値を`static_cast<void>`して、それ以外は暗黙変換する、という感じです。

名前の`_r`は`std::invoke`と間違えて使用しないようにするために付いています。

- [INVOKE - cpprefjp](https://cpprefjp.github.io/reference/concepts/Invoke.html)
- [P2136 進行状況](https://github.com/cplusplus/papers/issues/851)


### [P2142R1 : Allow '.' operator to work on pointers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2142r1.pdf)

ポインタ経由のメンバアクセスの際に、`->`だけでなく`.`も使用できるようにする提案。

`->`と`.`はほとんど同じことをするのに使い分けが必要なのは最初にCを学ぶ時の混乱する点の一つであり、現代の言語におけるメンバアクセスはほとんど`.`で統一されています。また、ポインタと同等の振る舞いをする参照との間でのコードの非互換（コピペしたときに書き換えが必要）もあり、ポインタ経由のメンバアクセスに`.`を許可しよう、というものです。

```cpp
struct S {
  int n;

  operator int() {
    return this.n;  // これも出来るようにする
  }
}

int main() {
  S  obj{.n = 10};
  S& ref = obj;
  S* ptr = &obj;

  ref.n = 20; // これは出来る
  ptr.n = 20; // これを出来るようにする

  obj->n = 20;  // これが出来るようになるわけではない
}
```

これまでポインタに対しての`.`はコンパイルエラーとなっていたので、この変更によって後方互換性が損なわれることはありません。

これは同時にC標準に対しても提案されています。

- [P2142 進行状況](https://github.com/cplusplus/papers/issues/868)


### [P2145R0 : Evolving C++ Remotely](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2145r0.html)

コロナウィルスの流行に伴ってC++標準化委員会の会議がキャンセルされている中で、リモートに移行しつつどのように標準化作業を進めていくのかをまとめた文章。

今後のテレビ会議のカレンダーとかリアル会議で何してるのかとか、リモートやメール等の代替手段でどう作業するかみたいなことが書いてあります。

- [8. High-Priority Work](https://api.csswg.org/bikeshed/?force=1&url=https://raw.githubusercontent.com/brycelelbach/wg21_p2145_evolving_cpp_remotely/master/evolving_cpp_remotely.bs#high-priority-work)

には、C++23以降の優先度の高いライブラリと言語機能についての進捗等のまとめが書かれています。

今の所は「[P0592R4 To boldly suggest an overall plan for C++23](https://wg21.link/p0592r4)」によって示された予定の変更はないようですが、既に[11月のニューヨークで行われる予定だった会議もキャンセル](https://herbsutter.com/2020/05/20/the-new-york-iso-c-meeting-is-postponed/)されているので、さすがに変更があるかもしれません・・・

### [P2159R0 : An Unbounded Decimal Floating-Point Type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2159r0.html)

[Numbers TS (P1889R1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1889r1.pdf)に対して、10進多倍長浮動小数点型`std::decimal`を追加する提案。

[P1889R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1889r1.pdf)は将来C++に導入することを目指した数値型関連の提案をまとめたもので、多倍長整数型などが提案されています。現状10進浮動小数点型は無いようなので追加しようということのようです。

- [コンピュータアーキテクチャの話(104) 10進浮動小数点演算 - マイナビニュース](https://news.mynavi.jp/article/architecture-104/)
- [P1889R1 C++ Numerics Work In Progress](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1889r1.pdf)
- [N2849 Extension for the programming language C++ to support decimal floating- point arithmetic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2849.pdf)

- [P2159 進行状況](https://github.com/cplusplus/papers/issues/870)

### [P2160R0 : Locks lock lockables (wording for LWG 2363)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2160r0.html)

現在の*Mutex*ライブラリ周りの文言にはいくつか問題があるのでそれを修正するための提案。

主に以下のような問題に対処するものです。

- `std::shared_lock<Mutex>`のパラメータ`Mutex`は[`shared mutex`要件を満たすことが要求](https://timsong-cpp.github.io/cppwp/n4861/thread.lock.shared#1.sentence-5)されているが、その参照先は[`shared timed mutex`](https://timsong-cpp.github.io/cppwp/n4861/thread.sharedtimedmutex.requirements)になっている。この不一致によって、たとえユーザーが時間指定して待機する関数を呼ばなかったとしても`shared_lock<shared_mutex>`は未定義動作となりうる。
- `std::shared_lock`の現在の表現は内部定義（規格に表されていない？）を参照しているため、ユーザー定義の共有Mutex型の利用が許可されていない。これは明らかな欠陥。
- [Lock関連の操作全般の文言](https://timsong-cpp.github.io/cppwp/n4861/thread.lock)に横たわる問題として、ロック操作の事前条件を基礎となるロック可能な操作の事前条件と混同したり、ロック可能であることをミューテックスと混同する問題がある。

これらの問題は文言や要件の不足によるものなので、必要な要件を追加し文言を整理・調整する事で解決を図っています。

- [P2160 進行状況](https://github.com/cplusplus/papers/issues/871)

### [P2161R0 : Remove Default Candidate Executor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2161r0.pdf)

Networking TSの`associated_executor`からデフォルトのExecutorを取り除く提案。

前回公開されたこの提案から派生したもののようです。

- [［C++］WG21月次提案文書を眺める（2020年4月） P2149R0 : Remove `system_executor` - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2020/05/01/194425#P2149R0--Remove-system_executor)

`associated_executor`は非同期処理の完了時に呼ばれるハンドラ（コールバック）に関連づけられたExeutorで、あるハンドラはその`associated_executor`で指定されたExecutor（および実行コンテキスト）で実行されます。これはユーザーによってカスマイズ可能にするために用意されており、デフォルトでは`system_executor`が使用されることになっています。

ただ、`system_executor`はいくつかの特異な性質を持っています。例えば、`system_context`は受け取った処理を任意の数並列実行することが許可されています（すなわち、スレッドプールを想定している）。これを使用するExecutorを選択する場合ユーザーには強い並行性要件が課されます。`system_context`は`system_executor`の実行コンテキストであり、暗黙のうちにこれにフォールバックすると静かにデータ競合（未定義動作）を引き起こします。

一方で、`io_contex::run()`など投入した処理は現在のスレッドをブロックして実行され、ユーザーが処理が実行されている時とされていない時を制御可能な実行コンテキストをデフォルトで使用するものもあります。これらはそれぞれ別々の場所で使用されており、ユーザーがそのつもりもないのに`system_executor`に静かにフォールバックする場合、全く意図しない偶発的なデータ競合を引き起こしてしまいます。

また、`system_context`は投入されたワークアイテムの生存期間（*lifetime*）を任意に延長することが許されています。処理の前方進行を停止する方法も提供されてはいますが、ワークアイテムの寿命が確実に尽きることを保証する方法はありません。対照的に、ユーザーはワークアイテムの生存期間がいつ終了するかを制御可能なExecutorを使用することができます。その場合に意図せず`system_executor`にワークアイテムを投入してしまうと、あらゆる種類の生存期間にまつわるバグを引き起こす可能性があります。

特に、これらの性質のそれぞれは`system_context`のシングルトンオブジェクトがグローバル変数であるということに由来しています。

これらの問題を抱えているものをデフォルトに据えておくのは明らかにバグの元であるので削除しよう、ということのようです。

- [N4771 Working Draft, C++ Extensions for Networking](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4771.pdf)
- [Networking TS の Boost.Asio からの変更点 - その 4: Associated Executor - あめだまふぁくとりー](https://amedama1x1.hatenablog.com/entry/2017/12/09/102405)
- [`associated_executor` - Boost C++ Libraries](https://www.boost.org/doc/libs/1_73_0/doc/html/boost_asio/reference/associated_executor.html)
- [P2161 進行状況](https://github.com/cplusplus/papers/issues/872)

### [P2162R0 : Inheriting from std::variant (resolving LWG3052)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2162r0.html)

`std::variant`を公開継承している型に対しても`std::visit()`できるようにする提案。

```cpp
namespace std {
  template <class R, class Visitor, class... Variants>
  constexpr R visit(Visitor&& vis, Variants&&... vars);
}
```

`std::visit`は上記のように宣言されていますが、例外指定の文言において「`vars`に含まれる全ての`std::variant`が...」のように指定されていることから、`Variants`パラメータパックに含まれてもいいのは`std::variant`の特殊化だけ、となっています。  
文言の調整によってこれを緩和し、`std::varinat`（の任意の特殊化）を曖昧でない`public`な基底クラスとして持つ型でも呼べるようにしようとしているものです。

これはすでにClang(libc++)とMSVCには実装済みのようなので、欠陥報告（C++17?）として採択されそうです。

- [`std::visit()` - cpprefjp](https://cpprefjp.github.io/reference/variant/visit.html)
- [LWG Issue 3052. `visit` is underconstrained](https://cplusplus.github.io/LWG/issue3052)
- [P2162 進行状況](https://github.com/cplusplus/papers/issues/873)

### [P2163R0 : Native tuples in C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2163r0.pdf)

言語サポートのあるより自然に使える*native tuple*を追加する提案。

*native tuple*は山かっこ`<>`のなかに型名を書くことによって導入し、`{}`（*braced init list*）によって初期化されます。要素アクセスは*native tuple*オブジェクト`nt`に対して`nt.<I>`の様に行われ、これは`std::tuple`のオブジェクト`lt`に対する`std::get<I>(lt)`と等価の働きをします（`I`は型名でもok）。

```cpp
<int, double> t1 = {1, 1.0};

int a = 0;

auto t2 = {a, "str"s};  // <int, string>
<int&, double> t3 = {a, 0.5}; // decayされずに転送

t2.<0> = 1; // aは変更されない
t3.<0> = 2; // aが変更される
auto d = t3.<double>;
```

スライシングと展開

```cpp
<int, double, int, std::string> t = {1, 2.0, 3, "4.0"};

auto slice = t.<1..2>;  // sliceは<doube, int>
auto t2 = {...t...};    // パック展開
```

クラステンプレートの型推論で利用

```cpp
// std::map<int, double>
std::map m = {
  {1, 2.3}, {3, 4.5}, {6, 7.8}
};
```

多値返却関数

```cpp
auto f() -> <int, double> {
  return {1, 2.0};
}

// あるいは戻り値型指定を省略可能
auto f() {
  return {1, 2.0};
}
```

主に`{...}`が`std::initializer_list`に推論されてしまう事から起きている一貫性の無さと不便さを解決することを目的としている様です。しかし、どう見ても`std::initializer_list`と衝突しているのでさらに検討が必要そうです。

- [P2163 進行状況](https://github.com/cplusplus/papers/issues/874)

### [P2164R0 : views::enumerate](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2164r0.pdf)

元のシーケンスの各要素にインデックスを紐付けた要素からなる新しいシーケンスを作成するRangeアダプタ`views::enumrate`の提案。

```cpp
std::vector days = {"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"};

int index = 0;
for(const auto& d : days) {
  std::cout << std::format("{} {} \n", i, d);
  index++;
}

// ↑これが↓こう書ける

for(const auto& [idx, d] : std::views::enumerate(days)) {
  std::cout << std::format("{} {} \n", idx, d);
}
```

範囲`for`でインデックスが欲しい時は本当によくあるけれどそのままだと取れないため、外部スコープでインデックスを定義してインクリメントしたり普通のforループが使用されたりします。これは冗長でバグの元であるため、単純なライブラリ機能で解決が可能な`views::enumrate`を追加しようというものです。また、すでに`range-v3`や`boost::range`には同等のものが実装されています。

参考実装が等価な`for`ループと同等のコードを出力している結果が掲載されています。

https://godbolt.org/z/2Kxo8d

- [P2164 進行状況](https://github.com/cplusplus/papers/issues/875)

### [P2165R0 : Comparing pair and tuples](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2165r0.pdf)

### [P2167R0 : Improved Proposed Wording for LWG 2114](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2167r0.html)

### [P2168R0 : generator: A Synchronous Coroutine Generator Compatible With Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2168r0.pdf)

### [P2169R0 : A Nice Placeholder With No Name](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2169r0.pdf)

### [P2170R0 : Feedback on implementing the proposed std::error type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2170r0.html)

### [P2171R0 : Rebasing the Networking TS on C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2171r0.pdf)

### [P2172R0 : What do we want from a modularized Standard Library?](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2172r0.pdf)

### [P2173R0 : Attributes on Lambda-Expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2173r0.pdf)

### [P2174R0 : Compound Literals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2174r0.html)
