
### [P2469R0 Response to P2464: The Networking TS is baked, P2300 Sender/Receiver is not.](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2469r0.pdf)

「[P2464R0 Ruminations on networking and executors](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2464r0.html)」の主張に反論する文書。

ASIO（NetworkingTS、以下ASIOとは=NetworkingTSも意味する）の定義する非同期モデルにおけるExecutorとは、非同期処理の*tail call*のカスタマイゼーションポイントだとされます。非同期処理の完了後その結果を継続（ASIOでは完了ハンドラと呼ばれる）に渡しますが、この時点でその非同期処理は終了しています。これは、同期処理においては同期処理が戻った後で後続の処理を呼び出すことに対応しています。ASIOにおけるExecutorはそのような*tail call*が任意の実行コンテキストにおいて安全かつ効率的に実行できるようにするためのカスタマイゼーションポイントです。

同期関数が戻った後で発生するエラー（継続の呼び出し時も含めて）は明らかに終了した同期関数が感知する必要はなく、他の誰かの問題です。これと同様に、非同期*tail call*の後で発生したエラーは元の非同期処理には戻りません。そのため、*tail call*のカスタマイゼーションポイントはエラー処理について責任を持たず、処理の送信のみを仕事とします。

P0443の`executor`はASIOのものも含めた様々なExecutorとされるものから統一的なモデルを定義したものです。その中にあっても*tail call*のカスタマイゼーションポイントとしてのExecutorは少し特殊でしたが、結局は`executor`+追加のプロパティ指定によってASIOのExecutorは表現されました。そして、ASIOはすでにP0443のExecutorを実装しリリース済みで、約1年の実装と利用経験を持ちます。ASIOのExecutorは使用しようとしなければユーザーは全く触れる必要がないため大多数のユーザーには影響はなかったようですが、カスタマイズを必要とする一部のユーザーにとっては（おそらくインターフェースの変更によって）複雑さが増し使いやすさが低下したようです。

ASIOの*tail call*のカスタマイゼーションポイントとしてのExecutorモデルと同等のモデルは他のところでも見ることができます（[SwiftのExecutor](https://github.com/rjmccall/swift-evolution/blob/custom-executors/proposals/0000-custom-executors.md)、[Java Netty libraryの`EventExecutor`](https://netty.io/4.0/api/io/netty/util/concurrent/EventExecutor.html)、[.Netの`SynchronizationContext`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext?view=net-5.0)など）。細部は異なるものの、この収斂進化は非同期モデルを設計する上での基本要件を示していると言えます。

しかし、P0443の`executor`は（ASIOのExecutorがそうであるように）エラー通知チャネルがなく処理を実行コンテキストに投入する能力しか持ちません。そのため、非同期処理を構成するには能力不足だとして削除され、P2300では`scheduler`（エラー通知チャネルと処理のスケジューリングが可能で、`sender/reciever`をサポートする）をファーストクラスのExecutorとしてP0443を構築し直したExecutorライブラリが提案されました。前述のように、ASIOのExecutorは`scheduler`ほど高機能なものではなく、またその必要がありません。ASIOのExecutorにとって`scheduler`は過剰なもので、*tail call*のカスタマイゼーションポイントを表現するのに適していません。

そして、P2300の抽象化は`scheduler`の具体的実装を知っていなければ一般的なアルゴリズムを構成できず、P2300は非同期モデルを定義するものではなく非同期処理グラフを作成するためのDSLに過ぎず、そのことおよび次のような理由から、ASIO/NetworkingTSの非同期モデルはP2300のDSLを実装することができるより基礎的なモデルであると主張しています。

- ASIO/NetworkingTSの非同期モデルはより高次の非同期操作を公開しており、即時実行・コルーチン・ファイバーなどに加えて`sender`を単一の実装から作成できる
- ASIO/NetworkingTSの非同期モデルは、正しくデフォルトで安全な非同期性を確保するためにExecutorを組み込んでいる。それは必要がないユースケースでは無視することができる

文書には、ASIO/NetworkingTSとP2300とで同じ非同期処理を実装した時の比較が掲載されています。

その上で、P2464の指摘に対して個別回答をしています。以下引用

> P0443の`executor`が標準化されれば、C++プログラマはそのようなExecutorを数千作成し使用することになる（そこでは、`executor`の表現力不足による問題解決のお決まりパターンを書かねばならなくなる）

これは、Executorの目的とASIOの*tail call*のカスタマイゼーションポイントとしてのExecutorの役割のメンタルモデルに関する不整合を表している。ASIOでの10年以上、P0443の1年の実装経験によれば、ユーザーの大半はExecutorを直接使用することはない。GUIのイベントループとの統合など一部の特殊な場合にのみカスタムのExecutorが作成され、使用される。そのような場合の多くは、それをASIOの言葉でのIOオブジェクト（デフォルトの`io_context/io_service`相当のもの）として表現することで最適に対処可能だと思われる。そこには処理を非同期操作として実行する機能が含まれ、`scheduler`相当のものはそうして作成される。

> NetworkingTSの支持者はこれ（`executor`の表現力不足など、先ほどの指摘）は問題ではないと主張している。プログラマは*refined executor*（Executorをラップするなどして作成）にエラーハンドリングの機能を持たせれば良いと主張するか、プログラマは完了ハンドラから処理を構成するだけでExecutorはその全体像の中で重要ではない、と主張している。

上で説明したように、Executorは非同期*tail call*のカスタマイゼーションポイントとして機能する。このため、必要なインターフェースは継続の送信に限定される。失敗する可能性のあるインターフェースは、そのような*tail call*のカスタマイゼーションポイントの要件に適合すれば良い。

ただし、失敗が予想されるセマンティクスを持つ処理を非同期チェーンに合成することを意図するのであれば、先ほどと同様にこれをIOオブジェクトとして表現することを推奨する。

> 200の異なる実行戦略と10500の異なる継続修飾をサポートするにはこの関数（`scheduler`と`sender`のサンプルコード）の変種が幾つ必要だろうか？
> NetworkingTSモデルの提案者によって提示された解決策は、その答えが「多く」だと言っているようだが、`sender/reciever`なら「1つ」だ。

ASIOでの答えは「1つ」である。ASIOのモデルはP2300のスーパーセットであるため、同じ手法を適用できる。

逆に、P2300で提案されているソリューションはすべてのユーザーに実装と使用の経験がない単一の構成メカニズムを強制する。ユーザーが複数の実績のあるメカニズムの中から最適な（特定のドメインによって）一つを選択できるという選択肢は不利な点とみなされているようだ。

> NetworkingTSでは、入力される実行戦略は`executor`になる。これでは機能しないしスケールせず、抽象度が高すぎてジェネリックに統合できない。なぜなら、実行戦略は任意に複雑であり、ラッピングされた継続も同様であり、継続の実行に失敗することのないスレッドプールだとは限らない。

これも、Executorの目的とASIOの*tail call*のカスタマイゼーションポイントとしてのExecutorの役割のメンタルモデルに関する不整合を表している。

ネットワーキングのコンテキストではネットワークの実際の作業はソケットによって行われ、そこでは読み込みと書き込みが主な作業となる。同様に、実行する作業がGPUのように障害が発生しうるセマンティクスを持つ複雑なものである場合、これをI/Oオブジェクトにして機能を非同期操作として提示するのが正しいアプローチとなる。

これは、ASIOのモデルに適合するだけでなく、非同期操作を調整するために利用可能なすべてのツールを利用して、ユーザーが作業のスケジューリングと管理を制御することができる。

> P0443のExecutorは一般的なアルゴリズの構成を扱うことができない。P0443のExecutorは常に、`executor`というコンセプトを無視してエラー情報を取得するための具体的な実装を行い、ペイロードデータを構成可能なものに変形する必要がある。このコンセプトは全く役に立たず、これによって非同期処理を構成することはできない。
> [...]
> P0443のExecutorを作成するのはアドホックな作業である。[...] そのような統一モデルはおそらく完了ハンドラ上に構築することができるが、Executor上に構築することはできず、その場合の問題点は、誰もが独自の互換性のない構成モデルを構築してしまうことだ。

明らかに、ASIOのモデルの上に構成された非同期処理とジェネリックアルゴリズムを書くことができる。実際、ほとんどの場合の処理の構成において、Executorを無視することは、まさにそうすべきことだ！非同期の*tail call*のカスタマイゼーションポイントとして機能するExecutorのポイントは、非同期処理の構成それ自体の横断的な問題として扱うことができることである。

> NetworkingTSには、一度継続の実行コンテキストが確立されると、エラーでも成功でもそのコンテキストが継続のすべての呼び出しに使用されるという保証が必要であると言われている。

ASIOはそのような保証を要求しておらず、モデルに組み込まれているシングルコンテキストの要件はない。

組み込まれているもの : 非同期操作は、関連するExecutor（*Associated Executor*）の表すルールに従って完了ハンドラを実行することが要求される。つまり、Executorは非同期アルゴリズムのカスタマイゼーションポイントを表す。

この要件は