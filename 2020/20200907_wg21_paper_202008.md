# ［C++］WG21月次提案文書を眺める（2020年7月）

文書の一覧
[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-07:embed:cite]

提案文書で採択されたものはありません。全部で34本あります。

[:contents]

### [N4862 : Business Plan and Convener's Report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4862.pdf)

C++標準化委員会の全体的な作業の進捗状況や今後の予定などについての報告書。

おそらく、C++を利用している企業などに向けて書かれたものです。

### [P0288R6 : any_invocable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0228r6.html)

ムーブのみが可能で、関数呼び出しの`const`性や`noexcept`性を指定可能な`std::function`である`std::any_invocable`の提案。

`std::any_invocable`は次の点を除いてほとんど`std::function`です。

1. ムーブのみ可能
   - `std::unique_ptr`をキャプチャしたラムダのように、コピー不可能な*Callable*オブジェクトを受け入れられる
2. 関数型に`const`/参照修飾や`noexcept`を指定可能
   - `const`性を正しく伝播できる
3. `target_type()`および`target()`を持たない
4. 呼び出しには強い事前条件が設定される
   - これによって、呼び出し時の`null`チェックが省略される

```cpp
#include <any_invocable>  // 専用の新ヘッダ
#include <functional>

struct F {
  bool operator()() {
    return false;
  }
  
  bool operator()() const {
    return true;
  }
};

int main() {
  std::cout << std::boolalpha;
  
  const std::function<bool()> func1{F{}};
  const std::any_invocable<bool()> func2{F{}};
  const std::any_invocable<bool() const> func3{F{}};
  
  std::cout << func1() << '\n';  // false
  std::cout << func2() << '\n';  // false
  std::cout << func3() << '\n';  // true
}
```

このように`const`性を指定して正しく呼び出しが行えることで、並列処理においてスレッドセーフな呼び出しができるようになります。

他にも、`noexcept`や参照修飾は次のように指定します。なお、`volatile`修飾は指定することができません。

```cpp
#include <any_invocable>

struct F {
  int operator()(int n) const & noexcept {
    return n;
  }
  
  int operator()(int n) && {
    return n + 1;
  }
};

int main() {
  std::any_invocable<int(int) const & noexcept(true)> func1{F{}};
  std::any_invocable<int(int) && noexcept(false)> func2{F{}};

  std::cout << func1(1) << '\n';  // 1
  std::cout << func2(1) << '\n';  // 2
}
```

これらの修飾や指定は全て省略することもできます。

`std::any_invocable`でも小さいオブジェクトで動的メモリ確保を避けるように規定されているので、`std::function`に比べると若干パフォーマンスが良さそうです。

`std::any_invocable`はすでにLWGでのレビューに入っていて、C++23に入る可能性が高そうです。

- [N4348 Making `std::function` safe for concurrency](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4348.html)
- [P0288 進行状況](https://github.com/cplusplus/papers/issues/400)

### [P0881R6 : A Proposal to add stacktrace library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0881r6.html)

スタックトレースを取得するためのライブラリを追加する提案。

このライブラリの目的はひとえにデバッグをより効率化することにあります。例えば次のような実行時アサーションメッセージを

> boost/array.hpp:123: `T& boost::array<T, N>::operator[](boost::array<T, N>::size_type)`: Assertion '`(i < N)&&("out of range")`' failed.
Aborted (core dumped)

次のような出力にできるようにします

> Expression '`i < N`' is false in function '`T& boost::array<T, N>::operator[](boost::array<T, N>::size_type)`': out of range.  
> Backtrace:  
>  0# boost::assertion_failed_msg(char const*, char const*, char const*, char const*, long) at ../example/assert_handler.cpp:39  
>  1# boost::array<int, 5ul>::operator[](unsigned long) at ../../../boost/array.hpp:124  
>  2# bar(int) at ../example/assert_handler.cpp:17  
>  3# foo(int) at ../example/assert_handler.cpp:25  
>  4# bar(int) at ../example/assert_handler.cpp:17  
>  5# foo(int) at ../example/assert_handler.cpp:25  
>  6# main at ../example/assert_handler.cpp:54  
>  7# 0x00007F991FD69F45 in /lib/x86_64-linux-gnu/libc.so.6  
>  8# 0x0000000000401139

このライブラリはBoost.Stacktraceをベースに設計されています。スタックトレースの一行（すなわちスタックフレーム）は`std::stacktrace_entry`というクラスで表現され、`std::stacktrace`というクラスが一つのスタックトレースを表現します。`std::stacktrace`はほとんど`std::stacktrace_entry`の`std::vector`です。

```cpp
#include <stacktrace> // このヘッダに定義される

void f() {
  // 現在のスタックトレースを取得
  auto st = std::stacktrace::current();

  // スタックトレース全体の出力
  std::cout << st << std::endl;

  // スタックトレースのイテレーション
  for (const auto& entry : st) {
    // 例えばソースファイル名だけを取得
    std::cout << entry.source_file() << std::endl;
  }
}
```

スタックトレースの取得はプラットフォーム毎にそこでのシステムコールやAPI呼び出しにマッピングされます。情報を取り漏らさないためにスタックトレースの取得サイズは可変長としているので動的メモリ確保が伴います。また、取得したスタックトレース情報のデコードはギリギリまで遅延されます。上記でいうと、`std::stacktrace_entry::source_file()`が呼び出された時、あるいは内部でそれを呼び出す`std::stacktrace`の標準出力への出力時に取得した情報が逐次デコードされます。

提案によれば、コンパイラオプションによってABIを変化させずにこれらの関数が何もしないように制御する実装をサポート可能としているようで、これはBoost.Stacktraceから受け継いでいる機能です。

この提案は元々C++20に導入することを目指していたようで、すでにLWGでのレビューが一旦完了しており大きな問題もなさそうなので、C++23に入る可能性が高そうです。

- [Boost.Stacktrace - Boost C++ Libraries](https://www.boost.org/doc/libs/1_74_0/doc/html/stacktrace.html)
- [P0881 進行状況](https://github.com/cplusplus/papers/issues/119)

### [P1787R5 : Declarations and where to find them](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1787r5.html)
### [P1875R1 : Transactional Memory Lite Support in C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1875r1.pdf)
### [P1949R5 : C++ Identifier Syntax using Unicode Standard Annex 31](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1949r5.html)
### [P2013R2 : Freestanding Language: Optional ::operator new](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2013r2.html)
### [P2053R1 : Defensive Checks Versus Input Validation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2053r1.pdf)
### [P2079R1 : Parallel Executor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2079r1.html)
### [P2096R2 : Generalized wording for partial specializations](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2096r2.html)
### [P2162R1 : Inheriting from std::variant (resolving LWG3052)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2162r1.html)
### [P2187R4 : std::swap_if, std::predictable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2187r4.pdf)
### [P2192R1 : std::valstat - function return type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2192r1.pdf)
### [P2197R0 : Formatting for std::complex](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2197r0.html)
### [P2205R0 : Executors Review - Polymorphic Executor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2205r0.pdf)
### [P2207R0 : Executors review: concepts breakout group report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2207r0.pdf)
### [P2209R0 : Bulk Schedule](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2209r0.html)
### [P2210R0 : Superior String Splitting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2210r0.html)
### [P2212R0 : Relax Requirements for time_point::clock](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2212r0.html)
### [P2213R0 : Executors Naming](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2213r0.pdf)
### [P2215R0 : "Undefined behavior" and the concurrency memory model](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2215r0.pdf)