# ［C++］WG21月次提案文書を眺める（2020年6月）

文書の一覧
[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-06:embed:cite]

提案文書で採択されたものはありません。全部で28本あります。

[:contents]

### [P1401R3 : Narrowing contextual conversions to bool](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1401r3.html)

`constexpr if`や`static_assert`の引数でのみ、整数型から`bool`型への暗黙の縮小変換を定数式で許可する提案。

現在定数式での整数の暗黙変換では、文脈的な`bool`変換も含めて縮小変換が禁止されており次のようなコードはコンパイルエラーになります。

```cpp
enum Flags { Write = 1, Read = 2, Exec = 4 };

template <Flags flags>
int f() {
  if constexpr (flags & Flags::Exec) // 縮小変換が起きるためコンパイルエラー
  // if constexpr (bool(flags & Flags::Exec)) とするとok
    return 0;
  else
    return 1;
}

int main() {
  return f<Flags::Exec>();  // コンパイルエラー
}
```
```cpp
template <std::size_t N>
class Array {
  static_assert(N, "no 0-size Arrays"); // 縮小変換が起きるためコンパイルエラー
  // static_assert(N != 0); とするとok

  // ...
};

Array<16> a;  // コンパイルエラー
```

一方対応する実行時コードは普通にコンパイルでき、期待通りに動作します。

```cpp
if (flags & Flags::Exec) // ok
  {}

assert(N); // ok
```

このような一貫しておらず直感的ではない挙動を修正するために、`constexpr if`と`static_assert`の条件式に限って、文脈的な`bool`変換時の縮小変換を許可しようというものです。

そもそもこれらの条件式でさえも`bool`への縮小変換が禁止されていたのは、`noexcept`式での縮小変換を禁止した時に巻き込まれてしまったためのようです。関数`f()`の例外仕様が別の関数`g()`と同じ（あるいはそれに従う）場合、`noexcept`を二つ重ねて書きます。しかし、その場合に書き間違えて関数名だけを書いたり、1つにしてしまって`g()`が`constexpr`関数だったりすると思わぬバグを生みます。

```cpp
int f() noexcept(noexcept(g()));  // 書きたいこと、noexcept指定指の中にnoexcept式を書く

int f() noexcept(g);    // 関数ポインタからの暗黙変換、でもこう書きたさもある・・・
int f() noexcept(g());  // 定数評価の結果bool値へ変換されると・・・
```

このような些細な、しかし気づきにくいバグを防ぐために定数式での文脈的な`bool`変換の際は縮小変換を禁止することにしました。しかし、`noexcpet`以外のところではこれによって（最初に上げたような）冗長なコードを書くことになってしまっていました。

この欠陥報告（CWG 2039、C++14）を行ったRichard Smithさんによると、本来は`noexcept`式にだけ適用するつもりで、`static_assert`には表現の改善のみで縮小変換禁止を提案してはいなかったそうですが、その意図に反して両方で縮小変換が禁止されてしまいました。結果、おそらくその文言を踏襲する形で`constexpr if`や`explicit(bool)`にも波及したようです。

- [CWG Issue.2039 Constant conversions to bool](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#2039)

### [P1450R3 : Enriching type modification traits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1450r3.pdf)

型の修飾情報などを操作するためのいくつかの新しいメタ関数の提案。

主に次の2種類のものが提案されています。

- `remove_all_pointers`
- 型に付いている情報をコピーする`copy_*`メタ関数

```cpp
using remove_ptr = std::remove_all_pointers_t<int************>;     // int
using copy_ptr1 = std::copy_all_pointers_t<int***, double>;         // double***
using copy_ptr2 = std::copy_all_pointers_t<int***, double*>;        // double****
using copy_r1 = std::copy_reference_t<int&, double>;                // double&
using copy_r2 = std::copy_reference_t<int&, double&>;               // double&&
using copy_r3 = std::copy_reference_t<int&, double&&>;              // double&
using copy_const1 = std::copy_concst_t<const int, double>;          // const double  
using copy_const2 = std::copy_const_t<const volatile int, double>;  // const double  
using copy_cvr = std::copy_cvref_t<const volatile int&&, double>;   // const volatile double&&
```

この他にも`copy_volatile`とか`copy_extent`、`copy_pointer`などが提案されています。

`copy_*`系メタ関数の引数順は`<From, To>`になっており、全てに`_t`付きのエイリアスが用意されています。また、対象の修飾がコピー先にすでに付いている場合はそれはそのままに追加でコピーする形になり、コピー元に対象の修飾がない場合は何もコピーしません。

筆者の方々の経験からプロクシクラス作成やカスタムオーバーロードセットを構築するツールの実装に有用であった型特性を提案しているそうです。

- [std::remove_all_extents - cpprefjp](https://cpprefjp.github.io/reference/type_traits/remove_all_extents.html)
- [vreverdy/type-utilities - Github](https://github.com/vreverdy/type-utilities)

### [P1467R4 : Extended floating-point types and standard names](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1467r4.html)

C++コア言語/標準ライブラリに追加の浮動小数点型のサポートを追加する提案。

機械学習（特にディープラーニング）では多くの場合それほど高い精度が求められないため、`float`（32bit浮動小数点数）よりもより小さい幅の浮動小数点型（時には整数型）を利用することでその時間的/空間的なコストを抑えることが行われており、それを支援する形でハードウェア（GPU/CPU）やソフトウェア（CUDA/LLVM-IR）でのサポートが充実してきています。

現在のC++には3種類の浮動小数点型だけが定義されておりそれ以外のものは何らサポートがあリません。現在それらの拡張浮動小数点型は、算術・変換演算子をオーバーロードして組み込み型に近い挙動を示すようなクラス型を定義することでサポートされています。しかし、そのような方法は完全ではなく面倒で、効率化のためにインラインアセンブラやコンパイラ固有のサポートが必要とされます。  
これらの問題はユーザー定義のライブラリで解決できるものではなく、コア言語でのサポートが必要です。そして、拡張浮動小数点型が求められる場所ではC++が使用される事が多くこれらの問題を解決するに足る価値（ポータビリティ、効率性など）があるので、拡張浮動小数点型の言語/ライブラリサポートを追加しようという提案です。

ただし、現在のところ拡張浮動小数点型のスタンダードとなるものは確定しておらず、将来どれが使われていく（あるいは廃れる）のか予測することは困難であるため、何がいくつ定義されるかは実装定義とされます。そのため、`bfloat16`とか`float16`みたいな具体的な型は提供されませんが、代わりに似た形のエイリアスが実装定義で提供されます。

変更は既存の浮動小数点型の振る舞いを保ったままで追加の浮動小数点型をより安全に利用可能かつ拡張可能である（ハードウェアに依存しない）ようにされています。

- 拡張浮動小数点型は`double`に昇格されない
- 拡張浮動小数点型の関わる暗黙変換では縮小変換を許可しない
    - ただし、定数式では許可される
- 式のオペランドとなっている2つの浮動小数点型を統一する算術型変換（*Usual arithmetic conversions*）では、どちらのオペランドももう片方の型に変換できない場合はill-formed

```cpp
float f32 = 1.0;
std::float16_t f16 = 2.0;
std::bfloat16_t b16 = 3.0;

f32 + f16; // OK、f16はfloatに変換可能、結果の型はfloat
f32 + b16; // OK、b16はfloatに変換可能、結果の型はfloat
f16 + b16; // NG、2つの型の間に互換性がなく、どちらの型ももう片方の型に値を変更することなく変換できない

std::float16_t x{2.1};  // OK、2.1は2進浮動小数で表現可能ではないため縮小変換が発生している、定数式なのでok

// <charconv>が使用可能
char out[50]{};
if (auto [ptr, ec] = std::to_chars(out, out + 50, f16); ec == std::errc{}) {
  std::cout << std::string_view(out, ptr - out) << std::endl;
}

std::float16_t outv;
if (auto [ptr, ec] = std::from_chars(out, ptr, outv); ec == std::errc{}) {
  std::cout << outv << std::endl;
}

// ユーザー定義リテラルが用意される
using namespace std::float_literals;

// complexも規定される
std::complex<std::bfloat16_t> z = {1.0bf16, 2.0bf16};
```

これら型エイリアスが定義されるヘッダには`<fixed_float>`か`<stdfloat>`という名前を提案しているようですが、筆者の方々はあまり気に入っていないようでより良い名前やふさわしい既存のヘッダを考慮中のようです。いい名前が思いついたらコントリビュートチャンスです。

- [半精度浮動小数点数 - wikipedia](https://ja.wikipedia.org/wiki/半精度浮動小数点数)
- [bfloat16 floating-point format - wikipedia](https://en.wikipedia.org/wiki/Bfloat16_floating-point_format)

### [P1468R4 : Fixed-layout floating-point type aliases](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1468r4.html)
### [P1642R3 : Freestanding Library: Easy [`utilities`], [`ranges`], and [`iterators`]](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1642r3.html)
### [P1944R1 : Add Constexpr Modifiers to Functions in cstring and cwchar Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1944r1.pdf)
### [P1949R4 : C++ Identifier Syntax using Unicode Standard Annex 31](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1949r4.html)
### [P1990R1 : Add `operator[]` to `std::initializer_list`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1990r1.pdf)
### [P2025R1 : Guaranteed copy elision for return variables](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2025r1.html)
### [P2034R2 : Partially Mutable Lambda Captures](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2034r2.pdf)
### [P2037R1 : String's gratuitous assignment](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2037r1.html)
### [P2093R0 : Formatted output](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2093r0.html)
### [P2138R2 : Rules of Design<=>Wording engagement](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2138r2.html)
### [P2139R1 : Reviewing Deprecated Facilities of C++20 for C++23](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2139r1.html)
### [P2141R0 : Aggregates are named tuples](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2141r0.html)
### [P2146R1 : Modern std::byte stream IO for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2146r1.pdf)
### [P2152R0 : Querying the alignment of an object](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2152r0.pdf)
### [P2161R1 : Remove Default Candidate Executor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2161r1.pdf)
### [P2164R1 : views::enumerate](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2164r1.pdf)
### [P2166R0 : A Proposal to Prohibit `std::basic_string` and `std::basic_string_view` construction from `nullptr`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2166r0.html)
### [P2176R0 : A different take on inexpressible conditions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2176r0.html)
### [P2178R0 : Misc lexing and string handling improvements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2178r0.pdf)
### [P2179R0 : SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2179r0.html)
### [P2181R0 : Correcting the Design of Bulk Execution](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2181r0.html)
### [P2182R0 : Contract Support: Defining the Minimum Viable Feature Set](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2182r0.html)
### [P2184R0 : Thriving in a crowded and changing world: C++ 2006-2020](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2184r0.pdf)
### [P2185R0 : Contracts Use Case Categorization](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2185r0.html)
### [P2188R0 : Zap the Zap: Pointers should just be bags of bits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2188r0.html)


### 次

7月半ば

[この記事のMarkdownソース](https://github.com/onihusube/blog/blob/master/2020/20200701_wg21_paper_202006.md)