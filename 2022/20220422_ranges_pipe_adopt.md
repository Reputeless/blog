#  ［C++］ rangesのパイプにアダプトするには

C++20の`<ranges>`のパイプ（`|`）に自作の`view`（Rangeアダプタ）を接続できるようにするにはどうすればいいのでしょうか？その方法は一見よくわからず、特に提供されてもいません。それでもできないことはないので、なんとかする話です。

### パイプの実態

rangesのパイプは言語組み込みの機能ではなく、ビット論理和演算子（`|`）をオーバーロードしたものです。そのため、単純には`|`のオーバーロードを自作の`view`に対して提供すれば良さそうに思えます。

しかし、よくあるパイプライン記法による記述を見てみると、それではダメそうなことがわかります。

```cpp
int main() {
  using namespace std::views;

  auto seq = iota(1) | drop(5)
                     | filter([](int n) { return n % 2 == 0;})
                     | transform([](int n) { return n * 2; })
                     | take(5);
}
```

このチェーンの起点となっているのは`iota(1)`であり、これは入力となる`range`を生成しています。この`iota`は`iota_view`という`view`を返していて、このように引数から何か`view`を生成しているものをRangeファクトリ（オブジェクト）と呼びます。Rangeファクトリはこの`iota`のようにパイプの最初で使用して入力となる`range`を生成するタイプのものです。今回どうにかしたいのはこれではありません。

`iota(1)`の後ろで、`|`で接続されていのがRangeアダプタ（オブジェクト）と呼ばれるもので、これは`view`を入力として何かしらの変換を適用した`view`を返すものです。これは必ず`|`の右辺に来るものです。今回どうにかしたいのはこれです。

ここで注意すべきなのは、Rangeファクトリの戻り値型は常に`view`であるのに対して、Rangeアダプタの戻り値型はそうではないことです。例えば`drop(5)`の戻り値型は引数に与えられた`5`を保持した何かを返しています。その後、`|`によって`view`を入力することでようやく`view`を生成します（`iota(1) | drop(5)`の結果は`dorp_view`になる）。

Rangeファクトリを`RF`、Rangeアダプタを`RA`、与える0個以上の引数を`Args`として、コンセプトっぽい書き方で表すと次のようになっています

- Rangeファクトリ : `RF(Args) -> view`
- Rangeアダプタ : `RA(Args) -> ??`
- パイプライン  : `view | RA(Args) -> view`

`view`は[`view`コンセプト](https://cpprefjp.github.io/reference/ranges/view.html)を満たす型であることを表します。

この性質から分かるように、パイプライン演算子（`|`）を提供しているのはRangeアダプタの戻り値型（上記の`??`）です。そして、自作のRangeアダプタをパイプにチェーンしたければこれらと同じことをする必要があります。

### Rangeアダプタオブジェクト/Rangeアダプタクロージャオブジェクト

Rangeアダプタオブジェクトとは、1つ目の引数に[`viewable_range`](https://cpprefjp.github.io/reference/ranges/viewable_range.html)を受けて呼出可能なカスタマイゼーションポイントオブジェクトであり、その戻り値型は`view`となります。中でも、1引数のRangeアダプタオブジェクトのことを特に、Rangeアダプタクロージャオブジェクトと呼びます。

このRangeアダプタクロージャオブジェクトには規格によって変な性質が付加されています。

Rangeアダプタクロージャオブジェクト`C`と入力の`range`（正確には、`viewable_range`）オブジェクト`r`があった時、次の2つの記述は同じ意味と効果を持ちます

```cpp
C(r);   // 関数記法
r | C:  // パイプライン記法
```

ようはRangeアダプタクロージャオブジェクトに入力`range`を関数呼出とパイプラインの2つの方法で入力できるということです。先ほど見たように、この戻り値型は`view`となります（でなければなりません）。コンセプトを用いて書いてみると次のようになります

```cpp
// 入力のrange(viewable_range)オブジェクト
viewable_range auto r = ...;

// この2つの呼び出しは同じviewを返す
view auto v1 = C(r);
view auto v2 = r | C ;
```

さらに、別のRangeアダプタクロージャオブジェクト`D`に対して、`C | D`が有効である必要があり、その戻り値型はまたRangeアダプタクロージャオブジェクトである必要があります。

```cpp
auto E = C | D;  // EはRangeアダプタクロージャオブジェクト

// これらの呼び出しは同じviewを返す
view auto v1 = r | C | D;
view auto v2 = r | (C | D) ;
view auto v3 = r | E ;
view auto v4 = E(r) ;
```

つまりは、Rangeアダプタクロージャオブジェクト同士もまた`|`で（事前に）接続可能であるということです。そしてその結果もRangeアダプタクロージャオブジェクトとなり、入力に対して順番に接続した時と同じ振る舞いをしなければなりません。ただし、Rangeアダプタクロージャオブジェクト同士の事前結合においては関数記法を使用できません。

```cpp
auto E = D(C);  // これはできない
```

Rangeアダプタクロージャオブジェクトは1引数ですが、Rangeアダプタオブジェクトの中には追加の引数を受け取る者もいます（というかそっちの方が多い）。その場合、引数を渡してから`range`を入力しても、`range`と一緒に引数を渡しても、等価な振る舞いをします。

```cpp
view auto v1 = r | C(args...);
view auto v2 = C(r, args...);
view auto v3 = C(args...)(r);
```

つまりは、Rangeアダプタオブジェクトにその追加の引数`args...`をあらかじめ渡すことができて、その結果（`C(args...)`）はRangeアダプタオブジェクト（Rangeアダプタクロージャオブジェクト）となります。

ここまでくると、Rangeアダプタクロージャオブジェクトとは、このように追加の引数を全て部分適用して、あとは入力の`range`を受け取るだけになったRangeアダプタオブジェクト（1引数で呼出可能なRangeアダプタオブジェクト）、であることがわかります。そして、パイプで使用可能なRangeアダプタオブジェクトとはRangeアダプタクロージャオブジェクトのことです。

なお、事前結合が可能なのはRangeアダプタクロージャオブジェクトだけなので、そうではないRangeアダプタオブジェクトを事前接続することはできません。

### 実例

```cpp
int main() {
  auto seq = iota(1) | std::views::take(5);
}
```

ここでは、`std::views::take`はRangeアダプタオブジェクトですがまだRangeアダプタクロージャオブジェクトではありません。`take(5)`によって必要な引数が満たされ、Rangeアダプタクロージャオブジェクトとなり、これで`|`で使用可能となります。そして、`iota(1) | take(5)`の結果は`view`を生成します。

標準にあるRangeアダプタクロージャオブジェクトには例えば`views::common`があります。

```cpp
int main() {
  auto seq = iota(1) | std::views::common;
}
```

`views::common`はすでにRangeアダプタクロージャオブジェクトであるので追加の引数を渡す必要がなく、そのままパイプで接続可能です。`iota(1) | common`の結果は`view`を生成します。

Rangeアダプタの事前適用は次のようになります

```cpp
int main() {
  using namespace std::views;

  auto adoptor = drop(5)
               | filter([](int n) { return n % 2 == 0;})
               | transform([](int n) { return n * 2; })
               | take(5);

  auto seq = iota(1) | adoptor;
}
```

ここで、`adoptor`はRangeアダプタクロージャオブジェクトであり、まだ`range`は入力されていません。そして、`iota(1) | adoptor`は冒頭の全部まとめているコードと同じ振る舞いをします（ただし、ここではまだ処理を開始していないので何も始まっていません）。

- [ここまでの例 - Compiler Explorer](https://godbolt.org/z/Y8ThbT4zP)

自作のRangeアダプタ（`view`）でパイプを使用可能にするとは、その`view`のためのRangeアダプタオブジェクトを定義した上で、これらのことを正しく実装する必要がある事を意味しています。

### 標準ライブラリ実装による実装
#### GCC
#### MSVC
#### Clang
### 共通実装
### C++23
### 参考文献
