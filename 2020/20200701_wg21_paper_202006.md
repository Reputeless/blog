# ［C++］WG21月次提案文書を眺める（2020年6月）

文書の一覧
[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-06:embed:cite]

提案文書で採択されたものはありません。全部で28本あります。

[:contents]

### [P1401R3 : Narrowing contextual conversions to bool](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1401r3.html)

`constexpr if`や`static_assert`の引数でのみ、整数型から`bool`型への暗黙の縮小変換を定数式で許可する提案。

現在定数式では文脈的な`bool`変換も含めて縮小変換が禁止されており、次のようなコードはコンパイルエラーになります。

```cpp
enum Flags { Write = 1, Read = 2, Exec = 4 };

template <Flags flags>
int f() {
  if constexpr (flags & Flags::Exec) // 縮小変換が起きるためコンパイルエラー
  // if constexpr (bool(flags & Flags::Exec)) とするとok
    return 0;
  else
    return 1;
}

int main() {
  return f<Flags::Exec>();  // コンパイルエラー
}
```
```cpp
template <std::size_t N>
class Array {
  static_assert(N, "no 0-size Arrays"); // 縮小変換が起きるためコンパイルエラー
  // static_assert(N != 0); とするとok

  // ...
};

Array<16> a;  // コンパイルエラー
```

一方対応する実行時コードは普通にコンパイルでき、期待通りに動作します。

```cpp
if (flags & Flags::Exec) // ok
  {}

assert(N); // ok
```

このような一貫しておらず直感的ではない挙動を修正するために、`constexpr if`と`static_assert`の条件式に限って、文脈的な`bool`変換時の縮小変換を許可しようというものです。

そもそもこれらの条件式でさえも`bool`への縮小変換が禁止されていたのは、`noexcept`式での縮小変換を禁止した時に巻き込まれてしまったためのようです。関数`f()`の例外仕様が別の関数`g()`と同じ（あるいはそれに従う）場合、`noexcept`を二つ重ねて書きます。しかし、その場合に書き間違えて関数名だけを書いたり、1つにしてしまって`g()`が`constexpr`関数だったりすると思わぬバグを生みます。

```cpp
int f() noexcept(noexcept(g()));  // 書きたいこと、noexcept指定指の中にnoexcept式を書く

int f() noexcept(g);    // 関数ポインタからの暗黙変換、でもこう書きたさもある・・・
int f() noexcept(g());  // 定数評価の結果bool値へ変換されると・・・
```

このような些細な、しかし気づきにくいバグを防ぐために定数式での文脈的な`bool`変換の際は縮小変換を禁止することにしました。しかし、`noexcpet`以外のところではこれによって（最初に上げたような）冗長なコードを書くことになってしまっていました。

この欠陥報告（CWG 2039、C++14）を行ったRichard Smithさんによると、本来は`noexcept`式にだけ適用するつもりで、`static_assert`には表現の改善のみで縮小変換禁止を提案してはいなかったそうですが、その意図に反して両方で縮小変換が禁止されてしまいました。結果、おそらくその文言を踏襲する形で`constexpr if`や`explicit(bool)`にも波及したようです。

- [CWG Issue.2039 Constant conversions to bool](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#2039)

### [P1450R3 : Enriching type modification traits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1450r3.pdf)
### [P1467R4 : Extended floating-point types and standard names](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1467r4.html)
### [P1468R4 : Fixed-layout floating-point type aliases](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1468r4.html)
### [P1642R3 : Freestanding Library: Easy [`utilities`], [`ranges`], and [`iterators`]](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1642r3.html)
### [P1944R1 : Add Constexpr Modifiers to Functions in cstring and cwchar Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1944r1.pdf)
### [P1949R4 : C++ Identifier Syntax using Unicode Standard Annex 31](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1949r4.html)
### [P1990R1 : Add `operator[]` to `std::initializer_list`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1990r1.pdf)
### [P2025R1 : Guaranteed copy elision for return variables](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2025r1.html)
### [P2034R2 : Partially Mutable Lambda Captures](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2034r2.pdf)
### [P2037R1 : String's gratuitous assignment](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2037r1.html)
### [P2093R0 : Formatted output](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2093r0.html)
### [P2138R2 : Rules of Design<=>Wording engagement](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2138r2.html)
### [P2139R1 : Reviewing Deprecated Facilities of C++20 for C++23](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2139r1.html)
### [P2141R0 : Aggregates are named tuples](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2141r0.html)
### [P2146R1 : Modern std::byte stream IO for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2146r1.pdf)
### [P2152R0 : Querying the alignment of an object](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2152r0.pdf)
### [P2161R1 : Remove Default Candidate Executor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2161r1.pdf)
### [P2164R1 : views::enumerate](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2164r1.pdf)
### [P2166R0 : A Proposal to Prohibit `std::basic_string` and `std::basic_string_view` construction from `nullptr`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2166r0.html)
### [P2176R0 : A different take on inexpressible conditions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2176r0.html)
### [P2178R0 : Misc lexing and string handling improvements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2178r0.pdf)
### [P2179R0 : SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2179r0.html)
### [P2181R0 : Correcting the Design of Bulk Execution](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2181r0.html)
### [P2182R0 : Contract Support: Defining the Minimum Viable Feature Set](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2182r0.html)
### [P2184R0 : Thriving in a crowded and changing world: C++ 2006-2020](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2184r0.pdf)
### [P2185R0 : Contracts Use Case Categorization](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2185r0.html)
### [P2188R0 : Zap the Zap: Pointers should just be bags of bits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2188r0.html)


### 次

7月半ば

[この記事のMarkdownソース](https://github.com/onihusube/blog/blob/master/2020/20200701_wg21_paper_202006.md)