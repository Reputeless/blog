# ［C++］WG21月次提案文書を眺める（2021年01月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2021 mailing2021-01](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/#mailing2021-01)

採択されたものはありません、全部で30本あります。

[:contents]

### [SD-1 2021 PL22.16/WG21 document list](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/sd-1.htm)

2016年〜2021年（1月）までの提案文書の一覧。

### [P0447R12 Introduction of std::colony to the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0447r12.html)
### [P0847R6 Deducing this](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r6.html)
### [P1121R2 Hazard Pointers: Proposed Interface and Wording for Concurrency TS 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1121r2.pdf)


標準ライブラリにハザードポインタを導入する提案。

ハザードポインタは*deferred reclamation*を実装する為の方法の一つで、並行処理におけるデータ共有のための仕組みの一つです。

*deferred reclamation*に関しては以前の記事を参照。

- [P0561R5 An RAII Interface for Deferred Reclamation - WG21月次提案文書を眺める（2020年12月）](https://onihusube.hatenablog.com/entry/2021/01/17/005823#P0561R5-An-RAII-Interface-for-Deferred-Reclamation)

```cpp
struct Name : public hazard_pointer_obj_base<Name> {
  /* details */
};

std::atomic<Name*> name;

// 頻繁にparallelに呼ばれる
void print_name() {
  // nameを使用する
  hazard_pointer h = make_hazard_pointer();
  Name* ptr = h.protect(name);
  // 以降、*ptrには安全にアクセスできる（競合したり勝手に消えたりしない）
}

// あんまり呼ばれない
void update_name(Name* new_name) {
  // nameを更新する
  Name* ptr = name.exchange(new_name);
  ptr->retire();
}
```

この提案はConcurrency TS v2に向けて議論が進んでいます。現在はLWGで議論中なのでそこには入りそうです。

- [Lockfree list - Slideshare](https://www.slideshare.net/kumagi/lockfree-list)
- [P1121 進行状況](https://github.com/cplusplus/papers/issues/132)

### [P1425R2 Iterators pair constructors for stack and queue](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1425r2.pdf)

`std::stack`と`std::queue`に、イテレータペアを受け取るコンストラクタを追加する提案。

`std::stack`と`std::queue`はイテレータペアを受け取るコンストラクタがなく他のコンテナとの一貫性を欠いており、それによって`ranges::to`の実装では特別扱いするかサポートしない選択を迫られていました。

この提案はこれらのコンテナアダプタと他のコンテナの間の一貫性を改善し、統一的な扱いができるようにするものです。

```cpp
#include <array>
#include <stack>
#include <queue>

int main() {
  std::array<int, 4> arr = {1, 2, 3, 4};

  // C++20まで、こう書けばできた
  std::stack<int> st{{arr.begin(), arr.end()}};
  std::queue<int> qu{{arr.begin(), arr.end()}};

  // この提案
  std::stack<int> st{arr.begin(), arr.end()};
  std::queue<int> qu{arr.begin(), arr.end()};
}
```

この提案はLWGでのレビューをほぼ終えていますが、最近提出されたIssue（[LWG 3506](https://cplusplus.github.io/LWG/issue3506)）との兼ね合いを調査するためのLEWGでのレビューを待っている状態です。問題がなければC++23に入るものと思われます。

- [P1425 進行状況](https://github.com/cplusplus/papers/issues/204)

### [P1682R2 std::to_underlying](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1682r2.html)
### [P1708R3 Simple Statistical Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1708r3.pdf)
### [P1989R1 Range constructor for std::string_view 2: Constrain Harder](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1989r1.pdf)
### [P2036R1 Changing scope for lambda trailing-return-type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2036r1.html)
### [P2072R1 Differentiable programming for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2072r1.pdf)
### [P2093R3 Formatted output](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2093r3.html)
### [P2168R1 generator: A Synchronous Coroutine Generator Compatible With Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2168r1.pdf)
### [P2210R1 Superior String Splitting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2210r1.html)
### [P2216R2 std::format improvements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2216r2.html)
### [P2232R0 Zero-Overhead Deterministic Exceptions: Catching Values](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2232r0.html)
### [P2244R0 SG14: Low Latency/Games/Embedded/Finance/Simulation Meeting Minutes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2244r0.pdf)
### [P2245R0 SG19: Machine Learning Meeting Minutes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2245r0.pdf)
### [P2246R1 Character encoding of diagnostic text](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2246r1.pdf)
### [P2259R1 Repairing input range adaptors and counted_iterator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2259r1.html)
### [P2266R0 Simpler implicit move](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2266r0.html)
### [P2276R0 Fix std::cbegin(), std::ranges::cbegin, and cbegin() for span (fix of wrong fix of lwg3320)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2276r0.pdf)
### [P2277R0 Packs outside of Templates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html)
### [P2278R0 cbegin should always return a constant iterator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2278r0.html)
### [P2279R0 We need a language mechanism for customization points](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2279r0.html)
### [P2280R0 Using unknown references in constant expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2280r0.html)
### [P2281R0 Clarifying range adaptor objects](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2281r0.html)
### [P2283R0 constexpr for specialized memory algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2283r0.html)
### [P2285R0 Are default function arguments in the immediate context?](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2285r0.html)
### [P2286R0 Formatting Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2286r0.html)
### [P2287R0 Designated-initializers for base classes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2287r0.html)