# ［C++］WG21月次提案文書を眺める（2021年01月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2021 mailing2021-01](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/#mailing2021-01)

採択されたものはありません、全部で30本あります。

[:contents]

### [SD-1 2021 PL22.16/WG21 document list](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/sd-1.htm)

2016年〜2021年（1月）までの提案文書の一覧。

### [P0447R12 Introduction of std::colony to the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0447r12.html)
### [P0847R6 Deducing this](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r6.html)
### [P1121R2 Hazard Pointers: Proposed Interface and Wording for Concurrency TS 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1121r2.pdf)


標準ライブラリにハザードポインタを導入する提案。

ハザードポインタは並行処理におけるデータ共有のための仕組みで、ABA問題を回避するための*deferred reclamation*を実装する方法の一つです。

*deferred reclamation*に関しては以前の記事を参照。

- [P0561R5 An RAII Interface for Deferred Reclamation - WG21月次提案文書を眺める（2020年12月）](https://onihusube.hatenablog.com/entry/2021/01/17/005823#P0561R5-An-RAII-Interface-for-Deferred-Reclamation)

複数のスレッドによって共有されるデータがあり（ヒープ上にあるとします）、あるスレッドがそれを読み取っており他のスレッドも同様に読み書きができる時、読んでいるスレッドは勝手にデータを変更されたり削除されたりされたくはありません。そこで、全スレッドが読み取る事の出来るところにポインタを用意しておいて、読み取り中のデータのアドレスをそこに入れておきます。そのポインタに登録されたデータは誰かが見ている途中なので変更しない事、というルールを課します。このポインタのことをハザードポインタと呼びます。  
ハザードポインタはある瞬間には最大1つのスレッドによって書き込みが可能とされます。読み取りは全てのスレッドから行えます。

他のスレッドが共有データを変更しようとする時、まずハザードポインタを見に行きます。何も登録されていなければ現在のデータを消すのも書き換えるのも自由です。ハザードポインタに登録がある時（そして変更しようとするデータが登録されている時）、現在のデータを維持したまま新しいデータで置き換えることでデータを更新します。維持されたデータは削除待ちとしてマークして、ハザードポインタからの登録が解除された段階で削除されます。

ハザードポインタのイメージ（P0233R6より）
![](./20210206_wg21_paper_202101/hazard_pointer.png)

ハザードポインタは単一のものを全スレッドで共有するというよりは、それぞれのスレッドがそれぞれハザードポインタを所有し、変更の際は全てのスレッドのハザードポインタをチェックする、というような実装になるようです。また、ロックフリーデータ構造の実装に使用される場合はハザードポインタは2要素程度のリストになることがあります。

ハザードポインタを中心としたこの様な仕組みをサポートし、安全かつ簡単に利用できるようにするためのライブラリを導入しようとする提案です。

提案より、サンプルコード。

```cpp
struct Name : public hazard_pointer_obj_base<Name> {
  /* details */
};

std::atomic<Name*> name;

// 頻繁に複数スレッドから呼ばれる
void print_name() {
  // ハザードポインタを取得する
  hazard_pointer h = make_hazard_pointer();
  // nameをハザードポインタへ登録
  Name* ptr = h.protect(name);
  // 以降、*ptrには安全にアクセスできる（勝手に消えたり変更されたりしない）
}

// あんまり呼ばれない
void update_name(Name* new_name) {
  // nameを更新する
  Name* ptr = name.exchange(new_name);
  // 削除待ち登録、全てのスレッドが必要としなくなった時に削除される
  ptr->retire();
}
```

コメントにあるように、ハザードポインタはデータの読み取りに比べてデータの更新が稀である場合に威力を発揮するものです。更新が頻繁に起こるような場合に適した方法ではありません。

この提案はConcurrency TS v2に向けて議論が進んでいます。現在はLWGで議論中なのでそこには入りそうです。標準ライブラリに入るとしてももう少し先になりそうです。

- [P0233R6 Hazard Pointers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0233r6.pdf)
- [Hazard pointer - Wikipedia](https://en.wikipedia.org/wiki/Hazard_pointer)
- [HTMはメモリ管理の為に生まれてきたんだよ！　ΩΩ＜な、なんだってー - Software Transactional Memo](https://kumagi.hatenablog.com/entry/2013/01/08/232549)
- [P1121 進行状況](https://github.com/cplusplus/papers/issues/132)

### [P1425R2 Iterators pair constructors for stack and queue](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1425r2.pdf)

`std::stack`と`std::queue`に、イテレータペアを受け取るコンストラクタを追加する提案。

`std::stack`と`std::queue`はイテレータペアを受け取るコンストラクタがなく他のコンテナとの一貫性を欠いており、それによって`ranges::to`の実装では特別扱いするかサポートしない選択を迫られていました。

この提案はこれらのコンテナアダプタと他のコンテナの間の一貫性を改善し、統一的な扱いができるようにするものです。

```cpp
#include <array>
#include <stack>
#include <queue>

int main() {
  std::array<int, 4> arr = {1, 2, 3, 4};

  // C++20まで、こう書けばできた
  std::stack<int> st{{arr.begin(), arr.end()}};
  std::queue<int> qu{{arr.begin(), arr.end()}};

  // この提案
  std::stack<int> st{arr.begin(), arr.end()};
  std::queue<int> qu{arr.begin(), arr.end()};
}
```

この提案はLWGでのレビューをほぼ終えていますが、最近提出されたIssue（[LWG 3506](https://cplusplus.github.io/LWG/issue3506)）との兼ね合いを調査するためのLEWGでのレビューを待っている状態です。問題がなければC++23に入るものと思われます。

- [P1425 進行状況](https://github.com/cplusplus/papers/issues/204)

### [P1682R2 std::to_underlying](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1682r2.html)

列挙型の値からその基底の整数型への変換を行う`std::to_underlying`の提案。

多くのコードベースで、列挙値をその基底型に変換する小さな関数を見ることができます。この様な関数がよく見られる理由は単純で、`static_cast<int>`のように書くと列挙型から基底型に変換しているという事を見失いやすくなるためです。

この様な関数はEffective Modern C++においても`toUtype()`として紹介されており、2019年6月17日時点で、Githubなどでの`to_underlying/to_underlying_type/toUtype`のヒット数は（重複を除いても）1000件を超えているようです。

この関数の使用量の増加はScott Meyersの先見性とアドバイスがあらゆる層のC++プログラマーに受け入れられていることを示しており、この様に頻繁に使用されるユーティリティに標準での名前と意味を与えることには価値があります。

また、列挙値の変換という処理は簡単でありながらも正しく書くことが難しいものでもあります

```cpp
#include <cstdint>

// 基底型を後から変更した（明示的に指定した）
enum class ABCD : uint32_t {
	A = 0x1012,
	B = 0x405324,
	C = A & B,
	D = 0xFFFFFFFF // uint32_t最大値
};

// from before:

void do_work(ABCD some_value) {
	// static_castを使用していることで、コンパイラはこのキャストは意図的なものだと認識
  // 警告は発せられない
  // ABCD::Dが渡ってきた時に間違ったキャストをすることになる
	internal_untyped_api(static_cast<int>(some_value));
}
```

`do_work(ABCD::D);`と呼び出されると間違ったキャストが行われ、`internal_untyped_api()`には意図しないビットパターン渡されることになります。`static_cast<int>`はそのキャストを意図的に行っていることを宣言するものでもあるため、コンパイラはエラーも警告も発しません。

`do_work()`内のキャストは、正しくは次のように書く必要があります。

```cpp
void do_work(ABCD some_value) {
	internal_untyped_api(static_cast<std::underlying_type_t<ABCD>>(some_value));
}
```

しかし、この関数の引数型を整数に変換可能な型に変更してしまった時の事を考えるとまだ問題があります。`static_cast`を適切に修正するか`ABCD`という型を削除しない限りこのコードはコンパイル可能であり続けます。

- [P1682 進行状況](https://github.com/cplusplus/papers/issues/460)

### [P1708R3 Simple Statistical Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1708r3.pdf)
### [P1989R1 Range constructor for std::string_view 2: Constrain Harder](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1989r1.pdf)
### [P2036R1 Changing scope for lambda trailing-return-type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2036r1.html)
### [P2072R1 Differentiable programming for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2072r1.pdf)
### [P2093R3 Formatted output](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2093r3.html)
### [P2168R1 generator: A Synchronous Coroutine Generator Compatible With Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2168r1.pdf)
### [P2210R1 Superior String Splitting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2210r1.html)
### [P2216R2 std::format improvements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2216r2.html)
### [P2232R0 Zero-Overhead Deterministic Exceptions: Catching Values](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2232r0.html)
### [P2244R0 SG14: Low Latency/Games/Embedded/Finance/Simulation Meeting Minutes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2244r0.pdf)
### [P2245R0 SG19: Machine Learning Meeting Minutes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2245r0.pdf)
### [P2246R1 Character encoding of diagnostic text](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2246r1.pdf)
### [P2259R1 Repairing input range adaptors and counted_iterator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2259r1.html)
### [P2266R0 Simpler implicit move](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2266r0.html)
### [P2276R0 Fix std::cbegin(), std::ranges::cbegin, and cbegin() for span (fix of wrong fix of lwg3320)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2276r0.pdf)
### [P2277R0 Packs outside of Templates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html)
### [P2278R0 cbegin should always return a constant iterator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2278r0.html)
### [P2279R0 We need a language mechanism for customization points](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2279r0.html)
### [P2280R0 Using unknown references in constant expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2280r0.html)
### [P2281R0 Clarifying range adaptor objects](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2281r0.html)
### [P2283R0 constexpr for specialized memory algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2283r0.html)
### [P2285R0 Are default function arguments in the immediate context?](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2285r0.html)
### [P2286R0 Formatting Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2286r0.html)
### [P2287R0 Designated-initializers for base classes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2287r0.html)