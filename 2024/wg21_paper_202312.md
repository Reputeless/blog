# ［C++］WG21月次提案文書を眺める（2023年12月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-12)

全部で125本あります。

もくじ

[:contents]

### [N4966 St. Louis Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4966.pdf)

2024年6月24〜29日（米国時間）にかけてアメリカのセントルイスで行われるWG21全体会議の案内。

### [N4967 WG21 2023-10 Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4967.pdf)

2023年10月27日に行われたWG21管理者ミーティングの議事録

前回（6月）のミーティング以降の各SGの進捗や作業の報告や、11月のKona会議におけるミーティングの予定などが報告されています。

### [N4970 WG21 2023-11 Kona Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4970.pdf)

2023年11月にハワイのKonaで行われたWG21全体会議の議事録

### [N4971 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4971.pdf)

C++26のワーキングドラフト第3弾

### [N4972 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4972.html)

↑の変更点をまとめた文書。

### [P0447R24 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0447r24.html)
### [P0447R25 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0447r25.html)
### [P0447R26 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0447r26.html)
### [P0609R2 Attributes for Structured Bindings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0609r2.pdf)

構造化束縛の個々の名前に属性を指定できるようにする提案。

構造化束縛宣言には属性を指定することができますが、その属性が作用するのは構造化束縛宣言の裏に隠れている分解対象のオブジェクトであり、導入されている個々の名前ではありません。

```cpp
auto f() -> std::tuple<int, double, char>;

int main() {
  // この属性指定はf()の戻り値（見えていない）に対するもの
  [[maybe_unused]]
  auto [a, b, c] = f();
}
```

構造化束縛対象そのものに対してアライメントを指定するなど、この指定にはユースケースがあります。

しかし一方で、構造化束縛宣言の個々の名前に対して属性を指定する方法はありません。標準属性で使用可能かつ意味があるのは`[[maybe_unused]]`のみですが、コンパイラベンダなどが提供する多くのアノテーション属性などを考慮すると、それを行いたい動機付けは大きくなる可能性があります。

この提案は、構造化束縛宣言内のそれぞれの名前に対して直接属性指定を行えるように文法を拡張しようとするものです。

提案されている構文は次のようなものです

```cpp
auto f() -> std::tuple<int, double, char>;

int main() {
  // cにのみ[[maybe_unused]]を指定
  auto [a, b, [[maybe_unused]] c] = f();
}
```

構造化束縛宣言の`[]`の中で名前に対して直接属性を指定できるようにしています。最初の名前に指定する場合`[[[`のように角括弧が連続する可能性はありますが、構文は他の場所での属性指定構文と一貫しています。

- [P0609 進行状況](https://github.com/cplusplus/papers/issues/1233)

### [P0952R2 A new specification for std::generate_canonical](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0952r2.html)
### [P1028R6 SG14 status_code and standard error object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1028r6.pdf)
### [P1061R6 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1061r6.html)
### [P1068R10 Vector API for random number generation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1068r10.pdf)
### [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
### [P1708R8 Basic Statistics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1708r8.pdf)
### [P1709R4 Graph Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1709r4.pdf)
### [P1928R8 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r8.pdf)
### [P1967R12 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1967r12.html)
### [P2022R3 Rangified version of lexicographical_compare_three_way](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2022r3.pdf)
### [P2264R6 Make assert() macro user friendly for C and C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2264r6.html)
### [P2264R7 Make assert() macro user friendly for C and C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2264r7.html)
### [P2267R1 Library Evolution Policies](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2267r1.html)
### [P2308R1 Template parameter initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2308r1.html)
### [P2414R2 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2414r2.pdf)
### [P2447R6 std::span over an initializer list](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2447r6.html)
### [P2481R2 Forwarding reference to specific type/template](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2481r2.html)
### [P2542R7 views::concat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2542r7.html)
### [P2573R1 = delete("should have a reason");](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2573r1.html)
### [P2642R5 Padded mdspan layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2642r5.html)
### [P2662R3 Pack Indexing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2662r3.pdf)
### [P2663R5 Proposal to support interleaved complex values in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2663r5.html)
### [P2664R5 Proposal to extend std::simd with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2664r5.html)
### [P2717R4 Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2717r4.html)
### [P2717R5 Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2717r5.html)
### [P2747R1 constexpr placement new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2747r1.html)
### [P2758R1 Emitting messages at compile time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2758r1.html)
### [P2760R1 A Plan for C++26 Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2760r1.html)
### [P2761R0 Slides: If structured binding (P0963R1 presentation)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2761r0.pdf)

P0963R1の紹介スライド。

P0963R1については以前の記事を参照

- [P0963R1 Structured binding declaration as a condition - WG21月次提案文書を眺める（2023年08月）](https://onihusube.hatenablog.com/entry/2023/10/14/223052#P0963R1-Structured-binding-declaration-as-a-condition)

EWGIのメンバに向けて、P0963R1で提案されている機能のモチベーションや動作について説明するものです。

### [P2767R2 flat_map/flat_set omnibus](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2767r2.html)
### [P2795R4 Erroneous behaviour for uninitialized reads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2795r4.html)
### [P2806R2 do expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2806r2.html)
### [P2810R2 is_debugger_present is_replaceable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2810r2.html)
### [P2810R3 is_debugger_present is_replaceable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2810r3.html)
### [P2819R2 Add tuple protocol to complex](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2819r2.pdf)
### [P2821R5 span.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2821r5.html)
### [P2826R1 Replacement functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2826r1.html)
### [P2827R1 Floating-point overflow and underflow in from_chars (LWG 3081)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2827r1.html)
### [P2830R1 constexpr type comparison](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2830r1.pdf)
### [P2845R5 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2845r5.html)
### [P2863R3 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2863r3.html)
### [P2864R2 Remove Deprecated Arithmetic Conversion on Enumerations From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2864r2.pdf)
### [P2865R4 Remove Deprecated Array Comparisons from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2865r4.pdf)
### [P2868R3 Remove Deprecated `std::allocator` Typedef From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2868r3.pdf)
### [P2869R3 Remove Deprecated `shared_ptr` Atomic Access APIs From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2869r3.pdf)
### [P2870R3 Remove `basic_string::reserve()` From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2870r3.pdf)
### [P2871R3 Remove Deprecated Unicode Conversion Facets From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2871r3.pdf)
### [P2878R6 Reference checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2878r6.html)
### [P2890R1 Contracts on lambdas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2890r1.pdf)
### [P2890R2 Contracts on lambdas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2890r2.pdf)
### [P2894R1 Constant evaluation of Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2894r1.pdf)
### [P2900R2 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2900r2.pdf)
### [P2900R3 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2900r3.pdf)
### [P2909R3 Fix formatting of code units as integers (Dude, where's my char?)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2909r3.html)
### [P2909R4 Fix formatting of code units as integers (Dude, where's my char?)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2909r4.html)
### [P2918R2 Runtime format strings II](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2918r2.html)
### [P2932R2 A Principled Approach to Open Design Questions for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2932r2.pdf)
### [P2933R1 std::simd overloads for <bit> header](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2933r1.html)
### [P2935R4 An Attribute-Like Syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2935r4.pdf)
### [P2952R1 auto& operator=(X&&) = default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2952r1.html)
### [P2961R2 A natural syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2961r2.pdf)
### [P2968R1 Make std::ignore a first-class object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2968r1.html)
### [P2968R2 Make std::ignore a first-class object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2968r2.html)
### [P2969R0 Contract annotations are potentially-throwing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2969r0.pdf)

`contract_assert`式に対する`noexcept`演算子の振る舞いについての解決策を探る提案。

C++26 Contractsのセマンティクスとして、特に例外に関する部分についてSG21では次のことが合意されています

- 契約条件式の評価に伴って例外がスローされる場合は契約違反として扱われ、関数の例外仕様とは無関係に違反ハンドラを呼び出す
- 違反ハンドラからの例外送出は、通常の例外と同じ扱いとなる
  - スタック巻き戻しが発生し、巻き戻しが`noexcept`関数呼び出しに及んだ場合は`std::terminate()`によってプログラムは終了する
- 契約注釈がチェックされているかどうかによって、`noexcept`演算子の結果や契約注釈が付加されている関数の型が変化することはない
- 事前条件・事後条件・アサーションは全て、述語または違反ハンドラからの例外送出に関して同じように動作する

これによって、チェックされると常に例外を送出する、Well-definedな動作をもつWell-formedなC++プログラムが存在し得ます

```cpp
#include <contracts>
using namespace std::contracts;

void handle_contract_violation(const contract_violation&) {
  throw 666;
}

int main() {
  contract_assert(false); // チェックされると必ず例外を送出する
}
```

しかもこのことは、契約違反ハンドラが`noexcept`であることがわかっている場合にのみコンパイル時にわかります（違反ハンドラの置換は一般的にリンク時に行われるため、コンパイル時には分からないでしょう）。従って、違反ハンドラがどの様にカスタマイズされているか（あるいはされていないか）によらず、ユーザーから見た契約注釈は常に例外を投げうるものとして写ります。

現在のC++にはプログラムのコンパイル時のセマンティクスが特定の式が例外送出するかどうかに依存する場合があります。それは、`noexcept`演算子の結果を決定する時、最初の宣言が`default`である特殊メンバ関数の例外仕様を決定する場合、の2つの場合です。

2023年11月のKona会議において、クラスの特殊メンバ関数の最初の宣言が`default`である場合、契約注釈を付加できないことが決定されました。しかし、それでもなお、この2つの場合のそれぞれについて契約注釈の有無によって結果が変化しうる場合が存在し、現在のMVP仕様ではその状況について何も指定していません。

1つは、契約注釈そのものに`noexcept`演算子を適用した場合で、これは`contract_assert()`でのみ起こります。

```cpp
noexcept(contract_assert(false)); // これはtrueになる？falseになる？
```

2つめは、クラスの特殊メンバ関数の例外仕様が推定される場合で、通常この場合はその関数が例外を投げうるものを含んでいなければ`noexcept(true)`と推定されます。現在その様な場所に直接契約注釈を付加することはできませんが、間接的に現れる可能性があります

```cpp
struct B {
  int i = (contract_assert(false), 42);
};

struct S : B {
  // これらのコンストラクタのnoexcept性はどうなる？
  S() = default;
  S(S&&) = default;
};
```

この様なコンテキストは現在この2つだけのはずですが、将来の機能（例えば、`noexcept(auto)`）を考慮するとさらに増加する可能性があります。

この提案は、C++26に契約機能を導入する前にこれらの仕様の空白を埋めるために可能な解決策を探るものです。

この提案で上げられている解決策は次の7つです

1. 契約注釈を例外を送出しうるものとして扱う
    - 上記どちらも、`noexcept(false)`となる
    - ゼロオーバーヘッド原則に反する（契約注釈の追加によりムーブコンストラクタの例外仕様が変化するなど）。これは契約機能の採用の阻害要因となりうる
2. 契約注釈を例外を送出しないものとして扱う
    - 上記どちらも、`noexcept(true)`となる
    - 契約注釈が存在する場合に`noexcept`演算子が嘘をつくことなる
    - 例外中立なライブラリフレームワーク（P2300の様なもの）の記述が困難となる
3. 1と2の両方の状況を許可する
    - 契約注釈のメタアノテーションやコンパイラオプションによって契約注釈が例外を投げうるかを指定する
    - ユーザーが契約注釈に`noexcept`メタアノテーションを付加する場合、単純に関数全体に`noexcept`を付加するだけで良い
    - ビルドモードを導入するとC++の方言が生まれる
4. 謝って送出された例外が推定された`noexcept(true)`例外仕様を回避できる様にする
    - 契約注釈は言語内で例外を投げないものとして扱われるが、違反ハンドラからスローされた例外のみ`noexcept(true)`な関数のスタック巻き戻しを行うことが許可される
    - 呼び出しが例外を投げないことを前提とする処理でこれが起こると、結局プログラムの実行は安全ではなくなる
    - 例外仕様のメンタルモデルが複雑化し言語内に矛盾が生じ、仕様と実装が複雑化する
5. これらの場合が現れない様にする
    - 次の3つの方法が考えられる
        1. `contract_assert`を式ではなく文にする
        2. `noexcept`演算子を`contract_assert`または`contract_assert`を部分式として含む式に適用するとill-formed
            - さらに、例外仕様に影響を与えうる箇所に`contract_assert`が出現するとill-formed
        3. `noexcept`演算子を`contract_assert`または`contract_assert`を部分式として含む式に適用するとill-formed
            - ただし、例外仕様に影響を与えうる箇所にある`contract_assert`がill-formedとなるのはその存在が例外仕様の推定に影響を与える場合のみ
    - 仕様や実装が複雑になり、ユーザーにより多くの苦労を強いることになるが、上記問題を回避し全ての場合にゼロオーバーヘッド原則を満たす
6. ガイドラインと診断に頼る
    - ユーザーにその様なコードを書かないほうがいいと警告するならば、単にill-formedとしたほうがいい
7. 違反ハンドラからの例外送出サポートを禁止する
    - 違反ハンドラからの例外送出を使用するのは実際には非常に難しいため、これを削除し例外を使用しない方法で同等の契約違反後の処理継続を可能にする方法を模索する
    - それを決定するとこの提案で挙げられている問題は全て解決されるが、後から違反ハンドラからの例外送出を許可するのは困難になる
    - 現時点では例外に代わる同等のメカニズムは存在していない

この提案では、それぞれの解決策による影響や実現可能性について考察していますが、どれかを推しているわけではありません。ただし、3,4の案は実現可能ではないと評されており、1,2,6の案は問題があり、7の案も困難が伴うとして、一番ポジティブな評価を受けているのは5（の2,3）の案です。

この提案でどの様な決定がなされたとしても事前・事後条件における違反ハンドラからの例外送出について同様の問題がある様に見えますが、それはすでに合意済みのことです。契約注釈の存在は例外仕様等のコンパイル時セマンティクスに影響を与えず、Lakos Ruleに基づいて契約注釈がなされている限り（無条件`noexcept`指定と契約注釈の両立は誤っている）それは問題になりません。例えば、あるクラスのムーブコンストラクタが`noexcept`となる場合、そのムーブコンストラクタは広い契約を持ちいかなる事前・事後条件も持たないはずで、そのクラスのメンバのムーブコンストラクタそれぞれについても同様の仮定が成立するはずです。この過程が成り立っていない場合、そのムーブコンストラクタは`noexcept(false)`とするのが適切であり、その場合にのみ契約注釈によって事前・事後条件をチェックすることができます。

- [契約プログラミング機能のこれまでとこれから - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2023/12/25/220134)
- [P2969 進行状況](https://github.com/cplusplus/papers/issues/1701)

### [P2977R0 Module commands database format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2977r0.html)

ツール間で同じモジュールを生成するために必要となるコンパイルのための情報をファイルにまとめておく提案。

ビルドシステムのようなC++プロジェクトのビルドを管理するツールは、それをコンパイルしたコンパイラとは異なるコンパイラを使用するプロジェクトにおいてもモジュールを管理しなければなりません。しかし、一般的にビルド済みモジュールはコンパイラ間や同じコンパイラのバージョン間、あるいはモジュールを分析する必要のあるツール（静的解析ツールなど）等それぞれの間で互換性がありません。これらのツールはメインのビルドの設定に対応する形で、それぞれ独自の形式によってモジュール（のインターフェース）をビルドできる必要があり、メインのビルドと（形式等は除いて）同等のコンパイル済みモジュールを生成するために必要なフラグなどを知る必要があります。

この提案は、そのような情報をファイルに保存してツール間でやり取りすることを目的として、どのような情報が必要かやその保存の方法などを特定しようとするものです。

メインビルドと同等のコンパイル済みモジュールを作成するためには、ツールは少なくとも次の情報を知っている必要があります

- モジュールインターフェースのソース
- 生成されるモジュールのモジュール名
    - そのモジュールが使用される場所を特定するために必要
- 必要なモジュールの名前（依存モジュール名）
    - モジュールの依存関係を解決するために必要
- 必要なモジュールを提供するソースコード
- ソース内でのモジュールの可視性
    - モジュール実装単位/実装パーティションのように、プライベートなモジュールが存在する
    - そのようなモジュールに属するシンボルは外部からアクセスできない場合があり、より的確な診断のためにモジュール名を使用できる
- ソースを処理するビルド中に使用されるローカルプリプロセッサ引数
    - メインビルドの成果物に対応するものを生成するために使用する必要がある
    - ツールは、メインビルドに使用されるコンパイラのフラグを自身の利用のために変換する必要がある可能性がある
- コンパイルのための作業ディレクトリ
    - 相対パスの解釈を一致させるために必要

これらの情報をビルドツリー内で表現する方法としては次の3つが挙げられています

1. スタンドアロン
    - 全ての情報を何らかのファイルに保存する
    - （おそらくソースファイルごとに）別々のファイルとして存在している
    - この利点は、情報をビルドだけでなくインストールにも使用できる点
2. コンパイルコマンドデータベースとの相互参照
    - [Compile Commands Database](https://clang.llvm.org/docs/JSONCompilationDatabase.html)と手元の情報とを組み合わせて使用する
    - 重複を減らすことができるが、必要な情報を全て取得するには2つのデータベースを手動でマージするツールが必要になる
    - この欠点は、あるソースが異なるフラグでビルドグラフ上に複数回現れうる点
3. コンパイルコマンドデータベースとの共有
    - 手元の情報をコンパイルコマンドデータベースと共有できる部分とそうでない部分に分割し、共有できる部分はコンパイルコマンドデータベースのものを取得する

このようなモジュールコンパイルデータベースは、一般的にビルド中に作成される必要があります。なぜなら、モジュール名はビルドが完了するまでわからないからです。しかし、上記コンパイルコマンドデータベースがビルドの一部が完了するまで存在しない生成されるソースのコンパイルを参照することができ、新しい問題というわけではありません。

メインビルドに関わらない他のツールがこれらの情報を簡易に取得するために、ビルドシステムはモジュールコンパイルデータベースをよく知られた場所（おそらく、pkgconfigなどのようなものがある場所）にあるファイルにまとめる仕組みを提供する必要があります。これによって、他のツールが関連ファイルを探索する手間が軽減され、ファイル全体にわたって情報が一貫していることが保証されます。

この提案はこのような要件を列挙したもののようで、まだ何かを提案するには至っていないようです。

- [JSON Compilation Database Format Specification — Clang 18.0.0git documentation](https://clang.llvm.org/docs/JSONCompilationDatabase.html)
- [P2977 進行状況](https://github.com/cplusplus/papers/issues/1697)

### [P2980R1 A motivation, scope, and plan for a quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2980r1.html)
### [P2981R1 Improving our safety with a physical quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2981r1.html)
### [P2982R1 `std::quantity` as a numeric type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2982r1.html)
### [P2984R1 Reconsider Redeclaring static constexpr Data Members](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2984r1.html)
### [P2996R1 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r1.html)
### [P2999R1 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r1.html)
### [P2999R2 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r2.html)
### [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
### [P3006R0 Launder less](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3006r0.html)

バイト配列上に構築した別の型のオブジェクトへのポインタをより直感的に取得できる様にする提案。

バイト配列を確保して、その配列の要素型とは異なる型のオブジェクトをその配列上に構築する場合、そのオブジェクトへの正しいアクセス方法は非常に限定されています。

```cpp
// Tのオブジェクトを配置するバイト配列
alignas(T) std::byte storage[sizeof(T)];

// Tのオブジェクト構築、戻り値のポインタをそのアクセスに使用する
T* ptr1 = ::new (&storage) T(); // ok

// storageのアドレスから直接Tのオブジェクトへのアドレスを得る
T* ptr2 = reinterpret_cast<T*>(&storage);  // UB
T* ptr3 = std::launder(reinterpret_cast<T*>(&storage));  // ok
```

この場合、配置`new`によって`storage`上に構築されているオブジェクトへのアクセスを行えるのは`ptr1`と`ptr3`のみであり、`storage`のアドレスから`reinterpret_cast<T*>`しただけの`ptr2`からのアクセスは未定義動作となります。

これはポインタとその領域で生存期間内にあるオブジェクトとが結びつかないためで、配置`new`の戻り値を使用しない場合は`ptr3`のように`std::launder`によってその領域上で生存期間内にあるオブジェクトへのポインタを取得しなければなりません。

とは言えこのことはかなり意味論的なことで、多くのコンパイラは`ptr2`の様に`std::launder`を使用しない場合でも`std::launder`を使用する場合と同等のコードを出力する様です。

この提案は、その様な既存の慣行を標準化し、このようなユーザーの期待に沿わないUBを取り除こうとするものです。

これによるメリットは、現在UBを回避するために配置`new`の戻り値を保存している様なコード（例えば、Boost.Optionalなど）において、その様なポインタを保存しなくてもよくなることでストレージサイズを削減でき、なおかつ`std::launder`というよく分からないものを使用せずとも直感的なコードによってUBを回避して意図した動作を実現できる点です。

- [P3006 進行状況](https://github.com/cplusplus/papers/issues/1703)

### [P3007R0 Return object semantics in postconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3007r0.pdf)

事後条件の契約注釈で戻り値を参照する場合の、その戻り値のセマンティクスに関する提案。

事後条件注釈では、その関数の戻り値を使用するために戻り値の名前を指定してそれを参照することができます。

```cpp
int f()
  post (r: r > 0);  // 戻り値は正の値
```

現在のMVP仕様では、まだこの戻り値に関するセマンティクスが正確に指定されていません。

C++20時点の仕様及びそれを受け継いだMVP仕様においては、「事後条件では、その関数のglvalueもしくはprvalueの結果オブジェクトを表す識別子を導入できる」とだけ言及されていて、その値カテゴリは何か、それは参照なのか、その型は何か、アドレスを取れるのか、変更可能なのか、などについての規定はありません。

この提案は、事後条件の戻り値のセマンティクスについての現在の不明な点について考察し、そのセマンティクスを決定しようとするものです。ここで提案されていることは次のような事です

- 事後条件における戻り値を表す変数名は、本物の戻り値オブジェクトを参照する左辺値である、とする
    - これは構造化束縛によって導入される名前のセマンティクスからの借用
    - その値カテゴリは左辺値（lvalue）
    - 言語参照（`T&`）ではないが、戻り値を参照している
    - 従って、事後条件から戻り値を参照する場合にはコピーもムーブも行われず、RVOを妨げない
- 戻り値名`r`に対する`decltype(r)`の結果は、関数の戻り値型
- 戻り値型がtrivially copyableである場合、戻り値名のアドレスと実際の戻り値のアドレスは異なる可能性がある
    - これは、trivially copyableオブジェクトをレジスタに配置して返す挙動を変化させない（ABI破壊を回避する）ため
    - その場合、戻り値名は戻り値を保持する一時オブジェクトを参照している
- 呼び出し側で戻り値を受ける変数が`const`である場合、関数の戻り値型が`const`でなければ、事後条件における戻り値の変更は未定義動作とならない、とする
    - 変数に対する`const`は初期化が完了するまで有効ではなく、事後条件は戻り値を受ける変数の初期化よりも前に呼び出される

この提案では、事後条件における戻り値名が暗黙`const`であるかは著者の間で合意できなかったことから提案していません。それには利点と欠点がありますがどちらを採用するべきかは明確ではないため、その方向性の決定は委員会に委ねています。

- [P3007 進行状況](https://github.com/cplusplus/papers/issues/1704)

### [P3016R1 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3016r1.html)
### [P3019R1 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3019r1.pdf)
### [P3019R2 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3019r2.pdf)
### [P3019R3 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3019r3.html)
### [P3022R1 A Boring Thread Attributes Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3022r1.pdf)
### [P3023R1 C++ Should Be C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3023r1.html)
### [P3024R0 Interface Directions for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3024r0.pdf)

C++26に向けて提案中の`std::simd`のインターフェースやその設計動機などについて紹介するスライド。

### [P3025R0 SG14: Low Latency/Games/Embedded/Financial trading/Simulation virtual Minutes to 2023/09/12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3025r0.pdf)

SG14の2023年9月12日に行われたオンラインミーティングの議事録。

### [P3026R0 SG19: Machine Learning virtual Meeting Minutes to 2023/07/13](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3026r0.pdf)

SG19の2023年7月13日に行われたオンラインミーティングの議事録。

### [P3027R0 UFCS is a breaking change, of the absolutely worst kind](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3027r0.html)

P3021のUFCS（Unified function call syntax）提案に異議を唱える提案。

P3021については以前の記事を参照

- [P3021R0 Unified function call syntax (UFCS) - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P3021R0-Unified-function-call-syntax-UFCS)

P3021では、メンバ関数呼び出しを拡張する形でUFCSを有効化することを提案しており、メンバ関数呼び出し（`x.f(a,b)`と`x->f(a, b)`）を非メンバ関数の呼び出し（`f(x, a, b)`と`f(*x, a, b)`）にフォールバックすることでUFCSを可能にするものです。

P3021のUFCSは確かに既存のコードを壊しません（有効なコードがill-formedにならない）が、現在のメンバ関数呼び出しに関してユーザーが依存している保証を壊している、というのがこの提案の主張です。

その保証とは、メンバ関数呼び出しはADLとは無関係に行われるというものであり、別の言い方をするとメンバ関数呼び出しではADLは行われないという保証です。このため、確かに現在ある既存のコードが壊れることはありませんが、将来のコードは壊れる可能性があります。

例えばリファクタリングにおいて誰もが経験すると思われる、メンバ関数の名前を変更する場合を考えます。

```cpp
struct Foo {
  // この関数名を変えたい
  void snap();
};

// この.snap()は例えばこのように呼び出されている
template <class T>
void do_snap(T&& f) {
  f.snap(); 
}
```

この`Foo::snap()`の名前を`slap()`に変更しようとする場合、これを宣言・定義しているファイルを編集し名前を変更してから使用されているところを修正していけば良いでしょう。修正を忘れたり、呼び出しを間違えればコンパイラがコンパイルエラーとして修正が完全ではないことを教えてくれます。これは静的型付け言語の基本中の基本振る舞いであり、コードベースが大きくなったとしてもそれは変化しません。

しかしP3021が有効化された場合そのような保証はもはや期待できず、`snap()`を`slap()`に変更してなにも修正しなかったとしても一切エラーが出ない可能性があります。なぜなら、ADLによって`snap()`を探しに行き、たまたま呼び出せる候補を見つけてしまうかもしれないからです。P3021が導入される以前はメンバ関数呼び出しからADLが発動されることはなく、ADLによって呼び出せてしまうような`slap()`を定義していたとしても安全でした。しかし、P3021導入後はそのような関数がメンバ関数呼び出しからのADLによって呼び出されることを意図していたかどうかは分からなくなります（P3021以前の保証の上に立っているのか、P3021の機能の上に立っているのかが分からなくなるため）。

これはまた、メンバ関数を削除する場合や、関数の引数型を変えるなどのリファクタリングにおいても同様です。

本来であればメンバ関数呼び出しではそのようなADLの複雑さを考えなくても良いはずで、P2855のようにそれを有効に利用しようとする向きもあります。しかし、P3021の機能が導入されるとそのような保証はなくなり、メンバ関数呼び出しは常に意図しない関数呼び出しによってバグを静かに埋め込んでしまう可能性を抱えることになります。

意図的かどうかはともかく、現在の多くのC++ユーザーはメンバ関数呼び出しを使用することでクラスのメンバ関数のみが呼び出され、ADLの複雑さについて頭を悩ませることを回避しています。メンバ関数はクラスという単位でのカプセル化によって、そのアクセス範囲及び呼び出される方法はかなり明確です。

メンバ関数呼び出し構文がそのようなカプセルの外側に及ぶようにするというのは、その単純さと分かりやすさを壊しています。それはユーザーへのサービスではなく、ユーザーに対して破滅的な不利益を与えるものです。

このような理由によりこの提案はP3021のUFCSに反対し、UFCSが必要ならば専用の構文を導入して行うべきであり、既存の関数呼び出し構文を拡張する形でそれを行えば以前にはその複雑さが無かった場所に新しい複雑さを導入してしまい、UFCSによる利点を複雑さの増大による欠点が上回るとしています。

- [P2855R0 Member customization points for Senders and Receivers - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2855R0-Member-customization-points-for-Senders-and-Receivers)
- [P3027 進行状況](https://github.com/cplusplus/papers/issues/1708)

### [P3028R0 An Overview of Syntax Choices for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3028r0.pdf)

2つの契約構文候補を比較する提案。

C++26契約プログラミング機能に向けて議論が進んでおり、残す大きな問題は構文の決定のみとなっています。現在契約構文としてはC++20の契約機能由来の属性様構文（P2935）と新しい文脈依存キーワードによる自然な構文（P2961R2）の2つが候補として残っています。

- [P2935R4 An Attribute-Like Syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2935r4.pdf)
    - [P2935R0 An Attribute-Like Syntax for Contracts - WG21月次提案文書を眺める（2023年08月）](https://onihusube.hatenablog.com/entry/2023/10/14/223052#P2935R0-An-Attribute-Like-Syntax-for-Contracts)
- [P2961R2 A natural syntax for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2961r2.pdf)
    - [P2961R0 A natural syntax for Contracts - WG21月次提案文書を眺める（2023年09月）](https://onihusube.hatenablog.com/entry/2023/10/29/180915#P2961R0-A-natural-syntax-for-Contracts)

P2695で示されたロードマップに従って、2023年11月のKona会議ではこのどちらの構文を採用するのかを決定する予定です。

この提案はその議論のために、2つの構文候補を比較することでそれぞれの特性を明らかにしようとするものです。

この提案では次の2つの観点から候補を比較しています

1. 提案されている全ての構文候補を、契約のある機能についてそれぞれ対応する構文で記述したものを横に並べて比較
2. P2885で挙げられている原則とともに、各構文候補がその原則をどの様に満たすのか（あるいは満たさないのか）を比較

事前条件構文の比較

```cpp
// P2935
void f() [[ pre : true ]];

// P2961
void f() pre( true );
```

事後条件構文の比較

```cpp
// P2935
int f() [[ post r : true ]];
int f() [[ post (r) : true ]];
// P2935R4の代替提案
int f() [[ post : r : true ]];

// P2961
int f() post( r : true );
```

アサーション構文の比較

```cpp
// P2935
void f() {
  [[ assert : true ]];
}

// P2961
void f() {
  contract_assert( true );
}
```

かかる文字数の比較

||P2935|P2961|
|---|---|---|
|事前条件|8|5|
|事後条件|9〜10|6〜7|
|アサーション|11|17|

これ以外にも様々な観点からの比較が行われています。

2023年11月に行われたKona会議では、P2961の自然な構文をC++契約プログラミング機能のための構文として採用することで合意されました。

- [契約プログラミング機能のこれまでとこれから - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2023/12/25/220134)
- [P3028 進行状況](https://github.com/cplusplus/papers/issues/1709)

### [P3029R0 Better mdspan's CTAD](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3029r0.html)

`std::span`/`std::mdspan`がコンパイル時定数によってインデックス指定を受ける場合のCTADを改善する提案。

たとえば、`mdspan`でよく使用されることになると思われる配列ポインタとそれを参照する多次元インデックスの指定を受けるコンストラクタに対応する推論補助は次の様に定義されています

```cpp
template<class ElementType, class... Integrals>
  requires((is_convertible_v<Integrals, size_t> && ...) &&
            sizeof...(Integrals) > 0)
explicit mdspan(ElementType*, Integrals...)
  -> mdspan<ElementType, dextents<size_t, sizeof...(Integrals)>>;
```

このため、このコンストラクタ（CTAD）が使用される場合にはインデックスにコンパイル時定数を渡していても`mdspan`のエクステントは`dextent`（実行時エクステント）が使用されます。

```cpp
mdspan ms (p, 3, 4, 5); // mdspan<int, extents<size_t, dynamic_extent, dynamic_extent, dynamic_extent>>
mdspan ms2(p, 3, integral_constant<size_t, 4>{}, 5);                              // 同上
mdspan ms3(p, integral_constant<size_t, 3>{}, 4, integral_constant<size_t, 5>{}); // 同上
```

後2つについてはコンパイル時定数を渡しているため、エクステントのその部分は静的になってほしいものがあります。現在これを叶えるためには、ユーザーは次の様に記述する必要があります

```cpp
mdspan ms2(p, extents<size_t, dynamic_extent, 4, dynamic_extent>(3, 5)); // mdspan<int, extents<size_t, dynamic_extent, 4, dynamic_extent>>
mdspan ms3(p, extents<size_t, 3, dynamic_extent, 5>(4));                 // mdspan<int, extents<size_t, 3, dynamic_extent, 5>>
```

最初の例の後ろ2つが自動的にこれと同等になることが望ましいでしょう。また、`std::span`にも同様の問題があります。

この提案は、`std::mdspan`及び`std::span`の推論補助を修正して、動的インデックス指定がコンパイル時定数（`std::integral_constant`のような型の値）によって指定されている場合にそれを静的な指定としてエクステントに反映する様にしようとするものです。

これによる利点は次の様なものが挙げられています

- 動的・静的エクステントを同等な形式によって指定できるため、エクステント型の反映が直感的になる
    - 現在、動的エクステントは数値で直接コンストラクタに指定できるのに対して、静的エクステントは`std::extents<I, idx...>{...}`の様に指定する必要がある
- 正しい数の引数を渡すために`dynamic_extents`の数を計算する必要がなくなり、エラーが起こりにくくなる
    - `extents<size_t, dynamic_extent, 4, dynamic_extent>(3, 5)`の様に、静的エクステント中に動的エクステントが混ざっている場合に`extents`のコンストラクタでその要素数を指定しなければならない
- P2781の`std::constexpr_v`を使用すると、エクステントが混在する`mdspan`を`mdspan(c_<3>, 4, c_<5>)`の様に記述できる様になる。

この様なことは`std::submdspan`（C++26に導入済）では既に行われており、その仕組みを再利用することで実装可能です。

まず次の様な検出ユーティリティを用意して（`integral-constant-like`は`std::submdspan`とともに導入済）

```cpp
// std::integral_constantと同等の型を検出する
template<class T>
concept integral-constant-like =        // exposition only
  is_integral_v<decltype(T::value)> &&
  !is_same_v<bool, remove_const_t<decltype(T::value)>> &&
  convertible_to<T, decltype(T::value)> &&
  equality_comparable_with<T, decltype(T::value)> &&
  bool_constant<T() == T::value>::value &&
  bool_constant<static_cast<decltype(T::value)>(T()) == T::value>::value;


template<class T>
constexpr size_t maybe-static-ext = dynamic_extent;        // exposition only

template<integral-constant-like T>
constexpr size_t maybe-static-ext<T> = static_cast<size_t>(T::value);
```

これを用いて`std::mdspan`及び`std::span`の既存の動的エクステント指定に対応する推論補助を修正します

```cpp
// 変更前
template<class It, class EndOrSize>
span(It, EndOrSize) -> span<remove_reference_t<iter_reference_t<It>>>;

// 変更後
template<class It, class EndOrSize>
span(It, EndOrSize) -> span<remove_reference_t<iter_reference_t<It>>, maybe-static-ext<EndOrSize>>;
//                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


// 変更前
template<class ElementType, class... Integrals>
  requires((is_convertible_v<Integrals, size_t> && ...) && sizeof...(Integrals) > 0)
explicit mdspan(ElementType*, Integrals...)
  -> mdspan<ElementType, dextents<size_t, sizeof...(Integrals)>>;

// 変更後
template<class ElementType, class... Integrals>
  requires((is_convertible_v<Integrals, size_t> && ...) && sizeof...(Integrals) > 0)
explicit mdspan(ElementType*, Integrals...)
  -> mdspan<ElementType, dextents<size_t, maybe-static-ext<Integrals>...>;
//                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```

- [`std::mdspan` - cpprefjp](https://cpprefjp.github.io/reference/mdspan/mdspan.html)
- [P2781R2 `std::constexpr_v` - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2781R2-stdconstexpr_v)
- [P3029 進行状況](https://github.com/cplusplus/papers/issues/1710)

### [P3031R0 Resolve CWG2561: conversion function for lambda with explicit object parameter](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3031r0.html)

ジェネリックな`this`パラメータを持つラムダ式の関数ポインタへの変換の規定が曖昧なのを解決する提案。

C++23のDeducing thisはクラスのメンバ関数で`this`パラメータを明示的に書くことができる機能です（この引数の事を明示的オブジェクトパラメータと呼びます）。これはラムダ式においても使用することができますが、ラムダ式の場合はそのクロージャ型名を知ることができないので、通常`this auto`のように書かれます。

また、ラムダ式はキャプチャしていない場合にのみ関数呼び出し演算子のシグネチャと互換性のある関数ポインタへ変換することができます。

このとき、明示的オブジェクトパラメータを持つラムダ式が対応する関数ポインタへ変換可能であるかについて実装間で挙動に差があります。

```cpp
int main() {
  using T1 = decltype([](int x) { return x + 1; });  // ok、ラムダ式のクロージャ型
  int(*fp1)(int) = +T1{};  // ok、関数ポインタへの変換

  using T2 = decltype([](this auto, int x) { return x + 1; });  // ok、ラムダ式のクロージャ型
  int(*fp2)(int) = +T2{};  // Clangはng、MSVCはok
}
```

1つ目の例は通常のラムダ式から関数ポインタへ変換する例です。これはC++11以来のもので今回特に問題はありません。

2つ目の例がこの提案の主要な問題であり、ジェネリックな明示的オブジェクトパラメータを持つラムダ式が対応する関数ポインタへ変換できるかどうかが、現時点でこの機能を実装しているClangとMSVCの間で異なっているようです。

また、ラムダの明示的オブジェクトパラメータがジェネリックではなかったとしてもClangは拒否するようで、どうやら規格ではこの場合に生成されるクロージャ型のメンバがどうなるかについて曖昧なようです。

```cpp
struct Any { Any(auto) { puts("called"); } };

int main() {
  auto a1 = [](int x) { return x+1; };
  auto a2 = [](this Any self, int x) { return x+1; }; // 明示的オブジェクトパラメータはジェネリックではない
  
  int(*fp)(int) = +a2;  // Clangはng、MSVCはok
}
```

この`a1, a2`それぞれのクロージャ型は例えば次のようになります

```cpp
// 型変換演算子で複雑な型を使用するためのエイリアス
template<class T>
using Just = T;

// a1のクロージャ型の例
struct A1 {
  int operator()(int x) const { return x+1; }
  operator Just<int(*)(int)>() const { return +[](int x) { return A1()(x); }; }
};

// MSVCにおけるa2のクロージャ型の例
struct A2_MSVC {
  int operator()(this Any self, int x) { return x+1; }
  operator Just<int(*)(int)>() const { return +[](int x) { return A2_MSVC()(x); }; }
};

// Clangにおけるa2のクロージャ型の例
struct A2_Clang {
  int operator()(this Any self, int x) { return x+1; }
  operator Just<int(*)(Any, int)>() const { return &A2_Clang::operator(); }
};
```

Clangにおいては明示的オブジェクトパラメータの部分の引数についても関数ポインタ型へ現れるようです。一方、MSVCは明示的オブジェクトパラメータは関数ポインタに現れません。

MSVCの挙動は、従来の暗黙的オブジェクトパラメータを持つラムダを明示的オブジェクトパラメータを持つものにそのままリファクタリングでき（その逆も可能）たり、自身の型を関与させない形で再帰ラムダを定義できたりと、よりユーザーフレンドリーであると思われます。

```cpp
// Error on Clang, OK on MSVC
auto fib = [](this int (*fib)(int), int x) {
  return x < 2 ? x : fib(x-1) + fib(x-2);
};
int i = fib(5);
```

この例は、Clangの場合は`this`パラメータの型に自身の型が再帰的に現れるのを回避することができませんが、MSVCはこのように関数ポインタによってその再帰を断ち切ることができます。これは再帰ラムダを非ジェネリックに定義できるため、コンパイル時間で有利になるかもしれません。

ラムダ式の関数ポインタへの変換演算子に関して、MSVCはラムダ式における明示的オブジェクトパラメータをかなり特別扱いしており、その引数は常にそのラムダ式自身と同等とみなせると強く仮定しています。ラムダ式が関数ポインタへ変換可能であるのはキャプチャしていない場合のみなので、これは実際にはあまり問題にならないかもしれません。

一方で、`this auto`を用いずにテンプレート構文によって明示的オブジェクトパラメータを記述するとMSVCでもClangと同様なクロージャ型を生成するようです。

```cpp
auto a = [](this auto) {}; // MSVCは非ジェネリックとして扱う
auto b = []<class T>(this T) {}; // ジェネリックラムダ

auto pa = +a; // OK on MSVC
auto pb = +b; // error on MSVC
void (*qa)() = a; // OK on MSVC
void (*qb)() = b; // error on MSVC
```

この非一貫性は非自明ではあります。

この問題は[CWG Issue 2561](https://cplusplus.github.io/CWG/issues/2561.html)で捕捉され、当初はClangのアプローチを標準化する方向性でした。この提案はそれに対してMSVCのアプローチの方を推すものでしたが、それには文言についてさらなる検討が必要になるということで、明示的オブジェクトパラメータを持つ関数の関数ポインタへの変換をとりあえず禁止しておくことを提案するものです（このR0が出る前に6つのリビジョンがあった様子）。

この提案には、明示的オブジェクトパラメータを持つラムダ式の関数ポインタへの変換を禁止する、Clangのアプローチを採用、MSVCのアプローチを採用、の3つのオプションが含まれており、EWGは1つ目のアプローチを採用したようです。ただし、これはMSVCのアプローチを将来的に採用することを妨げるものではありません。

- [CWG Issue 2561. Conversion to function pointer for lambda with explicit object parameter](https://cplusplus.github.io/CWG/issues/2561.html)
- [メンバ関数の新しい書き方、あるいは Deducing this - Zenn](https://zenn.dev/acd1034/articles/221117-deducing-this)
- [P3031 進行状況](https://github.com/cplusplus/papers/issues/1711)

### [P3033R0 Should we import function bodies to get the better optimizations?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3033r0.html)

モジュールのインターフェースにある関数定義をそのモジュールをインポートした翻訳単位にインポートしないようにする提案。

Clangの最適化においては、あるモジュールからインポートされた関数について、その関数の定義をインライン化するような最適化をリンク前に行っているようです。

```cpp
// a.cppm
export module a;
export int a() { return 43; }

// use.cpp
import a;
int use() { return a(); }
```

たとえば、最適化を有効にすると`use.cpp`の`use()`は`int use() { return 43; }`であるかのようにコンパイルされます。

これはゼローバーヘッド原則に則っており、一見合理的であるように見えます。しかし、`use.cpp`をコンパイルする時にオプティマイザはモジュール内の`a()`に対しても作用してしまうため、プロジェクトの規模が大きくなるとコンパイル時間に跳ね返ってきます。

とはいえそれでも、この問題は単に実装の問題であり規格が口を出す話ではないように思えます。しかし、実際にはABI依存関係と潜在的なODR違反に関連しています。

例えば上記コード群が次のようなコンパイル結果を生成していた場合

```
a.o       // モジュールaのオブジェクトファイル
a.pcm     // モジュールaのBMI
use.o     // use.cppのオブジェクトファイル
libuse.so // use.cppを含む共有ライブラリ
```

この時にモジュール`a`内の`a()`を`44`を返すように変更して再コンパイルした場合、再コンパイルが発生して再生成されるのはどのファイルでしょうか？これには2つのオプションがあります

```
rebuild a.o
rebuild a.pcm
rebuild use.o
link libuse.so
```

もしくは

```
rebuild a.o
rebuild a.pcm
link libuse.so
```

この2つの違いは`use.cpp`が再コンパイルされるかどうかだけです。モジュールの位置づけを考えた場合は再コンパイルされないのが正しい振る舞いにも思えますが、その場合インライン化されている`a()`の定義の変更が反映されません。 再コンパイルする場合は実装の一貫性は保たれますが、コンパイル時間が増大します。あるいは、最適化を有効にしている場合にのみABI依存関係（現在一般的ではない）に基づいて再コンパイルを行うべきでしょうか？

この提案ではこの問題への対処として、モジュール本文内の非`inline`関数本体を変更する場合、対応するモジュールインターフェースのBMIを変更するべきではない、とすることを提案するものです。

すなわち、ユーザーがモジュールインターフェースユニット（の本文）内の非インライン関数の本体のみを変更したプロジェクトを再コンパイルする場合、再コンパイルされるのは変更されたモジュールインターフェースのみであり（そのBMIすらも再コンパイルするべきではなく）、他のすべてのコンパイルは行われるべきではありません。ただし、リンクを除きます。

提案では、これによりユーザーエクスペリエンスが向上するはずとしています。

ビルドシステムのレベルでは、ビルドシステムが再コンパイルが必要かを決定する依存関係はモジュールのソースではなくモジュールのBMIに依存するように実装することでこれが実現できます。そして、コンパイラはBMIにはモジュールからエクスポートされているインターフェースのみを保存しておき、その定義を保存しないようにする必要があります。GCC/MSVCは現在そのようにしていますが、Clangは2フェーズコンパイルモデルを実行する都合上そのようになっていないようです。

実行時のパフォーマンスについても、ヘッダファイルベースのライブラリをモジュールに移行することを考えた場合、ヘッダファイル内の関数はほぼインライン関数であるためこの提案の制約に接触せず、パフォーマンスの低下が発生する場合は限定されるとしています。また、LTOを使用することで翻訳単位を跨いだ定義のインライン化のような最適化が可能となるため、問題とされている最適化が全く利用できなくなるわけではありません。

- [P3033 進行状況](https://github.com/cplusplus/papers/issues/1712)

### [P3034R0 Module Declarations Shouldn't be Macros](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3034r0.html)

名前付きモジュールのモジュール宣言において、モジュール名のマクロ展開を禁止する提案。

モジュールのソースファイル形式は他のものと区別されておらず、あるファイルがモジュールソースであるかは、そのファイルの先頭にモジュール宣言があるかどうかによって決まります。モジュール宣言およびグローバルモジュールフラグメントの宣言はプリプロセッサによって導入することができませんが、モジュール名はマクロの展開によって指定することができます。

例えば、次の様なコードはC++20時点で有効です

```cpp
// version.h
#ifndef VERSION_H
#define VERSION_H

#define VERSION libv5

#endif


// lib.cppm
module;
#include "version.h"
export module VERSION;
```

あるソースファイルがモジュールファイルであり、かつそのモジュール名が何であるかを知ることは、ソースの依存関係を知るために必要な作業です。従来のヘッダインクルードであれば、その依存関係を知らなくてもビルドを行うことができますが、モジュールの場合はビルドにあたってその依存関係を把握しソースのビルド順を決定する必要があります。これを行うのはコンパイラではなくビルドシステムの仕事であるため、ビルドシステムはソースファイルを読み込みそれがモジュールであるか、モジュールの場合はその名前は何かを読み取る必要があるかもしれません（これを行わなくてもいい方法がいくつか考案されていますが、まだ標準化等されてはいません）。

モジュール宣言はプリプロセッサによって導入されないものの、モジュール名はマクロの展開を完了させた上で読み取らなければなりません。そのためには、上記例のようにグローバルモジュールフラグメント内のインクルードやマクロ定義を読み込んだ上でマクロの展開を行わなければなりません。その作業は実装も処理も簡単なものとは言えず、ビルドシステムの実装および処理時間にかなりの負担になります。

この様な理由から、この提案はモジュール名もマクロによって導入できない様にする提案です。

その目的はモジュールファイルのパースを簡単にすることでビルドシステムがモジュール名パースを実装しやすくすることにあります。また、ビルドの前にモジュールの依存関係解決フェーズを行う場合に、パース処理が単純化されることで依存関係解決フェーズの遅延時間を短くすることもできます。

ただし、この変更はC++20への破壊的変更になります。提案では、モジュールの実装はまだ出揃っておらず使用例も稀であるため、影響は最小限である、としています。

この提案はSG15でもEWGでもほぼ反対なく支持されたようで、EWGではこの提案をC++20へのDRとするつもりの様です。

- [P3034 進行状況](https://github.com/cplusplus/papers/issues/1696)

### [P3037R0 `constexpr std::shared_ptr`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3037r0.pdf)

`std::shared_ptr`を定数式でも使える様にする提案。

C++20で定数式における動的メモリ確保が可能になり、C++23で`std::unique_ptr`が`constexpr`対応され定数式で使用できる様になりました。

スマートポインタは実行時と同様に定数式においてもメモリ管理を自動化することができます。しかし、`std::shared_ptr`はその実装に必要な言語機能の一部が定数式で使用可能ではなかったためすぐに`constexpr`対応することができませんでした。

C++23におけるP2738R1（`void*`からの正しいポインタキャストの許可）とP2448R2（定数式で実行不可能なものは評価されるまではエラーにならない）の採択によりその障害は取り除かれており、この提案はそれを受けてC++26に向けて`std::shared_ptr`を`constexpr`対応しようとするものです。

筆者の方はlibstdc++の`std::shared_ptr`実装をベースとして実装を試みており、アトミック操作の使用を回避の必要性や`std::make_shared()`などの行う1回のメモリ確保による初期化の問題などを報告していますが、いずれも回避は可能であり実装可能であるとしています。

また、この提案ではさらに、C++23では`constexpr`で実装できなかったため外されていた`std::unique_ptr`の比較演算子に対しても`constexpr`を付加することも提案しています。

- [P2738R0 constexpr cast from void*: towards constexpr type-erasure - WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2738R0-constexpr-cast-from-void-towards-constexpr-type-erasure)
- [C++23 constexpr関数が定数実行できない場合でも適格とする - cpprefjp](https://cpprefjp.github.io/lang/cpp23/relaxing_some_constexpr_restrictions.html)
- [P3037 進行状況](https://github.com/cplusplus/papers/issues/1713)

### [P3038R0 Concrete suggestions for initial Profiles](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3038r0.pdf)

既存のC++コードの一部により強力な保証を付加するためのプロファイルについての提案。

この提案は、P2687で提案されていたアイデアについて、より具体的な最初の機能について説明するものです。

プロファイルはC++コード上でユーザーによって指定されるもので、スコープもしくはモジュールに対して付加することができます。

```cpp
// モジュール宣言にmemory_safetyプロファイルを適用
export module DataType.Array [[enforce(memory_safety)]];

// 名前空間宣言にプロファイルを適用
namespace N [[enforce(p)]] {
  ...
}
```

`[[enforce(p)]]`はプロファイル`p`をそのスコープに対して適用するもので、そのスコープの内側にあるコードに対してプロファイル`p`の保証が強制されます。モジュールの場合の適用範囲は、そのモジュール本文の全体です。

```cpp
// モジュールMに対してプロファイルPを適用
import M [[enable(P)]];

// モジュールoldでtype_safetyプロファイルを無効化
import old [[suppress(type_safety)]];
```

プロファイルは既存コードに付加して保証を強化するものであり、`[[enable(P)]]`によって特にプロファイルを使用していないモジュールのインポート時にプロファイルを適用することができます。また、プロファイルはスコープに対して指定されある程度広い領域でその保証が強制されるため、`[[suppress(P)]]`によって部分的にプロファイルを無効化することもできます。

想定されるプロファイルにはいくつかの種類が考えられますが、この提案では実装負担の軽減のために最初の小さいものとして`type_safety`プロファイルに焦点を当てています。与えられる保証は例えば

- 変数初期化の強制
    - `[[uninitilize]]`とマークされない変数には初期化が必要
- ポインタの利用の制限
    - ポインタは単一要素を指すか、`nullptr`であるかのどちらか
      - ポインタによる範囲のランダムアクセス禁止、その用途には`span`や`vector`を使用する
    - `owner`とマークされていない限り、ポインタは所有権を持たない
      - `owner`はポインタの先のオブジェクトを破棄する責任を負う
      - `owner`以外のポインタに対して`new/delete`できない
    - `nullptr`チェックなしのポインタアクセスの禁止
- ダングリングポインタ（参照）の抑止
    - ポインタ（参照）はオブジェクトを指すか、`nullptr`のどちらか
    - `owner`ではないポインタは`delete`できない
    - 生存期間が不明なポインタを外側のスコープに漏出できない
    - `return`できるポインタを制限する
- ポインタ（参照）の無効化の防止
    - 非`const`参照によってコンテナを取得する関数では参照の無効化が発生する可能性があり、`const`参照によってコンテナを取得する関数では参照の無効化が発生しないと仮定
    - 非`const`参照によってコンテナを取得するがコンテナを変更しない関数では`[[not_invalidating]]`アノテーションによってそれを表明する
      - 間違った`[[not_invalidating]]`の利用は検出できるはずで、エラーにする

提案文書より、例

```cpp
void f1() {
  int n;  // error

  [[uninitialized]]
  int m;  // ok
}

void f2(int* p1, owner<int*> p2) {
  delete p1; // error、ownerでは無いポインタをdeleteいている
  delete p2; // p2はdeleteしないとエラー
}

void f3(int* p1, owner<int*> p2) {
  p1=p2; // OK、p1はownerではないが、p2と同じオブジェクトを指す
  p2=p1; // error、p2は上書きされる前にdeleteされなければならない
}

int* glob = nullptr;
void f4(int* p) {
  glob = p; // error、不明な生存期間のポインタを保存しようとしている
}

int glob2 = 0;
int* f5(int* p) {
  int x = 4;
  return &x;          // error: ローカルオブジェクトへのポインタを返そうとしている
  return p;           // OK: pは関数呼び出し時に有効であり、無効化されていない
  return new int{7};  // error, ownerポインタを非ownerで返そうとしている
  return &glob2;       // OK 静的オブジェクトへのポインタ
  throw p;            // error: pを*pのスコープ外に漏出しうる
}

void f6(vector<int>& vi) {
  vi.push_back(9); // 要素の再配置が発生しうる
}

void f7() {
  vector<int> vi { 1,2 };
  auto p = vi.begin(); // viの最初の要素を指すイテレータ
  f6(vi); // 参照を無効化しうる関数呼び出し
  *p = 7; // error、参照が無効化されている可能性がある
}
```

提案では、この`type_safety`プロファイルに加えて、`vector`等の範囲に対するアクセスの境界チェックを行う実行時検査を伴うプロファイルである`ranges`プロファイルや、組み込み数値演算の安全性向上（オーバーフロー防止、縮小変換・符号変換の禁止など）のためのプロファイルである`arithmetic`プロファルなどを初期のプロファイルの候補として挙げています。

このようなプロファイルに基づく保証の提供はC++ Core Guidelineおよびそのチェッカー実装とガインドラインサポートライブラリの経験から来ています。それはあくまで静的解析としてC++コンパイルとは別でチェックされることでしたが、プロファイルとしてその保証をC++のコードに対して取り込むことで、既存のC++コードの上に被せる形でC++コードの安全性を高めることができ、プロファイルの指定は小さななスコープから始めることができます。

この提案のプロファイルとその静的な検査については、コアガイドラインチェッカーにて現在利用できるものであり、実装可能であることが確かめられています。また、この提案による安全性の静的検査は、コンパイラに強力なフロー解析などを強いるものではなく、危険を招く可能性のある操作を制限することで抑止するとともに、コンパイラの静的解析にいくつかの仮定を与えることで解析を補助する事を目指す物です。

- [P2687R0 Design Alternatives for Type-and-Resource Safe C++ - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2687R0-Design-Alternatives-for-Type-and-Resource-Safe-C)
- [P3038 進行状況](https://github.com/cplusplus/papers/issues/1692)

### [P3039R0 Automatically Generate `operator->`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3039r0.html)

`<=>`演算子の様な書き換えによって`operator->`を導出する提案。

この提案では、`->`と`->*`演算子をオーバーロード解決時に書き換えて実行することでこの2つの演算子を自動で導出できる様にすることを提案しています。それぞれ次の様になります

- `lhs->rhs`を`(*lhs).rhs`に書き換えて実行
- `lhs->*rhs`を`(*lhs).*rhs`に書き換えて実行

ライブラリソリューション（Boost.Operatorsのような）でこれと同じことを行おうとする場合、`*lhs`がprvalueを返す場合（例えばプロクシイテレータなど）に一時オブジェクトの寿命が`->`の定義内で尽きてしまうことによって未定義動作が発生する問題が回避できません。しかし、言語機能による演算子の書き換えはその様な問題を回避することができます（その場でインラインに置換される形になるので、`->`の呼び出しコンテキストと書き換え後の`*lhs`の生存コンテキストは一致する）。

また、比較演算子の場合は逆順の演算子や細かいコーナーケースを処理するためにその書き換えルールが複雑になっていますが、`->`と`->*`はどちらも逆順を考慮する必要がなく、`->`はクラス内でのみ定義でき右辺のオペランドはオーバーロード解決とは無関係となるため、書き換えに伴う仕様はかなりシンプルになります。

どちらの演算子でも、まずは`->`/`->*`として定義されたもの（`delete`含む）を優先して選択し、それが見つからなず`operator*`が利用可能である場合にのみ書き換えた候補を使用します。`->`を定義したいクラス側で`default`宣言しておく必要はなく、書き換えによって導出されたくない場合は`delete`宣言をしておくことで書き換えを抑止できます。

これによるメリットは、主にイテレータ定義時の`->`に関する記述をほぼ完全に削除することができる点です。

提案では、`<=>`にならってこの提案が採択された場合に既存の`->`定義を削除するオプションについて検討されており、そこではC++20時点の標準ライブラリで`->`を持つクラスにおける定義のされ方を調査しています。それによれば、スマートポインタや`std::optional`、コンテナのイテレータ型や一部のRangeアダプタのイテレータ型など、多数のクラス型において`->`定義を削除することができることが示されています。

ただし、`std::iterator_traits`の`pointer`メンバ型の定義や、`std::to_address`と`std::pointer_traits`などその動作について`->`演算子の存在に依存している部分があるライブラリ機能について、この提案の影響を回避する様にしなければなりません。それについてはいくつか方法が提示されているものの未解決です。

- [演算子を自動定義する - boostjp](https://boostjp.github.io/tips/operators.html)
- [C++20 一貫比較 - cpprefjp](https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html)
- [P3039 進行状況](https://github.com/cplusplus/papers/issues/1693)

### [P3040R0 C++ Standard Library Ready Issues to be moved in Kona, Nov. 2023](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3040r0.html)
### [P3041R0 Transitioning from "#include" World to Modules](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3041r0.pdf)

ヘッダファイルによるライブラリをモジュールベース変換する際の実装戦略についての報告書。

標準ライブラリモジュール`std`と標準ヘッダファイルは同時にインポート/インクルードしたとしてもODR違反等を起こさず一貫して使用可能であることが規定されています。

```cpp
#include <vector>
import std;

int main() {
  // vectorおよびそのメンバ関数実体は曖昧にならない
  std::vector<int> vee { 1, 2, 3, 4, 5 };
  return vee.size();
}
```

これは、通常のユーザーが定義できる名前付きモジュールでは得られない保証です。

ヘッダインクルードによるエンティティはグローバルモジュールに属しており、モジュールのエンティティは名前付きモジュールという翻訳単位に属しています。この2つのものは例え同じ名前で定義されていたとしても異なるものとして扱われるため、上記の様なコードをユーザー定義ライブラリでやると意図通りになるか曖昧になるかは実装次第となります。しかし標準ライブラリモジュールとヘッダファイルに関しては、これが確実に動作する（ヘッダファイルと`std`モジュールとの対応する名前は同じ1つのエンティティを参照する）ことが規定され、要求されています。

これは、標準ヘッダと標準モジュールの両方を適用する必要がある現状においても両方を自然に同居させるための要求ですが、もしこの様な保証をユーザー定義の名前付きモジュールに対しても与えることができれば、ヘッダファイルとモジュールを同時に提供するライブラリの実装が可能になり、ヘッダからモジュールへの移行を促進することができます。

また、上記の様な標準ライブラリの保証を実現する実装戦略は、グローバルモジュール（ヘッダファイル）のエンティティに対して`std`モジュールのエンティティを対応づけるような形になる様ですが、これは名前付きモジュールのいくつかの利点を犠牲にしています。

この報告書は、ヘッダとモジュールを同時に提供しながら名前付きモジュールの利点を余すところなく享受し、なおかつそれを任意のC++ライブラリで利用可能にする実装戦略について説明するものです。

この戦略は、ビルド定義とコンパイラが連携してBMIマッピングと`#include`変換を組み合わせることで、現在の`std`モジュールの保証を実現するものです。標準ライブラリヘッダに関しては、ビルドは次の様に行われます

1. 標準ライブラリヘッダのインクルードをヘッダユニットのインポートへ変換
2. 全ての標準ヘッダユニットに対して、`std`モジュールのBMIを使用する様にコンパイラへ指示する
3. 標準マクロを強制的にインクルードする

マクロに関してはこの方法では導入できないため、別途（コマンドライン等から）インクルードする必要があります。この文書では、C互換ではない標準ヘッダが提供する必要のあるマクロをまとめたヘッダファイルを用意しそれをインクルードする事を推奨しています。

この実装戦略は標準モジュールに対してのものですが、より一般のC++ライブラリに対しても適用可能です。ただし、そのためには次のようなものが必要です

1. あるヘッダが名前付きモジュール（または別のヘッダ）に含まれていることを記述する機能
2. ヘッダのインクルードをヘッダユニットのインポートへ変換する機能
3. 2のヘッダユニットのBMIを包含モジュールのBMIへマッピングする機能
4. ヘッダファイルで導入されるはずのマクロを強制的にインクルードする機能

現在のところこれらの機能のいずれも非標準ライブラリに対しては提供されていません。

### [P3042R0 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3042r0.pdf)

P3019の紹介スライド。

`std::indirect`と`std::polymorphic`のモチベーションや設計要求などについて丁寧に説明されています。おそらく、提案を見るよりも分かりやすそうです。

- [P3019R0 Vocabulary Types for Composite Class Design - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P3019R0-Vocabulary-Types-for-Composite-Class-Design)

### [P3043R0 Slides: Using variable template template without meta programming](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3043r0.pdf)
### [P3046R0 Core Language Working Group "ready" Issues for the November, 2023 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3046r0.html)
### [P3050R0 Optimize linalg::conjugated for noncomplex value types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3050r0.html)

`std::linalg::conjugated()`を非複素数型に対してアクセサの変更をしないようにする提案。

`std::linalg::conjugated()`は複素数配列を参照する`mdspan`の各要素を、その複素共役となるように変換する関数です。ただし、戻り値も`mdspan`で返され、変換は`mdspan`のアクセサポリシーを変更することで行われます。従って実際の要素は変更されず、`mdspan`からの要素参照時に引き当てられた要素に対して複素共役への変換を行うことで配列全体の変換を行います。

```cpp
namespace std::linalg {

  // conjugated()の宣言例
  template<class ElementType,
           class Extents,
           class Layout,
           class Accessor>
  constexpr auto conjugated(mdspan<ElementType, Extents, Layout, Accessor> a);
}
```

`std::linalg::conjugated()`の現在の動作は次のようになっています

- 入力`mdspan<T, E, L, A>`のアクセサ型`A`が`conjugated_accessor<NestedAccessor>`（`NestedAccessor`は任意の他のアクセサ型）である場合、`mdspan<NestedAccessor::element_type, E, L, NestedAccessor>`を戻り値型として入力`a`の領域とレイアウトをそのまま渡して返す
    - 複素共役の複素共役を元のアクセサにして返すことでアクセサ型の多重ネストを回避
- それ以外の場合、`mdspan<T, E, L, conjugated_accessor<A>>`を戻り値型として入力`a`の領域とレイアウトをそのまま渡して返す
    - 複素共役を行うアクセサポリシー`conjugated_accessor`で元のアクセサをラップする

`conjugated_accessor<A>`はアクセサポリシー`A`をラップして、`A`で定義されたアクセス結果に対して複素共役変換を適用して返すアクセサポリシー型です。

`conjugated_accessor<A>`による変換は、`conj-if-needed()`という説明専用の関数によって行われ、`conj-if-needed(c)`は`c`に対するADLによって非メンバ`conj()`が使用可能であればそれを使用して複素共役を取得し、それが見つからない場合は`c`をそのまま返します。これによって、`c`および`mdspan`の要素型が複素数型ではない場合はこの変換は最適化によってスキップされることが期待できます。

しかし、その呼び出し階層を削除することができたとしても、`conjugated_accessor`型の存在を削除することはできません。

`mdspan`を扱う多くのユーザーは関数等で`mdspan`を受け取る場合デフォルトのポリシーを使用して型を記述し、特にアクセサ型を変更する形で記述されることは稀だと思われます（すなわち、要素型`T`に対して`default_accessor<T>`が専ら使用されるはず）。

そのようなユーザーは`<linalg>`の主機能であるBLASラッパを使用しないとしても、`std::linalg::conjugated()`などのユーティリティは使用することになるでしょう。そして、自身の持つ`mdspan`を`std::linalg::conjugated()`に通すとアクセサポリシーが変更された`mdspan`が得られ、デフォルトのアクセサを使用した`mdspan`を受け取るように定義された関数に対してそれを渡すとコンパイルエラーに遭遇するでしょう。

`std::linalg::conjugated()`は複素数要素に対して作用するためこれは回避不可能なものであるといえるかもしれません。しかし、BLASそのものやMatlab等では、転置と共役転置（随伴）の操作は同じものとして統合されており、`<linalg>`でも`conjugate_transposed()`が用意されている他、`conjugated(transposed(x))`のように書かれることもあるでしょう。これらの関数に対する入力はその要素型が浮動小数点数型か複素数型かを意識せずに渡されるはずで、この場合に非複素数要素型の`mdspan`に対してアクセサ型の変更が行われることは驚きを伴う可能性があります。

これに対応するにはアクセサポリシー型をジェネリックにしなければならず、それはコンパイル時間の増大を招くとともに、デフォルトアクセサを仮定する最適化を行えなくなることを意味します。

LWGにおけるP1673のレビュー中にこの問題が指摘され、そのままでも致命的な問題ではなかったためP1673はそのままレビューされC++26 WDにマージされました。この提案は、改めてこの問題を解決するために提出されました。

この提案による変更は、`std::linalg::conjugated()`がアクセサポリシーを`conjugated_accessor`に変更しようとする場合（共役の共役とならない場合）にその要素型が複素数型ではないならば入力の`mdspan`をそのまま返すようにします。これによって、次の2点の変更は観測可能となります

- `std::linalg::conjugated()`の戻り値型は必ずしも`conjugated_accessor<A>`ではなくなる
- 非複素数型の要素型の`mdspan`に対して、戻り値型の`mdspan`は`const element_type`を持たなくなる

これは、`conjugated()`の呼び出しは常に`const element_type`を持つわけではないことや、結果を他の関数に渡しているコードの呼び出しが壊れるわけではないことなどから許容されるとしています。

- [`std::mdspan` AccessorPolicy応用例 - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20240117/p1)
- [P3050 進行状況](https://github.com/cplusplus/papers/issues/1719)

### [P3051R0 Structured Response Files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3051r0.html)

ツールが他のツールにコマンドラインオプションをファイルで引き渡す方法についての提案。

現在、いくつかのコンパイラはそのオプションをファイルにまとめて指定する方法を提供しています。それはよく似た方法で行われていますが、コンパイラ間で互換性はなく、相互運用が可能なものではありません。例えばファイルを渡すオプション名が異なり、ファイル形式もバラバラです。

そのような方法を標準化することで、ツールが他のツールへ（例えばビルドシステムからコンパイラへ）そのコマンドラインオプションを渡すことが容易になり、ツール間の相互運用性が向上します。また、そのような一貫した方法/フォーマットはツールに対する一貫した共通オプションのようなものを定義するための下地にもなります。

この提案は、コマンドラインオプションをまとめたファイルのフォーマットとそれを受け渡す方法について提案するものです。

提案ではファイルの形式としてJSONファイルとすることを提案しています。

そして、そのファイルにツールのオプションを記録する方法として、引数とオプションの2つのスタイルを提案しています。引数はコマンドラインオプション文字列をそのまま記録するもので、オプションは実際のコマンドラインオプションに対応するより概念的な指定となるものです。

提案より、それぞれの表現例

```json
// 引数の例
{
  "arguments": [
    "-fPIC",
    "-O0",
    "-fno-inline",
    "-Wall",
    "-Werror",
    "-g",
    "-I\"util/include\"",
    "-c"
  ]
}

// オプションの例
{
  "options": [
    "fPIC",
    { "O": "0" },
    "fno-inline",
    { "W": [ "all", "error" ] },
    "g",
    { "I": [ "util/include" ] },
    "c"
  ]
}
```

引数のスタイルは既存のコマンドラインオプション構文に直接対応しており移行しやすいものですが、ツール依存になります。オプションは既存のコマンドラインオプション構文をより抽象化したもので、ツール間のオプション構文の差異を吸収できる可能性があります。また、これら2つのスタイルは1つのファイル内に同居することができます。

それぞれの利点/欠点

- 引数
    - 利点
      - 既存のJSON compilation databaseをベースとしており、これをパースする実装は既に存在している
      - ツールのコマンドラインオプションとの直接のマッピングがあり、サポートに労力がかからない
    - 欠点
      - オプションとその値を取得するにはパースが必要
      - 通常のコマンドラインオプションと同じ制限を受ける
- オプション
    - 利点
      - オプション名はオプションのプリフィックス（`- -- /`など）を省略しているため、ツールに依存しない共通名を使用できる
      - オプション値に配列やオブジェクトを利用できることで論理的なグループ化が可能になり、コマンドライン引数のパースで発生するような追加の引数マージ処理のようなものが不用になる
    - 欠点
      - 既存ツールはこの新しいオプション構文を読み取る実装が無い
      - JSON compilation databaseでもこの形式が採用される場合、さらに追加の作業が発生する

そして、このファイルを指定するコマンドラインオプションとして`std-rsp`を提案しています。

```
tool --std-rsp=file
tool -std-rsp:file
```

実際のファイル全体は例えば次のようになります

```json
{
  "$schema": "https://raw.githubusercontent.com/cplusplus/ecosystem-is/release/schema/std_rsp-1.0.0.json",
  "version": "1",
  "arguments": ["-fPIC", "-O0", "-fno-inline", "-Wall", "-Werror", "-g", "-I\"util/include\"", "-c" ]
}
```

提案では、オプションスタイルの場合の各オプション名について、実際のコマンドライン引数名に対応させるか、より抽象的な名前にするかについて未解決としています（例えば、`W, o, I`と`warning, output, include`）。これにも利点欠点があるため、どちらを選択するかやこの提案でそれを追求するかについてはSG15の決定に委ねています。

- [P3051 進行状況](https://github.com/cplusplus/papers/issues/1720)

### [P3052R0 `view_interface::at()`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3052r0.html)

`view_interface`に`at()`メンバ関数を追加する提案。

C++26でP2821が採択されたことで`std::span`でもインデックスアクセスに`at()`が使用できる様になり、既存の標準コンテナ等とのインターフェースの一貫性が向上しています。これにより、標準にある2つの`view`型（`span`と`string_view`）で`at()`が使用できる様になったため、これをより汎用的な`view`型でも一貫させることの根拠が生まれました。

残りの`view`型とは`<ranges>`の各種`view`型（`subrange`やRangeアダプタの`view`型）のことで、これらの型はその共通インターフェースを`view_interface`というCRTPベースクラスを継承することで提供しています。

この提案は、インデックスアクセスの安全性とインターフェースの一貫性を向上させるために、`view_interface`に`at()`メンバ関数を追加しようとするものです。

```cpp
namespace std::ranges {
  template<class D>
    requires is_class_v<D> && same_as<D, remove_cv_t<D>>
  class view_interface {
    ...
  public:
    ...
    
    // 現在の添字演算子オーバーロード
    template<random_access_range R = D>
    constexpr decltype(auto) operator[](range_difference_t<R> n) {
      return ranges::begin(derived())[n];
    }

    template<random_access_range R = const D>
    constexpr decltype(auto) operator[](range_difference_t<R> n) const {
      return ranges::begin(derived())[n];
    }

    // 提案するat()
    template<random_access_range R = D>
      requires sized_range<R>
    constexpr decltype(auto) at(range_difference_t<R> n);

    template<random_access_range R = const D>
      requires sized_range<R>
    constexpr decltype(auto) at(range_difference_t<R> n) const;
  };
}
```

この`at()`はコンテナ等のそれと同様に動作し、指定されたインデックスが範囲外参照となる場合に`out_of_range`例外を送出するものです。`view_interface`で提供されることで、`<ranges>`のほぼ全ての`view`型で使用可能になります。

- [`std::ranges::view_interface` - cpprefjp](https://cpprefjp.github.io/reference/ranges/view_interface.html)
- [P3052 進行状況](https://github.com/cplusplus/papers/issues/1721)

### [P3053R0 2023-12 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3053r0.html)
### [P3055R0 Relax wording to permit relocation optimizations in the STL](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3055r0.html)

リロケーション操作による最適化を標準ライブラリのコンテナ等で許可するために、標準の規定を緩和する提案。

C++26に向けてリロケーション（*relocation*）操作を言語に導入する議論が進んでいます。リロケーションは意味的にはムーブ+破棄に相当し、ムーブした直後にムーブ元オブジェクトを破棄する操作をひとまとめにしたものです。中でも、トリビアルリロケーションは`memcpy`によってオブジェクト表現（ビット列）をコピーするだけで行うことができます。

リロケーション後の元のオブジェクトはコード上で使用不可になるという性質から、一部のムーブを伴う操作はリロケーションによって効率化できる可能性があります。特に、標準コンテナの操作やアルゴリズムに関わる操作などにおいて最適化を促進することが期待されています。

仮にリロケーション操作が言語に入った時に問題となるのは、それらコンテナやアルゴリズムの規定、特に計算量の規定がリロケーションではなくムーブを前提として指定されていることです。たとえば、`std::vector::erase()`をリロケーションによって書き換えると次の様な実装になるでしょう

```cpp
void erase(iterator it) {
  if constexpr (std::is_trivially_relocatable_v<value_type>) {
    std::destroy_at(std::to_address(it));
    std::uninitialized_relocate(it + 1, end_, it);
  } else {
    std::ranges::move(it + 1, end_, it); // operator=
    std::destroy_at(std::to_address(end_ - 1));
  }
  
  --end_;
}
```

しかし、`std::vector::erase()`の計算量の指定は、「要素型`T`のデストラクタは消去された要素の数と等しい回数呼ばれ、`T`の代入演算子は消去された要素の後にある要素の数と等しい回数呼ばれる」と規定されています。トリビアルリロケーションの場合、要素のムーブはそのオブジェクト表現のコピーのみで元オブジェクトの破棄は行われない（オブジェクトの配置場所が変わるだけでオブジェクトそのものは何ら変化しない）ため、`std::vector::erase()`ではリロケーション操作が利用可能になったとしても標準の範囲内でそれを利用することができません。

このような規定がなされているものがコンテナの操作やアルゴリズムに関して存在しており、これがある限り言語にリロケーションが導入されても標準ライブラリはそれを活かすことができません。しかし、これを取り除いておけばリロケーションの到来と関係なく、標準ライブラリはトリビアルリロケーション可能であると現在わかっている型（`std::deque<int>`など）についてそのような最適化を行うことができます。

この提案は、その様な過剰な制限を強いてしまっている現在の規定をリストアップし、それをトリビアルリロケーションをサポート可能なように緩和しようとするものです。

提案する変更は、全て現在の制限を若干緩めるものなので、既存の実装がこれを受けて何か変更する必要があるものではありません。たとえば、先ほどの`std::vector::erase()`の計算量の規定の場合、「元の`vector`上で削除された一番先頭にある要素の後にある要素の数について線形」の様に変更しています。これによって、特定の操作に対して計算量を指定する事を回避しています。

- [P2786R0 Trivial relocatability options - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2786R0-Trivial-relocatability-options)
- [P1144R6 Object relocation in terms of move plus destroy - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1144R6-Object-relocation-in-terms-of-move-plus-destroy)
- [P1144R8 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P1144R8-stdis_trivially_relocatable)
- [P3055 進行状況](https://github.com/cplusplus/papers/issues/1723)

### [P3056R0 what ostream exception](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3056r0.html)

現在例外を投げる際に避けることのできない動的メモリ確保を回避する提案。

標準ライブラリにある`std::exception`派生クラスは`.what()`メンバ関数からエラーメッセージを返すためにそのコンストラクタで文字列を受け取りますが、動的に構成した文字列を`std::string`に保持してる状態で渡そうとする場合、文字列をコピーして受け取る以外の選択肢がありません。

```cpp
void f(int n) {
  std::string err_msg = std::to_string(n);
  std::runtime_error err{err_msg};  // コピーされる

  throw err;
}
```

これは、`std::exception`派生クラスの`std::string`を受け取るコンストラクタは`const std::string&`を受け取るものしかないためです。

また、このように例外が発生するコンテキストでエラーメッセージを動的に構成する場合、その作業そのものに伴って動的メモリ確保が発生しています。例えば例外の`.what()`が呼ばれない場合、このコストは余分なものとなります。

この提案は、`std::exception`派生クラスおよび`std::exception`に2種類のメンバ関数を追加することによって、この2つの動的メモリ確保を回避もしくは遅延させ、ライブラリ実装者およびそのユーザーが動的メモリ確保を制御できる様にしようとするものです。

追加するのは次の2つです

1. `std::exception`派生クラスのコンストラクタに`std::string&&`を受け取るコンストラクタを追加する
2. `std::exception`の`.what()`のオーバーロードとして、`std::ostream&`を受け取りエラーメッセージの構築と出力まで行うオーバーロードを追加する

1つ目の変更によって、`std::exception`派生クラスにエラーメッセージの`std::string`をムーブ渡しできる様になり、コピーに伴う動的メモリ確保を回避することができます。

```cpp
void f(int n) {
  std::string err_msg = std::to_string(n);
  std::runtime_error err{std::move(err_msg)};  // ムーブされる

  throw err;
}
```

2つ目の変更ではさらに、例外オブジェクト内部に必要な情報を保持しておき、エラーメッセージが必要になったタイミングでエラーメッセージをオンデマンドに構成することが可能になります。

```cpp
class runtime_error_v2 : virtual public runtime_error_v2 {
private:
    const int m;
    const std::source_location location;
public:
  runtime_error_v2(int n, const std::source_location location)
    : m{n}
    , location{location}
  {}

  virtual std::ostream& what(std::ostream& os) const noexcept override {
    // 呼ばれてからメッセージを構成する
    return os << "file: "
        << location.file_name() << '('
        << location.line() << ':'
        << location.column() << ") `"
        << location.function_name() << "`: "
        << "value: " << n << '\n';
  }
};

void f(int n) {
  std::runtime_error err{n, std::source_location::current()};
  throw err;
}
```

- [`<stdexcept>` - cpprefjp](https://cpprefjp.github.io/reference/stdexcept.html)
- [P3056 進行状況](https://github.com/cplusplus/papers/issues/1724)

### [P3057R0 Two finer-grained compilation model for named modules](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3057r0.html)

名前付きモジュールの依存関係管理について、より細かい単位で依存関係を管理する方法についての報告書。

名前付きモジュールでは、ヘッダファイルとは異なり個々のモジュールが1つの翻訳単位を成しているため、プログラム全体をビルドするためにはその依存関係を把握した上で依存関係の根本から順番にビルドしていく必要があります。そのため、インクリメンタルビルド等においては、ある1つのファイルの変更がより多くのモジュールや翻訳単位のリビルドを引き起こす可能性があります。

この文書は、この問題を軽減するために、より細かい単位で依存関係管理を行うコンパイルモデルを説明するものです。

この文書で挙げられているモデルは2つあります。

1. 使用したファイルベースのソリューション
    - あるソースファイルのコンパイル中に使用されたソースファイルを記録しておき、2回目以降のビルドでは自身及び使用したファイルが変更されていなければ再コンパイルを省略する
    - この場合の使用されたかされていないかは、ファイルのインポートやインクルードではなく、その中身の宣言が使用されているかによって判定される
    - ここでのファイルの変更は、ファイルシステムにおける変更によって判定する
2. 宣言のハッシュによるソリューション
    - あるソースファイルのコンパイル中に、そこで使用されている宣言のハッシュを記録しておき、2回目以降のビルドでは記録した宣言ハッシュを比較して変更がなければ再コンパイルを省略する
    - ハッシュの計算と比較のコストやビルドシステム側での対応など課題がある

この2つの方法はClangのプラグインを通して既に試すことができるようで、文書中でも実際のデモの様子が報告されています。

- [[C++20] [Modules] Introduce a tool 'clang-named-modules-querier' and two plugins 'ClangGetUsedFilesFromModulesPlugin' and 'ClangGetDeclsInModulesPlugin' by ChuanqiXu9 · Pull Request #72956 · llvm/llvm-project](https://github.com/llvm/llvm-project/pull/72956)

### [P3059R0 Making user-defined constructors of view iterators/sentinels private](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3059r0.html)
### [P3060R0 Add std::ranges::upto(n)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3060r0.html)
### [P3061R0 WG21 2023-11 Kona Record of Discussion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3061r0.pdf)
### [P3062R0 C++ Should Be C++ - Presentation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3062r0.pdf)
### [P3066R0 Allow repeating contract annotations on non-first declarations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3066r0.pdf)
### [P3070R0 Formatting enums](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3070r0.html)
### [P3071R0 Protection against modifications in contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3071r0.html)

↓

### [P3071R1 Protection against modifications in contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3071r1.html)

契約注釈内から参照されるローカル変数と関数引数は暗黙的に`const`として扱われるようにする提案。

現在のContracts MVP仕様では、契約注釈内での意図しないプログラム状態の変更に対する保護が欠けているため、それを追加しようとする提案です。次のようなことを提案しています

- *contract context*（契約コンテキスト）は契約注釈内の条件式
    - その文法はP2961R2で提案されているnatural syntaxのもの
- 契約コンテキストの部分式であり、オブジェクト型`T`の自動変数、または自動変数に対する`T`型の構造化束縛を指名するid式は、`const T`型の左辺値（*lvalue*）
- 契約コンテキストの部分式であり、自動変数である`T`の参照を指名するid式は、`const T`型の左辺値（*lvalue*）
- 契約コンテキストの部分式であるラムダ式がコピーによって非関数エンティティをキャプチャする場合、暗黙に宣言された（クロージャオブジェクトの）メンバ型は`T`だが、ラムダの本体内でそのようなメンバを指名するとラムダが`mutable`でない限り`const`左辺値が返される（これは通常通り）
    - ラムダ式が参照によってそのようなエンティティをキャプチャする場合、その参照を指名するid式は、`const T`型の左辺値（*lvalue*）
- 契約コンテキストの部分式で現れる`this`式は`cv X`へのポインタを示す*prvalue*
    - `cv`は`const`と囲むメンバ関数のCV修飾（存在する場合）との組み合わせ
    - この場合の契約コンテキストの部分式には、非静的メンバ関数の本体内での暗黙変換の結果を含む
- 契約コンテキストの部分式であるラムダ式が`T`へのポインタである`this`をキャプチャする場合、暗黙に宣言された（クロージャオブジェクトの）メンバ型は`const T`へのポインタ

提案文書より、サンプルコード。

```cpp
int global = 0;

int f(int x, int y, char *p, int& ref)
  pre((x = 0) == 0)            // proposal: ill-formed、const左辺値への代入
  pre((*p = 5))                // OK
  pre((ref = 5))               // proposal: ill-formed、const左辺値への代入
  pre(std::same_as_v<decltype(ref), int&>)  // OK; 結果はtrue
  pre((global = 2))            // OK
  pre([x] { return x = 2; }())           // error: xはconst
  pre([x] mutable { return x = 2; }())   // OK, 関数引数xのコピーを変更する
  pre([&x] { return x = 2; }())          // proposal: ill-formed、const左辺値への代入
  pre([&x] mutable { return x = 2; }())  // proposal: ill-formed、const左辺値への代入
  post(r: y = r)               // error: yはconstではないので事後条件で使用できない
{
  contract_assert((x = 0));    // proposal: ill-formed、const左辺値への代入
  int var = 42;
  contract_assert((var = 42)); // proposal: ill-formed、const左辺値への代入

  static int svar = 1;
  contract_assert((svar = 1)); // OK
  return y;
}

struct S {
  int dm;

  void mf() /* not const */
    pre((dm = 1))                         // proposal: ill-formed、const左辺値への代入
    pre([this]{ dm = 1; }())              // proposal: ill-formed、const左辺値への代入
    pre([this] () mutable { dm = 1; }())  // proposal: ill-formed、const左辺値への代入
    pre([*this]{ dm = 1; }())             // error: ill-formed、const左辺値への代入
    pre([*this] () mutable { dm = 1; }()) // OK, *thisのコピーを変更
  {}
};
```

proposalとコメントされているところがこの提案によって動作が変更されるところです。メンバ関数の契約注釈から`this`を使用する場合、それは`const`メンバ関数内であるかのように扱われます。

この提案は既にSG21においてMVPに採用することに合意されているようです。

- [P3071 進行状況](https://github.com/cplusplus/papers/issues/1732)

### [P3072R0 Hassle-free thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3072r0.html)
### [P3074R0 constexpr union lifetime](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3074r0.html)
### [P3075R0 Adding an Undefined Behavior and IFNDR Annex](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p3075r0.pdf)
