# ［C++］WG21月次提案文書を眺める（2023年05月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-05](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-05)

SG22のWG14からのものを除いて、全部で41本あります。

[:contents]

### P2654R0 Macros And Standard Library Modules

標準ライブラリで提供されるマクロを、標準ライブラリモジュール（`std.compat`）からエクスポートするようにする提案。

C++23から`std/std.compat`モジュールが提供されるようになり、標準ライブラリの全体をモジュールとしてインポートできるようになります。ただし、これには標準ライブラリ（特に、C互換ヘッダ）でマクロとして提供される機能が含まれていません。

これはモジュールの仕様に基づくもので、名前付きモジュールからはマクロをエクスポートすることができないためです。この制限がないヘッダユニットと呼ばれる、従来のヘッダファイルをモジュールとして`import`する方法もありこちらはマクロもエクスポートされますが、標準ライブラリのC互換ヘッダはヘッダユニットとして`import`可能であるかは実装定義です。

結局、標準のマクロ機能を使用しようとすると、従来のヘッダファイルのインクルード以外に手段がありません。

この提案は、モジュールにおけるマクロの扱いに変更を加えることなくこの制限を取り除くために、標準ライブラリ中でマクロとして提供される機能の代替提供手段を検討するものです。

この提案では、その対象として次のものを挙げています

- リテラル値に置換されるマクロ
    - これらは`#if`ディレクティブで多用されるため、`constexpr`変数で置換できない
    - テキスト置換を行わない新しいプリプロセッシングディレクティブにより解決（別提案）
- `assert`
    - このマクロはC++においては様々な問題を抱えている
    - P2884R0では、`assert`をキーワード化して演算子として使用するようにすることを提案しており、懸念事項が取り上げられている
- `offsetof`
    - P2883R0で議論
- `setjmp/longjmp`
    - C++オブジェクトモデル及びオブジェクト生存期間の概念と直接関わるもの
    - キーワード化して動作を提供することを提案
- `va_arg`
    - 言語の基礎的な機能であり、`import`で使用可能であるべき
    - キーワード化して動作を提供することを提案
- `errno`
    - 現在解決案はない
- `ATOMIC_XXX_LOCK_FREE`
    - これらのマクロはサポートされる場合にコンパイラによって定義される（モジュールからエクスポートする必要がない）
- `ATOMIC_FLAG_INIT`
    - C23ライブラリで削除されているため、削除すれば解決

この提案では必ずしも個別の解決策全てを提案しておらず、他の提案に委ねている部分があります。

- [モジュール - cpprefjp](https://cpprefjp.github.io/module.html)
- [P2654 進行状況](https://github.com/cplusplus/papers/issues/)

### P2767R0 `flat_map`/`flat_set` omnibus

`flat_map`/`flat_set`の仕様にあるいくつかの問題点とその解決策について報告する提案。

この提案は、libc++における`flat_map`/`flat_set`とそのファミリを実装する過程で明らかになった問題をまとめ、解決が可能なものはその解決策について報告するものです。

この提案で報告されている大きなものは次のような事項です

1. 編集上の変更
    - 主に、アロケータを受け取るコンストラクタの調整
2. 一部のデフォルト引数を持つ`explicit`コンストラクタの分離
3. `flat_set::insert_range()`において、要素をムーブするようにする
4. `flat_set::insert_range()`において、要素をムーブするようにする
5. `insert()`が`emplce()`を使用しないようにする
    - 挿入位置決めのために、まず最初に挿入予定の要素をスタック上に構築する必要があるが、引数で渡されているオブジェクトを使用することでこれを回避できる
    - 同じ理由から、`falt_multiset`においてヘテロジニアスな`insert()`が有用となるため追加する（これは、他の`multi`な連想コンテナと異なる性質）
    - `emplace()`の制約を削除
    - `flat_set::insert()`に制約を追加し、イテレータペアを渡した時にヘテロジニアス`insert()`と曖昧にならないようにする
6. `sorted_unique`をとる`insert()`のオーバーロードに、`range`をとるものを追加
    - `insert(sorted_unique, args...)`は、複数の要素がソート済で一意であることを前提に1操作で挿入するAPI
    - `insert(first, last)`に対して`insert(sorted_unique, first, last)`、`insert(il)`に対して`insert(sorted_unique, il)`はあった
    - しかし、`insert(range)`に対して`insert(sorted_unique, range)`が欠けていたため、これを追加する
7. ソートが必要なコンストラクタの計算量の指定の修正
    - 一部のソート済みを仮定しないコンストラクタにおける計算量が`O(N)`と指定されている
    - これを達成するのは容易ではなく、そのような規定を`ranges::sort()`と同等になるように修正
8. `replace()`が右辺値参照ではなく値で受けるようにする
    - `replace(key_container_type&&, mapped_container_type&&)`はキーと対応する値の配列を受けて、内部の配列をそれによって置換するAPI
    - 引数としては、内部コンテナ型の右辺値参照を受けていた
    - `replace()`は常に右辺値を渡さなければならないが、似た他の場所のAPIではこのような用法ではなかった
    - 値で受け取るようにすることで、コピーして渡すことを容易にしつつムーブして渡す場合の使用感を維持する
9. `flat_set::keys()`の追加
    - `flat_map`には、そのキーと値の配列を参照するための`keys(), values()`が用意されているが、`flat_set`にはない
    - 利便性向上と一貫性のために、`flat_set`に`keys()`（だけ）を追加する

他にも、解決策が提案されていないIssueがいくつか報告されています。

- [P2767 進行状況](https://github.com/cplusplus/papers/issues/)