# ［C++］WG21月次提案文書を眺める（2022年02月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2022-02](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/#mailing2022-02)

全部で66本あります（SG22のWG14からのものは除きます）。

[:contents]

### [N4903 PL22.16/WG21 agenda: 7 February 2022, Virtual Meeting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4903.html)

2022年2月7日（北米時間）に行われたWG21全体会議のアジェンダ。

C++23のための4回目の全体会議です。

### [N4904 WG21 admin telecon meetings: 2022 summer and autumn (revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4904.pdf)

次回以降のWG21の各作業部会の管理者ミーティング。

次は2022年7月11日（北米時間）に予定されています。

### [N4905 WG21 2022-01 Admin telecon minutes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4905.pdf)

WG21の各作業部会の管理者ミーティング。

前回から今回の会議の間のアクティビティの報告がされています。

### [N4906 Transactional Memory TS2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4906.pdf)

P2066の最小トランザクショナルメモリのTechnical Specifications。

P2066R2については以前の記事を参照

- [P2066R2 Suggested draft TS for C++ Extensions for Minimal Transactional Memory - ［C++］WG21月次提案文書を眺める（2020年05月）](https://onihusube.hatenablog.com/entry/2020/06/01/001003#P2066R2--Suggested-draft-TS-for-C-Extensions-for-Transaction-Memory-Light)
- [P2066R3 Suggested draft TS for C++ Extensions for Minimal Transactional Memory - ［C++］WG21月次提案文書を眺める（2020年09月）](https://onihusube.hatenablog.com/entry/2020/10/09/221025#P2066R3--Suggested-draft-TS-for-C-Extensions-for-Transaction-Memory-Light)
- [P2066R4 Suggested draft TS for C++ Extensions for Minimal Transactional Memory - ［C++］WG21月次提案文書を眺める（2020年10月）](https://onihusube.hatenablog.com/entry/2020/11/02/221657#P2066R4-Suggested-draft-TS-for-C-Extensions-for-Minimal-Transactional-Memory)
- [P2066R5 Suggested draft TS for C++ Extensions for Minimal Transactional Memory - ［C++］WG21月次提案文書を眺める（2021年02月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P2066R5-Suggested-draft-TS-for-C-Extensions-for-Minimal-Transactional-Memory)
- [P2066R6 Suggested draft TS for C++ Extensions for Minimal Transactional Memory - ［C++］WG21月次提案文書を眺める（2021年03月）](https://onihusube.hatenablog.com/entry/2021/04/10/222356#P2066R6-Suggested-draft-TS-for-C-Extensions-for-Minimal-Transactional-Memory)
- [P2066R7 Suggested draft TS for C++ Extensions for Minimal Transactional Memory - ［C++］WG21月次提案文書を眺める（2021年05月）](https://onihusube.hatenablog.com/entry/2021/06/13/165215#P2066R7-Suggested-draft-TS-for-C-Extensions-for-Minimal-Transactional-Memory)
- [P2066R8 Suggested draft TS for C++ Extensions for Minimal Transactional Memory - ［C++］WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2066R8-Suggested-draft-TS-for-C-Extensions-for-Minimal-Transactional-Memory)
- [P2066R9 Suggested draft TS for C++ Extensions for Minimal Transactional Memory - ［C++］WG21月次提案文書を眺める（2021年09月）](https://onihusube.hatenablog.com/entry/2021/10/03/193523#P2066R9-Suggested-draft-TS-for-C-Extensions-for-Minimal-Transactional-Memory)
- [P2066R10 Suggested draft TS for C++ Extensions for Minimal Transactional Memory - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2066R10-Suggested-draft-TS-for-C-Extensions-for-Minimal-Transactional-Memory)

### [N4907 WG21 2022-02 Virtual Meeting Minutes of Meeting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4907.pdf)

2022年2月7日（北米時間）に行われた、WG21全体会議の議事録。

CWG/LWG/LEWGの投票の様子などが記載されています。

### [P0009R15 MDSPAN](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0009r15.html)

多次元配列に対する`std::span`である、`mdspan`の提案。

以前の記事を参照

- [P0009R12 MDSPAN - WG21月次提案文書を眺める（2021年05月）](https://onihusube.hatenablog.com/entry/2021/06/13/165215#P0009R12-MDSPAN)
- [P0009R13 MDSPAN - WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P0009R13-MDSPAN)
- [P0009R14 MDSPAN - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P0009R14-MDSPAN)

このリビジョンでの変更は

- `mdspan::rank[_dynamic]`の型が`size_t`になった
- strideを考慮するように`layout_stride`の比較演算子を修正
- `layout_stride`の`required_span_size`へのマッピングを修正
- レイアウトマッピングクラスの`operator()`の効果で`index_sequenceand`のみを使用するようにした（`stride(P())`によるエラーを回避）
- `extents<>`を処理するために、単項畳み込み式を二項へ置き換えた
- `mdspan`の`std::array`を受け取るコンストラクタが`Extent`の`std::array`コンストラクタを呼び出すように修正
- 提案する文言の調整・改善

などです。

この提案は現在、LWGにおいてレビュー作業中です。

- [P0009 進行状況](https://github.com/cplusplus/papers/issues/96)

### [P0323R12 std::expected](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0323r12.html)

エラーハンドリングを戻り値で行うための型、`std::expected<T, E>`の提案。

以前の記事を参照

- [P0323R10 std::expected - WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P0323R10-stdexpected)
- [P0323R11 std::expected - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P0323R11-stdexpected)

このリビジョンでの変更はよくわかりません。

この提案は2022年2月の全体会議で承認され、C++23入りが決定しています。

- [P0323 進行状況](https://github.com/cplusplus/papers/issues/254)

### [P0447R19 Introduction of std::hive to the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0447r19.html)

要素が削除されない限りそのメモリ位置が安定なコンテナである`std::hive`（旧名`std::colony`）の提案。

以前の記事を参照

- [P0447R11 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2020年12月）](https://onihusube.hatenablog.com/entry/2020/12/06/015108#P0447R11-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R12 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2021年01月）](https://onihusube.hatenablog.com/entry/2021/02/11/153333#P0447R12-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R13 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P0447R13-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R14 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2021年05月）](https://onihusube.hatenablog.com/entry/2021/06/13/165215#P0447R14-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R15 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P0447R15-Introduction-of-stdhive-to-the-standard-library)
- [P0447R16 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2021年09月）](https://onihusube.hatenablog.com/entry/2021/10/03/193523#P0447R16-Introduction-of-stdhive-to-the-standard-library)
- [P0447R17 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P0447R17-Introduction-of-stdhive-to-the-standard-library)
- [P0447R18 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P0447R18-Introduction-of-stdhive-to-the-standard-library)

このリビジョンでの変更は、Introduction節の修正、`sort()`によってイテレータが無効化されることを追記、記載されていたQ&Aの削除、`constexpr`についての説明の移動、などです。

- [P0447 進行状況](https://github.com/cplusplus/papers/issues/328)

### [P0561R6 An RAII Interface for Deferred Reclamation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0561r6.html)

*deferred reclamation*を実現するためのより高レベルAPIを標準ライブラリに追加する提案。

以前の記事を参照

- [P0561R5 An RAII Interface for Deferred Reclamation - ［C++］WG21月次提案文書を眺める（2020年12月）](https://onihusube.hatenablog.com/entry/2021/01/17/005823#P0561R5-An-RAII-Interface-for-Deferred-Reclamation)
- 
このリビジョンでの変更は、`<snapshot>`を`<experimental/snapshot>`に変更した事、機能テストマクロを追加した事です。

この提案はConcurency TS v2に向けて作業されているようです。

- [P0561 進行状況](https://github.com/cplusplus/papers/issues/268)

### [P0792R7 function_ref: a non-owning reference to a Callable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0792r7.html)
### [P0792R8 function_ref: a non-owning reference to a Callable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0792r8.html)
### [P0957R5 Proxy: A Polymorphic Programming Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0957r5.pdf)

静的な多態的プログラミングのためのユーティリティ、"Proxy"の提案。

多態性（*Polymorphism*）はプログラムコンポーネントを分離し、拡張性を向上させるために不可欠です。ただし、そのコストとして実行時のパフォーマンスを低下させます。

現在の標準には仮想関数による継承ベースの方法とライブラリのポリモルフィックラッパ型（`std::function, std::any, std::pmr::polymorphic_allocator`など）の2つの多態性サポートがありますが、ライブラリのポリモルフィックラッパ型は特定の用途のために拡張性が制限されており、多態的なプログラミングには通常継承ベースの方法の使用が避けられません。

この提案の"Proxy"は自由に拡張可能で効率的な多態性を実現するためのユーティリティであり、多くの部分を静的に解決することによって従来のC++におけるOOPとFPの使いやすさとパフォーマンスの制限を取り払うことを目指すものです。

図形クラスによるサンプル。

```cpp
// Drawableのインターフェースクラス
class IDrawable {
public:
  virtual void Draw() const = 0;    // 図形の描画
  virtual double Area() const = 0;  // 面積の取得
};

// 長方形クラス
class Rectangle : public IDrawable {
public:
  void Draw() const override;
  void SetWidth(double width);
  void SetHeight(double height);
  void SetTransparency(double);
  double Area() const override;
};

// 円クラス
class Circle : public IDrawable {
public:
  void Draw() const override;
  void SetRadius(double radius);
  void SetTransparency(double transparency);
  double Area() const override;
};

// 点クラス
class Point : public IDrawable {
public:
  void Draw() const override;
  double Area() const override { return 0; }
};

// Drawableな対象を操作する
void DoSomethingWithDrawable(IDrawable* p) {
  printf("The drawable is: ");
  p->Draw(); // .Draw()の呼び出し
  printf(", area = %f\n", p->Area());  // .Area()の呼び出し
}

// 文字列による指定からDrawableを構築する
auto MakeDrawableFromCommand(const std::string&) -> std::unique_ptr<IDrawable>;

int main() {
  std::unique_ptr<IDrawable> p;

  p = MakeDrawableFromCommand("Rectangle 2 3");
  DoSomethingWithDrawable(p.get());

  p = MakeDrawableFromCommand("Circle 1");
  DoSomethingWithDrawable(p.get());

  p = MakeDrawableFromCommand("Point");
  DoSomethingWithDrawable(p.get());
}
```

このよくある継承ベースのポリモルフィズムのサンプルは、Proxyによって次のように書くことができます。

```cpp
#include <proxy>

// Drawableに要求される2つの操作の定義（図形の描画と面積の取得）
struct Draw : std::dispatch<
    void(), [](const auto& self) { self.Draw(); }> {};
struct Area : std::dispatch<
    double(), [](const auto& self) { return self.Area(); }> {};

// DrawableのFacadeクラスの定義
struct FDrawable : std::facade<Draw, Area> {};

// 長方形クラス
class Rectangle {
 public:
  void Draw() const
      { printf("{Rectangle: width = %f, height = %f}", width_, height_); }
  void SetWidth(double width) { width_ = width; }
  void SetHeight(double height) { height_ = height; }
  void SetTransparency(double);
  double Area() const { return width_ * height_; }

 private:
  double width_;
  double height_;
};

// 円クラス
class Circle {
 public:
  void Draw() const { printf("{Circle: radius = %f}", radius_); }
  void SetRadius(double radius) { radius_ = radius; }
  void SetTransparency(double);
  double Area() const { return std::numbers::pi * radius_ * radius_; }

 private:
  double radius_;
};

// 点クラス
class Point {
 public:
  Point() noexcept { puts("A point was created"); }
  ~Point() { puts("A point was destroyed"); }
  void Draw() const { printf("{Point}"); }
  constexpr double Area() const { return 0; }
};

// Drawableな対象をstd::proxy経由で呼び出す
void DoSomethingWithDrawable(std::proxy<FDrawable> p) {
  printf("The drawable is: ");
  p.invoke<Draw>(); // .Draw()の呼び出し
  printf(", area = %f\n", p.invoke<Area>());  // .Area()の呼び出し
}

// 文字列による指定からDrawableを構築する
auto MakeDrawableFromCommand(const std::string&) -> std::proxy<FDrawable>;

int main() {
  std::proxy<FDrawable> p;

  p = MakeDrawableFromCommand("Rectangle 2 3");
  DoSomethingWithDrawable(std::move(p));

  p = MakeDrawableFromCommand("Circle 1");
  DoSomethingWithDrawable(std::move(p));

  p = MakeDrawableFromCommand("Point");
  DoSomethingWithDrawable(std::move(p));
}
```

この提案のProxyの中核は、`std::dispatch, std::facade, std::proxy`の3つのクラスです。

`std::dispatch`は関数型と関数呼び出し可能なもの（*Callable*）をテンプレートパラメータに受け取る空のクラスで、第二引数の*Callable*にはディスパッチ処理を記述します（ここでは、メンバ関数`Draw(), Area()`の呼び出し）。`std::facade`は`std::dispatch`によって定義されたディスパッチ要件の列を受け取る空のクラスです。この2つのクラス定義ではこれ以外のことをする必要はありません（多分`using`でもいいはず）。

`std::proxy`は`std::dispatch, std::facade`によって定義した要件にアダプトした任意の型のオブジェクトを保持する型消去ラッパーです。テンプレートパラメータにディスパッチ要件を指定した`std::facade<...>`を受け取ります。構築及び代入では柔軟な変換によって任意のオブジェクトを受け取り（`std::any`の振る舞いに近い）、`.invoke<D>()`メンバ関数によって保持するオブジェクトを使用して`std::dispatch`（`D`）に指定した方法によって関数の呼び出しを行います。`.invoke<D>()`は追加の引数を受け取って呼び出される関数まで転送することもできます。

`std::proxy`はポリモルフィックなオブジェクトを外部から受け取って内部に保持するもので、そのオブジェクトの構築は任意に行うことができます。それによって、それらポリモルフィックなオブジェクトのライフタイム管理の戦略をも柔軟にカスタマイズすることができます。例えば、上記例の`MakeDrawableFromCommand()`は次のように実装されます。

```cpp
std::proxy<FDrawable> MakeDrawableFromCommand(const std::string& s) {
  // 引数をパースする（ParseCommandは別に定義されているとする）
  std::vector<std::string> parsed = ParseCommand(s);

  if (!parsed.empty()) {
    if (parsed[0u] == "Rectangle") {
      if (parsed.size() == 3u) {
        // polymorphic_allocatorとプールによるアロケートとライフタイムのカスタマイズ
        static std::pmr::unsynchronized_pool_resource rectangle_memory_pool;
        std::pmr::polymorphic_allocator<> alloc{&rectangle_memory_pool};

        auto deleter = [alloc](Rectangle* ptr) mutable { 
          alloc.delete_object<Rectangle>(ptr);
        };

        Rectangle* instance = alloc.new_object<Rectangle>();
        std::unique_ptr<Rectangle, decltype(deleter)> p{instance, deleter};

        p->SetWidth(std::stod(parsed[1u]));
        p->SetHeight(std::stod(parsed[2u]));
        
        return p; // unique_ptr -> proxyへ暗黙変換（unique_ptrを内部で保持することで間接所有する）
      }
    } else if (parsed[0u] == "Circle") {
      if (parsed.size() == 2u) {
        // ローカル（スタック）変数
        Circle circle;
        circle.SetRadius(std::stod(parsed[1u]));

        return std::make_proxy<FDrawable>(circle); // コピーして直接保持、SBO（Small Buffer Optimization）が適用される
      }
    } else if (parsed[0u] == "Point") {
      if (parsed.size() == 1u) {
        // グローバルシングルトンオブジェクト
        static Point instance;

        return &instance; // ポインタを保持
      }
    }
  }
  throw std::runtime_error{"Invalid command"};
}
```

このような柔軟で安全かつ効率的（SBOによる）なライフタイム管理は、従来の継承ベースの手法では困難だったものです。`std::proxy`はここにさらにインターフェースのディスパッチサポートが追加されていることで、継承ベースの手法と同等の多態性サポートを行うとともに、安全性と効率性や使いやすさを向上させています。

継承ベースと`std::proxy`のメモリレイアウトの比較図

![](20220310_wg21_paper_202202/p0957_1.png)

- [my-stl/proxy.h - Github](https://github.com/mingxwa/my-stl/blob/cb79714c7f4332e302edcd1ec34535acf5b50b67/main/p0957/proxy.h)
- [my-stl/demo/p0957 - Github](https://github.com/mingxwa/my-stl/tree/cb79714c7f4332e302edcd1ec34535acf5b50b67/demo/p0957)
- [P0957 進行状況](https://github.com/cplusplus/papers/issues/306)

### [P1018R15 C++ Language Evolution status - pandemic edition – 2022/01-2022/02](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1018r15.html)
### [P1202R4 Asymmetric Fences](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1202r4.pdf)
### [P1223R3 `find_last`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r3.pdf)

指定された値をシーケンスの後ろから探索する`find_last`アルゴリズムの提案。

これは`std::find`の逆を行うものです。現在それを書こうとすると、単純なループか`std::reverse_iterator`を使用するかのどちらかになるでしょう。

```cpp
template<std::bidirectional_iterator I, typename T>
  requires std::indirect_binary_predicate<ranges::equal_to, I, const T*>
auto find_last1(I first, I it, const T& x) {
  // ループを使った探索
  while (it-- != first) {
    if (*it == x) {
      // Use it here...
    }
  }

  return it;
}

template<std::bidirectional_iterator I, typename T>
  requires std::indirect_binary_predicate<ranges::equal_to, I, const T*>
auto find_last1(I first, I it, const T& x) {
  // reverse_iteratorとfindを使った探索
  auto rfirst = std::make_reverse_iterator(it);
  auto rlast = std::make_reverse_iterator(first);
  
  auto it2 = std::find(rfirst, rlast, x);
  // Use it here...

  return it2;
}
```

しかし、やりたい事の単純さと比較してこれらの記法はどちらも煩わしさがあります。理想的には次のようにかけるといいはずです。

```cpp
auto it2 = std::find_last(first, it, x);
```

この提案はこの`find_last`をはじめとした各種ファミリー（`find_last_if, find_last_if_not`）の標準ライブラリへの追加を目指すものです。

```cpp
namespace std::ranges {
  // イテレータペアを受け取る
  template<forward_iterator I, sentinel<I> S, class T, class Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr I find_last(I first, S last, const T& value, Proj proj = {});

  // rangeを受け取る
  template<forward_range R, class T, class Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr borrowed_iterator_t<R> find_last(R&& r, const T& value, Proj proj = {});

}
```

現在の提案ではこれらの関数は全て対象の要素を発見した位置のイテレータを返すようになっていますが、`find_last()`はその実行に際してまず範囲の終端を求める必要があります（`range`を受け取る方の場合）。したがって（その他のアルゴリズム、特に`ranges`版がそうであるように）、その有用な情報をユーザーに返す必要があります。そこで、`subrange`を返すように変更することが議論されています。

```cpp
namespace std::ranges {
  // イテレータペアを受け取る
  template<forward_iterator I, sentinel<I> S, class T, class Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr subrange<I> find_last(I first, S last, const T& value, Proj proj = {});

  // rangeを受け取る
  template<forward_range R, class T, class Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr borrowed_subrange_t<R> find_last(R&& r, const T& value, Proj proj = {});
}
```

この場合、指定されたものを見つけたら`[it, last)`の`subrange`を、何も見つからなかったら`[last, last)`の`subrange`を返します。

この設計の問題点は、この戻り値が`find`などと一貫していないこと、多くの場合ユーザーは終端情報（`last`）を使用しないので捨てるべき余分な情報が増えるだけと思われることです。しかし、筆者の方はこれを改善であると認識していて、その方向で議論が進んでいるようです。

- [P0957 進行状況](https://github.com/cplusplus/papers/issues/149)

### [P1478R7 Byte-wise atomic memcpy](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1478r7.html)
### [P1664R7 reconstructible_range - a concept for putting ranges back together](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1664r7.html)
### [P1774R6 Portable assumptions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1774r6.pdf)
### [P1839R3 Accessing Object Representations](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1839r3.pdf)

`reinterpret_cast<char*>`によるオブジェクト表現へのアクセスを未定義動作とならないようにする提案。

この提案の解決する問題は、キャストとポインタ演算という2つの操作によって発生します。

```cpp
int a = 420;

char b = *reinterpret_cast<char*>(&a);  // UB
```

この`reinterpret_cast<char*>(&a)`は`static_cast<char*>(static_cast<void*>(&a))`と同じ効果となり（[[expr.reinterpret.cast]/7](http://eel.is/c++draft/expr.reinterpret.cast#7)）、そのような`static_cast`の指定するところ（[[expr.static.cast]/13](http://eel.is/c++draft/expr.static.cast#13)）によってそのポインタ値（アドレス値）は変化しません。そのため、このキャスト後のポインタは元のオブジェクトを指しています。

この時、`b`の初期化式に*lvalue-to-rvalue conversion*を適用するとその結果は`int`の値（`420`）となり、それは`char`で表現できる値ではないので未定義動作となります（[[expr.pre]/4](http://eel.is/c++draft/expr.pre#4)）。もしこの時、`char`にその表現が存在する場合でも、[[basic.types]/4](http://eel.is/c++draft/basic.types#general-4)の規定するところのオブジェクト表現は配列ではなく`unsgined char`のオブジェクトの列となってしまい、現在のオブジェクトモデルの下ではポインタ演算に適していません。

この問題はC++17でP0137R1が採択されたことによって発生した問題のようです。この提案では、ポインタが単なるメモリのアドレス表現ではなくオブジェクトを指すものという形でポインタの動作方法の変更を行なっており、そこでは、ポインタを介してオブジェクトのオブジェクト表現へアクセスする方法についての考慮がおろそかになっていたようです。

この提案では、次のような変更によってこの問題の解決を図ります。

- ある型のオブジェクト表現が連続したストレージを占有している場合、そのオブジェクト表現は`unsigned char`の配列とみなされるようにする
- `unsigned char, char, std::byte`のオブジェクトとその配列は、それ自身のオブジェクト表現とする（定義の再帰防止）
- `unsigned char, char, std::byte`以外の型のオブジェクト表現の各要素の値は未規定であり、`unsigned char, char, std::byte`のオブジェクト表現の要素の値はそれらのオブジェクト表現の値とする
- オブジェクト表現へのポインタを、`unsigned char, char, std::byte`への（ポインタ）キャストによって取得できるようにする
- オブジェクト表現へのポインタは、キャストを用いて元のオブジェクトへのポインタに戻せるようにする
- `std::launder`が、オブジェクト表現の要素ではないオブジェクトへのポインタを返すことを優先するように規定
    - 複数のオブジェクトが同じストレージを占めている時、そのような領域へのポインタに対する`std::launder`が返すポインタはプログラム定義のオブジェクトを指すものとする
    - おそらく、その時生存期間内にあるオブジェクトへのポインタを返すことを意図していると思われる、たぶん・・・
- 式の型が`unsigned char*, char*, std::byte*`の場合、オブジェクト表現の要素に対してポインタ演算できるようにする

これらの変更は新しい機能を導入するものではなく、既存の慣行を標準化するものです。


<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
using T = unsigned char*;
int a = 0;
T b = reinterpret_cast<T>(&a);
// ポインタ値は変更されない
// bはaを指す

T c = ++b;
// UB、式の型は要素型と異なる
```

</td>
<td valign="top">

```cpp
using T = unsigned char*;
int a = 0;
T b = reinterpret_cast<T>(&a);
// bはa(int)のオブジェクト表現の
// 最初の要素（unsigned char）を指す

T c = ++b;
// cはa(int)のオブジェクト表現の2番目の要素を指す

++(*c); // OK
```

</pre>
</td>
</tr>
</table>

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
using T = unsigned char*;
int a[5]{};
T b = reinterpret_cast<T>(&a);
// ポインタ値は変更されない
// bはaを指す

for (int i = 0; i < sizeof(int) * 5; ++i){
  b[i] = 0; // UB、式の型は要素型と異なる
}
```

</td>
<td valign="top">

```cpp
using T = unsigned char*;
int a[5]{};
T b = reinterpret_cast<T>(&a);
// bはa(int[5])のオブジェクト表現の
// 最初の要素（unsigned char）を指す

for (int i = 0; i < sizeof(int) * 5; ++i){
  b[i] = 0; // OK
}
```

</pre>
</td>
</tr>
</table>

- [P1839 進行状況](https://github.com/cplusplus/papers/issues/592)

### [P1841R3 Wording for Individually Specializable Numeric Traits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1841r3.pdf)
### [P1885R10 Naming Text Encodings to Demystify Them](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1885r10.pdf)
### [P2093R13 Formatted output](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2093r13.html)
### [P2214R2 A Plan for C++23 Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2214r2.html)
### [P2416R2 Presentation of requirements in the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2416r2.pdf)
### [P2438R2 std::string::substr() &&](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2438r2.html)
### [P2441R2 views::join_with](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2441r2.html)
### [P2446R2 views::as_rvalue](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2446r2.html)
### [P2448R2 Relaxing some constexpr restrictions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2448r2.html)
### [P2452R0 2021 October Library Evolution and Concurrency Polls on Networking and Executors](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2452r0.html)
### [P2453R0 2021 October Library Evolution Poll Outcomes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2453r0.html)
### [P2458R1 2022 January Library Evolution Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2458r1.html)
### [P2459R0 2022 January Library Evolution Poll Outcomes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2459r0.html)
### [P2465R2 Standard Library Modules std and std.compat](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2465r2.pdf)
### [P2467R1 Support exclusive mode for fstreams](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2467r1.html)
### [P2472R1 make function_ref more functional](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2472r1.html)
### [P2495R0 Interfacing `stringstream`s with `string_view`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2495r0.pdf)

`std::stringstream`が`std::string_view`を受けとれるようにする提案。

`std::stringstream`は`std::string`による文字列を受け取ってその文字列によるストリームを構成するものです。C++20から`.view()`メンバ関数によってストリームの中身への`std::string_view`を取得することができるようになっていますが、ストリームの最初の内容をコンストラクタで指定する際には`std::string`しか渡せません。また、C++20から`.str()`メンバ関数によって後からストリームの中身を置き換えることができるようになっていますが、ここでも`std::string`しか渡せません。

`std::stringstream`に文字列リテラルおよび`std::string_view`を渡そうとすると、`std::string`の一時オブジェクトを作成してからそれをコンストラクタに渡さなければなりません。しかも、`std::stringstream`はそこからさらに内部の`std::string`を構築するために、コピー/ムーブすることになります。

この提案はこの問題を解決するために、コンストラクタと`.str()`の両方が`std::string_view`を受けとれるようにするものです。

その際問題となるのが、文字列リテラルを渡した時に`std::string`を受け取るオーバーロードと`std::string_view`を受けとるオーバーロードで曖昧になることです。いくつかの解決が考えられますが、この提案では文字列リテラル用のオーバーロード（`const char*`を受け取る）も同時に追加することでそれを解消しています。

この提案による変更の例

```cpp
const ios_base::openmode mode;
const allocator<char> alloc;
const string str;
// mystringはstring_viewに暗黙変換可能だとする
const mystring mstr;

stringstream s0{""};                  // ok
stringstream s1{"", alloc};           // ng -> ok
stringstream s2{"", mode, alloc};     // ng -> ok

stringstream s3{""sv};                // ng -> ok
stringstream s4{""sv, alloc};         // ng -> ok
stringstream s5{""sv, mode, alloc};   // ng -> ok

stringstream s6{""s};                 // ok
stringstream s7{""s, alloc};          // ok
stringstream s8{""s, mode, alloc};    // ok

stringstream s9{str};                 // ok
stringstream s10{str, alloc};         // ok
stringstream s11{str, mode, alloc};   // ok

stringstream s12{mstr};               // ng -> ok
stringstream s13{mstr, alloc};        // ng -> ok
stringstream s14{mstr, mode, alloc};  // ng -> ok

stringstream s15;
s15.str("");      // ok
s15.str(""sv);    // ng -> ok
s15.str(""s);     // ok
s15.str(str);     // ok
s15.str(mstr);    // ng -> ok
```

- [`std::basic_stringstream` - cppreference](https://en.cppreference.com/w/cpp/io/basic_stringstream)
- [P2495 進行状況](https://github.com/cplusplus/papers/issues/1190)

### [P2502R1 std::generator: Synchronous Coroutine Generator for Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2502r1.pdf)
### [P2505R1 Monadic Functions for std::expected](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2505r1.html)
### [P2506R0 `std::lazy`: a coroutine for deferred execution](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2506r0.pdf)

コルーチンによって非同期タスクを表現するためのユーティリティ、`std::lazy`の提案。

`std::lazy`はC#などの他の言語では`Task`という名前のクラスであることが多いものです。

これはコルーチンによって非同期処理の実行と待機、継続処理の実行を自動化するためのユーティリティ型で例えば次のように使用します。

```cpp
// 何かのデータ型
struct record {
  int id;
  std::string name;
  std::string description;
};

// recordをどこかから読み出す非同期処理
std::lazy<record> load_record(int id);
// recordをどこかに保存する非同期処理
std::lazy<> save_record(record r);

// recordの更新処理
std::lazy<void> modify_record() {
  // これらの処理はこの順番に実行される
  record r = co_await load_record(123);     // 1. レコードの読み出し
  r.description = “Look, ma, no blocking!”; // 2. 1の実行後rが初期化されてから実行
  co_await save_record(std::move(r));       // 3. レコード保存。2の実行後に実行される
  std::cout << "modify end.\n";             // 4. 3の実行が完了してから実行される
}
```

この`modify_record()`をコルーチンではなく`future`とコールバックによって同じ実行順となるように書くと次のようになります

```cpp
// modify_record()の非コルーチン版
void modify_record_async() {
  auto f1 = load_record_async(123, [](record r) {
    r.description = “Look, ma, no blocking!”;
    auto f2 = save_record_async(std::move(r), [](){
      std::cout << "modify end.\n"
    });

    f2.wait();
  });

  f1.wait();
  // f1, f2はstd::future相当のものとする
}
```

このコールバックコードで手動でやっているようなことを、`co_await`構文を使用することで隠蔽・自動化するためのコルーチン制御を担っているのが`std::lazy`型です。

`std::lazy`は元々は別の著者によって別の提案（[P1056R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2506r0.pdf)）で議論されていましたが、そちらは長期間止まっていたため、この提案が引き取った形です。そのため、ほとんどの部分の設計は変更されていません。筆者の方は、`std::lazy`を含めた基本的なコルーチンユーティリティがC++20に含まれていないのは間違いであり、C++23に含まれないのはもっと間違いだ、と述べていますが、この提案は今の所C++23に向けたものではありません（C++23の設計フェーズはすでに終了しているため）。

`std::lazy`は次のようなとてもシンプルで小さいクラスです

```cpp
template<class T, class Allocator = void>
class [[nodiscard]] lazy {
public:
  lazy(lazy&& that) noexcept;
  ~lazy();

  unspecified operator co_await();

  T sync_await();
};
```

おそらくこれらのメンバ関数を明示的に呼び出すことはないでしょう。テンプレートパラメータ`T`はコルーチンから返す値の型（`move_constructible`であること）を指定し、何も返さない場合は`void`を指定することができます。2つ目の`Allocator`は、コルーチンステートのために必要となるヒープアロケーションをカスタマイズするために指定します。

`std::lazy`はコルーチンとその呼び出し元の境界で暗黙的に使用されるものであって、上記サンプルコードにあるように、呼び出し側の`co_await`を除いてコルーチン側でもこの型に対して何か明示的な操作をする必要はありません。

C++26 Executorライブラリ（[P2300](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2300r4.html)）（予定）では、`sender`とコルーチンの相互変換などの仕組みが用意されており、`std::lazy`も別の提案によって後ほどP2300にアダプトする作業が行われる予定です。

なお、`std::lazy`が`std::task`という名前ではないのは、`std::task`という名前をここで消費してしまうことを嫌ってのことのようです。

- [P2470R0 Slides for presentation of P2300R2: `std::execution` (`sender/receiver`)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2470r0.pdf)
- [P2495 進行状況](https://github.com/cplusplus/papers/issues/1190)

この部分の7割は以下の方のご指摘によって成り立っています。

- [@yohhoyさん](https://twitter.com/yohhoy/status/1497086762895609857)

### [P2513R1 char8_t Compatibility and Portability Fix](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2513r1.html)
### [P2521R1 Contract support -- Working Paper](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2521r1.html)
### [P2528R0 C/C++ Identifier Security using Unicode Standard Annex 39](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2528r0.html)

セキュリティ上の問題のある文字を識別子に使用できなくする提案。

C++20では（DRなので以前のバージョンに対してもですが）[P1949](https:://wg21.link/p1949)の採択によって不可視の文字や絵文字など、識別子（変数名やクラス名など）として使用すると問題のある一部の文字が識別子に使用できなくなりました。そこでは、ユニコード標準のAnnex 31というものを参照して識別子として使用可能な文字の集合を指定（制限）していました。

ユニコード標準にはAnnex 39としてユニコード文字のセキュリティ上の問題を解決するためのメカニズムを提供しています。P1949では、UAX31とUAX39の両方を実装するのは困難であるとして、UAX31による制限だけを提案していました。この提案は、筆者の方の経験（[libu8ident](https://github.com/rurban/libu8ident/)の実装）やRustやJavaなどでUAX31とUAX39が正しく実装していることから、両方を実装するのは可能であるとしてそれを提案するものです。

UAX31に加えてUAX39を実装するとユニコード識別子に関する既知のセキュリティ上の問題のほとんどを修正することができます。残った問題は、文字列やコメント中のbidiオーバーライド（文字列中での双方向テキストの切り替えによる攻撃）ですが、これは識別子に対する制限だけでは解決できないため、この提案の範囲ではありません。それでも、最近GCCに実装されたように、トークナイザやプリプロセッサの警告によって発見することができます。

提案していることは以下の事です

- [UAX39 #5.2](https://unicode.org/reports/tr39/#Restriction_Level_Detection) Mixed-Scripts Moderately Restrictive profileに部分的に準拠
    - ラテン語との混同を避けるためにギリシャ文字の一部を許可する
- UAX31 [#Table_7](https://unicode.org/reports/tr31/#Table_Limited_Use_Scripts)（限定文字）とUAX31 [#Table_4](https://unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers)（除外文字）をすべて使用しない
- [UAX39 #Table_1](https://unicode.org/reports/tr39/#Identifier_Status_and_Type)のRecommended, Inclusion, Technicalに分類される文識別子タイプのみを許可 
    - アラビア語の単語の中央の位置を尊重するようにする（現在のユニコードの指定では間違っている）
- NFCの正規化を要求する
    - すべてのcomposable sequence（結合文字のこと？）を拒否する
- 混合スクリプト (SCX)を使用した不正な形式の混合マークシーケンス（Sk, Cf, Mn, Me）を拒否する
    - [UAX39 #5.4](https://unicode.org/reports/tr39/#Optional_Detection)
- オプション
    - `#pragma unicode <LongScript>`によって、ソースファイルごとに除外スクリプトを指定できるようにする

ここに出てくるスクリプトというのは、特定の文字の集合みたいな意味です（日本語では[用字](https://ja.wikipedia.org/wiki/%E7%94%A8%E5%AD%97_(Unicode))というらしい）。

提案では、拒否する文字が識別子に現れた場合はコンパイルエラーとすることを提案しています（ただし、それは政治的な決断になるかもしれないと言っています）。

- [UTS #39 UNICODE SECURITY MECHANISMS](https://unicode.org/reports/tr39/)
- [UTS #31 UNICODE IDENTIFIER AND PATTERN SYNTAX](https://unicode.org/reports/tr31/)
- [用字 (Unicode) - Wikipedia](https://ja.wikipedia.org/wiki/%E7%94%A8%E5%AD%97_(Unicode))
- [双方向テキスト - Wikipedia](https://ja.wikipedia.org/wiki/%E5%8F%8C%E6%96%B9%E5%90%91%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88)
- [P2528 進行状況](https://github.com/cplusplus/papers/issues/1190)

この部分の7割は以下の方のご指摘によって成り立っています。

- [@kazatuyuさん](https://twitter.com/kazatsuyu/status/1497470114546941952)

### [P2529R0 generator should have `T&&` reference_type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2529r0.html)

提案中の`std::generator<T>`の`reference_type`は`T&&`であるべきとする提案。

`std::generator`は現在[P2502](https://wg21.link/p2502r1)で議論されていますが、そこでは`std::generator<T>`についてその`reference_type`が何であるべきかが主な論点になっているようです。現在の提案では`const T&`が提案されています。この提案は、それは`T&&`とするように推奨しその根拠を述べるものです。

前提として、誰もが合意するであろうことは

- `std::generator<U>`の`U`が`T&, const T&, T&&`である場合
    - `reference_type`は`U`、`value_type`は`remove_cvref_t<U>`
    - `promise_type::yield_value`のシグネチャは`yield_value(U)`
- `std::generator<U>`の`U`が`const T, const T&&`、または`volatile`である場合を考慮する必要はない
    - これらを機能させるために時間をかける価値はない
- `std::generator<T>`の`T`がCV・参照修飾されていない場合
    - `value_type`のデフォルトは`T`
    - `reference_type`は`T, const T, const T&&`ではない
        - `T`はP2168R3で提案されていたがその時点での著者はそれが正しい選択ではないことに同意している
        - これによって、`T, const T, const T&&`は候補から外れる
    - `co_yield EXPR`をサポートする、この時の`EXPR`は左辺値もしくは右辺値
        - これは右辺値のみを`co_yield`できる`std::generator<T&&>`では異なる
        - `co_yield`に渡される左辺値と`const`右辺値は関数の外部から変更できないようにする必要がある
        - `co_yield`に渡された非`const`右辺値は変更されるか、少なくともムーブされる
            - 必ずそうしなければなら無いという事ではなく、右辺値が変更されることに対する異議があるとは思っていないということ

そして、問題となっているのは

- `std::generator<T>`の`T`がCV・参照修飾されていない場合
    -  `reference_type`は`T&&`と`const T&`のどちらか
        - `const T&` : P2502R0
        - `T&&` : この提案
        - `T&`は既存のジェネレータで採用されており有効なオプションだが、`std::generator`に対して提案した人はいない
    - `co_yield`に左辺値が渡された時にどうすべきか？
        - P2502R0は`const`参照によって直接返すことを提案している
        - この提案では、コピーしてその右辺値を返すことを提案する

この提案では、次の4つの理由によって`T&&`とこの振る舞いが最適であると説明しています。

#### パフォーマンスとムーブオンリー型のサポート

`make_gen()`は`std::generator<T>`を返す関数であるとして、

<table>
<tr>
<th>`T&&`</th>
<th>`const T&`</th>
</tr>
<tr>
<td valign="top">

```cpp
ranges::copy(generator, output); // no copies

make_gen() | to<vector>; // no copies


```

```cpp
for (auto s : make_gen()) {} // no copies

for (auto&& s : make_gen()) {
    consume(s); // copies (as it should!)
    consume(std::forward<decltype(s)>(s)); // no copies
}
```

</td>
<td valign="top">

```cpp
ranges::copy(generator, output); // copies

make_gen() | to<vector>; // copies
make_gen() | views::move | to<vector>; // still copies
```
```cpp
for (auto s : make_gen()) {} // copies

for (auto&& s : make_gen()) {
    consume(s); // copies (as it should!)
    consume(std::forward<decltype(s)>(s)); // copies
    consume(std::move(s)); // still copies;
}
```

</pre>
</td>
</tr>
</table>

この2つの問題は異なる問題ですが、同じサンプルコードで表現できます。この場合の`T`がムーブオンリーであった場合、上記の全てのコピーはコンパイルエラーとなります。

`reference_type`が`const T&`であることで、あらゆる場合に要素型のムーブが妨げられることによってこの違いが出ています。`:generator`が自分で変更できない場合、この問題を解決することはできません。

#### 言語の他の部分との一貫性

- `std::generator<T>`を使用するコルーチン内部
    - `co_yield EXPR;`は、`f`が`T`をとる時の`f(EXPR)`や`T`を返す関数の内部で`return EXPR;`した時と同様に考えるのが良い。どちらの場合も、`EXPR`が左辺値の時はコピーされるが、右辺値の時はそうではない。
- `T`を取る関数の引数の場合
    - 同等のものは、`T&&`と`const T&`を取るオーバーロードであると認識されている。`xvalue`引数の最終的な状態は呼び出された側に依存するため厳密には等価ではないが、`std::move()`して渡した後の変数の状態は通常気にされないので無視できる。
    - さらに、ムーブ不可能なxvalueを`T&&/const T&`をとる関数に渡すことはできても、`T`を取る関数に渡すことはできない。

これは、`std:generator<T>::promise_type::yield_value()`の振る舞いについてのこと（及び提案）です。寿命が短すぎるため`T`を直接取ることはできないため、次善の策として`T&&`を取るようにしておき（これは`T`が参照の場合にも正しい動作をする）、`copyable`（かつ`movable`でない）非参照の型のために`const T&`のオーバーロードを提供して渡されたオブジェクトのコピーを作成できるようにします。

#### ジェネレータのユースケースに最適

`std::generator<T>`はその名前が示すように、複数の`T`のオブジェクトを生成して返す場合に最適なツールです。一方で、既存のデータ構造に対してイテレータを作成するためのツールにはなり得ません。一般的にその用途には`forward_range`が求められますが、`std::generator`は必然的に`input_range`にしかなりえません。

そのため、範囲の各要素は高々1度しかアクセスされず、`std::generator`を使用するコルーチンが新しいオブジェクトを生成する場合にそれを一々コピーさせるのは明らかに無駄です。

筆者の方のコードベースでは、このジェネレータのようなものを使用していませんが、似たようなパターンを色々な場所で使用しているようです。そこでは、連続した値の生成のためにSTLスタイルのイテレータではなく`std::optional<T>`を返す`getNext()`のようなものを使用しています。そして、それを使用するほぼすべての場所では、返されるのは右辺値であるか、ムーブが安全なローカル変数です。そのようなAPIは当初、呼び出し側が所有するオブジェクトを返すために`T*`を返すことができましたが、誰も使用しなかったようです。

#### シンプルさ

この提案の主なポイントは、`std::generator<T&&>::iterator::operator*()`は常に`T&&`を返す必要がある、ということです。

これは、言語の参照の折り畳みルールを使用して、`T`が参照型である場合も含めてすべての場合に正しい振る舞いをします。それによって、`reference_type`等の導出に`conditional_t`を用いるなど複雑なことをしなくても良くなります。

これらの理由により、`co_yield`の引数型および`operator*`の戻り値型として非参照の`T`を使用することはいいアイデアではなく、常に`T&&`を使用するようにすることを提案しています。

この提案は既にLEWGのレビューを終えて、P2529への適用に合意が取れています。これによって、`std::generator<T>`は`std::generator<T&&>`と同等の振る舞いをするようになります。

- [P2528 進行状況](https://github.com/cplusplus/papers/issues/1193)

### [P2530R0 Why Hazard Pointers should be in C++26](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2530r0.pdf)

標準ライブラリにハザードポインタサポートを追加する提案。

これは現在Concurrency TS v2（未発行）に含まれているハザードポインタ関連のユーティリティのサブセットをC++26の標準ライブラリに含めようとする提案です。以前はP1121で議論されていたため、詳細はそちらの解説記事を参照してください。

- [P1121R3 Hazard Pointers: Proposed Interface and Wording for Concurrency TS 2 - ［C++］WG21月次提案文書を眺める（2021年01月）](https://onihusube.hatenablog.com/entry/2021/02/11/153333#P1121R2-Hazard-Pointers-Proposed-Interface-and-Wording-for-Concurrency-TS-2)

この提案の動機と根拠は、P1121R3のハザードポインタの設計が2018年頃にはほぼ固まっており変更されていない事、FacebookのFollyというライブラリで2016年頃から実装され、Facebook社内で2017年頃から実利用されていること、などによります。提案しているのはConcurrency TS v2にあるハザードポインタ関連のすべてではなく上記の経験に基づく安定している一部であり、文言の変更も軽微であるため少ない労力で導入できると述べています。

P1121R3およびConcurrency TS v2から含まれていないのは次の2点です

- カスタムドメイン
    - ドメインとはハザードポインタを参照（使用）する範囲（主にスレッド）のこと
    - Follyの経験では、カスタムドメインなしでもデフォルトのドメインを拡張・改良可能だった
    - これはカスタムドメインの必要性を否定するものではないが、一般的なユースケースに必要であるかは不透明であるため、この提案には含めない
- グローバルクリーンアップ関数（`hazard_pointer_clean_up()`）
    - グローバルクリーンアップ関数が呼び出されると、ハザードポインタによってロックされているすべてのリソースが再利用可能となる（つまりロックが解放される）。これを*synchronous reclamation*と呼ぶ。
    - Follyでは、グローバルクリーンアップよりも効率的な*synchronous reclamation*（*cohort-based synchronous reclamation*）を実装しており、2018年頃から利用されている。こちらを導入させたいためグローバルクリーンアップはこの提案に含めない。
    - ただし、*cohort-based synchronous reclamation*に関する文言は複雑となることが予想され（Concurrency TS v2にも含まれていない）、ハザードポインタの一般的なユースケースのサポートを優先するためにこちらも将来の提案とする。

結果として、提案されているのはハザードポインタクラスそのもの及びそのファクトリ関数（と`swap()`特殊化）のみです。ただしこのドロップされたものも含めて将来の拡張の計画があるようで、それを意識した文言になっています。

- [P2530 進行状況](https://github.com/cplusplus/papers/issues/1194)

### [P2531R0 C++ Standard Library Issues to be moved in Virtual Plenary, Feb. 2022](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2531r0.html)
### [P2532R0 Removing exception_ptr from the Receiver Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2532r0.html)
### [P2533R0 Core Language Working Group "ready" Issues for the February, 2022 meeting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2533r0.html)
### [P2534R0 Slides: function_ref in the wild (P0792R7 presentation)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2534r0.pdf)
### [P2535R0 Message fences](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2535r0.pdf)
### [P2536R0 Distributing C++ Module Libraries with dependencies json files.](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2536r0.pdf)
### [P2537R0 Relax va_start Requirements to Match C](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2537r0.html)
### [P2538R0 ADL-proof std::projected](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2538r0.html)
### [P2540R0 Empty Product for certain Views](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2540r0.html)
### [P2542R0 views::concat](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2542r0.html)
### [P2544R0 C++ exceptions are becoming more and more problematic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2544r0.html)
### [P2545R0 Why RCU Should be in C++26](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2545r0.pdf)
### [P2546R0 Debugging Support](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2546r0.html)
### [P2547R0 Language support for customisable functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2547r0.pdf)
### [P2549R0 std::unexpected should have error() as member accessor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2549r0.html)
### [P2550R0 ranges::copy should say output_iterator somewhere](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2550r0.html)
### [P2551R0 Clarify intent of P1841 numeric traits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2551r0.pdf)
### [P2552R0 On the ignorability of standard attributes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2552r0.pdf)
### [P2553R0 Make mdspan size_type controllable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2553r0.html)
### [P2554R0 C-Array Interoperability of MDSpan](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2554r0.html)
### [P2555R0 Naming improvements for std::execution](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2555r0.html)
### [P2557R0 WG21 2022-02 Virtual Meeting Record of Discussion](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2557r0.pdf)
