# ［C++］ P0588R1　Simplifying implicit lambda capture　についてのメモ

C++20にひっそりと採択されているP0588R1という提案は、3度見したくらいでは何をしているのか、何がしたいのかさっぱりわかりません。一体これはなんなのでしょうか・・・

### P0588R1のやっていること

眺めているとP0588R1ではラムダ式に関連したいくつかのこと・振る舞いを明確化しようとしていることが朧げながら見えてきます。それはおそらく次の4つです

1. ラムダ式が名前をキャプチャする（できる）場所の明確化
2. ラムダ式がクラスメンバ初期化子で使用された時の挙動の明確化 (CWG1632)
3. ラムダ式の構文内でキャプチャした対象に対する`decltype((x))`の振る舞いの明確化 (CWG1913)
4. 構造化束縛をキャプチャできないことを明確化

これらの変更は全て、規格上でその振る舞いが不透明だったものをしっかりと記述し直そうとするもののようで、既存の振る舞いを変更することを意図するものではないようです。

そのため規格文書の言い回しを工夫する変更になっており、それが上記4要素分いっぺんに入っているので意味不明度を高めています。

### 言葉の定義

ここでは、P0588R1で導入されている用語や、それに使用されている用語などの定義をしておきます。

#### エンティティ

エンティティ（*entity*）とは次のいずれかに該当するものです

- 値
- オブジェクト
- 参照
- 構造化束縛
- 関数
- 列挙体
- 型
- クラスメンバ
- ビットフィールド
- テンプレート
- テンプレート特殊化
- 名前空間
- パラメータパック

C++のコード上で構文以上の何かしらの意味を持つもののことを総じてエンティティと呼びます。

#### ローカルエンティティ

ローカルエンティティ（*local entity*）とは、エンティティの中でも次のいずれかに該当するものです

- ローカル変数
- 分解対象がローカルエンティティである構造化束縛
- `*this`オブジェクト

ほぼほぼ、ローカル変数のことを言っていると思って差し支えありません。

#### 宣言領域

宣言領域（*declarative region*）とは、あるエンティティを指す名前が有効なコード上の最大の範囲（領域）のことです。

```cpp
void f() {
  int n = 0;

  {
    int n = 1;

  }

}
```

C++コード上の全ての名前（変数名やクラス名などなど）はそのコード上に宣言領域を持ちます。

#### スコープ

ある名前のスコープ（*scope*）とは、その名前が持つ宣言領域のことです。

例えば、変数名の宣言領域とは変数のスコープのことです。

#### ブロックスコープ

ブロックスコープ（*block scope*）とは、ブロック内で宣言された名前が持つスコープのことです。

その名前はブロック内でローカルであり、そのスコープは宣言された場所からブロックの終端までです。

ブロックとは構文定義で*compound-statement*として指定されるもので、関数定義の`{...}`やラムダ式の本体`{...}`はブロックですが、クラス定義の`{...}`や名前空間定義の`{...}`はブロックではありません。

```cpp
namespace N {
  // ブロックスコープではない
}

struct S {
  // ブロックスコープではない
};

export {
  // ブロックスコープではない
}

{
  // ブロックスコープ
}

int main () {
  // ブロックスコープ

  {
    // ブロックスコープ
  }

  try {
    // ブロックスコープ
  } catch(...) {
    // ブロックスコープ
  }

  [] {
    // ブロックスコープ
  };
}
```

ブロックスコープで宣言された変数はローカル変数です。

#### 関数パラメータスコープ

関数パラメータスコープ（*function parameter scope*）とは、関数の仮引数名の持つスコープのことです。

関数パラメータスコープは関数の仮引数が宣言された地点から始まるため、関数のローカル引数よりも少しだけ広いスコープを占めます。

```cpp
void f(int a) {

  {
    int a = 1;
  }

}
```

#### クラススコープ

クラススコープ（*class scope*）とは、クラスで宣言された名前の持つスコープです。

クラススコープはその定義内だけでなく、クラス定義外のメンバ関数定義スコープなども含まれます。

```cpp
struct S {
  // Sのクラススコープ
  int n;

  void f() {
    // Sのクラススコープ
  }

  void g();
};

void S::g() {
  // Sのクラススコープ
}
```

#### ローカルラムダ式

ローカルラムダ式（*local lambda expression*）とは、ラムダ式であって次のいずれかに該当するものです

- 宣言された場所を囲む最も内側のスコープがブロックスコープである
- クラスのデフォルトメンバ初期化子で現れており、囲む最も内側のスコープがそのメンバに対応するクラススコープである

```cpp
struct S {
  int m = []{ return 0; }(); // ローカルラムダ式
};

int N = []{ return 0; }();  // ローカルラムダ式ではない

int main() {
  []{}; // ローカルラムダ式
}
```

ローカルラムダ式のみが、デフォルトキャプチャ（`= &`）と明示的キャプチャ（名前を指定するキャプチャ）を行うことができます。言い換えると、非ローカルなラムダ式では初期化キャプチャのみが行えます。

```cpp
int N = 10;

int M1 = [=] { return 20; }();  // ng
int M2 = [&] { return 20; }();  // ng
int M3 = [N] { return 20; }();  // ng

int M4 = [n=N] { return n*2; }(); // ok

int main() {

  [=] { return 20; };  // ok
  [&] { return 20; };  // ok
  [N] { return 20; };  // ok
}
```

これは、ラムダ式がキャプチャする（必要がある）ものは常にローカルエンティティであることを反映しています。

### odr-usable

odr-usableもまたP0588R1で定義されている言葉ですが、他と比べて重要度が高いので詳しく見てみます。

odr-usableとはまず、ローカルエンティティに対する概念です。

あるローカルエンティティがその宣言領域内で参照される場合

- そのエンティティは`*this`ではない、もしくは
- その場所はクラススコープかラムダ式のものではない関数パラメータスコープに囲われている
    - そのスコープの最も内側のスコープが関数パラメータスコープであるならば、そのスコープは非静的メンバ関数のもの

のどちらかに該当しており（これを前段の条件と呼びます）

そのローカルエンティティが導入される地点とそのローカルエンティティが参照される領域との間に介在している全ての宣言領域について

- 介在する宣言領域はブロックスコープである、もしくは
- 介在する宣言領域はラムダ式の関数パラメータスコープであり
    - そのローカルエンティティを明示的にキャプチャしているか、デフォルトキャプチャを持っていて
    - そのラムダ式のブロックスコープ（本体）もまた、介在する宣言領域である

のどちらかに該当する場合に、そのローカルエンティティはodr-usableとなります（この条件を後段の条件と呼びます）。

介在する宣言領域というのは、ローカルエンティティの導入（宣言/定義）地点から、そのローカルエンティティを参照する地点の間に存在している宣言領域（スコープ）です。介在する（*intervening*）というのは、参照地点から導入地点の間でそのスコープが折り重なっている様を言っているのだと思われます。

そして、ローカルエンティティがodr-usableではない宣言領域でodr-usedとなる場合、プログラムはill-formedです。

規格書より、サンプルコード

```cpp
void f(int n) {
  [] { n = 1; };                // #1 error: n is not odr-usable due to intervening lambda-expression

  struct A {
    void f() { n = 2; }         // #2 error: n is not odr-usable due to intervening function definition scope
  };

  void g(int = n);              // #3 error: n is not odr-usable due to intervening function parameter scope

  [=](int k = n) {};            // #4 error: n is not odr-usable due to being
                                // outside the block scope of the lambda-expression

  [&] { [n]{ return n; }; };    // #5 OK
}
```

この例の場合、ローカルエンティティ`n`は関数`f`の関数パラメータスコープを宣言領域として導入されていて、`*this`ではないので、odr-usableの前段の条件はクリアしており、問題となるのは後段の条件のみです。

1. ローカルエンティティ`n`はラムダ式の関数パラメータスコープに囲われて（介在して）いますが、そのラムダ式はキャプチャに何も指定していない（明示的にも暗黙的にも`n`をキャプチャしていない）ため、この場所で`n`はodr-usableではありません
2. ローカルエンティティ`n`は`A::f()`の関数定義スコープ（ブロックスコープ）と関数パラメータスコープと`A`のクラススコープに囲われています。後2つはブロックスコープではないため（当然ラムダ式の関数パラメータスコープでもないため）、odr-usableではありません
3. ローカルエンティティ`n`は`g()`の関数パラメータスコープに囲われていますが、これも後段2条件のどちらに合致するスコープでもないため、odr-usableではありません
4. ローカルエンティティ`n`はラムダ式の関数パラメータスコープに囲われていて、そのラムダ式はデフォルトキャプチャを持っています。しかし、そのラムダ式の本体のスコープが介在していない（`n`が参照される地点は本体の外側の）ため、odr-usableではありません
5. ローカルエンティティ`n`は2つのラムダ式の関数パラメータスコープに囲われていて、いずれのラムダ式も`n`をキャプチャしており（デフォルトキャプチャ->明示的キャプチャ）、`n`が参照される地点は2つのラムダ式の本体のブロックスコープの内部です。従って、これはodr-usableです。

このサンプルコードをよく見ると、いずれのケースでもこの関数`f()`の外側にローカルエンティティ`n`を参照しているもの（関数やラムダ式、ローカルクラス）を持ち出すことができます。戻り値を`auto`にするとか関数ポインタにするとか、`std::function`を使用するとか・・・

もしこのng例がokだったとすると、それら外に持ち出したものを介してこれらの関数が呼び出し可能となるため、`f()`のローカルエンティティ`n`は`f()`の外側から読み書きされることになります。それはあたかもラムダ式における参照キャプチャが暗黙的に行われているようなもので、当然それは正しい振る舞いでも標準が意図する振る舞いでもないため禁止されなければなりません。ng例はいずれもそれが起こる場合を指していることがわかると思います。

逆に、okの最後の例は外に持ち出した時にそのようなことは起こらないことがわかります。参照キャプチャだけを使用した場合は同様の問題がありますが、少なくともそれはコードに表れているため暗黙的には起こりません（そして、この問題を解決しようとすることはまた別の問題でもあります）。

### ラムダ式が名前をキャプチャする（できる）場所の明確化

まずこの作業は、残りの作業（特にCWG issue由来のもの）を進めるにあたって基礎を固めるためのものだと思われます。


### ラムダ式がクラスメンバ初期化子で使用された時の挙動の明確化
### ラムダ式の構文内でキャプチャした対象に対する`decltype((x))`の振る舞いの明確化

### 構造化束縛をキャプチャできないことを明確化

### 参考文献

- [P0588R1: Simplifying implicit lambda capture](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0588r1.html)
- [CWG Issue 1632](http://wg21.link/cwg1632)
- [CWG Issue 1913](http://wg21.link/cwg1913)
- [CWG Issue 2380](https://cplusplus.github.io/CWG/issues/2380.html)
- [feat: P0588R1で追加されたodr-usableについて記述 by yumetodo・Pull Request #1103・cpprefjp/site](https://github.com/cpprefjp/site/pull/1103)

### メモ


まず、P0588R1のやっていることは4つあって

1. ラムダ式がクラスメンバ初期化子で使用された時の挙動の明確化 (CWG1632)
2. ラムダ式の構文内でキャプチャした対象に対する`decltype((x))`の振る舞いの明確化 (CWG1913)
3. ラムダ式が名前をキャプチャする（できる）場所の明確化
4. 構造化束縛をキャプチャできないことを明確化

だと思います。4はほぼオマケです。

大前提としてラムダ式がキャプチャする必要があるものは常にローカルなものです。ここではそれはローカルエンティティとして指定されており、ほぼローカル変数と`*this`のことです（非静的メンバ変数はローカルエンティティではありません）。

ここでのodr-usableとはおそらく、ある名前をラムダ式がキャプチャできるのかを言うために導入されており、キャプチャするのかどうか不明瞭だったところを弾く（あるいはキャプチャ範囲を狭める）ためにodr-usableではない場合は不適格、としています。これはCWG2380によって事後的にも制限されています。

従って、odr-usableという概念は最初のやっていることの1と3に関わるものです。

その上で、odr-usableとはまず、ローカルエンティティに対する概念であって

あるローカルエンティティがその宣言領域（シャドウイングされないで名前が有効な領域、スコープ）内で参照される場合、そのエンティティもしくはその場所が

- `*this`ではない、もしくは
- クラススコープかラムダ式のものではない関数パラメータスコープに囲われている
    - そのスコープの最も内側のスコープが関数パラメータスコープであるならば、そのスコープは非静的メンバ関数のもの

のどちらかに該当しており

そのローカルエンティティが導入される地点とそのローカルエンティティが参照される領域との間に介在している宣言領域のそれぞれについて

- 介在する宣言領域はブロックスコープである、もしくは
- 介在する宣言領域はラムダ式の関数パラメータスコープであり
    - そのローカルエンティティを明示的にキャプチャしているか、デフォルトキャプチャを持っていて
    - そのラムダ式のブロックスコープ（本体）もまた、介在する宣言領域である

のどちらかに該当する場合に、そのローカルエンティティはodr-usableとなります。

介在する宣言領域というのは、ローカルエンティティの導入（宣言/定義）地点から、そのローカルエンティティ（の名前）を参照する地点の間に存在している宣言領域（主に各種スコープのこと）です。介在する（*intervening*）というのは、参照地点から導入地点の間でそのスコープが重なっている様を言っているのだと思います

前段の条件の2は、P0588R1のやっていることの1に関わるもので、クラスメンバ初期化子と非静的メンバ関数の引数宣言で`this`をキャプチャするラムダ式のハンドリングのためだと思われます（これは今回関係ありません）。

P0588R1の中程で、ラムダ式が明示的にキャプチャするもの（ローカルエンティティ）はodr-usableでなければならないとされています（これも今回関係ありません）。

で、このPRのメインの謎であるサンプルコードが含まれる例を見ていくと

```cpp
void f(int n) {
  [] { n = 1; };                // #1 error: n is not odr-usable due to intervening lambda-expression
  struct A {
    void f() { n = 2; }         // #2 error: n is not odr-usable due to intervening function definition scope
  };
  void g(int = n);              // #3 error: n is not odr-usable due to intervening function parameter scope
  [=](int k = n) {};            // #4 error: n is not odr-usable due to being
                                // outside the block scope of the lambda-expression
  [&] { [n]{ return n; }; };    // #5 OK
}
```

この例の場合、ローカルエンティティ`n`は関数`f`の関数パラメータスコープを宣言領域として導入されていて、`*this`ではないので、odr-usableの前段の条件はクリアしており、問題となるのは後段の条件のみです。

1. ローカルエンティティ`n`はラムダ式の関数パラメータスコープに囲われていますが、そのラムダ式はキャプチャに何も指定していない（明示的にも暗黙的にも`n`をキャプチャしていない）ため、この場所で`n`はodr-usableではありません
2. ローカルエンティティ`n`は`A::f()`の関数定義スコープと`A`のクラススコープに囲われています。いずれもブロックスコープではないため（当然ラムダ式の関数パラメータスコープでもないため）、odr-usableではありません
3. ローカルエンティティ`n`は`g()`の関数パラメータスコープに囲われていますが、これも後段2条件のどちらに合致するスコープでもないため、odr-usableではありません
4. ローカルエンティティ`n`はラムダ式の関数パラメータスコープに囲われていて、そのラムダ式はデフォルトキャプチャを持っています。しかし、そのラムダ式の本体のスコープが介在していない（`n`が参照される地点は本体の外側の）ため、odr-usableではありません
5. ローカルエンティティ`n`は2つのラムダ式の関数パラメータスコープに囲われていて、いずれのラムダ式も`n`をキャプチャしており（デフォルトキャプチャ->明示的キャプチャ）、`n`が参照される地点は2つのラムダ式の本体のブロックスコープの内部です。従って、これはodr-usableです。

多分このサンプルの言いたいことは、関数ローカル変数を関数の外に持ち出すことができうるケースを厳しく制限（コンパイルエラーに）しているよ、ってことだと思います（感想

このPRの疑問に答えるにはこれで良いと思います、間違ってたらすいません・・・

