# ［C++］WG21月次提案文書を眺める（2020年12月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2020 mailing2020-12](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-12)

採択されたものはありません、全部で32本あります。

[:contents]

### [N4878 Working Draft, Standard for Programming Language C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4878.pdf)

C++23ワーキングドラフト第3弾。

### [N4879 Editors' Report - Programming Languages - C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4879.html)

↑の変更点をまとめた文書。

前回会議で採択された提案文書とコア言語/ライブラリのIssue解決が適用されているようです。

### [P0401R5 Providing size feedback in the Allocator interface](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0401r5.html)
### [P0561R5 An RAII Interface for Deferred Reclamation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0561r5.html)

*deferred reclamation*を実現するためのより高レベルAPIを標準ライブラリに追加する提案。

*deferred reclamation*は並行処理における複数スレッド間のデータ共有におけるパターンで、この提案では次のように説明されています。

ある1つのデータ（変数）に対して*reader*と*updater*の2種類のコンポーネントを考えます。*reader*も*updater*も複数存在し、各々別々のスレッドからデータにアクセスします。  
*reader*は読み取りロックを取得してデータを読み取ります。ここでは、そのロックが保持されている間そのデータの生存が保証されます。一方、*updater*はデータを新しく確保された値によって置き換えることでデータを更新します。更新以降にデータを読みだした*reader*は新しい値を読み取りますが、置換前の古いデータを読み取った全ての*reader*がロックを解除するまでは古いデータは破棄されずに生存します。  
*reader*の読み取り操作は他の*reader*や*updater*をブロックせず、*updater*も*reader*をブロックしません。データの更新はメモリ確保を必要とするため高コストですが、読み取りと比較すると非常に稀であることが想定されます。

この*deferred reclamation*の実装には参照カウントやread-copy update(RCU)、ハザードポインタなどの方法があり、そのうちのいくつかは過去にC++に対して提案されています。しかし、それらはより実装そのものに近い低レベルなAPIを提供するものであり、それらの利用例の一つとして*deferred reclamation*が実現できるものでしかありませんでした。

この提案は、そのような低レベルなプリミティブによるものよりも安全性と使いやすさを重視し、かつ効率的な実装を可能とする*deferred reclamation*だけのための高レベルなAPIを提供するものです。

```cpp
#include <snapshot> // 新ヘッダ

// Configクラスによる設定を用いてリクエストを処理するServerクラス
class Server {
public:

  // 設定は随時変更可能
  // 設定変更を調べる別のスレッドから更新される
  void SetConfig(Config new_config) {
    config_.update(std::make_unique<const Config>(std::move(new_config)));
  }

  // リクエストはその時点の設定を使用して処理する
  // 設定の更新タイミングを考慮する必要はない
  void HandleRequest() {
    // リクエスト処理開始時点での設定データの取得
    std::snapshot_ptr<const Config> config = config_.get_snapshot();
    // configはunique_ptr<const Config>のように使用可能
    // configの生存期間内に設定データが更新されたとしても、configが参照するデータに影響はない
  }

private:
  // 共有される設定データ
  // 読み取り、更新、いずれに際しても同期を必要としない（ロックフリー）
  std::snapshot_source<Config> config_;
};
```

この提案のAPIはGoogle社内で実装され使用されているものをベースにしており、そこでは高レベルAPIとRCUによる実装の低レベルなAPIの両方が提供されているようですが、高レベルAPIの利用者が低レベルAPIに比べて多く、その経験こそが*deferred reclamation*のための高レベルAPIを提供する価値を実証していると主張しています。

- [ABA problem - Wikipedia](https://en.wikipedia.org/wiki/ABA_problem)
- [ABA問題 - Wikipedia](https://ja.wikipedia.org/wiki/ABA%E5%95%8F%E9%A1%8C)
- [CON09-C. ロックフリープログラミングの手法を使うときは ABA 問題を避ける - JPCERT/CC](https://www.jpcert.or.jp/sc-rules/c-con09-c.html)
- [P0233R3 Hazard Pointers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0233r3.pdf)
- [P0279R1 Read-Copy Update (RCU) for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0279r1.pdf)
- [P0461R1 Proposed RCU C++ API](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0461r1.pdf)
- [P0561 進行状況](https://github.com/cplusplus/papers/issues/268)

### [P0849R6 auto(x): decay-copy in the language](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0849r6.html)
### [P0901R8 Size feedback in operator new](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0901r8.html)
### [P1030R4 std::filesystem::path_view](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1030r4.pdf)

パス文字列を所有せず参照する`std::filesystem::path_view`の提案。

`std::filesystem::path`クラスはパスを表現するクラスですが、その実態はパス文字列であり、`std::string`と同様にパス文字列を所有しています。したがって、構築や連結などの操作において動的メモリ確保が発生します。  
`std::filesystem::path`に対する操作のいくつかは新しい`path`オブジェクトを返します。そこではメモリ確保と文字列のコピーが発生します。

例えば、ディレクトリを列挙する様な場合には1つのディレクトリの列挙毎に`path`オブジェクトの構築コストがかかる事になり、ディレクトリの数が多い場合にはボトルネックとなります。また、`path`オブジェクトの構築に伴う新規メモリ確保と文字列のコピーはCPUのキャッシュにも優しくありません。Windowsのパス文字列制限260文字に遭遇したことのある人が多くいる様に、パス文字列は数百バイトに達することもあり、パス文字列のコピーの度にキャッシュから有用なデータを削除する事になります。

`std::filesystem::path_view`は`std::filesystem::path`を参照する軽量な*View*です。`std::filesystem::path`と同様のインターフェースを提供し、ローカルプラットフォームのパス文字列に対して`const`/`constexpr`な参照であり、`std::filesystem::path`とほぼ同様に振舞います。これによって、現在`std::filesystem::path`を受け入れている所をリファクタリングをほぼ必要とせずに`std::filesystem::path_view`を受け入れられる様にすることができます。

また、`std::filesystem::path_view`に対するイテレーションで`path_view`を返さない様にするために、`std::filesystem::path_view_component`も追加されます。これは`path_view`とほぼ同じものですが、パス要素のイテレーションや抽出のための一部のメンバ関数を提供していません。  
`path_view`に対するイテレーションで得られた各パス要素をさらにパスとして扱う事は意味がなく、またそれを行う事はバグの可能性が高いため、パス要素である事を表現するための別の型が必要とされたのだと思われます。

この提案はC++23入りを念頭に作業が進められているようです。

- [P1030R4 std::filesystem::path_view](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1030r3.pdf)
- [`std::filesystem::path` - cpprefjp](https://cpprefjp.github.io/reference/filesystem/path.html)
- [P1030 進行状況](https://github.com/cplusplus/papers/issues/406)

### [P1072R6 basic_string::resize_and_overwrite](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1072r6.html)

`std:string`に領域（文字長）を拡張しつつその部分を利用可能にする為のメンバ関数`resize_and_overwrite()`を追加する提案。

例えばパフォーマンスに敏感なところで、`std::string`に文字を流し込んでいく処理を書くとき、おおよそ次の3つのいずれかを選択することになります。

1. 追加の初期化のコストを捧げる : `resize()` ゼロ初期化してから元の文字列をコピー
2. 追加のコピーコストを捧げる : 一時バッファに文字列をためておき、最後にまとめてコピー
3. 追加の簿記コストを捧げる : `reserve()` その後文字列が追加されるたびに、残りの長さが調べられ、null終端される

ここでやりたいことは、断続的に取得される文字列を随時追記していき最後にまとめて1つの文字列として扱う事です。しかし、いずれの方法も何かしら余分なコストがかかってしまい、最適な方法はありませんでした。

問題なのは、この様な場合に`std::string`をバッファとして使おうとしても、その領域をある程度の長さで確保しつつそのままアクセス可能にする、という操作が欠けていることです。

`resize_and_overwrite()`はまさにそのためのもので、指定された長さに領域を拡張しつつ、増やした領域はデフォルト初期化するだけに留める関数です。

```cpp
namespace std {

  template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
  class string {

    template<typename Operation>
    void resize_and_overwrite(size_type n, Operation op);

  };
}
```

`resize_and_overwrite()`は1つ目の引数に変更したい長さをとり、現在の長さがそれよりも短い場合は追加された領域はデフォルト初期化されています。また、2つ目の引数に変更後の領域に対する初期化処理を書く事ができ、変更後の領域の先頭ポインタと1つ目の引数`n`を取る任意の関数を指定できます。`op`は`erase(begin() + op(data(), n), end())`の様に呼び出されるため、`op`は処理後に残しておきたい領域のサイズを返す必要があります。

- [P1072 進行状況](https://github.com/cplusplus/papers/issues/31)

### [P1102R2 Down with ()!](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1102r2.html)
### [P1315R6 secure_clear (update to N2599)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1315r6.html)
### [P1478R6 Byte-wise atomic memcpy](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1478r6.html)
### [P1642R5 Freestanding Library: Easy [utilities], [ranges], and [iterators]](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1642r5.html)
### [P1689R3 Format for describing dependencies of source files](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1689r3.html)
### [P2077R2 Heterogeneous erasure overloads for associative containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2077r2.html)
### [P2136R2 invoke_r](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2136r2.html)
### [P2175R0 Composable cancellation for sender-based async operations](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2175r0.html)
### [P2186R1 Removing Garbage Collection Support](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2186r1.html)
### [P2195R1 Electronic Straw Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2195r1.html)
### [P2213R1 Executors Naming](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2213r1.pdf)
### [P2216R1 std::format improvements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2216r1.html)
### [P2233R3 2020 Fall Library Evolution Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2233r3.html)
### [P2238R0 Core Language Working Group "tentatively ready" issues for the November, 2020 meeting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2238r0.html)
### [P2247R1 2020 Library Evolution Report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2247r1.html)
### [P2248R1 Enabling list-initialization for algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2248r1.html)
### [P2262R0 2020 Fall Library Evolution Poll Outcomes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2262r0.html)
### [P2263R0 A call for a WG21 managed chat service](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2263r0.html)
### [P2264R0 Make assert() macro user friendly for C and C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2264r0.html)
### [P2265R0 Renaming any_invocable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2265r0.pdf)
### [P2268R0 Freestanding Roadmap](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2268r0.html)
### [P2272R0 Safety & Security Review Board](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2272r0.pdf)
### [P2273R0 Making std::unique_ptr constexpr](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2273r0.pdf)
### [P2274R0 C and C++ Compatibility Study Group](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2274r0.pdf)