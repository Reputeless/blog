# ［C++］WG21月次提案文書を眺める（2021年03月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2021 mailing2021-03](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/#mailing2021-03)

全部で36本あり、SG22（C/C++相互互換性に関する研究グループ）のCの提案を除くと32本になります。

[:contents]

## 採択された文書

### [P2313R0 Core Language Working Group "tentatively ready" issues for the February, 2021 meeting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2313r0.html)

2月の会議で採択されたコア言語のIssue解決の一覧。

解決されたIssueは一件だけです。

1. [2470. Multiple array objects providing storage for one object](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#2470)
      - `unsigned char/std::byte`の配列上に別のオブジェクトを構築する時、新しく作成されるオブジェクトにどの配列がストレージを提供したのかが曖昧にならないようにした。

## その他文書

### [N4884 WG21 2021-02 Virtual Meeting Minutes of Meeting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/n4884.pdf)

2021年2月22日（米国時間）に行われた、WG21全体会議の議事録。

CWG/LWG/LEWGの投票の様子などが記載されています。

### [N4885 Working Draft, Standard for Programming Language C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/n4885.pdf)

C++23ワーキングドラフト第4弾。

### [N4886 Editors’ Report - Programming Languages - C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/n4886.html)

↑の変更点をまとめた文書。

2月の会議で採択された提案とコア言語/ライブラリのIssue解決が適用されています。

### [P0448R4 A strstream replacement using span as buffer](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0448r4.pdf)
### [P0958R3 Networking TS changes to support proposed Executors TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0958r3.html)
### [P1018R9 C++ Language Evolution status - pandemic edition - 2021/01–2021/03](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1018r9.html)
### [P1315R7 secure_clear](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1315r7.html)
### [P1425R4 Iterators pair constructors for stack and queue](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1425r4.pdf)
### [P1518R1 Stop overconstraining allocators in container deduction guides](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1518r1.html)

↓

### [P1518R2 Stop overconstraining allocators in container deduction guides](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1518r2.html)

シーケンスコンテナとコンテナアダプタの推論補助を修正し、`pmr`コンテナの初期化を行いやすくする提案。

```cpp
std::pmr::monotonic_buffer_resource mr;
std::pmr::polymorphic_allocator<int> a = &mr;
std::pmr::vector<int> pv(a);

// CTADを使用しない構築、全てok
auto s1 = std::stack<int, std::pmr::vector<int>>(pv);
auto s2 = std::stack<int, std::pmr::vector<int>>(pv, a);
auto s3 = std::stack<int, std::pmr::vector<int>>(pv, &mr);

// CTADを使用する構築
auto ds1 = std::stack(pv);
auto ds2 = std::stack(pv, a);
auto ds3 = std::stack(pv, &mr); // NG!
```
[[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ](https://wandbox.org/permlink/PDyRONeSAYdBB4jD)

※CTAD = Class Template Argument Deduction (クラステンプレートの実引数推定)

`stack`をはじめとするコンテナアダプタのアロケータ引数は、クラステンプレートのテンプレートパラメータの推論に寄与しません。従って、対応するCTADを使用しない構築の時と同様にコンテナ型からの推論を行うのが望ましいはずです。

```cpp
namespace std {

  template<typename Container, typename Allocator>
  class stack;

  // stackの2引数推論補助
  template<class Container, class Allocator>
  stack(Container, Allocator)
    -> stack<typename Container::value_type, Container>;
}
```

このことは何か意図があってのものではなく、単に見落とされただけだと思われるので修正しようとする提案です。

なぜこのようなことが起こるのかというと、コンテナアダプタの推論補助について次のような規定が存在しているためです。

> A deduction guide for a container adaptor shall not participate in overload resolution if any of the following are true: 
> - ...
> - It has an Allocator template parameter and a type that does not qualify as an allocator is deduced for that parameter.
> - ...

[[N4861 container.adaptors.general]/4.4](https://timsong-cpp.github.io/cppwp/n4861/container.adaptors.general#4.4)

アロケータとしての資格のない型がアロケータ型として渡されている場合、そのアロケータ型がテンプレートパラメータの推論に寄与しないとしても、アロケータ型を受け取る推論補助を無効化してしまいます。

アロケータとしての資格がある型というのは実装定義ですが、最小の要件の一つとして、アロケータ型`A`についてメンバ型`A::value_type`が利用可能であることがあります（[[container.requirements.general]/17](https://timsong-cpp.github.io/cppwp/n4861/container.requirements.general#17)）。

```cpp
auto ds3 = std::stack(pv, &mr); // NG!
```

先程の例のここでは、第二引数の`&mr`の型は`std::pmr::monotonic_buffer_resource*`というポインタ型であって、当然メンバ型を持っておらず、アロケータとしての資格がある型ではないため対応する推論補助は考慮されなくなります。ただ一方で、`std::pmr::vector<int>`は`std::pmr::monotonic_buffer_resource*`をアロケータとして利用して構築することができます。

さらに、同様の問題が`std::vector`そのものにも存在しています。

```cpp
std::pmr::monotonic_buffer_resource mr;
std::pmr::polymorphic_allocator<int> a = &mr;
std::pmr::vector<int> pv(a);

// CTADによらない構築
auto v1 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv);
auto v2 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv, a);
auto v3 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv, &mr);

// CTADを利用した構築
auto dv1 = std::vector(pv);
auto dv2 = std::vector(pv, a);
auto dv3 = std::vector(pv, &mr);  // NG!
```

ここでの問題は先ほどとは少し違っていて、暗黙に生成される推論補助を利用する経路で問題が起きています。

推論補助が無い場合、対応するコンストラクタから推論補助を生成してテンプレートパラメータを推論しようとします。ここで対応しているコンストラクタはアロケータを受け取るコピーコンストラクタです。

```cpp
namespace std {

  template<typename T, typename Allocator>
  class vector {

    // アロケータを受け取るコピーコンストラクタ
    vector(const vector<T, Allocator>&, const Allocator&);
  };
}
```

そして、第1引数からは`T = int, Allocator = std::polymorphic_allocator<int>`が導出され、第2引数からは`Allocator = std::pmr::monotonic_buffer_resource*`が導出されます。同一のパラメータに対して衝突する候補が発生しているので、推論は失敗しコンパイルエラーとなります。

この提案ではこれらの解決のために、すべてのコンテナのアロケータを受け取るコンストラクタ引数を`std::type_identity_t`で包むことでアロケータ引数をCTAD推論の対象から外し、またコンテナアダプタのアロケータ型がある場合の推論補助の要件を「コンテナ型が無く、アロケータ型がある場合」のように少し緩和します。


```cpp
namespace std {

  template<typename T, typename Allocator>
  class vector {

    // 現在
    vector(const vector<T, Allocator>&, const Allocator&);

    // この提案
    vector(const vector<T, Allocator>&, const type_identity_t<Allocator>&);
  };
}

void stack() {
  std::pmr::monotonic_buffer_resource mr;
  std::pmr::polymorphic_allocator<int> a = &mr;
  std::pmr::vector<int> pv(a);

  // この提案の後では、共にOK
  auto ds3 = std::stack(pv, &mr);
  auto dv3 = std::vector(pv, &mr);
}
```

`std::vector`の場合は、`std::type_identity_t`によって第2引数の`&mr`から`Allocator`パラメータを推論しなくなるので`Allocator`が一つに定まるようになり、`std::stack`の場合は文言の変更によって`&mr`から推論されるアロケータ型の適格性がチェックされなくなるので既存の推論補助によって正しく推論が行われるようになります。

- [`std::stack` 推論補助 - cpprefjp](https://cpprefjp.github.io/reference/stack/stack/op_deduction_guide.html)
- [`std::type_identity` - cpprefjp](https://cpprefjp.github.io/reference/type_traits/type_identity.html)
- [テンプレート引数として使用するtype_identity_tはなんのため？ - cpprefjp/site - Github](https://github.com/cpprefjp/site/issues/829)
- [P1518 進行状況](https://github.com/cplusplus/papers/issues/381)

### [P1875R2  Transactional Memory Lite Support in C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1875r2.pdf)
### [P2025R2 Guaranteed copy elision for return variables](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2025r2.html)
### [P2041R1 template = delete](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2041r1.html)
### [P2066R6 Suggested draft TS for C++ Extensions for Minimal Transactional Memory](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2066r6.html)
### [P2093R5 Formatted output](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2093r5.html)
### [P2210R2 Superior String Splitting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2210r2.html)
### [P2242R2 Non-literal variables (and labels and gotos) in constexpr functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2242r2.html)
### [P2266R1 Simpler implicit move](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2266r1.html)
### [P2299R0 `mdspan` and CTAD](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2299r0.html)
### [P2314R1 Character sets and encodings](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2314r1.html)
### [P2322R1 ranges::fold](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2322r1.html)
### [P2325R1 Views should not be required to be default constructible](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r1.html)
### [P2328R0 join_view should join all views of ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2328r0.html)
### [P2330R0 WG21 2021-02 Virtual Meeting Record of Discussion ](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2330r0.pdf)
### [P2332R0 Establishing std::hive as replacement name for the proposed std::colony container](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2332r0.html)
### [P2333R0 2021 Winter Library Evolution Poll Outcomes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2333r0.html)
### [P2334R0 Add support for preprocessing directives elifdef and elifndef](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2334r0.pdf)
### [P2338R0 Freestanding Library: Character primitives and the C library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2338r0.html)
### [P2339R0 Contract violation handlers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2339r0.html)
### [P2340R0 Clarifying the status of the ‘C headers’](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2340r0.html)
### [P2400R0 Library Evolution Report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2400r0.html)