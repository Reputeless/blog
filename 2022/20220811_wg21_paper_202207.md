# ［C++］WG21月次提案文書を眺める（2022年07月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2022-07](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/#mailing2022-07)

全部で47本あります。

[:contents]

### [P0009R18 MDSPAN](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0009r18.html)
### [P1018R17 C++ Language Evolution status - pandemic edition - 2022/06-2022/07](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1018r17.html)
### [P1083R6 Move resource_adaptor from Library TS to the C++ WP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1083r6.pdf)
### [P1255R8 A view of 0 or 1 elements: views::maybe](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1255r8.pdf)
### [P1642R11 Freestanding Library: Easy [utilities], [ranges], and [iterators]](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1642r11.html)
### [P1684R3 mdarray: An Owning Multidimensional Array Analog of mdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1684r3.html)
### [P1899R3 stride_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1899r3.html)
### [P1967R8 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1967r8.html)
### [P2047R3 An allocator-aware optional type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2047r3.html)
### [P2079R3 System execution context](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2079r3.html)
### [P2165R4 Compatibility between tuple, pair and tuple-like objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
### [P2248R5 Enabling list-initialization for algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2248r5.html)
### [P2295R6 Support for UTF-8 as a portable source file encoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2295r6.pdf)
### [P2361R5 Unevaluated strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2361r5.pdf)
### [P2374R4 views::cartesian_product](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2374r4.html)
### [P2404R3 Move-only types for equality_comparable_with, totally_ordered_with, and three_way_comparable_with](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2404r3.pdf)
### [P2417R2 A more constexpr bitset](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2417r2.pdf)
### [P2419R2 Clarify handling of encodings in localized formatting of chrono types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2419r2.html)
### [P2460R2 Relax requirements on wchar_t to match existing practices](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2460r2.pdf)
### [P2474R2 views::repeat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2474r2.html)
### [P2481R1 Forwarding reference to specific type/template](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2481r1.html)
### [P2494R2 Relaxing range adaptors to allow for move only types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2494r2.html)
### [P2513R4 char8_t Compatibility and Portability Fix](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2513r4.html)
### [P2547R1 Language support for customisable functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2547r1.html)
### [P2548R0 `copyable_function`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2548r0.pdf)

`std::move_only_function`に対して、コピー可能な*Callable*ラッパである`copyable_function`の提案。

C++23で導入された`std::move_only_function`は、その関数シグネチャに`const`/参照修飾と`noexcept`を指定することができ、呼び出し時に自信の`const`性と値カテゴリを保持する*Callable*オブジェクトまで伝播させたうえで呼び出しを行うことができます。これによって、`std::move_only_function`オブジェクトの`const`有無と右辺値であるかの状態と、保持する*Callbale*オブジェクトの呼び出し環境を一致させることができます。

一方`std::function`にはそのようなサポートはなく、そのために`const`修飾のミスマッチバグ等の設計上の問題がいくつか指摘されていました。

- `const`修飾を正しく扱えない
- ムーブのみ可能な（コピーできない）*Callable*オブジェクトを保持できない
- 左辺値から呼び出す*Callable*オブジェクトしか保持できない（参照修飾を正しく扱えない）

`std::move_only_function`は`std::fucntion`の持つこれらの問題と軽微ないくつかの問題（RTTIへの依存、呼び出し時の空チェック）を解決するために導入されましたが、名前が示すとおりに`std::move_only_function`のオブジェクトはムーブしかできません（ムーブしかできない*Callable*だけを保持可能なわけではありません）。

コピー可能な`std::move_only_function`が欲しい場合は`std::function`を使用するしかないのですが、`std::function`には上記のような問題があります。また、後方互換のためには、`std::function`を`std::move_only_function`のような設計に変更することもできません。

この提案は、コピー可能かつ現在の`std::function`の問題を解決した、`std::move_only_function`のコピー可能なバージョンである`std::copyable_function`を標準ライブラリに追加する提案です。

`std::move_only_function`が保持する*Callable*は`copyable`であっても単に`movable`でしかなくても大丈夫ですが、`std::copyable_function`は`copyable`な*Callable*しか保持できません。それ以外のところでは、`std::move_only_function`にコピーコンストラクタとコピー代入演算子を追加しただけです。

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
auto lambda{[&]() /*const*/ { … }};

function<void(void)> func{lambda};  // ✔
const auto & ref{func};

func(); // ✔
ref();  // ✔
```

</td>
<td valign="top">

```cpp
auto lambda{[&]() /*const*/ { … }};

copyable_function<void(void)> func0{lambda};    // ✔
const auto & ref0{func0};

func0();  // ✔
ref0();   // ❌ operator() is NOT const! 

copyable_function<void(void) const> func1{lambda};  // ✔
const auto & ref1{func1};

func1();  // ✔
ref1();   // ✔ operator() is const! 
```

</pre>
</td>
</tr>
</table>

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
auto lambda{[&]() mutable { … }};

function<void(void)> func{lambda};  // ✔
const auto & ref{func};

func(); // ✔
ref();  // ⁉✔ operator() is const! 
        //     this is the infamous constness-bug
```

</td>
<td valign="top">

```cpp
auto lambda{[&]() mutable { … }};

copyable_function<void(void)> func{lambda}; // ✔
const auto & ref{func};

func(); // ✔
ref();  // ❌ operator() is NOT const! 

copyable_function<void(void) const> tmp{lambda};  // ❌
```

</pre>
</td>
</tr>
</table>

- [N4159 `std::functionand` Beyond](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4159.pdf)
- [MFHava/P2548 - Github](https://github.com/MFHava/P2548)
- [P2548 進行状況](https://github.com/cplusplus/papers/issues/1275)

### [P2549R1 std::unexpected should have error() as member accessor](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2549r1.html)
### [P2561R0 operator??](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2561r0.html)
### [P2579R0 Mitigation strategies for P2036 “Changing scope for lambda trailing-return-type”](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2579r0.pdf)
### [P2585R1 Improving default container formatting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2585r1.html)
### [P2587R1 to_string or not to_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2587r1.html)
### [P2590R2 Explicit lifetime management](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2590r2.pdf)
### [P2592R1 Hashing support for std::chrono value classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2592r1.html)
### [P2601R1 Make redundant empty angle brackets optional](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2601r1.html)
### [P2602R1 Poison Pills are Too Toxic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2602r1.html)
### [P2609R1 Relaxing Ranges Just A Smidge](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2609r1.html)
### [P2610R0 2022-07 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2610r0.html)
### [P2613R1 Add the missing `empty` to `mdspan`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2613r1.html)
### [P2614R0 Deprecate numeric_limits::has_denorm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2614r0.pdf)
### [P2615R0 Meaningful exports](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2615r0.html)
### [P2616R0 Making std::atomic notification/wait operations usable in more situations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2616r0.html)
### [P2617R0 Responses to NB comments on DTS 12907 "Extensions to C++ for Transactional Memory Version 2"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2617r0.html)
### [P2618R0 C++ Standard Library Issues to be moved in Virtual Plenary, Jul. 2022](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2618r0.html)
### [P2620R0 Lifting artificial restriction on universal character names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2620r0.pdf)
### [P2621R0 UB? In my Lexer?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2621r0.pdf)
### [P2622R0 Core Language Working Group "ready" Issues for the July, 2022 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2622r0.html)
### [P2623R0 implicit constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2623r0.html)
### [P2624R0 Make operations on bools more portable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2624r0.html)