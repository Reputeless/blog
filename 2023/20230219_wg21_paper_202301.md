# ［C++］WG21月次提案文書を眺める（2023年01月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-01](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-01)

SG22のWG14からのものを除いて、全部で84本あります（R0が36本、R1以上で見てないのが4本）

[:contents]

### [N4928 Working Draft, Standard for Programming Language C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4928.pdf)

C++23のワーキングドラフト第8弾。

### [N4929 Editors' Report - Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4929.html)

↑の変更点をまとめた文書。

11月のKona会議で採択された提案とコア言語/ライブラリのIssue解決が適用されています。

### [N4933 WG21 November 2022 Kona Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4933.pdf)

2022年11月7-12日にハワイのKonaで行われた、WG21全体会議の議事録。

開催期間中の各グループの活動報告や、CWG/LWG/LEWGの投票の様子などが記載されています。

### [N4934 2023 WG21 admin telecon meetings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4934.pdf)

2023年（今年）のWG21管理者ミーティングの予定表。

### [N4935 2023 Varna Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4935.pdf)

2023年6月にブルガリアのヴェルナで開催される予定のWG21全体会議のインフォーメーション。

主に開催場所やその注意点などが記載されています。

### [N4936 2023-11 Kona meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4936.pdf)

2023年11月にハワイのKonaで開催される予定のWG21全体会議のインフォーメーション。

同上。

### [N4937 Programming Languages — C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n4937.pdf)

次期標準ライブラリ機能候補の実装経験を得るためのTSである、Library Fundamental TS v3のFDIS。

### [N4939 Working Draft, C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4939.html)

次期標準ライブラリ機能候補の実装経験を得るためのTSである、Library Fundamental TS v3のドラフト文書。

おそらく内容はN4937と同一です。

### [N4938 Editor's Report: C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4938.html)

↑の変更点を記した文書。

この版での変更は、typoの修正などです。

### [P0260R5 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0260r5.html)

標準ライブラリに並行キューを追加するための設計を練る提案。

キューはシステムコンポーネント間のデータのやり取りの方法を提供する基礎的なものです。現在のC++標準ライブラリにも`std::deque`などが用意されていますが、それらは全てシーケンシャルなデータ構造であり、その要素アクセスとキューの操作を並行に行うことができません。そのため、並行キューを導入するためには、それらとは別のものが必要となります。

さらに、並行性の要求はパフォーマンスとそのセマンティクスに新たな評価軸を追加し、並行キューにおいては競合しない操作のコスト、競合する操作のコスト、要素の順序保証をトレードオフにする必要があり、これによって既存のキューよりもセマンティクスが弱くなります。

そのような対立軸にはたとえば

- 固定長 vs 可変長
- ブロッキング vs 上書き
- シングルエンド vs マルチエンド
- 厳密なFIFOによる順序 vs 優先度による順序

などがあります。

この提案は今の所、そのような並行キューのインターフェースのベースとなる概念的なインターフェースの要件を定義しています。

**基本操作**

並行キューイングの問題に対する本質的な解決策は、参照ベースではなく値ベースの操作へ以降することです。そのために次の2種類の基本操作を定義しています

```cpp
// 要素をキューイングする
void queue::push(const Element&);
void queue::push(Element&&);

// 要素をキューから取り出す
// 要素はコピーではなくムーブされる
void queue::pop(Element&);
```

ここでの`queue`は特定のキューを示すものではなく、コンセプト的なプレースホルダです。

これらの操作はまたブロッキングを伴う操作でもあり、キューが満杯/空の場合に待機し、操作の競合を回避するためにブロックされる可能性があります。

**即時操作**

満杯/空のキューで待機すると操作が完了するまでにしばらく時間を要する可能性があり、機会費用がかかります。この待ち時間を回避することで、満杯/空のキューで操作の完了を待機する代わりに他の作業を行うことができます。そのために、次の2種類の即時操作（待機しない操作）を定義しています

```cpp
// キューが満杯/クローズ状態の場合はその状態を返し、そうではない場合にキューイングしqueue_op_status::successを返す
queue_op_status queue::try_push(const Element&);

// キューが満杯/クローズ状態の場合はその状態を返し、第一引数を第二引数へムーブする
// そうではない場合にキューイングしqueue_op_status::successを返す
queue_op_status queue::try_push(Element&&, Element&);

// キューが空ならqueue_op_status::emptyを返し
// そうではない場合に要素をキューから取り出し（コピーではなくムーブされる）、queue_op_status::successを返す
queue_op_status queue::try_pop(Element&);
```

`queue_op_status`は次のようなスコープ付き列挙型です

```cpp
enum class queue_op_status { 
  success, 
  empty,
  full,
  closed
};
```

これらの操作はキューが満杯/空の場合にブロックしませんが、操作の競合を回避するためにブロックされる可能性があります。

**キューのクローズ**

通信にキューを使用しているスレッドでは、キューが不要になった場合にそのキューを使用している他のスレッドにそのことを通知するメカニズムが必要になる場合があります。典型的には、それはキューとは別の条件変数やアトミック変数などの帯域外信号が使用されます。ただし、このアプローチでは、そのキューで待機している他のスレッドを起床しなければならない問題があり、そのためにキューの満杯/空のブロッキングに使用される条件変数にアクセスする必要が出てくるなど、インターフェースの複雑さと危険性を増大させます。また、ミューテックスやアトミック変数を使用することでパフォーマンスに影響が及ぶ可能性もあります。

そのため、この提案ではそのようなシグナルをキュー自体でサポートすることを選択しており、これによってコーディングがかなり簡素化されます。

このシグナルのために、キューはクローズ（`close()`）を行うことができます。あるスレッドでキューがクローズされると新しい要素をそのキューに挿入（`push`）することができなくなります。クローズ済キューに対する挿入操作は`queue_op_status::closed`を返すか例外としてスローします。キューに存在する要素は取り出し（`pop`）が可能ですが、キューが空でクローズされている場合、取り出し操作は`queue_op_status::closed`を返すか例外としてスローします。

```cpp
// キューを閉じる
void queue::close() noexcept;

// キューが閉じられていればtrueを返す
bool queue::is_closed() const noexcept;

// キューが閉じられていればqueue_op_status::closedを返す
// そうでないならば、要素をキューイングする
queue_op_status queue::wait_push(const Element&);
queue_op_status queue::wait_push(Element&&);

// キューが空で閉じられていればqueue_op_status::closedを返す
// そうではなく、キューが空ならばqueue_op_status::emptyを返す
// それ以外の場合、キューから要素を取り出しqueue_op_status::successを返す
queue_op_status queue::wait_pop(Element&);
```

`wait_`とある`push/pop`操作は、キューが閉じられている場合に例外を回避するためのインターフェースです。この操作はキューが閉じられておらず満杯/空の場合に待機し、操作の競合を回避するためにブロックされる可能性があります。

クローズ後のキューを再開したいユースケースがあり、この提案ではそのためのインターフェースも定義しています

```cpp
// キューをオープンする
void queue::open();
```

キューを再開する機能が困難になる実装は現在把握されてはいませんが、存在する可能性があります。また、キューの再開は通常キューが閉じていて空の場合にのみ呼び出すことができ、これによってクリーンな動機ポイントを提供することができます。ただし、空でないキューで`open()`を呼び出すことは可能です。

`is_closed()`が`false`を返す場合でも、他のスレッドがキューを同時にクローズする可能性があるため、後続の操作でキューが閉じられている保証はありません。

オープン操作が利用できない場合、キューが閉じられるとキューは閉じたままになるという保証があります。したがってその場合、プログラマが他のすべてのスレッドがキューを閉じないように細心の注意を払わない限りは、`is_closed()`の戻り値は`true`のみが意味を持ちます。

キューの再開にはこれらの問題があるため、この提案ではこのインターフェースを提案してはいません。

**要素型の要件**

上記の操作のためには、要素型にはコピー/ムーブコンストラクタ、コピー/ムーブ代入演算子、及びデストラクタが必要になります。

コンストラクタと代入演算子は例外を投げる可能性がありますが、後続の操作のためにはオブジェクトを有効な状態のままにしておく必要があります。

**例外ハンドリング**

基本操作の2つの操作（`push()/pop()`）はキューの状態によって例外を投げる可能性があります。その例外オブジェクトは`std::exception`の派生クラスであり、`queue_op_state`の値を含んでいる必要があります。

他のスレッドがキューの状態を監視している時に変更を透過的に元に戻すことができないため、並行キューは要素型がスローした例外の影響を完全に隠すことはできません。そのような例外は要素型のコピー/ムーブコンストラクタ及びコピー/ムーブ代入演算子から投げられる可能性があります。

それ以外の場合、キューは、メモリ確保、キューテックス、条件変数から例外を再スローする可能性があります。

要素のコピー/ムーブが例外を投げる可能性がある場合、一部のキュー操作には追加の動作が定義されています

- 構築時は例外を再スローし、構築しようとしていた要素を破棄する
- 挿入操作は再スローし、キューの状態は変化しない
- 取り出し操作は再スローし、取り出そうとしていた要素はキューから取り除かれる（要素は実質的に失われる）


この提案ではこれらの要件に沿った具体的なキューを提案してはいませんが、[P1958R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1958r0.html)でその一つである`buffer_queue`が提案されている他、[google-concurrency-library](https://github.com/alasdairmackintosh/google-concurrency-library)にこの提案の初期のインターフェースをベースとした実装があります。

この提案は、フィードバックを得るためにConcurrency TS v2入りを目指しています。

- [P0260 進行状況](https://github.com/cplusplus/papers/issues/99)

### [P0342R1 What does "current time" mean?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0342r1.pdf)

`<chrono>`の時計型の`now()`が最適化によって並べ替えられないようにする提案。

`<chrono>`の時計型（`steady_clock`など）はその静的メンバ関数`now()`によってその時計の示す現在の時刻（*current point in time*）を取得することができます。しかし、この現在の時刻が何を指すのか不明瞭であり、必ずしもコードに記述した実行地点での現在時刻を取得しないことがあります。

提案より、サンプルコード

```cpp
#include <chrono>
#include <atomic>
#include <iostream>

std::size_t fib(std::size_t n) {
  if (n == 0)
    return n;
  if (n == 1)
    return 1;
  return fib(n - 1) + fib(n - 2);
}
int const which{42};

int main() {
  // fib()の実行にかかる時間を計測する
  auto start = std::chrono::high_resolution_clock::now(); // #1
  auto result = fib(which);                               // #2
  auto end = std::chrono::high_resolution_clock::now();   // #3

  std::cout << "fib(" << which << ") is " << result << std::endl;
  std::cout << "Elapsed time is "
            << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()
            << "ms" << endl;

  return 0;
}
```

[godbolt](https://godbolt.org/z/ofvfd7WbK)

このようなコードはかなり基本的なものですが、少なくともMSVCは最適化を有効にすると`#2 #3`の順番を入れ替えて、`#1 -> #3 -> #2`のように実行してしまい、結果0msが出力されます。このような最適化は標準の範囲内で許可されているため、この最適化自体は合法です。

これはシングルスレッドプログラムにおける実行順序の並べ替えであるため、標準の範囲内で回避するのは難しいようです。ファイルを分割することで回避できるようですが、それもプログラム全体の最適化やリンク時最適化を考慮すると確実なものとは言えません。また、この問題はコンパイラによっては起こらないかもしれず、回避策を含めたこのようなコードの移植性を損ねています。

プログラム中で現在のタイムスタンプを取得するという単純な処理にすらこのような罠が潜んでいて回避が難しいというのは大きな問題であり、この提案はその改善のためのものです。

この提案ではこの問題の解決のためにいくつかの方法を挙げています

- 標準を変更はしないが、ガイダンスを充実させる
    - SG20で配布可能なガイダンスを作成するだけでも教育者には大きな助けになる
- 編集上の変更を加える
    - ↑のガイダンスを標準に記述する
- `now()`の並べ替えを禁止する
    - このアプローチはR0の議論において実装可能性について懸念があった
- シングルスレッドフェンスを導入する
    - この問題が発生するのは時刻取得に止まらないと考えられるため、このユースケースに応えるためにより一般的なソリューションを提供する
    - このアプローチはR0で提案していたものだったが、実装可能性について懸念があった

ただし、現在のところどれかを選択してはいません。

この提案のR0ではこの問題の解決のためのシングルスレッドフェンスを提案していましたが、2016年にレビューされた際にはその実装可能性の懸念などから受け入れられず、提案の追求はストップしていました。しかし、2022年のKona会議におけるSG1のミーティング中にこの問題が取り上げられ、この提案の改訂版が望まれたことで、とりあえず問題を整理したR1（このリビジョン）が再度提出されました。

著者の方やSG1のメンバは、現在の時刻の取得という単純なタスクでプログラマが直面するこの問題は、現状の改善をより広く検討するのに十分に深刻だと考えているようです。

- [C++標準化委員会の文書: P0340R0-P0349R0 - 本の虫](https://ezoeryou.github.io/blog/article/2016-08-09-cpp-P0340R0-P0349R0.html#:~:text=P0342R0%3A%20Timing%20barriers)
- [P0342 進行状況](https://github.com/cplusplus/papers/issues/1417)

### [P0792R12 function_ref: a non-owning reference to a Callable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0792r12.html)

*Callable*を所有しない`std::function`である`std::function_ref`の提案。

以前の記事を参照

- [P0792R6 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P0792R6-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R8 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年02月）](https://onihusube.hatenablog.com/entry/2022/03/19/224729#P0792R8-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R9 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P0792R9-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R10 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P0792R10-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R11 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年09月）](https://onihusube.hatenablog.com/entry/2022/10/09/021557#P0792R11-function_ref-a-non-owning-reference-to-a-Callable)

このリビジョンでの変更は、LWGのフィードバックによる文言の調整と、メンバ変数ポインタを誤って処理していた推論補助の修正です。

この提案は次のリビジョン（未公開）がLWGのレビューをパスして、次の全体会議にかけられることが決まっています（C++26ターゲットです）。

- [P0792 進行状況](https://github.com/cplusplus/papers/issues/256)

### [P1383R1 More constexpr for `<cmath>` and `<complex>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1383r1.pdf)

`<cmath>`と`<complex>`の数学関数を`constexpr`にする提案。

`<cmath>`の数学関数をはじめとする浮動小数点数を扱うものを`constexpr`対応させるにあたって問題となっているのは、同じ浮動小数点数値に対するある関数の結果がコンパイラの設定やプラットフォーム、実行タイミング等のコンテキストによって等しい必要があるのか？という点です。明らかにそうなって欲しいのですが、浮動小数点数の特性などの事情によってそれは実際には困難であり、そうするとそれら関数の実行結果についてどのように規定するのか、あるいはどのような保証を与えるのか？が問題となります。

C++23におけるP0533R9による`<cmath>`等の関数の`constexpr`対応にあたってもそのような問題の議論を回避するために、四則演算（`+ - * /`）よりも（その事情の下では）複雑でないとみなされる関数のみが`constexpr`対応されました。

この提案は次のような設計指針によって、`<cmath>`と`<complex>`にあるほぼすべての数学関数を`constexpr`対応させようとしています

1. 数学関数の実行結果が実行時とコンパイル時で異なることを許容する
2. 数学関数の定数実行が異なるプラットフォームで異なることを許容する
3. `<cmath>`内の既存関数に正確な動作を義務付けるのではなく、QoIの定量化を奨励することが望ましい

そもそも実行時における現在の`<cmath>`の数学関数や浮動小数点演算は、異なるコンパイラやプラットフォームの間、あるいは異なるコンパイラオプション（`-ffast-math`など）の間で結果が一致しないことはない間許容されています。また、定数式では数学関数を呼び出さない浮動小数点演算は可能であり、規格も利用者もその結果の実行時とコンパイル時の差異を許容してきています（実行時における丸めモードの変更やFMAの利用など）。

`costexpr`な数学関数にのみ過剰な正確性や結果の一貫性を要求することは、実装の困難さを高めるとともにそれそのものが実行時とコンパイル時の出力差の原因となります。そのためこの提案では、許容されている現在の実行時の振る舞いをベースとした設計指針によって数学関数を`constexpr`対応させる方針を押しています。

- [P1383 進行状況](https://github.com/cplusplus/papers/issues/168)

### [P1673R11 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r11.html)

標準ライブラリに、BLASをベースとした密行列のための線形代数ライブラリを追加する提案。

以前の記事を参照

- [P1673R3 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P1673R3-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R4 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P1673R4-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R5 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P1673R5-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R6 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P1673R6-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R7 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2022年04月）](https://onihusube.hatenablog.com/entry/2022/05/08/195618#P1673R7-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R8 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P1673R8-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R9 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1673R9-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R10 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P1673R10-A-free-function-linear-algebra-interface-based-on-the-BLAS)

このリビジョンでの変更は

- `in_{vector,matrix,object}*_t`がユニークなレイアウトを持つという要件を削除
- `in_{vector,matrix,object}*_t`に対する名前付き要件を説明専用コンセプトに変更
- 対称なHermitian updateアルゴリズムを制約するために、説明専用コンセプト`possibly-packed-inout-matrix`を追加
- 新しい説明専用コンセプトと重複する制約を削除
- 全てのアルゴリズムの制約から、`mdspan`がユニークなレイアウトを持つという制約を削除
- ベクトル/行列オブジェクトのテンプレートパラメータが`mdspan`への`const`左辺値参照もしくは非`const`右辺値参照を推論する可能性があるという要件を削除
- 両方のベクタ型を含めるように`dot`の要件を修正
- `mdspan`の`element_type`エイリアスの代わりに`value_type`エイリアスを使用するように、いくつかの関数の規定を修正
- `matrix_vector_product`のテンプレートパラメータ順序と仮引数の順序を合わせた
- LEWGのガイダンスに従って、効果と制約を数学的に記述するようにした
- `matrix_one_norm`の事前条件（要素の`abs()`の結果が`T`に変換可能であること）を制約に変更
- `vector_abs_sum`の事前条件（`init + abs(v[i])`の結果が`T`に変換可能であること）を制約に変更
- Bikeshedの代わりにPandocを使用するようにした
- `conjugated-scalar`の`conjugatable<ReferenceValue>`を適格要件ではなく制約に変更
- “If an algorithm in [linalg.algs] accesses the elements of an out-vector, out-matrix, or out-object, it will do so in write-only fashion.”という文言を削除
- P2642の内容をR2にアップデート
- 全てのタグ型の`default`実装デフォルトコンストラクタに`explicit`を付加
- `givens_rotation_setup`を出力パラメータではなく新しい`givens_rotation_setup_result`構造体の値を返すように変更

などです。

- [P1673 進行状況](https://github.com/cplusplus/papers/issues/557)

### [P1684R4 mdarray: An Owning Multidimensional Array Analog of mdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1684r4.html)
### [P1883R2 `file_handle` and `mapped_file_handle`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1883r2.pdf)

ファイルI/Oライブラリの提案。

この提案のファイルI/Oライブラリは[llfio](https://github.com/ned14/llfio/)というライブラリをベースとしたもので、llfioは現代の高性能ストレージに対するI/Oで理論性能値に迫るパフォーマンスを引き出すことができることを謳っています。また、llfioはPOSIX（Linux/Mac等）とWindowsにおけるI/Oを抽象化して扱うクロスプラットフォームなライブラリでもあります。

この提案では、そのllfioから`file_handle`と`mapped_file_handle`を中心としたファイル毎のI/O機能を標準ライブラリへ導入しようとしています（llfio自体はネットワークI/Oやファイルシステム操作などより広い機能を持っています）。

llfioではファイルやファイルシステムの要素などをハンドルという次のような7階層の階層構造によって抽象化しています

1. `handle`
    - オープン/クローズ、パスの取得、クローン、追加のみのset/unset、キャッシュの変更、などの特性を提供する
2. `fs_handle`
    - inode番号を持つ`handle`
3. `path_handle`
    - ファイルシステムの一部分への競合の無いアンカー
4. `directory_handle`
    - ファイルシステムを列挙する
5. `io_handle`
    - 追加で、同期スキャッタ/ギャザーI/O、バイト範囲ロックを提供する
6. `file_handle`
    - 追加で、ファイルのオープン/クローズ、最大サイズの設定/取得を提供する
7. `mapped_file_handle `
    - 追加で、メモリマップされたファイルに対する低レインテンシのスキャッタ/ギャザーI/Oを提供する

この階層構造はこのままクラスの継承関係に対応しています。

`file_handle`と`mapped_file_handle`は6,7階層に位置するもので、ファイルという対象に対する実際のI/O操作を提供します。主役がこの2つであるだけで、下の5階層のクラスも一緒に導入されます。

提案文書より、スキャッタ書き込みのサンプルコード

```cpp
// 上記階層構造によって、file_handleでもmapped_file_handleでも使用可能
void write_and_close(file_handle &&fh) {
  // ファイルの最大サイズを設定
  // mapped_file_handleはファイルサイズが固定のために必要
  fh.truncate(12).value();

  // 書き込むデータのバッファ
  const char a[] = "hel";
  const char b[] = "l";
  const char c[] = "lo w";
  const char d[] = "orld";

  // ギャザー書き込み（バラバラのバッファからのスキャッタ書き込み）を行う
  // file_handleの場合 : max_buffers() >= 4ならばこの書き込みは並行する読み取りに対してアトミック
  //                    そのような読み取りは何も読まないか、完了した結果を読むかのどちらか（破損はない）
  // mapped_file_handleの場合 : 書き込みに伴う同期は行われず、読み書きは並行するリーダ/ライターに対して競合するため、追加の同期が必要になる
  fh.write(
    // ギャザーリストの指定
    { // 入力はstd::byteで行われるためキャストが必要
      { reinterpret_cast<const byte*>(a), sizeof(a) - 1 },
      { reinterpret_cast<const byte*>(b), sizeof(b) - 1 },
      { reinterpret_cast<const byte*>(c), sizeof(c) - 1 },
      { reinterpret_cast<const byte*>(d), sizeof(d) - 1 },
    }
    // デフォルトのタイムアウトは無限
  ).value(); // 失敗した場合、filesystem_error例外をスローする

  // ファイルのクローズに失敗する場合に備えて、明示的にファイルをクローズする
  fh.close().value();
}


// 書き込み用にファイルをオープン
// 必要に応じてファイルを作成、キャッシュをスルーして書き込み
write_and_close(file(
  {},                                       // 子要素（↓）を探索するベースディレクトリのpath_handle（この場合はカレントディレクトリを意味する）
  "hello",                                  // ベースディレクトリ（↑）からの相対的なパスフラグメントへのpath_view（ファイル名）
  file_handle::mode::write,                 // 書き込みアクセスを要求
  file_handle::creation::if_needed,         // 必要ならファイルを新規作成
  file_handle::caching::reads_and_metadata  // ストレージに到達するまで書き込み（デフォルトはnone
).value());                                 // 失敗した場合、filesystem_error例外をスローする


const path_handle& somewhere;

// メモリマップを使用して既存ファイルを更新する例
write_and_close(mapped_file(
  somewhere,                            // 子要素（↓）を探索するベースディレクトリのpath_handle
  "hello2",                             // ベースディレクトリ（↑）からの相対的なパスフラグメントへのpath_view（ファイル名）
  file_handle::mode::write,             // 書き込みアクセスを要求
  file_handle::creation::open_existing  // 既存ファイルを開くのみ、ファイルがない場合に失敗する
                                        // デフォルトは全てキャッシュを使用する
).value());                             // 失敗した場合、filesystem_error例外をスローする
```

`mapped_file_handle`はメモリにマップされたファイルの抽象であり、ファイル書き込みに伴ってファイルサイズの自動延長が行われないなどの制約があります。一方で、`file_handle`はもっと広いファイルの抽象であり、通常ファイルの自動延長機能を持ちます。

各I/O操作やハンドル作成の結果で`value()`を呼んでいるのは、それぞれの操作が`result<T>`型を返しており、その成功結果を取得するためです。`result<T>`はエラー型が`std::error`（[P1028R4](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1028r4.pdf)）に固定された`std::expected`のような型で、同じようなインターフェースを持っています。

`file_handle`と`mapped_file_handle`の`file`とはUNIXにおけるファイルという概念のようなもので、必ずしもファイルシステム上のファイルだけを意味するのではなく、ファイルとして扱えるもの全体を指しています。例えば、ASIOがソケットベースのI/Oライブラリであるとすると、このライブラリはファイルベースのI/Oライブラリです。

このライブラリは次のような設計原則を謳っています

1. デフォルトパラメータや設定はパフォーマンスよりもセキュリティを重視する。
    - これはいつでも明示的にアプトアウトできる
2. 実行されるI/Oの種別に関係なく、基礎となるシステムコールのラインタイムオーバーヘッドを超える（ライブラリの）統計的に計測可能なラインタイムオーバーヘッドはない
3. ホストOSの並行I/Oに関する保証を可能な限りそのまま提供する
4. POSIXのrace free filesystem path lookup拡張を中心として設計されている
5. システム内でのどこでも、C++I/Oと最終ストレージデバイスの間の全てのメモリコピーを常に回避可能である必要がある
6. カーネルI/Oキャッシュ制御および仮想メモリ制御機能を提供する
7. ファイルシステムの競合を検知して回避する機能を提供し、少なくともホストOSが許可する範囲で第三者によるファイルシステム同時変更によって導入される競合が完全にないコードを記述可能にする

筆者の方（llfio開発者の方）によれば、llfioの中で`file_handle`と`mapped_file_handle`周りのAPIおよびABIは2020年ごろから安定しており、市場取引のデータ処理において数年間の使用実績があり、現在も1TB/日のデータを処理している、とのことです。

この提案は現在のところ機能や設計についてのレビューを受けている段階であり、具体的な文言はありません。

- [ned14/llfio P1031 low level file i/o and filesystem library for the C++ standard](https://github.com/ned14/llfio/)
- [LLFIO: Mainpage](https://ned14.github.io/llfio/)
- [P1883 進行状況](https://github.com/cplusplus/papers/issues/633)

### [P1928R2 Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r2.pdf)
### [P1967R10 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1967r10.html)
### [P2013R5 Freestanding Language: Optional ::operator new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2013r5.html)
### [P2047R5 An allocator-aware optional type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2047r5.html)
### [P2075R2 Philox as an extension of the C++ RNG engines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2075r2.pdf)
### [P2164R9 views::enumerate](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2164r9.pdf)
### [P2169R3 A Nice Placeholder With No Name](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r3.pdf)
### [P2198R6 Freestanding Feature-Test Macros and Implementation-Defined Extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2198r6.html)
### [P2198R7 Freestanding Feature-Test Macros and Implementation-Defined Extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2198r7.html)
### [P2338R3 Freestanding Library: Character primitives and the C library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2338r3.html)
### [P2363R4 Extending associative containers with the remaining heterogeneous overloads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r4.html)
### [P2406R1 Fix counted_iterator interaction with input iterators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2406r1.html)
### [P2406R2 Add lazy_counted_iterator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2406r2.html)
### [P2407R2 Freestanding Library: Partial Classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2407r2.html)
### [P2508R2 Exposing std::basic-format-string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2508r2.html)
### [P2530R2 Why Hazard Pointers should be in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2530r2.pdf)
### [P2537R2 Relax va_start Requirements to Match C](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2537r2.html)
### [P2545R2 Why RCU Should be in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r2.pdf)
### [P2570R2 Contract predicates that are not predicates](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2570r2.html)
### [P2591R2 Concatenation of strings and string views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2591r2.html)
### [P2616R3 Making std::atomic notification/wait operations usable in more situations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2616r3.html)
### [P2630R2 Submdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r2.html)
### [P2636R2 References to ranges should always be viewable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2636r2.html)
### [P2642R2 Padded mdspan layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2642r2.html)
### [P2656R1 C++ Ecosystem International Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2656r1.html)
### [P2659R2 A Proposal to Publish a Technical Specification for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2659r2.pdf)
### [P2675R1 LWG3780: The Paper (format's width estimation is too approximate and not forward compatible)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2675r1.pdf)
### [P2677R2 Reconsidering concepts in-place syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2677r2.pdf)
### [P2680R1 Contracts for C++: Prioritizing Safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2680r1.pdf)
### [P2689R1 atomic_accessor](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2689r1.html)
### [P2700R1 Questions on P2680 "Contracts for C++: Prioritizing Safety"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2700r1.pdf)
### [P2713R0 Escaping improvements in `std::format`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2713r0.html)

↓

### [P2713R1 Escaping improvements in `std::format`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2713r1.html)

`std::format`のエスケープ出力（`?`）時の出力方法を修正する提案。

`std::format`の`?`指定は、C++23で`range`出力サポート（[P2286R8](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2286r8.html)）と同時に、ロギングやデバッグ時の出力のために追加されたものです。

`?`による指定は特に文字/文字列の出力時に有効なもので、入力の文字列をそのまま（人間の視認性を優先して）出力します。出力はまず、出力文字列全体が`"`にくくられて出力され、入力された文字で対応するエスケープシーケンスがある文字（`\t \n \r " \`の5つ）は対応するエスケープシーケンスに置換されて出力されます。また、ユニコード文字の中でも出力できない（見えない）ものなどや、無効な文字となるものもエスケープされて（`\u{xxxx}`の形で）出力されます。

```cpp
int main() {
  std::cout << std::format("{:?}", "hello") << std::endl;
  // "hello"と出力
  std::cout << std::format("{:?}", R"("hello"\n)") << std::endl;
  // "\"hello\"\n"と出力
}
```

このフォーマット時のエスケープの振る舞いは、入力文字列を1文字づつ見ていって、文字が置換条件に合致した場合に対応する表現に置換（エスケープ）されて出力する、ような形で記述されています。

ただ、このフォーマット方法は、何を目的としてフォーマットするのかが不明瞭だったようです。つまり、このエスケープは、入力文字列を人間にとって読みやすい形で出力することを意図しているのか、元のエンコーディングにおける文字表現を視認可能な形で出力することを意図しているのか、が不透明で、それによって一部の文字の最適なエスケープが変化します。これはC++23 CDに対するアメリカ/フランスからのNBコメントによって指摘されました。

この提案は、`?`によってエスケープされた出力文字列の意図が、入力文字/文字列をC++コード上で文字/文字列リテラルとして記述した場合の文字列を再現することにあることを明確化するために、エスケープ方法を修正するものです。

この提案はこの問題に関するSG16の投票によって確認された事項に対して標準の文言を提供するもので、SG16では次のことが確認されました

1. `?`によってエスケープされた文字列はそのまま文字/文字列リテラルとして使用できる
    - エスケープされた出力文字列は、文字列リテラルとして使用されたときに入力文字列を再現することのできる文字列となる
2. エスケープされた文字列は視覚的に明確な（人間にとって読み取りやすい）文字列を生成しない
3. 区切り文字や表示できない文字は引き続きエスケープされる

これによる主な変更は、次のようになります

- ユニコードの結合文字は、出力文字列の直前に結合可能な文字が現れている場合にエスケープされない
    - 結合文字とは、`Grapheme_­Extend=Yes`というユニコードプロパティを持つ文字
    - 結合可能な文字とは、エスケープされない文字もしくは、それに結合している結合文字のこと

提案文書より、サンプルコード

```cpp
string s0 = format("[{}]", "h\tllo");               // s0の結果文字列は [h    llo] （非エスケープ出力）
string s1 = format("[{:?}]", "h\tllo");             // s1の結果文字列は ["h\tllo"] （タブ文字が\tにエスケープ）
string s3 = format("[{:?}, {:?}]", '\'', '"');      // s3の結果文字列は ['\'', '"'] （\ と " はエスケープされて出力される）

// 次の例ではUTF-8エンコーディングを仮定
string s4 = format("[{:?}]", string("\0 \n \t \x02 \x1b", 9));  // s4の結果文字列は ["\u{0} \n \t \u{2} \u{1b}"]
string s5 = format("[{:?}]", "\xc3\x28");           // s5の結果文字列は ["\x{c3}("] （不正なUTF-8文字列のケース）
string s6 = format("[{:?}]", "\u0301");             // s6の結果文字列は ["\u{301}"]
string s7 = format("[{:?}]", "\\\u0301");           // s7の結果文字列は ["\\\u{301}"]
string s8 = format("[{:?}]", "e\u0301\u0323");      // s8の結果文字列は ["ẹ́"]
```

この提案において振る舞いが明確化されたのは、下の3つの例（`s6, s7, s8`）です。まず、`\u0301`と`\u0323`はダイアクリティカルマークという結合文字（アルファベットの上下につく文字）です。

`s6`は、結合文字に非結合文字（結合対称）が先行していないため、エスケープされて出力されています。`s7`は、エスケープされた文字が先行しているため、エスケープされて出力されています。`s8`はエスケープされない文字（`e`）が先行しているため`\u0301`（上付きの`,`）が結合し、結合した結合文字が先行しているため`\u0323`（下付きの`.`）も結合して出力され、結果は見た目1文字になり、エスケープされる文字はありません。

- [FR 005-134 22.14.6.4 [format.string.escaped] Aggressive escaping](https://github.com/cplusplus/nbballot/issues/408)
- [US 38-098 22.14.6.4p1 [format.string.escaped] Escaping for debugging and logging](https://github.com/cplusplus/nbballot/issues/515)
- [`std::format` - cpprefjp](https://cpprefjp.github.io/reference/format/format.html)
- [P2286R8 Formatting Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2286r8.html)
- [P2713 進行状況](https://github.com/cplusplus/papers/issues/1418)

### [P2714R0 Bind front and back to NTTP callables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2714r0.html)

`std::bind_front`と`std::bind_back`にNTTPとして呼び出し可能なものを渡すオーバーロードを追加する提案。

これは、[P2511](https://wg21.link/p2511)で提案されていた`std::nontype`のアプローチ（メンバポインタをNTTPとして渡す）を`std::bind_front`と`std::bind_back`でできるようにしようとするもので、バインドするCallableオブジェクトを第一引数からテンプレートパラメータへ移動させます。

```cpp
struct S {
  int func(int, char, std::string_view);
};

int main() {
  // 現在（C++20
  auto bf1 = std::bind_front(&S::func, 20, 'a');
  // この提案
  auto bf2 = std::bind_front<&S::func>(26, 'a');
}
```

このテンプレートパラメータにはメンバポインタだけでなくCPOのようなものも使用できます。

```cpp
#include <compare>

int main() {
  // 現在（C++20
  auto bf1 = std::bind_front(std::strong_order, 20);
  // この提案
  auto bf2 = std::bind_front<std::strong_order>(26);
}
```

この提案によるメリットは

1. ストレージ容量の削減
    - メンバ関数とその対象オブジェクトをバインドする場合、その結果オブジェクトは元のオブジェクトよりも大きくなり、`std::function`等のSBOのサイズを超えてしまう
    - 呼び出したいメンバ関数等はコンパイル時にわかっていることがほとんどだが、現在の実装では回避できない
    - NTTPとしてメンバポインタを転送することで、そのストレージサイズを削減できる
2. 実装の単純化とデバッグ情報のスリム化
    - ステートレスラムダ式のような空のcallableオブジェクトを効率的に保存するために複雑なこと（EBOの有効化）をする必要がなくなる
    - `std::move()`等をデバッグ時に掘り下げない場合、束縛されたエンティティにアクセスする際にデバッグ情報を肥大化させる中間層が無くなる
3. `std::bind_front`と`std::bind_back`の可読性向上
    - `invoke(func, a, b, ...)`のような呼び出しはC++において一般的になりつつあるが、依然として`func(a, b, ...)`の方がより関数呼び出しの表現として自然だと感じる人が多いと思われる
    - そのため、`bind_front(func, a, b)`よりも`bind_front<func>(a, b)`の方が自然であると感じるかもしれない
    - また、callableターゲットとそこに束縛する引数が視覚的に分離されているため、見やすくなる

この提案では、同様の変更を`std::not_fn`に対しても行うことを提案しています。

- [P2511R0 Beyond operator(): NTTP callables in type-erased call wrappers - ［C++］WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2511R0-Beyond-operator-NTTP-callables-in-type-erased-call-wrappers)
- [P2714 進行状況](https://github.com/cplusplus/papers/issues/1419)

### [P2717R0 Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2717r0.html)

C++周辺ツールが、Ecosystem ISにどれほど準拠しているのかを互いに通信する手段を標準化する提案。

Ecosystem ISはC++のツール（コンパイラ、ビルドシステムやパッケージマネージャ、静的解析ツールなど）環境を整備するための独立した標準規格で、[P2656](https://wg21.link/P2656)で方向性が提案されています。Ecosystem ISにWG21として取り組んでいくことは合意されているようです。

Ecosystem ISは既存のツールを否定しWG21でツールを作り上げるものではなく、ツールとツールの間の相互通信に必要な部分を標準化しようとするものです。

Ecosystem ISもC++そのものと同様に徐々に進化していくことを考えると、Ecosystem ISにもバージョンが生まれ、Ecosystem ISに準拠したC++ツールはある時点では特定バージョンのEcosystem ISを実装することになるでしょう。Ecosystem ISの目的はそのようなツールの相互のやり取りの標準化にあるので、互いが想定するEcosystem ISバージョンが異なる場合にそれを知る手段がないことは問題となります。

この提案は、ツールが実装するEcosystem ISのバージョン情報を取得できるメカニズムをEcosystem ISに最初から組み込んでおくことを提案するとともに、あるツールが別のツールのEcosystem ISの機能を使用する（場合にどのバージョンを想定しているのかを同時に伝達できるメカニズムについても提案しています。

この提案は次の2つの機能を提案しています

1. イントロスペクション（*Introspection*）
    - 実装するバージョンについて相手に報告する
2. 宣言（*Declaration*）
    - 必要とするバージョンとエディションを相手に指定する

イントロスペクションによって、ツールは相手のツールが特定の機能を実装しているかを問い合わせることができます。問い合わせを受けたツールはサポートしている機能の範囲で応答するか何も応答しません。応答があった場合、その情報を使用して、Ecosystem IS標準に従って相手ツールとのさらなるやり取りを進めることができます。

宣言によって、ツールは特定の機能によってやり取りする時のその機能についてのバージョンを指定できます。相手ツールがその宣言を受け入れた場合は、その機能を使用してやり取りを進めることができます。

どちらの機能の場合も、これはツールのコマンドライン引数で渡し、返答はJSONで返します。

イントロスペクションの場合は`--std-info`というコマンドライン引数を使用します

```
tool --std-info
```

これに対する応答は例えば次のようになります

```json
{
  "$schema": "https://raw.githubusercontent.com/cplusplus/ecosystem-is/release/schema/std_info-1.0.0.json",
  "std:info": "[1.0.0,2.5.0]"
}
```

この問い合わせはEcosystem ISの全ての機能について行われ、結果もすべての機能について帰ってきます。しかし、場合によっては特定の機能についてだけ問い合わせをした方が効率的な場合がり、そのための制限付きの問い合わせをサポートしています

制限付き問い合わせも`--std-info`で行いますが、機能を示す名前とバージョンを同時に指定します

```
tool "--std-info=std:info==[1.0.0,2.1.0)"
```

これは`--std-info`そのもののバージョンの問い合わせです

これに対する応答は例えば次のようになります

```json
{
  "$schema": "https://raw.githubusercontent.com/cplusplus/ecosystem-is/release/schema/std_info-1.0.0.json",
  "std:info": "[1.5.0,2.0.0]"
}
```

この場合、相手のツールは要求されたバージョン（1.0.0 ~ 2.1.0）のサブセット（1.5.0 ~ 2.0.0）しか実装していないといっています。

また複数同時に問い合わせることもできます

```
tool "--std-info=std:info=[1.0.0,2.1.0)" "--std-info=gcc:extra[2.0.0,2.1.0]"
```

この結果は例えば次のようになります

```json
{
  "$schema": "https://raw.githubusercontent.com/cplusplus/ecosystem-is/release/schema/std_info-1.0.0.json",
  "std:info": "[1.0.0,2.0.0)",
  "gcc:extra": "2.1.0"
}
```

この結果を受けて、使用する機能のバージョンを指定（宣言）するには、使用する機能と共に`--std-decl`にその機能と要求バージョンを指定するようにします。

```
tool "--std-decl=std:info=2.0.0" "--std-decl=gcc:extra=2.1.0" --std:info --gcc:extra...
```

ここでは、`--std:info`は2.0.0を使用し、`--gcc:extra`は2.1.0を使用するように相手ツールに要求しています。

これらの返答のフォーマットやバージョン指定のフォーマットなどは、この提案ではJSON Schemaの形で規定することを提案しています。

- [cplusplus/ecosystem-is: Working Draft for a future C++ Ecosystem IS](https://github.com/cplusplus/ecosystem-is)
- [P2717 進行状況](https://github.com/cplusplus/papers/issues/1420)

### [P2723R1 Zero-initialize objects of automatic storage duration](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2723r1.html)
### [P2724R0 constant dangling](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2724r0.html)

現在ダングリング参照を生成しているものについて、定数初期化可能なものを暗黙的/明示的に定数初期化する提案。

この提案は、以前の[P2658](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2658r0.html)と[P2623](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2623r2.html)の提案から、定数初期化関連の部分をマージするものです。それぞれについては以前の記事を参照

- [P2623R0 implicit constant initialization - WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/08/11/193828#P2623R0-implicit-constant-initialization)
- [P2658R0 temporary storage class specifiers - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2658R0-temporary-storage-class-specifiers)

cほとんど定数と同等でありながら定数ではないためにふとした使い方の間違いでダングリング参照を生成し安全性を損ねているケースがC++のあちこちで見られます。そのような定数とみなせるものを定数初期化（コンパイル時に初期化）することで静的ストレージに配置し、ダングリング参照を回避するのがこの提案の目的です。

```cpp
std::string_view sv1 = "hello world";  // ok

// 共にダングリング参照となる
std::string_view sv2 = "hello world"s;           // UB、この提案によって暗黙定数初期化
std::string_view sv3 = constinit "hello world"s; // 明示的に定数初期化を行う
```

```cpp
struct X {
  int a, b;
};

const int& get_a(const X& x) {
  // 入力によってはダングリング参照を返す
  return x.a;
}

const int& a = get_a({4, 2}); // UB、aはダングリング参照となる
a; // この提案によって修正されると4を保持
```

```cpp
std::generator<char> each_char(const std::string& s) {
  for (char ch : s) {
      co_yield ch;
  }
}

int main() {
  auto ec = each_char("hello world"); // コルーチンから制御が戻った時点でダングリング参照となる。この提案によって暗黙定数初期化

  for (char ch : ec) {
      std::print(ch);
  }
}
```

この例で問題となっている個所は全て、この提案による暗黙定数初期化によってダングリング参照を生成しなくなります。

この提案はこれらの例を防止できるようになる一方で、同じようにダングリング参照を生成する全ての場合にそれを防止できるわけではありません。あくまで、一部のケースでダングリング参照の生成を抑止し、ダングリング参照の出現機会を減少させるものです。

また、この提案による暗黙/明示的定数初期化は定数初期化そのものは既存の仕組みを使用します。すなわち、クラス型の構築に使用されるコンストラクタが`constexpr`コンストラクタである（かつ、そのメンバをすべて定数式で初期化する）場合はこの提案の恩恵を受けられるようになります。それはすなわち`constexpr`の利点として安全性の向上が加わるようになり、クラスの初期化やそれに伴う処理を`constexpr`対応させておくことの重要性が高まることになります。

- [P2724 進行状況](https://github.com/cplusplus/papers/issues/1421)

### [P2725R1 std::integral_constant Literals](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2725r1.html)
### [P2728R0 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2728r0.html)

標準ライブラリにユニコード文字列の相互変換サポートを追加する提案。

ユニコードは文字コードの規格としてデファクトスタンダードとなっており、日常的にソフトウェアを使用する非常に多くのユーザーにとって重要なものです。しかし、C/C++は本質的にユニコードをサポートしていない数少ない主要なプログラミング言語となっています。

この提案はその状況の修正のために、まずUTF（ユニコードにおける文字表現）の相互変換機能を標準ライブラリに追加することを目指すものです。

この提案による変換インターフェースは次のような設計を選択しています

- `<ranges>`との親和性。番兵や遅延ビューのサポートなど
- （レガシーな）イテレータのサポート。任意のイテレータ型を考慮する
- ポインタのサポート。SIMDを用いるような最速の変換方法はポインタを介して行われる
- 変換はブラックボックスではない。入力文字列中の、エンコーディングの切れ目や壊れたエンコーディング個所などの状態をユーザーが調査できるユーティリティを提供する
- null終端された文字列を特別扱いしない
- 同じテキストを異なるタイミングでコードユニット（UTFエンコーディングの1単位の整数値）として表示したい場合とコードポイント（ユニコード空間上の32bit整数値）として表示したいことがよくある。そのため、変換イテレータは変換済みのコードユニットの元のデータにアクセスする簡便な方法を提供する。

この提案はそこそこ巨大ですが主に次のものから構成されています

1. APIを制約するためのコンセプト
2. null終端された文字列のための番兵型
3. UTFシーケンスの状態を紹介する定数と関数
4. 変換アルゴリズム
    - イテレータ/Rangeアルゴリズム
5. 変換イテレータ
6. 変換`view`

また、これらのものは基本的に`std::uc`名前空間に定義されています

提案文書より、サンプルコード

**バッファからバッファへのパフォーマンス重視の変換**

```cpp
// UTF-8 -> UTF-16 へ変換する

// バッファのサイズを同じにすることで、変換に余裕があるようにする
char utf8_buf[buf_size];
char utf16_buf[buf_size];

char * read_first = utf8_buf;
while (true) {
  // UTF-8シーケンスを読み取る（ネットワークなど）
  // 末尾に部分的なUTF-8シーケンスが現れうる
  char* buf_last = read_into_utf8_buffer(read_first, utf8_buf + buf_size);

  if (buf_last == read_first)
    continue;

  // 有効なUTF-8シーケンスを特定する（部分的なシーケンスを除外する）
  char* last = buf_last;
  auto const last_lead = std::ranges::find_last_if(utf8_buf, buf_last, std::uc::lead_code_unit);

  if (!last_lead.empty()) {
    auto const dist_from_end = buf_last - last_lead.begin();
    
    assert(dist_from_end <= 4);

    if (std::uc::utf8_code_units(*last_lead.begin()) != dist_from_end) {
      last = last_lead.begin();
    }
  }

  // std::ranges::copy()と同じインターフェースで、変換しながらコピーする
  auto const result = std::uc::transcode_to_utf16(utf8_buf, last, utf16_buf);

  // 変換結果（UTF-16）を使って何かする
  send_utf16_somewhere(utf16_buf, result.out);

  // 末尾にあった部分的なシーケンスを次の処理バッファの先頭へ移動
  read_first = std::ranges::copy_backward(last, buf_last, utf8_buf).out;
}
```

**オブジェクトからのなるべく高速な変換**

```cpp
struct my_string; // ポインタインターフェースを持たない文字列型

// UTF-8文字列の取得
my_string input = get_utf8_input();

// 出力バッファ
std::vector<uint16_t> input_as_utf16(input.size()); // Reserve some space.

// UTF-16 -> UTF-8 変換
auto const result = std::uc::transcode_to_utf16(input, input_as_utf16.data());

input_as_utf16.resize(result.out - input_as_utf16.data()); // Trim unused space.
```

**オブジェクトからのなるべく簡単な変換**

```cpp
struct my_string; // ポインタインターフェースを持たない文字列型

// UTF-8文字列の取得
my_string input = get_utf8_input();

// 出力バッファ
std::vector<uint16_t> input_as_utf16;

// UTF-16 -> UTF-8 変換
std::ranges::copy(input, std::uc::from_utf8_back_inserter(input_as_utf16));
```

**既存のイテレータAPIへのアダプト**

```cpp
// UTF-16シーケンスを受ける関数テンプレート
template<class UTF16Iter>
void process_input(UTF16Iter first, UTF16Iter last);

// UTF-8文字列の取得
std::string input = get_utf8_input(); // std::stringにUTF-8文字列を詰めて使用

// UTF-8 -> UTF-16 変換しつつ、関数に渡す（遅延評価）
process_input(std::uc::utf_8_to_16_iterator(input.begin(), input.begin(), input.end()),
              std::uc::utf_8_to_16_iterator(input.begin(), input.end(), input.end()));


// viewの利用によるさらなる簡単化
auto const utf16_view = std::uc::as_utf16(input);
process_input(utf16_view.begin(), utf16.end());
```

**既存のRange APIへのアダプト**

```cpp
// UTF-16シーケンスを受ける関数テンプレート
template<class UTF16Range>
void process_input(UTF16Range && r);

// UTF-8文字列の取得
std::string input = get_utf8_input(); // std::stringにUTF-8文字列を詰めて使用

// UTF-8 -> UTF-16変換しつつ、関数に渡す（遅延評価）
process_input(std::uc::as_utf16(input));
```

この例では（おそらくWindows環境で頻出する）UTF-8からUTF-16への変換のみを扱っていますが、提案としてはUTF-8/16/32の全ての相互変換を含んでいます。

この提案の提供する機能は、Boost.TextとしてBoostに提案中のライブラリの一部として5年ほどの実装経験があります。

- [tzlaine/text: What a c++ standard Unicode library might look like.](https://github.com/tzlaine/text)
- [P2728 進行状況](https://github.com/cplusplus/papers/issues/1422)

### [P2729R0 Unicode in the Library, Part 2: Normalization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2729r0.html)

標準ライブラリにユニコード文字列の正規化サポートを追加する提案。

この提案は↑の提案に引き続いて、ユニコードサポート改善のためにユニコード正規化機能を標準ライブラリに追加しようとするものです。

ユニコードの正規化とは、同じ意味を持つ複数の文字（コードポイント）をある1つの文字（コードポイント）に変換することを言います。例えば、半角全角や、丸文字などを対応する通常の文字へ変換します。

この提案による正規化インターフェースは次のような設計を選択しています

- `<ranges>`との親和性。番兵や遅延ビューのサポートなど
- （レガシーな）イテレータのサポート。任意のイテレータ型を考慮する
- ポインタのサポート。SIMDを用いるような最速の変換方法はポインタを介して行われる
- 変換はブラックボックスではない。入力文字列中の、エンコーディングの切れ目や壊れたエンコーディング個所などの状態をユーザーが調査できるユーティリティを提供する
- null終端された文字列を特別扱いしない
- UTFの形式ごとに最適なアルゴリズムへのディスパッチ
    - パフォーマンスのためと
    - 使用するUTF形式が変わった時でも、同じコードを利用することができるようにする
- 煩雑なユニコードの詳細を隠蔽する、より高レベルの抽象化を提供する

この提案は主に次のものから構成されています

1. ユニコードバージョン定数
2. ストリームセーフな操作
3. ストリームセーフなアルゴリズム
    - イテレータ/Rangeアルゴリズム
4. ストリームセーフなイテレータ
5. ストリームセーフな`view`
6. APIを制約するためのコンセプト
7. サポートする正規化形式の列挙型
8. 汎用の正規化アルゴリズム
9. 一度に複数の出力を行うアルゴリズム
10. `std::string`のための正規化操作

また、これらのものは基本的に`std::uc`名前空間に定義されています

提案文書より、サンプルコード

**コードポイントのシーケンスをNFCに正規化する**

```cpp
std::string s = /* ... */; // std::stringにUTF-8文字列を詰めて使用

// 正規化されていないことを確認
assert(!std::uc::is_normalized(std::uc::as_utf32(s)));

// 出力バッファ
char * nfc_s = new char[s.size() * 2];

// 正規化はコードポイントで動作するため、まずUTF32に変換する（as_utf32()によって）必要がある
auto out = std::uc::normalize<std::uc::nf::c>(std::uc::as_utf32(s), nfc_s);

// null終端
*out = '\0';

// 正規化されていることを確認
assert(std::uc::is_normalized(nfc_s, out));
```

**string-likeなコンテナへ出力する**

```cpp
std::string s = /* ... */; // std::stringにUTF-8文字列を詰めて使用

// 正規化されていないことを確認
assert(!std::uc::is_normalized(std::uc::as_utf32(s)));

// 出力先
std::string nfc_s;
nfc_s.reserve(s.size());

// 正規化はコードポイントで動作するため、まずUTF32に変換する（as_utf32()によって）必要がある
std::uc::normalize_append<std::uc::nf::c>(std::uc::as_utf32(s), nfc_s);

// 正規化されていることを確認
assert(std::uc::is_normalized(std::uc::as_utf32(nfc_s)));
```

この場合、`normalize_append()`によってある程度纏めて出力されることで、より高速になる可能性があります。

**正規化を維持したまま正規化済み文字列を更新する**

```cpp
std::string s = /* ... */;// std::stringにUTF-8文字列を詰めて使用

// 正規化されていることを確認
assert(std::uc::is_normalized(std::uc::as_utf32(s)));

// 挿入したい文字列（正規化されていないかもしれない
std::string insertion = /* ... */;

// 正規化しながら挿入
normalize_insert<std::uc::nf::c>(s, s.begin() + 2, std::uc::as_utf32(insertion));

// 正規化されていることを確認
assert(std::uc::is_normalized(std::uc::as_utf32(nfc_s)));
```

この提案の提供する機能もまた、Boost.TextとしてBoostに提案中のライブラリの一部として5年ほどの実装経験があります。

- [Unicode正規化 - Wikipedia](https://ja.wikipedia.org/wiki/Unicode%E6%AD%A3%E8%A6%8F%E5%8C%96)
- [P2729 進行状況](https://github.com/cplusplus/papers/issues/1423)

### [P2730R0 variable scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2730r0.html)

ローカルスコープの一時オブジェクトの寿命を文からスコープまで延長する提案。

この提案は、以前の[P2658](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2658r0.html)と[P2623](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2623r2.html)の提案から、ローカル一時オブジェクトの寿命延長関連の部分を抽出したものです。それぞれについては以前の記事を参照

- [P2623R0 implicit constant initialization - WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/08/11/193828#P2623R0-implicit-constant-initialization)
- [P2658R0 temporary storage class specifiers - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2658R0-temporary-storage-class-specifiers)

ただし、この提案ではP2658に含まれていた`variable_scope`などの指定は含まれておらず。P2623に加えてP2658に含まれていた`variable_scope`と同等の寿命延長を提案しています。

次のような関数がああったとき

```cpp
const std::string& f(const std::string& defaultValue) {
  return defaultValue;
}
```

この関数の内部からは、引数の`defaultValue`がどういう寿命を持つのかは分かりません。それの参照を戻り値で返すことには問題がありますが、それは必ずしもおかしいことでもありません。

この`f()`に一時オブジェクトを渡して呼び出すと、暗黙的なスコープが追加される形になります。

```cpp
int main() {
  // 先ほどのf()のこのような呼び出しは
  {
    f("Hello World"s);
  }

  // このような呼び出しとなる
  {
    {
      auto anonymous = "Hello World"s;
      f(anonymous);
    }
  }
}
```

この時、戻り値を受けていると

```cpp
int main() {
  // 先ほどのf()のこのような呼び出しは
  {
    const std::string& value = f("Hello World"s);
  }

  // このような呼び出しとなる
  {
    const std::string& value; // 実際には初期化子が必要
    {
      auto anonymous = "Hello World"s;
      value = f(anonymous);
    }
  }
}
```

コンパイラは通常のC++としてはかけないコードに書き換えたかのようにコンパイルします。これによって、一時オブジェクト`anonymous`のスコープは他の変数とは異なることになり、プログラマの期待とも一致しなくなります。

この時、最も自然なのは`anonymous`のスコープが戻り値を受けている`value`と同じになることです。この場合の`value`のスコープのことをこの提案ではブロックスコープと呼び、関数呼び出し時のこのような一時オブジェクトの寿命を現在の文からブロックスコープまで延長することを提案しています。

これによって、参照セマンティクスを持つクラスによっておこるダングリング参照も抑制されます。

```cpp
int main() {
  std::string_view sv = "Hello World"s;

  ...

  std::cout << sv;  // ok
}
```

ただしこのような場合には、一時オブジェクトのブロックスコープへの寿命延長が機能しない場所があります

```cpp
std::string_view sv = "initial value"s;

if (randomBool()) {
  sv = "if value"s;
} else {
  sv = "else value"s;
}
```

この場合、`"if value"s`や`"else value"s`の寿命は`if`節と`else`節のそれぞれのブロックスコープまでは延長していますが、`sv`に束縛することによってその外側に持ち出されてしまうと依然としてダングリング参照となります。

この場合に、これらの一時オブジェクトが変数`sv`と同じスコープを持っていればこの問題は解決されます。この提案ではそのようなスコープのことを変数スコープ（*variable scope*）と呼び、一時オブジェクトが直接別の変数に代入される場合にその寿命を代入先の変変数スコープまで延長することを提案しています。

これによって、関数内部で発生しうる直接的なダングリング参照の発生を抑制します。

結局、この提案は次の2つのことを提案します

- ローカル変数の一時変数は変数スコープを取得する
- 関数引数の一時変数はブロックスコープを取得する

これと同等なことは、例えばCの複合リテラルに見ることができますが、C++においても`const auto&`や`auto&&`による一時オブジェクト寿命延長時に行われているため、実装にあたって大きな問題があるわけではないと思われます。

- [P2730 進行状況](https://github.com/cplusplus/papers/issues/1424)

### [P2732R0 WG21 November 2022 Kona meeting Record of Discussion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2732r0.pdf)

2022年11月7-12日にハワイのKonaで行われた、WG21全体会議の議事録。

N4933との違いはよく分かりません。

### [P2733R0 Fix handling of empty specifiers in `std::format`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2733r0.html)

`std::format()`のフォーマット文字列内の置換フィールドが空である場合に、パースを行わなくてもよくする提案。

フォーマット文字列内の置換フィールド`{}`には`{:+3}`などのように出力を調整するためのオプション（フォーマット引数）を指定することができます。この解析のためには`std::formatter<T>::parse()`が使用され、ユーザー定義型に対するフォーマットのカスタマイズではこの関数でオリジナルオプションをパースすることで自作の型にオリジナルのオプションを指定してフォーマットすることができるようになります。

とはいえ、多くの場合はオプション無しの`{}`のまま使用されることが多いようで、その場合に、現在の規定はフォーマット引数の有無にかかわらず`std::formatter<T>::parse()`を呼び出すことを要求しています。

```cpp
struct S {};

// ↑のSをstd::format()可能にする
template <>
struct std::formatter<S> {
  auto parse(format_parse_context& ctx) { return ctx.begin(); }
  auto format(S, format_context& ctx) const { return ctx.out(); }
};

int main() {
  auto s1 = fmt::format("{}", S());  // (1) フォーマット引数指定なし
  auto s2 = fmt::format("{:}", S()); // (2) フォーマット引数は空
}
```

(1)と(2)の例はいずれもフォーマット引数は存在していないため、`parse()`を呼び出す意味がありません。`{fmt}`ライブラリでの実装経験によれば、このオーバーヘッドは実際に`range`のフォーマットにおいて悪影響を与えていることが確認できたようです。それはフォーマット文字列のコンパイル時検査等、`parse()`を呼び出す必要のある他のコンテキストにおいても同様である可能性があります。

また、C++23の`range`ではフォーマットオプション中で`:...`のようにして要素型に対するオプション指定を行うことができ、そこでも同様の問題が発生します。

```cpp
int main() {
  auto s3 = std::format("{}", std::vector<S>(2));     // vector : なし、S : なし
  auto s4 = std::format("{:}", std::vector<S>(2));    // vector : 空、  S : なし
  auto s5 = std::format("{::}", std::vector<S>(2));   // vector : 空、  S : 空
  //                       ^ 要素型Sに対する空のフォーマット引数指定
}
```

これはいずれのケースでも、外側の`std::vector`と要素型の`S`に対してフォーマットオプションを指定していません。現在の規定ではフォーマットオプションの指定なしと空は区別されていたようですが、`range`の要素型に対するフォーマットオプション指定においてはパースの都合上（ほぼ`:`の有無だけで要素型に対するフォーマットオプション有無が決まるので）この2つの違いを区別することができません。そのため、この提案ではこの2つのケースは同等に扱われるようになります。

この問題は[LWG Issue 3776](https://cplusplus.github.io/LWG/issue3776)で指摘され、その解決のためには提案が必要になるということで、この提案が書かれました。この修正は、省略することを許可するものの必須ではない、となるようになっています。

また、類似の問題の解決として、`std::tuple`に対するフォーマット時に要素型に対するデバッグ出力を有効化できていなかったバグの修正も同時に行われます。

`std::tuple`に対するフォーマットでは要素型に対するオプション指定が無いため、要素型に対するオプションの`parse()`は常に省略されていました。一方で、要素型の文字/文字列型に対してデバッグ出力オプション（`?`）が常に有効になっており、そのために要素型のフォーマットオプションの`parse()`で`std::formatter::set_debug_format()`の呼び出しが必要になる、というある種の矛盾状態に陥っていました（本来、`set_debug_format()`は`parse()`内で`?`オプションをパースしたときに呼び出されることでデバッグ出力を有効化します）。

この提案ではこれを解決し、`std::tuple`に対するフォーマットではネストした要素型でデバッグ出力が可能な場合に`set_debug_format()`を正しく呼ぶように規定を修正します。

```cpp
auto s = fmt::format("{}", std::make_tuple(std::make_tuple('a')));
// Before : ((a))
// Aftter : (('a'))
```

- [`std::format()` - cpprefjp](https://cpprefjp.github.io/reference/format/format.html)
- [`std::formatter::set_debug_format()` - cpprefjp](https://cpprefjp.github.io/reference/format/formatter/set_debug_format.html)
- [LWG Issue 3776. Avoid parsing format-spec if it is not present or empty](https://cplusplus.github.io/LWG/issue3776)
- [P2733 進行状況](https://github.com/cplusplus/papers/issues/1426)

### [P2734R0 Adding the new 2022 SI prefixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2734r0.pdf)

2022年に追加された新しいSI接頭辞に対応する`std::ratio`特殊化を追加する提案。

`<ratio>`ヘッダにはコンパイル時有理数型`std::ratio`と、SI接頭辞（ミリとかマイクロ、キロやギガなど）に対応するその事前定義型エイリアスが定義されています。

SI接頭辞は長らく更新されていませんでしたが、2022年に新しく次の4つが追加されました

- *quecto* : $10^{-30}$
- *ronto* : $10^{-27}$
- *ronna* : $10^{27}$
- *quetta* : $10^{30}$

この提案は、この4つに対応する設定済みの`std::ratio`エイリアスを追加するものです。名前はSI接頭辞名と同じで提案されています。

ただし、既存の`std::yocto`や`std::yotta`等と同様に、`itmax_t`型で値を表現可能な場合（64bitを超える幅の整数型を提供していない場合）は定義しなくてもよいようにされています。

- [SI接頭語追加：計量標準総合センター（NMIJ）](https://unit.aist.go.jp/nmij/info/SI_prefixes/indexS.html)
- [SI接頭辞 - cpprefjp](https://cpprefjp.github.io/reference/ratio/si_prefix.html)
- [`<ratio>` - cpprefjp](https://cpprefjp.github.io/reference/ratio.html)
- [P2734 進行状況](https://github.com/cplusplus/papers/issues/1427)

### [P2736R0 Referencing the Unicode Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2736r0.pdf)
### [P2737R0 Proposal of Condition-centric Contracts Syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2737r0.pdf)

新しいキーワードによる条件中心な契約構文の提案。

現在検討中の契約プログラミングのための構文は、C++20で削除された時から変わらず属性を利用したものが主流です。ただし、これはまだ確定したものではなく、他にもクロージャを意識した構文（[P2461R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf)）が提案されています。

<table>
<tr>
<th>属性</th>
<th>クロージャ</th>
</tr>
<tr>
<td valign="top">

```cpp
int select(int i, int j)
  [[pre: i >= 0]]
  [[pre: j >= 0]]
  [[post r: r >= 0]]
{
  [[assert: _state >= 0]];

  if (_state == 0)
    return i;
  else
    return j;
}

int pre;    // OK
int assert; // OK
int post;   // OK
```

</td>
<td valign="top">

```cpp
int select(int i, int j)
  pre{i >= 0}
  pre{j >= 0}
  post(r){r >= 0}
{
  assert{_state >= 0};

  if (_state == 0)
    return i;
  else
    return j;
}

int pre;    // OK
int assert; // ???
int post;   // OK
```

</td>
</tr>
</table>

この提案では3つ目の候補として、`precond, postcond, incond`（順に、事前条件、事後条件、アサート）の3つのキーワードを用いた条件中心な構文を提案するものです。

<table>
<tr>
<th>属性</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
int select(int i, int j)
  [[pre: i >= 0]]
  [[pre: j >= 0]]
  [[post r: r >= 0]]
{
  [[assert: _state >= 0]];

  if (_state == 0)
    return i;
  else
    return j;
}

int pre;    // OK
int assert; // OK
int post;   // OK
```

</td>
<td valign="top">

```cpp
int select(int i, int j)
  precond(i >= 0)
  precond(j >= 0)
  postcond(result >= 0)
{
  incond(_state >= 0);

  if (_state == 0)
    return i;
  else
    return j;
}

int precond;  // ERROR
int incond;   // ERROR
int postcond; // ERROR
```

</td>
</tr>
</table>

この提案はP2521R2にある契約機能のMVPについて次の変更を加えます

1. アサーションの構文を`assert`から`incond`に変更
2. `precond, postcond, incond`を完全な（文脈依存ではない）キーワードとして追加
3. 条件指定は`()`の中に式を指定する
    - `precond(expr), incond(expr), postcond(expr)`
4. 事後条件（`postcond`）では、定義済みの変数`result`によって戻り値を参照する変数が暗黙的に導入される

`incond`は事前条件（処理の前に満たすべき条件）と事後条件（処理の後で満たすべき条件）からの類推で、処理の途中で満たすべき条件を表す造語です。これは、2分木の探索順序を表す3つの単語`preorder, inorder, postorder`を参考にして作られた言葉でもあります。

アサーション（`assert`）を置き換えたい動機は次のようなものです

1. *assertion*は他の2つ（*precondition*、*postcondition*）と一貫していない
    - 条件は満たさないことを違反したと言うが、アサーションは失敗したと言われる
    - 3つの事柄の互いの関連性が明確であることが重要
2. 既存のアサーションとの混同
    - C assert（`assert()`マクロ）と`static_assert`に加えて、アサーションのためのライブラリが多数存在する
    - 単にアサーションと言った時にどれを指しているかが曖昧
3. `assert`はキーワードとして登録できない
    - 少なくともC assertと競合する

`incond`というワードはこの3つのいずれの問題もクリアしている新しい造語です。

この新しいキーワードはACTCD19というC/C++コードベース調査で1000件程度しかヒットしないため新しいキーワードとして使用できる、と主張しています（使われ方にもよりますが1000件は多いのではと思わないでもないですが）。

- [P2461R0 Closure-based Syntax for Contracts - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P2461R0-Closure-based-Syntax-for-Contracts)
- [P2487R0 Attribute-like syntax for contract annotations - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P2487R0-Attribute-like-syntax-for-contract-annotations)
- [P2521R2 Contract support - Working Paper - ［C++］WG21月次提案文書を眺める（2022年03月）](https://onihusube.hatenablog.com/entry/2022/04/02/175835#P2521R2-Contract-support---Working-Paper)
- [二分木のpre-order, in-order, post-orderの簡単でわかりやすい説明 - CTOを目指す日記](https://engineer.yeele.net/algorithm/data-structure/binary-tree-traversal/)
- [P2737 進行状況](https://github.com/cplusplus/papers/issues/1430)

### [P2738R0 constexpr cast from void*: towards constexpr type-erasure](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r0.pdf)
### [P2739R0 A call to action: Think seriously about "safety" then do something sensible about it](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2739r0.pdf)

C++の安全性向上のための行動を呼びかける文書。

2022年11月ごろに出されたNSA（アメリカ国家安全保障局）のレポート（[Software Memory Safety - Department of Defense](https://media.defense.gov/2022/Nov/10/2003112742/-1/-1/0/CSI_SOFTWARE_MEMORY_SAFETY.PDF)）において、C++はCとともにメモリ安全な言語ではなく他のメモリ安全な言語に移行することが望ましい、と名指しされました。この文書はそれを受けて、筆者の方（Bjarne Stroustrup先生）のこれまで及びこれからのC++の安全性向上のための取り組みを説明し、C++標準化委員会としても行動していくことを促すものです。

取り組みとしてはコアガイドラインの整備やそれをベースとした静的解析ツールの整備、コアガイドライン基準の静的解析アノテーションの提案（[P2687R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2687r0.pdf)）などが挙げられています。

NSAの文書は安全をメモリ安全性に限定していますが安全性とはそれだけではなく、安全性を実現するための方法も一通りではありません。また、安全性は重要ではありますが誰もが安全性だけを重視するわけではなく、安全性よりも他の事項（例えばパフォーマンス）が重視される場合もあります。また、モダンなコードだけを安全にしたとしても、現在の多くのC++コードがそうなるわけではなく、それらの過去のコードは安全なコード（あるいは安全なプログラミング言語）から呼び出されて使用されます。

安全性の問題を放置すればC++のコミュニティの大部分が損なわれ、委員会で行われている多くの作業が無駄になってしまいますが、安全性だけを重視しすぎても同様の結果を招くことになります。

この文書では、まず安全性の問題と考えられることのリストを作成し、P2687R0の枠組みの中でそれをどのように改善できるかを考えていくことを提案しています。これはまた、Bjarne先生の今後の方針でもあります。

- [Software Memory Safety - Department of Defense](https://media.defense.gov/2022/Nov/10/2003112742/-1/-1/0/CSI_SOFTWARE_MEMORY_SAFETY.PDF)
- [P2687R0 Design Alternatives for Type-and-Resource Safe C++ - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2687R0-Design-Alternatives-for-Type-and-Resource-Safe-C)
- [P2739 進行状況](https://github.com/cplusplus/papers/issues/1432)

### [P2740R0 Simpler implicit dangling resolution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2740r0.html)

関数からローカル変数の参照を返してしまうケースをコンパイルエラーにする提案。

C++23では、[P2266R3](https://wg21.link/P2266R3)の採択によって一部のローカル変数の参照を返す関数がコンパイルエラーとなるようになります。

```cpp
// 参照を返す関数
int& f(bool b, int i) {
  static int s;

  if (b) {
    return s;  // OK
  } else {
    return i;  // error : C++23から
  }
}

// reference_wrapperを返す関数
std::reference_wrapper<int> g() {
  int w;
  
  return w;  // error : C++23から
}
```

この変更は画期的なものですが、P2266の主目的はあくまで暗黙のムーブ対象の拡大にあったのでこれは副次的な効果に過ぎず、完全なものではありません。例えば、上記それぞれの場合においての参照に当たるものを`return`で返す場合は、その参照先がローカル変数でもエラーになりません。

この提案はここからさらに進んで、追加でいくつかの場合もコンパイルエラーにしようとするものです。

1つ目は参照ではなくポインタを返す関数の場合です。

```cpp
int* h(bool b, int i) {
  static int s;
  if (b) {
    return &s;  // OK
  } else {
    return &i;  // error: iは戻り値のポインタよりも先に寿命が尽きる
  }
}
```

（ここでのerrorとはエラーにすることを提案しているという意味で、以降も同様です）

これと同様のことは、関数の本体内でも起こり得ます。

```cpp
void h(bool b, int i) {
  int* p = nullptr;

  if (b) {
    static int s;
    p = &s;  // OK
  } else {
    int i = 0; 
    p = &i;  // error: iは戻り値のポインタよりも先に寿命が尽きる
  }

  // ...
}
```

このために、この提案では次のようなルールを提案しています

> ポインタまたは参照の寿命が尽きる前にその参照するオブジェクトの寿命が尽きる場合、オブジェクトのアドレスをポインタまたは参照に代入できない

ただしこれは、一段階の間接化だけを対象としています。つまり、すでに何かを参照している参照/ポインタを新しい参照/ポインタに代入する（`return`する）ような場合はこのルールに該当しません。それをしようとすると、コンパイラはローカル変数と参照/ポインタの依存関係グラフを作成することになり、これはコンパイル時間増大と実装の複雑化を招きます。

次に、ラムダ式やコルーチンがローカル変数を参照キャプチャしていて、それを内包するオブジェクトを返す場合をコンパイルエラーとします。

```cpp
auto lambda() {
  int i = 0;
  return [&i]() -> &int
      {
          return i;
      };  // error: iは戻り値のラムダよりも先に寿命が尽きる
}

auto coroutine() {
  int i = 0;
  return [&i]() -> generator<int>
      {
        co_return i;
      };  // error: instance `i` dies before the returned coroutine
}
```

このために、この提案では次のようなルールを提案しています

> ローカル変数へのポインタ/参照をキャプチャするラムダ式またはコルーチンを関数から返すことはできない

これは前項の提案から一段階だけ進んだ間接化の中でも言語機能による特殊なケースを処理するものです。これ以上の間接化を処理しようとすることは、前項と同様の理由により提案していません。

コンパイラは、関数が戻り値としてオブジェクトを返すのかその参照（ポインタ）を返すのかを知っていて、その関数内でのローカル変数とそれを参照する（一段階の）ポインタや参照を認識しています。二段階以上の間接化を処理しようとするとローカル変数の依存関係グラフを構築する必要が出てきてしまいますが、一段階の間接化（と一部の特殊ケース）だけなら全てのコンパイラが簡単に検証できるはずです。

この提案によって、追加の静的解析ツールを必要とすることなくC++の言語内で多くのダングリング参照を防止できるようになります。完全なものではありませんが、この修正は大きな改善です。また、Cコードを（この提案を実装した）C++としてコンパイルすることで、Cのポインタの安全性を検証することもできるなど、C/C++エコシステム全体の改善に貢献することができます。

- [P2740 進行状況](https://github.com/cplusplus/papers/issues/1433)

### [P2741R0 user-generated `static_assert` messages](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2741r0.pdf)

`static_assert`の診断メッセージ（第二引数）に、コンパイル時に生成した文字列を指定できるようにする提案。

`static_assert`の診断メッセージには現在文字列リテラルを直接指定することしかできず、定数式で生成した任意の文字列を指定することができません。これによって、コンパイル時の診断メッセージの柔軟さが損なわれています。

この提案は、`static_assert`の診断メッセージとして定数式で生成された文字列を指定してエラーメッセージとして出力可能とすることで、`static_assert`によるコンパイル時のエラー報告を改善しようとするものです。

この提案が通れば、将来的に`std::format()`を使用可能となるでしょう。

```cpp
static_assert(sizeof(S) == 1, std::format("Unexpected sizeof: expected 1, got {}", sizeof(S)));
```

ただし、この提案では`static_assert`の診断メッセージに指定可能なものを広げることをだけを念頭に置いていて、`std::format()`の`constexpr`対応については提案していません。

また、この提案によって指定可能になる文字列とは`std::string`を指すのではなく、次のような特性を持つ型の値を文字列と見做して出力可能とすることを提案しています。

- `.size()`メンバ関数を持つ
    - 戻り値型は整数型
- `.data()`メンバ関数を持つ
    - 戻り値型は`char*`か`char8_t*`のどちらか（CV修飾はあってもいい）
- 診断メッセージに指定されたオブジェクトを`msg`とすると、`[msg.data(), msg.data() + msg.size())`は有効な範囲であること

`std::string`だけでなく、`std::string_view`や`std::vector<char>`なども使用可能です。

- [P2741 進行状況](https://github.com/cplusplus/papers/issues/1434)

### [P2742R0 indirect dangling identification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2742r0.html)

戻り値の参照やポインタの有効期間が別の変数の生存期間に依存していることを表明する属性の提案。

この提案は、関数の戻り値で発生するダングリング参照の防止・削減を目的としており、上の方で出ていたP2724R0やP2730RO、P2740R0とよく似た目的で同じ作者による提案です。

この提案では、`parameter_dependency`という新しい属性を提案していて、これは`dependent`引数として文字列でその有効期間が他に依存しているものを指定し、`providers`引数に文字列で依存先のものを指定します。`"return"`で戻り値を指定することができるほか、依存先として`"this"`で`*this`オブジェクトを指定できます。

```cpp
[[parameter_dependency(dependent{"return"}, providers{"this", "left", "right", "first", "second", "last"})]]
```

`providers`引数は文字列の配列で、`dependent`1つにつき複数の依存先を指定できます。

`parameter_dependency`属性は関数（フリー関数及びメンバ関数）に指定するもので、これによって`dependent`に指定したものの有効期間が`providers`に指定したものの生存期間に依存していることを表明します。

```cpp
// 戻り値の参照の有効期間は引数iに依存している
[[parameter_dependency(dependent{"return"}, providers{"i"})]]
int& f(bool b, int& i) {
  static int s;
  if (b) {
    return s;
  } else {
    return i;
  }
}

// 戻り値の参照の有効期間は引数left/rightに依存している
[[parameter_dependency(dependent{"return"}, providers{"left", "right"})]]
int& g(bool b, int& left, int& right) {
  if (b) {
    return left;
  } else {
    return right;
  }
}

class Car {
private:
  Wheel wheels[4];
public:
  // 戻り値の参照の有効期間は*thisオブジェクトに依存している
  [[parameter_dependency(dependent{"return"}, providers{"this"})]]
  const Wheel& getDriverWheel() const {
    return wheels[0];
  }
}
```

この属性は参照とオブジェクトの依存関係を手動で表明するものであって、その依存関係を確立し参照が参照しているオブジェクトの生存期間を延長するものではありません。

このような属性はライブラリのAPIにおいてドキュメントや仕様記述として使用できます。ヘッダオンリーなライブラリであれば静的解析など他の手段によってその依存関係を知ることができるかもしれませんが、翻訳単位が分かれている場合のABI境界の関数宣言においてはこのような属性の有効性は高まります。

また、コンパイラや静的解析ツールがこの属性を認識することで、ライフタイム解析の手助けをすることができます。例えば先ほどの`Car::getDriverWheel()`では

```cpp
const Wheel& f() {
  Car local;
  return local.getDriverWheel();  // error?
}
```

この属性が無い（無視される）場合、`getDriverWheel()`から返される参照の有効期間は分からず、追加の解析なしではこの例が正しいのかどうかを判断できません（ABI境界の向こう側に実装がある場合、そのような解析は不可能かもしれない）。しかし、`parameter_dependency`属性によって戻り値は`*this`の生存期間に依存していることがわかるため、`*this`すなわちローカルの`Car`オブジェクト`local`の寿命に依存していることがわかり、コンパイラや静的解析器はこの関数の外側にその戻り値を持ち出すのは間違っていることを認識できるかもしれません。

上の方のP2740R0ではローカル変数依存関係の解析が必要となるため困難だった多段階の間接化によるダングリング参照生成も、この提案による属性指定によって手動ではありますがコンパイラが認識可能になるかもしれません。また、これはポインタでも機能し、C23からは属性構文がC++と同等になったため、この属性をCとの共通コードに書くこともでき、間接的にCコードの安全性向上にも役立つ可能性があります。

- [P2742 進行状況](https://github.com/cplusplus/papers/issues/1435)

### [P2743R0 Contracts for C++: Prioritizing Safety - Presentation slides of P2680R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2743r0.pdf)
### [P2746R0 Deprecate and Replace Fenv Rounding Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2746r0.pdf)

浮動小数点環境の丸めモード指定関数`std::fesetround()`を非推奨化して置き換える提案。

`std::fesetround()`には次のような問題があり、移植可能でも効果的でもないようです

1. `FENV_ACCESS`を`#pragma`していない場合、コンパイラは丸めモードを無視した最適化を実行する。しかし、そのマクロはC++ではサポートされていないため、C++では`fesetround()`が正しく動作することを保証できない
2. 丸めモードを変更した状態で、標準の数学関数やユーザー定義関数を呼び出した結果は一貫性が無く、予測可能ではない
3. 丸めモードはコードの領域に対して指定するのではなく、それぞれの演算に対して指定する必要がある
4. 様々な丸めモードを試すことで浮動小数点数の誤差をある程度把握することができるが、3と同じ理由によりそれはランダムに結果を擾乱するよりもわずかにマシ程度のもの
    - また、プログラムロジックが丸めモードに依存している場合やコードが丸めモードを変更している場合、このアプローチはうまくいかない
5. コンパイラは定数式においては丸めモードを無視する傾向にあり、プログラマが実際の結果を予測することを困難にしている
6. もし丸めモードを適用したうえで結果を確定させたいならば、定数式においても丸めモードを考慮しなければならない。しかし、これはCでは禁止されている
7. 特にC++では、そもそも正しく丸められていない演算に対する丸めモードの意味が不明確。IEEE標準は正しい丸めを要求しているが、C++実装は適合していない

Cの`FENV_ROUND`も`std::fesetround()`よりは良い振る舞いをしますが、結局上記のいずれかは問題となります。

これらの理由により、`std::fesetround()`は実際にはほとんど使用されていません。想定されるユースケースは区間演算や、それのように計算結果の上限と下限を得る必要がある場合ですが、そのような用途はあまり一般的ではありません。また、`fenv.h`はC++と相性が悪く、Cの改訂に追いついておらず、Cでさえその有用性が疑問視されているようです。

特に、この機能は数学関数の`constexpr`化の作業の際に多くの問題を引き起こしており、全ての数学関数は`fesetround()`による暗黙の丸めモード引数を持ってしまっており、この値はコンパイラによって予測不可能となるため、ユーザーが期待する最適化を混乱させることになります。C++では、数学ライブラリが丸めモードを尊重すべきかどうか、あるいは非標準の丸めモードにおいて合理的なことを行うべきかが不透明です。

このような理由から、この提案では`std::fesetround()`と`std::fegetround()`を非推奨にしたうえで、IEEE標準の指定する正しい丸めに従った浮動小数点演算結果を生成する代替機能を追加することを提案しています。

提案する代替機能は`correctly_rounded`というクラスで、メンバ関数としてIEEE準拠の浮動小数点演算を行う各種関数が提供されます。

```cpp
template<floating_point F>
class correctly_rounded {

  explicit correctly_rounded(F plain_value);
  // Other expected constructors, destructor, assignment;
  F to_plain() const;
   
  ...

  // IEEE準拠の四則演算
  correctly_rounded<F> operator+(correctly_rounded<F> y) const;

  template<float_round_style r = round_to_nearest>
  correctly_rounded<F> add(correctly_rounded<F> y) const;
  
  correctly_rounded<F> operator*(correctly_rounded<F> y) const;
  
  template<float_round_style r = round_to_nearest>
  correctly_rounded<F> multiply(correctly_rounded<F> y) const;
  
  ...

  // IEEE準拠の数学関数
  template<float_round_style r = round_to_nearest>
  correctly_rounded<F> sqrt() const;
  
  ...
};

correctly_rounded<double> operator"" _d_round_to_nearest(const char
*);
correctly_rounded<double> operator"" _d_round_toward_infinity(const
char *);
```

`correctly_rounded<F>`は浮動小数点数型`F`の値をラップして、正しい丸めを行う各種操作を提供するクラスです。コンストラクタに値を渡すか、ユーザー定義リテラルを使用して生成し、各種演算の際に非型テンプレートパラメータとして`float_round_style`の値をしていすることで丸めモードをコンパイル時に指定します。

- [`std::fesetround()` - cpprefjp](https://cpprefjp.github.io/reference/cfenv/fesetround.html)
- [`<cfenv>` - cpprefjp](https://cpprefjp.github.io/reference/cfenv.html)
- [FENV_ACCESS | Programming Place Plus　Ｃ言語編　標準ライブラリのリファレンス](https://programming-place.net/ppp/contents/c/appendix/reference/FENV_ACCESS.html)
- [P2746 進行状況](https://github.com/cplusplus/papers/issues/1437)

### [P2747R0 Limited support for `constexpr` `void*`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2747r0.html)

定数式において、`void*`からポインタ型への変換を許可する提案。

現在、定数式においては`void*`型のポインタを任意の`T*`にキャストすることは明示的に禁止されており、仮にそのポインタが正しく`T`のオブジェクトを指している場合でも許可されません。

このルールは定数式において不正なポインタの読み替え（*type punning*）が起こらないようにするためであり、`constexpr`をC++の安全なサブセットとする方針に基づいたものです。ただし、`void*`空の変換がいつも危険というわけではなく、中には安全と分かっているものもあり、一律に禁止されていることによっていくつかの便利なツールをコンパイル時に使用できなく居しています。

- 型消去ユーティリティ
    - 例えば、`function_ref`は型消去して保持している呼び出し可能なものへのポインタを復帰するために`void*`空の変換が必要
- 配置`new`
    - 配置`new`はオブジェクトを構築する領域ポインタを`void*`で受ける
    - `std::construct_at()`では`new`式で可能な全ての初期化をカバーできておらず（デフォルト初期化できないなど）、コピー省略を妨げる
- オブジェクトの遅延初期化（未初期化配列など）
    - 配置`new`が必要となる
    - 配置`new`回避のためには未初期化オブジェクトが問題となる
    - 現在、`static_vector`の`constexpr`対応で問題となっている

これらのユースケースのサポートのために、この提案では現在定数式で`void*`から`T*`へのキャストを禁止している一文を削除することで、`void*`からのポインタの復帰を定数式でも可能とすることを提案しています。

ただし、`void* -> T*`への変換を行うポインタは予め`T*`から`static_cast<void*>`で得られたものである必要があり、他の場合は許可されません。すなわち、ポインタが実際に指すオブジェクトの型に応じたポインタ型への変換のみを許可し、*type punning*のようなことを可能にするわけではありません。

また、未初期化配列（遅延初期化可能な`T`の配列）サポートのために、`union`のメンバとなっている配列に対する配置`new`が暗黙的に配列全体の生存期間を開始することも提案しています。

この提案の想定される実装上の懸念は、そのようなポインタ変換を検証するコストです。定数式におけるポインタの追跡コストが高くつくようになってしまうと、コンパイル時間の増大を招きます。しかし、`void* -> T*`への変換が禁止されていることによって型消去ユーティリティや配置`new`などを直接的に利用できないために、それが必要となった時に個別に`std::construct_at`のようなものを導入する必要があります。このコスト（規格化やコンパイラ実装の手間）に比べれば、この提案を実装するコストは低いと筆者の方は主張しています。

- [P2747 進行状況](https://github.com/cplusplus/papers/issues/1438)

### [P2748R0 Disallow Binding a Returned glvalue to a Temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2748r0.html)
### [P2750R0 C Dangling Reduction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2750r0.html)

Cの言語機能の範囲で発生するダングリングポインタを抑制する提案。

これは、上の方で出ていたP2724R0やP2730R0、P2740R0、P2742R0の内容を参照ではなくポインタに対して適用するものです。そちらの提案でも同様のソリューションはポインタに対しても提案しているので内容はほぼ同一です。この提案はそれらの提案からCのポインタ向けの部分をまとめたもののようです。

この提案で提案されている事をまとめると次のようなものです

1. ポインタの寿命が尽きる前にその参照するオブジェクトの寿命が尽きる場合、オブジェクトのアドレスをポインタに代入できない
    - ポインタを返す関数から、ローカル変数のポインタを直接`return`する場合をコンパイルエラーにする
    - 同様のことが関数内のローカルスコープで起こる場合をエラーにする
2. 1段階の間接化を処理
    - ポインタを返す関数から、ローカル変数の構造体メンバのポインタを直接`return`する場合をエラーにする
    - ポインタを返す関数から、ローカル変数へのポインタが代入されたポインタ変数を`return`する場合をエラーにする
3. `parameter_dependency`属性の導入
4. 一時オブジェクトの寿命を複合リテラルの寿命（*variable scope*）と同じにする
5. ローカル定数一時オブジェクトが必ず定数化されるようにする
    - `const`な一時オブジェクトがコンパイラによって定数化されるかもしれない、となっているところを定数化される、と変更する

1の例

```c
int* f() {
  return & 1;     // エラー
}

int* g() {
  int local = 1;
  return &local;  // エラー
}

struct Point {
  int x;
  int y;
};

Point* h() {
  Point local = {1, 3};
  return &local;  // エラー
}

void i(bool b, int i) {
  int* p = nullptr;

  if (b) {
    static int s = 0;
    p = &s;  // OK
  } else {
    int i = 0; 
    p = &i;  // エラー
  }
  
  ...
}
```

2の例

```c
struct Point {
  int x;
  int y;
};

int* f() {
  Point local = {1, 3};
  return &local.y;  // エラー
}

Point* f() {
  Point local = {1, 3};
  Point* p = &local;
  return p;         // エラー
}
```

3の例

```cpp
struct Point {
  int x;
  int y;
};

[[parameter_dependency(dependent{"return"}, providers{"point"})]]
Point* obfuscating_f(Point* point) {
  return point;
}

Point* f() {
  Point local = {1, 3};
  return obfuscating_f(&local); // エラー
}
```

4の例

```c
void f() {
  int* i = &5;  // or uninitialized

  if (whatever) {
    i = &7;
  } else {
    i = &9;
  }

  // iを安全に使用できる（間接参照も含めて）
}
```

5の例

```c
const int* f() {
  return & 1;   // ダングリングではない、グローバル変数と同等
}

const int* f() {
  const int local = 1;
  return &local;  // ダングリングではない、グローバル変数と同等
}

struct Point {
  int x;
  int y;
};

const Point* f() {
  const Point local = {1, 3};
  return &local;  // ダングリングではない、グローバル変数と同等
}

struct Point {
  int x;
  int y;
};

const int* f() {
  const Point local = {1, 3};
  return &local.y;  // ダングリングではない、グローバル変数と同等
}
```

- [P2750 進行状況](https://github.com/cplusplus/papers/issues/1440)

### [P2751R0 Evaluation of Checked Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2751r0.pdf)
### [P2752R0 Static storage for braced initializers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2752r0.html)
### [P2756R0 Proposal of Simple Contract Side Effect Semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2756r0.pdf)
### [P2757R0 Type checking format args](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2757r0.html)
### [P2758R0 Emitting messages at compile time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2758r0.html)
### [P2759R0 DG Opinion on Safety for ISO C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2759r0.pdf)
### [P2762R0 Sender/Receiver Interface For Networking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2762r0.pdf)
### [P2763R0 `layout_stride` static extents default constructor fix](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2763r0.html)
### [P2764R0 SG14: Low Latency/Games/Embedded/Finance/Simulation virtual meeting minutes 2023/01/11](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2764r0.pdf)
### [P2765R0 SG19: Machine Learning Virtual Meeting Minutes 2022/12/08-2023/01/12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2765r0.pdf)
### [P2766R0 SG16: Unicode meeting summaries 2022-10-12 through 2022-12-14](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2766r0.html)
### [P2769R0 get_element customization point object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2769r0.html)
