# ［C++］WG21月次提案文書を眺める（2022年09月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2022-09](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/#mailing2022-09)

全部で29本あります。

[:contents]

### [N4917 Working Draft, Standard for Programming Language C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4917.pdf)

C++23のワーキングドラフト第7弾。

### [N4918 Editors’ Report - Programming Languages – C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4918.html)

↑の変更点をまとめた文書。

7月の会議で採択された提案とコア言語/ライブラリのIssue解決が適用されています。

### [N4919 Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n4919.pdf)

C++23のCommittee Draft

### [N4920 Working Draft, C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4920.html)

次期標準ライブラリ機能候補の実装経験を得るためのTSである、Library Fundamental TS v3のドラフト文書。

### [N4921 Editor’s Report: C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4921.html)

↑の変更点を記した文書。

この版での変更は、typoの修正などです。

### [N4922 INCITS C++/WG21 agenda: 7-12 November 2022, Kona, HI US](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4922.html)

11月に行われる予定の、WG21全体会議のアジェンダ。

### [P0543R2 Saturation arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0543r2.html)
### [P0792R11 function_ref: a non-owning reference to a Callable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0792r11.html)
### [P0957R9 Proxy: A Polymorphic Programming Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0957r9.pdf)
### [P0987R1 `polymorphic_allocator` instead of type-erasure](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0987r1.pdf)

`std::function`に`std::pmr::polymorphic_allocator`によるアロケータサポートを追加する提案。

`std::function`のアロケータサポートはそれが実装されなかったことからC++14で削除されており、現在の`std::function`はアロケータのカスタマイズができなくなっています。一方、Library Fundamental TS v3にある`std::experimental::function`にはアロケータを受け取るコンストラクタとアロケータを型消去して保持するためのユーティリティが存在しています。

この提案は、そのLFTSv3にある`std::experimental::function`のアロケータサポートを専用の型消去アロケータではなくC++20で導入された`std::pmr::polymorphic_allocator<>`で置き換えるものです。


現在のLFTSv3にある`std::experimental::function`のコンストラクタは次のようになっています。

```cpp
template<class F, class A> 
function(allocator_arg_t, const A&, F);
```

ここの`F, A`の2つのパラメータはクラステンプレートには現れていません。ここでは2つの型の型消去が必要となり実装が複雑になります。また、現在のLFTSv3にある型消去アロケータはそれを受け取る他のオブジェクト（ここでは`std::experimental::function`）の領域内にうまく配置（スペースの節約）することができるようにより複雑になっています。

この提案はこれを次のように置き換えます

```cpp
template<class F> 
function(allocator_arg_t, const pmr::polymorphic_allocator<>&, F);
```

また同時に、現在使用しているアロケータを取得するためのインターフェースも追加します。

```cpp
polymorphic_allocator<> get_allocator() const noexcept;
```

`std::pmr::polymorphic_allocator<>`を用いることでアロケータの型消去と複雑な型消去アロケータが不用になり実装が簡単になります。また、この提案ではこの`std::pmr::polymorphic_allocator<>`の保持方法を特に指定しないため、単にメンバとして保持するのではなく型消去のための領域に保持するなどの効率化が図れます。

- [P0987 進行状況](https://github.com/cplusplus/papers/issues/1299)

### [P1030R5 std::filesystem::path_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1030r5.pdf)
### [P1985R3 Universal template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1985r3.pdf)
### [P2348R3 Whitespaces Wording Revamp](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2348r3.pdf)
### [P2495R1 Interfacing stringstreams with string_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2495r1.pdf)
### [P2586R0 Standard Secure Networking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2586r0.pdf)

Networking TSに代わる、セキュアネなットワークライブラリの提案。

この提案は次のような特徴があります

- TLSがデフォルト
- 動的メモリ確保を使用しない
- 例外を使用しない
- スレッドローカルストレージを使用しない
- 暗号化やTLSの詳細について指定しない
    - TLSネットワーク機能をコプロセッサにオフロードするような組み込み環境でも使用可能なように設計されている
    - TLSバックエンドを再コンパイルせずに入れ替えられる

また、この提案は現在のところ、非同期やコルーチン対応を含んでいないため（asioで問題となった）P2300とはあまり関連がありません。

HTTPSでwebページを取得するサンプル

```cpp
// 接続先のホスト
static constexpr string_view test_host = "github.com";
// HTTPリクエストペイロード
static constexpr string_view get_request = "GET / HTTP/1.0\r\nHost: github.com\r\n\r\n";

// ライブラリが推奨する、現在のプラットフォームのデフォルトTLSソケットソースを取得
// tls_socket_source_registryには異なるプロパティによって様々なTLSソケットソースが登録される
// tls_socket_source_ptrはスマートポインタ型ではあるが、必ずしもヒープ領域のオブジェクトを指していない
// 参照カウントシングルトンであったり、静的なシングルトンであったりして、動的確保を要求しない
// この提案の他の部分でも同様
tls_socket_source_ptr tls_socket_source = tls_socket_source_registry::default_source().instantiate().value();

// TLSソケットソースから、多重化可能な接続ソケットを作成する
// 多重化可能とは、1つのソケットによって異なるスレッドから複数のI/Oを実行可能であることを意味する
// 例えば、Linuxではnon-blocking、WindowsではOVERLAPPED
tls_byte_socket_ptr sock = tls_socket_source->multiplexable_connecting_socket(ip::family::any).value();
{
  // 接続先ホストの443番ポートへ接続する、タイムアウトは5秒
  // デフォルトでは、ローカルシステムの証明書ストアを使用して接続先ホストの証明書を検証する
  // この関数は利便性のためのAPIであり、接続の各ステップは個別のAPIによって順番に実行していくこともできる
  result<void> r = sock->connect(test_host, 443, std::chrono::seconds(5));
  if (r.has_error()) {
    if(r.error() == errc::timed_out
    || r.error() == errc::host_unreachable
    || r.error() == errc::network_unreachable)
    {
      std::cout << "\nNOTE: Failed to connect to " << test_host
                << " within five seconds. Error was: " << r.error().message()
                << std::endl;
      return;
    }
    r.value(); // throw the failure as an exception
  }
}

// ここで出力される文字列は実装定義、カンマ区切りであることを提案する
std::cout << "\nThe socket which connected to " << test_host
          << " negotiated the cipher " << sock->algorithms_description() << std::endl;

// ホストへのHTTP/1.0リクエスト内容を記述するための定数バッファの作成
// tls_socket_handleではこれはstd::span<const byte>
tls_socket_handle::const_buffer_type get_request_buffer(reinterpret_cast<const llfio::byte*>(get_request.data()), 
                                                        get_request.size());

// HTTP/1.0リクエストをホストへ送信する
size_t written = sock->write({get_request_buffer}).value();
// 結果のテスト（事後条件）
TEST_REQUIRE(written == get_request.size());

// リクエスト結果（githubフロントページ）を取得
// HTTP/1.0の動作として、すべてのデータが送信されると接続が閉じられ、read()は0を返す
std::vector<byte> buffer(4096);
size_t offset = 0;

for (size_t nread = 0; (nread = sock->read({{buffer.data() + offset, buffer.size() - offset}}, 
                                           std::chrono::seconds(3)).value()) > 0;)
{
  offset += nread;
  if (buffer.size() - offset < 1024) {
    buffer.resize(buffer.size() + 4096);
  }
}
buffer.resize(offset);

// 取得した結果の出力（最初の1024バイト分）
std::cout << "\nRead from " << test_host << " " << offset
          << " bytes. The first 1024 bytes are:\n\n"
          << std::string_view(reinterpret_cast<const char*>(buffer.data()), buffer.size()).substr(0, 1024) << "\n" << std::endl;

// TLS接続をシャットダウンし、ソケットを閉じる
sock->shutdown_and_close().value();
```

提案には他にも、多重化されたTLSサーバとサードパーティーのソケット実装をTLSでラップするサンプルが記載されています。

この提案は、昨年の秋ごろにLEWGにおいてC++標準ネットワークライブラリとしてasioの追求を（一旦）停止することを決定した後に、LEWGの数人のメンバから、LEWGの歴史的な懸念事項に応える標準ネットワークの提案を考案するように依頼されて書かれたもののようです。

この提案の内容は著者自身によって参照実装がなされており、そこではLLFIOというライブラリの一部としてGCC/clang/MSVC等C++14以上のコンパイラによってx86/x64/ARM環境で動作することが確かめられているようです。ただし、LLFIOというライブラリそのものは数年の実装・実用経験を持っているものの、この参照実装はこの提案のためにかかれたもので実装経験としては弱いとも注記されています。

- [llfio/tls_socket_handle.hpp - ned14/llfio](https://github.com/ned14/llfio/blob/develop/include/llfio/v2.0/tls_socket_handle.hpp)
- [LLFIO tls_socket_handle.hpp File Reference](https://ned14.github.io/llfio/tls__socket__handle_8hpp.html)
- [P2586 進行状況](https://github.com/cplusplus/papers/issues/1300)

### [P2587R3 to_string or not to_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2587r3.html)
### [P2588R1 Relax std::barrier phase completion step guarantees](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2588r1.html)
### [P2603R1 member function pointer to function pointer](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2603r1.html)
### [P2620R2 Improve the wording for Universal Character Names in identifiers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2620r2.pdf)
### [P2623R2 implicit constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2623r2.html)
### [P2631R0 Publish TS Library Fundamentals v3 Now!](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2631r0.html)

Library Fundamental TS v3を正式に発効するよう促す提案。

現在のLibrary Fundamental TSはv2が正式に発効された最後のもので、C++14をベースとして2016年に発行されました。発効後の6年間、LWGはこのv2をベースとして機能の追加や調整などを行っており、それはLFTSv3としてドラフト文書になっています。しかし、それはまだ正式なTSとして発行されていません。

この提案は、LFTSv3のベースをC++20に改訂するとともにLFTS関連の作業をいったん終了させ、C++23 DISよりも前にLFTSv3を正式なTSとして発効することを目指すものです。

LFTSv2からは`any`や`optional`、`string_view`など多くのものが既にC++標準に導入されている一方で、新しく追加されたものは`scope_exit`や`unique_resource`など少数で、かなり規模としては小さくなっています。

- [P2631 進行状況](https://github.com/cplusplus/papers/issues/1301)

### [P2636R0 References to ranges should always be viewable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2636r0.html)

ムーブオンリーな`range`の左辺値参照を`viewable_range`となるようにする提案。

例えば次のようなコードは、当初のC++20とその実装において全ての種類の`forward_range`に対して有効でした

```cpp
void foobar(ranges::forward_range auto && r) {
  auto v = r | views::take(3);
}
```

しかし、その後の[P2415](https://wg21.link/p2415)による変更の後、ムーブオンリーな`range`の左辺値参照の入力に対してコンパイルエラーを起こすようになります。例えば`foobar(std::views::all(std::vector<int>{1, 2, 3, 4}));`などとすると観測できます。

`<ranges>`のパイプライン演算子（`|`）は左辺にくる入力に対して`viewable_range`であることを要求しますが、ムーブオンリーな`range`の左辺値参照は`viewable_range`とならないため（ならなくなったため）にエラーとなります。

より詳しくみてみると

まず左辺値参照からの`view`の構築の場合

```cpp
{
  string_view s{"foobar"};
  auto v = s | views::take(3);  // sはdecay_copyされる
}
{
  string s{"foobar"};
  auto v = s | views::take(3);  // sはref_viewで参照される
}
{
  Generator g{};  // コピー不可なrange
  auto v = g | views::take(3);  // sはref_viewで参照される
}
{
  GeneratorView g{};  // viewとなるGenerator
  auto v = g | views::take(3);  // error
}
```

ただし、4つ目のコードはP2415以前の仕様では正常にコンパイルされます。

次に左辺値参照から構築された`view`を`|`でRangeアダプタと接続する場合

```cpp
{
  string_view s{"foobar"};
  auto v1 = s | views::take(3);           // sはdecay_copyされる
  auto v2 = v1 | views::transform(/**/);  // v1はdecay_copyされる
}
{
  string s{"foobar"};
  auto v1 = s | views::take(3);           // sはref_viewで参照される
  auto v2 = v1 | views::transform(/**/);  // v1はdecay_copyされる
}
{
  Generator g{};  // コピー不可なrange
  auto v1 = g | views::take(3);           // sはref_viewで参照される
  auto v2 = v1 | views::transform(/**/);  // v1はdecay_copyされる
}
{
  GeneratorView g{};  // viewとなるGenerator
  auto v1 = g | views::take(3);           // error
  auto v2 = v1 | views::transform(/**/);
}
```

エラーの理由は1つ前と同様です。

次に、右辺値`range`からの`view`の構築の場合

```cpp
{
  auto v = string_view{"foobar"} | views::take(3);  // string_viewはdecay_copyされる
}
{
  auto v = string{"foobar"} | views::take(3); // stringはowning_viewに保存される
}
{
  auto v = Generator{} | views::take(3);  // Generatorはowning_viewに保存される
}
{
  auto v = GeneratorView{} | views::take(3);  // GeneratorViewはdecay_copy（ムーブ）される
}
```

そして、右辺値`range`から構築された`view`を`|`でRangeアダプタと接続する場合

```cpp
{
  auto v1 = string_view{"foobar"} | views::take(3); // string_viewはdecay_copyされる
  auto v2 = v1 | views::transform(/**/);            // v1はdecay_copyされる
}
{
  auto v1 = string{"foobar"} | views::take(3); // stringはowning_viewに保存される
  auto v2 = v1 | views::transform(/**/);       // error
}
{
  auto v1 = Generator{} | views::take(3);  // Generatorはowning_viewに保存される
  auto v2 = v1 | views::transform(/**/);   // error
}
{
  auto v1 = GeneratorView{} | views::take(3);  // GeneratorViewはdecay_copy（ムーブ）される
  auto v2 = v1 | views::transform(/**/);       // error
}
```

ここの2~4番目の`v2`はムーブオンリーな`view`です。

これらの4パターンのコード例中でエラーとなっているのは、ムーブオンリーな左辺値`view`をRangeアダプタに入力しようとしているためです。この提案は、これらのエラーを修正しようとするものです。

この提案による修正は、左辺値ムーブオンリー`range`が`viewable_range`となるように`viewable_range`の定義を修正するとともに、`views::all`が左辺値ムーブオンリー`range`に対しては`ref_view`を生成するようにします。

```cpp
namespace std::ranges {
  template<class T>
  concept viewable_­range =
    range<T> &&
    ((view<remove_cvref_t<T>> && constructible_­from<remove_cvref_t<T>, T>) ||
    //(!view<remove_cvref_t<T>> && (is_lvalue_reference_v<T> || (movable<remove_reference_t<T>> && !is-initializer-list<T>))));
    is_lvalue_reference_v<T> || (movable<remove_reference_t<T>> && !is-initializer-list<T>));
}
```

- [P2636 進行状況](https://github.com/cplusplus/papers/issues/1302)

### [P2637R0 Member `visit` and `apply`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2637r0.html)

`std::visit`や`std::apply`などをメンバ関数として追加する提案。

`std::visit`1つの*Callable*と1つ以上の`std::variant`オブジェクトをとって、`std::variant`オブジェクトが実際に保持している型に応じたディスパッチを行う可変長関数テンプレートです。しかし、`std::visit`の多くのユースケースは1つの`std::variant`による単項のディスパッチです。その場合、メンバ関数として実装してあったほうが使いやすいように思えます。

`std::visit`が非メンバ関数として定義されている理由の一つは、`const`と値カテゴリの適切な転送を行うための最適な方法だったことがあります。これをメンバ関数で行おうとすると、`const`有無と値カテゴリによって4つのオーバーロードが必要となってしまい、実装が複雑化します。

ところが、C++23ではまさにこの問題を解決する機能であるDeducing `this`（[P0847R7](https://wg21.link/p0847r7)）が導入されたため、そのようなハンドリングを1つのメンバ関数のみで行うことができるようになっています。

この提案は、Deducing `this`を利用して`std::visit`等の非メンバ関数テンプレートをメンバ関数として追加しようとするものです。

`std::visit`と同じ理由から非メンバ関数として定義されているものに`std::apply`があり、`std::visit`のインターフェースに合わせるためだけに非メンバ関数として定義されているものに[`std::visit_format_arg`](https://cpprefjp.github.io/reference/format/visit_format_arg.html)があります。この提案ではこれらのものも対象にしています。この提案で追加するメンバ関数と追加対象は次のものです

- `.visit()`
    - `std::variant`
    - `std::basic_format_arg`
- `.apply()`
    - `std::pair`
    - `std::tuple`
    - `std::array`
    - `std::ranges::subrange`

例えば`std::variant::visit()`は次のように簡単に実装可能です

```cpp
namespace std {
  template <class... Types>
  class variant {
  public:
    ...

    // Deducing thisによるメンバvisit()の実装例
    template <class Self, class Visitor>
      requires convertible_to<add_pointer_t<Self>, variant const*>
    constexpr auto visit(this Self&& self, Visitor&& vis) -> decltype(auto) {
      return std::visit(std::forward<Visitor>(vis), std::forward<Self>(self));
    }
  };
}
```

- [P2637 進行状況](https://github.com/cplusplus/papers/issues/1303)

### [P2638R0 Intel's response to P1915R0 for std::simd parallelism in TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2638r0.pdf)
### [P2639R0 Static Allocations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2639r0.pdf)
### [P2640R0 Modules: Inner-scope Namespace Entities: Exported or Not?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2640r0.pdf)
### [P2641R0 Checking if a union alternative is active](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2641r0.html)
### [P2642R0 Padded mdspan layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2642r0.html)
### [P2643R0 Improving C++ concurrency features](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2643r0.html)
