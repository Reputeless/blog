# ［C++］WG21月次提案文書を眺める（2022年09月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2022-09](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/#mailing2022-09)

全部で80本あります。

[:contents]

### [N4923 Working Draft, Extensions to C++ for Transactional Memory Version 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4923.pdf)

P2066ベースの最小トランザクショナルメモリのTechnical Specifications。

差分は下の方のP2682R0の項を参照。

### [P0592R5 To boldly suggest an overall plan for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0592r5.html)

C++26に向けて、具体的に取り組むべき項目についての文書。

P2000はC++の大まかな方向性を指し示すような文書ですが、これはより具体的に次の3年間の作業項目（の内最高優先度のもの）をリストアップするものです。

C++26に向けて取り組むべきものとしては次のものが挙げられています

- C++26入りを目指すもの
    - Execution（[P2300](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2300r5.html)）
    - Rangesの改善（[P2214](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2214r1.html)）
    - Reflection（[P2237](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2237r0.pdf)）
- C++26作業期間中に進捗させるもの
    - 契約
    - パターンマッチ

コルーチンのライブラリサポートはExecutionに含まれており、ネットワークはExecutionとの親和性などの問題から一旦ストップしています。また、特別に優先されてはいませんが線形代数ライブラリの提案も順調に進行しています。

### [P0876R11 `fiber_context` - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0876r11.pdf)

スタックフルコルーチンのための`fiber_context`の提案。

C++20で導入されたコルーチンはスタックレスコルーチンのための言語基盤とライブラリ機能のみでした。この提案はそれに加えてスタックフルコルーチンを導入しようとするものです。

コルーチンではコルーチンの中断・再開のためにコルーチンフレームという保存領域を必要とします。ここにはコルーチン引数やコルーチン内部の自動変数が保存されており、コルーチンが終了しコルーチンハンドルが解放されるまで複数回の中断・再開を跨いで1つの状態を維持しています。

スタックレスコルーチンではコルーチンフレームにコールスタックが保存されていないことから、コルーチン内部でネストした関数呼び出し内部からコルーチンを中断することができません（スタックレスコルーチンは、コルーチンフレームに状態を維持してそれを利用していること以外は通常の関数呼び出しと同じように処理されています）。対してスタックフルコルーチンは、コルーチンフレームに加えてコールスタックも独自に保持していることによって、コルーチン内部でネストした関数呼び出し内からでも中断することができます。

これによって、スタックフルコルーチンは任意のタイミングでコルーチンを中断/再開することができるようになり利便性が増しますが、デメリットとして呼び出しに伴うスタックをほぼ全て自前で用意し利用するため、生成や維持が高コストになります。また、スタックフルコルーチンはその特性から言語機能を必要とせずにライブラリ機能として実装可能で、この提案もコア言語に対する追加・変更を含んでいません。

ここで導入しようとしてるのは`fiber_context`というクラス型のみで、これはBoost.Contextに相当するスタックフルコルーチン（提案の用語では専らファイバー（*fiber*））アプリケーションのための基盤となる機能です。ちょうど、C++20でスタックレスコルーチンの基盤となる言語とライブラリ機能のみが整備されたのと同じ感じです。

```cpp
// fiber_contextの宣言例
namespace std::experimental::inline concurrency_v2 {
  class fiber_context {
  public:
    fiber_context() noexcept;

    template<typename F>
    explicit fiber_context(F&& entry);

    ~fiber_context();

    fiber_context(fiber_context&& other) noexcept;
    fiber_context& operator=(fiber_context&& other) noexcept;
    fiber_context(const fiber_context& other) noexcept = delete;
    fiber_context& operator=(const fiber_context& other) noexcept = delete;

    fiber_context resume() &&;

    template<typename Fn>
    fiber_context resume_with(Fn&& fn) &&;

    // stop token handling
    [[nodiscard]] stop_source get_stop_source() noexcept;
    [[nodiscard]] stop_token get_stop_token() const noexcept;
    bool request_stop() noexcept;

    bool can_resume() noexcept;
    explicit operator bool() const noexcept;
    bool empty() const noexcept;

    void swap(fiber_context& other) noexcept;

  private:
    stop_source ssource; // exposition only
  };
}
```

`fiber_context`はコンテキストスイッチ（すなわち、コルーチンの中断と再開）のための最小限の機能を持つクラスです。どのようにコンテキストスイッチを行うかという部分はこれを用いてユーザーが指定するものであるため、スケジューラの機能も含まれてはいません。また、`fiber_context`は内部でスタックフルコルーチンのためのスタック等を保持しているためコピーは危険であり、ムーブオンリーなクラスとされています。

基本的には`.resume()`によって操作します。あるコルーチン中で`fc.resume()`を呼ぶと現在のコルーチンは中断し`fc`のコルーチンが再開します。

さらに、[`std::jthread`](https://cpprefjp.github.io/reference/thread/jthread.html)と同様の[`std::stop_source`](https://cpprefjp.github.io/reference/stop_token/stop_source.html)/[`std::stop_token`](https://cpprefjp.github.io/reference/stop_token/stop_token.html)による協調的キャンセル機構を備えていることで、そのコンテキスト上の処理のキャンセルを行うことができます（ただし、実際にそれを行うのは処理を定義するユーザーの責任です）。

提案文書より、STLアルゴリズムを使用する例

```cpp
int maine() {
  // 生成された値をやり取りする中間変数
  int a;

  autocancel consumer, generator;

  // フィボナッチ数列を生成する
  generator = autocancel{[&a, &consumer, &generator](std::fiber_context&& m){
    a = 0;
    int b = 1;

    while (! generator.stop_requested()){
      // generatorを中断し、consumerを再開する
      generator.resume(consumer);
      
      // フィボナッチ数列の計算
      int next = a+b;
      a = b;
      b = next;
    }

    return std::move(m);
  }};

  // generatorが生成した値を出力する
  consumer = autocancel{[&a, &consumer, &generator](std::fiber_context&& m){
    std::vector<int> v(10);

    // vectorに生成した値を保存する、数はこの範囲の長さ=10
    std::generate(v.begin(), v.end(), [&a, &consumer, &generator]() mutable {
      // consumerを中断し、generatorを再開する
      consumer.resume(generator);
      return a;
    });

    std::cout << "v: ";

    for (auto i: v) {
      std::cout << i << " ";
    }

    std::cout << "\n";

    return std::move(m);
  }};

  // consumerの開始
  consumer.resume();
}
```

出力

```
v: 0 1 1 2 3 5 8 13 21 34
```

ここで使用されている`autocancel`は、`fiber_context`によって次のように実装されています

```cpp
// fiber_context上の処理を自動停止し、安全に終了させるためのRAIIラッパー
class autocancel{
private:
  std::fiber_context f_;

public:
  autocancel() = default;

  template <typename Fn>
  autocancel(Fn&& entry_function)
    : f_{std::forward<Fn>(entry_function)}
  {}

  autocancel& operator=(autocancel&& other) = default;
  
  ~autocancel() {
    // キャンセル要求を送ってから
    f_.request_stop();

    // 実行終了（fiber_contextが空になるの）を待機
    // fiber_contextが空になる=そのコンテキスト上の処理が実行中
    // request_stop()を通知しているので、その処理はそこで終了する（はず
    // fiber_contextのoperator bool()は、!f_.empty() と等価
    while (f_) {
      resume(*this);
    }
  }

  // 処理をキャンセルする
  bool stop_requested() const noexcept {
    return f_.get_stop_source().stop_requested();
  }

  // 初回に処理を開始するためのresume()
  std::fiber_context resume() {
    // これによって、一旦this->f_は空になる
    return std::move(f_).resume();
  }

  // 別のautocancelを受け取り、自身を中断しそれを再開する
  void resume(autocancel& ac) {
    // 別のautocancel（ac）を再開する
    std::move(ac.f_).resume_with([this](std::fiber_context&& f) -> std::fiber_context {
      // このラムダは、ac.f_のコンテキスの最初（再開直前）に呼ばれる
      // ここでfに渡ってくるのはthis->f_だったもの、コンテキストスイッチ時に適切に保存する
      f_ = std::move(f);

      // 空のfiber_contextを返す（これは上記例では捨てられる）
      return {};
    });
  }
};
```

あるスタックフルコルーチンが実行中である場合そのスタックフルコルーチンの`fiber_context`は空の状態（`f_.empty() == true`）になっています。`autocancel::resume()`の処理は、制御フローが予測可能でない場合に適切に`fiber_context`を伝播するためのパターンです。

`fiber_context`を用いることで、Boost.CoroutineやBoost.fiberなどのより高機能なスタックフルコルーチンアプリケーションを記述することができるようになります。[提案内にそのリスト](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0876r11.pdf#page=17&zoom=100,79,444)があり、これらのアプリケーションの存在こそがスタックフルコルーチンを標準でサポートするべき理由であり、また、この`fiber_context`のようなクラスは標準C++の範囲で移植可能なように実装することは不可能であるためこの機能を標準に用意しておくことには価値がある、と述べられています。

- [C++20 コルーチン - cpprefjp](https://cpprefjp.github.io/lang/cpp20/coroutines.html)
- [20分くらいでわかった気分になれるC++20コルーチン](https://www.docswell.com/s/yohhoy/L57EJK-cpp20coro)
- [Coroutines introduction - C++ - Panic Software](https://blog.panicsoftware.com/coroutines-introduction/)
- [Boost.Contextでファイバーライブラリを実装してみた - yohhoyの日記（別館）](https://yohhoy.hatenablog.jp/entry/2012/04/10/003735)
- [P0876 進行状況](https://github.com/cplusplus/papers/issues/117)

### [P0987R2 polymorphic_allocator instead of type-erasure](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0987r2.pdf)
### [P1061R3 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1061r3.html)
### [P1068R6 Vector API for random number generation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1068r6.pdf)
### [P1083R7 Move resource_adaptor from Library TS to the C++ WP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1083r7.pdf)
### [P1385R7 A proposal to add linear algebra support to the C++ standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1385r7.pdf)
### [P1673R10 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1673r10.html)
### [P1709R3 Graph Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1709r3.pdf)

グラフアルゴリズムとデータ構造のためのライブラリ機能の提案。

グラフデータ構造は機械学習などの科学分野やビジネスやゲームをはじめとする一般的なプログラミングにおいて非常によく使用されますが、現在のC++の標準にはグラフデータ構造とそれを利用するアルゴリズムのサポートがほぼ皆無です。機械学習の一分野であるAIが近年大きく注目を集めるなど、グラフデータ構造を扱える標準ライブラリの必要性は増しています。

この提案はグラフデータ構造とそのアルゴリズムのためのライブラリの統一的なインターフェースを提示するもので、概念実証のような段階です。

ここで提案されているAPIはおおよそ次のような感じで使用することができるものです

```cpp
using G = … <graph definition>
G g(...); // グラフの構築

for (auto& u : g) { // グラフGの頂点をイテレーション
  for (auto& uv : edges(g, u)) { // 頂点uのエッジをイテレーション
    ...; // uとuvを用いた処理
  }
}

for (auto& uv : edges(g)) { // グラフの全てのエッジをイテレーション
  auto& u = in_vertex(g, uv);  // エッジuvの頂点の一方
  auto& v = out_vertex(g, uv); // エッジuvの頂点のもう一方
  ...; // uv, u, vを用いた処理
}
```

グラフとは頂点の範囲であり、頂点はエッジの範囲を持ちます（あるいは、範囲の範囲です）。エッジに焦点を当てる場合、グラフとは2つの頂点を持つエッジの範囲でもあります。

グラフには有向グラフと無向グラフがあり、このAPIではそれらを統一的に扱うことにも重点を置いています。APIは無向グラフを基本として整備されており、有向グラフに対しては`out_`付のものを使用するようになっています。ただし、それはエイリアスによってほぼ自動で処理されており、例えば上記例の`edges(g, u)`は有向グラフに対しては`out_edges(g, u)`のエイリアスとなります。

この提案のAPIは、グラフのプロパティを問い合わせる各種エイリアステンプレートとフリー関数テンプレートを用いて構成されています。

[Wikipediaの幅優先探索のページ](https://ja.wikipedia.org/wiki/幅優先探索)にある「ドイツの都市間の接続を示した例」のグラフを構築するサンプル。

```cpp
// グラフのデータ型
struct route {
  string from;
  string to;
  int km = 0;

  route(string const& from_city, string const& to_city, int kilometers)
    : from(from_city), to(to_city), km(kilometers) {}
};

std::vector<route> routes{
  {"Frankfürt", "Mannheim", 85}, {"Frankfürt", "Würzburg", 217},
  {"Frankfürt", "Kassel", 173}, {"Mannheim", "Karlsruhe", 80},
  {"Karlsruhe", "Augsburg", 250}, {"Augsburg", "München", 84},
  {"Würzburg", "Erfurt", 186}, {"Würzburg", "Nürnberg", 103},
  {"Nürnberg", "Stuttgart", 183}, {"Nürnberg", "München", 167},
  {"Kassel", "München", 502}
};

// グラフコンテナ型
using G1 = adjacency_list<name_value, weight_value, empty_value,
                          edge_type_undirected, edge_link_double,
                          map_vertex_set_proxy>;

// グラフコンテナの構築
auto g1 = create_adjacency_list<G1>();

// グラフの構築
for (auto& r : routes) {
  create_edge(g, r.from, r.to, r.km);
}
```

これを用いて、深さ優先探索するサンプル

```cpp
dfs_vertex_range rng(g, g.find_vertex("Frankfürt"));

for (vertex_iterator_t<G> u = rng.begin(); u != rng.end(); ++u) {
  std::cout << std::string(u.depth() * 2, ' ') << u->name << std::endl;
}
```
```
Frankfürt
  Mannheim
  Karlsruhe
    Augsburg
      München
  Würzburg
    Erfurt
    Nürnberg
      Stuttgart
  Kassel
```

幅優先探索するサンプル

```cpp
bfs_vertex_range bfs_vtx_rng(g, begin(g) + 2); // Frankfürt

for (auto u = bfs_vtx_rng.begin(); u != bfs_vtx_rng.end(); ++u) {
  std::cout << std::string(u.depth() * 2, ' ') << u->name << std::endl;
}
```
```
Frankfürt
Mannheim
Würzburg
Kassel
  Karlsruhe
  Erfurt
  Nürnberg
  München
    Augsburg
    Stuttgart
```

エッジに注目して深さ優先探索するサンプル

```cpp
dfs_edge_range rng(g, begin(g) + 2); // Frankfürt

for (vertex_edge_iterator_t<G> uv = rng.begin(); uv != rng.end(); ++uv) {
  vertex_iterator_t<G> u = out_vertex(g, *uv);
  vertex_key_t<G> u_key = vertex_key(g, *u);

  if (uv.is_back_edge()) {
    std::cout << std::string(uv.depth() * 2, ' ')
              << "view " << uv.back_vertex()->name << std::endl;
  } else {
    vtx_iter_t v = out_vertex(g, *uv); // or vertex(g, *uv)
    std::cout << std::string(uv.depth() * 2, ' ') << "travel " << u->name
              << " --> " << v->name << " " << uv->weight << "km" << std::endl;
  }
}
```

```
travel Frankfürt --> Mannheim 85km
  travel Mannheim --> Karlsruhe 80km
  travel Karlsruhe --> Augsburg 250km
  travel Augsburg --> München 84km
view München
  travel Frankfürt --> Würzburg 217km
  travel Würzburg --> Erfurt 186km
    view Erfurt
  travel Würzburg --> Nürnberg 103km
  travel Nürnberg --> Stuttgart 183km
    view Stuttgart
  travel Nürnberg --> München 167km
travel Frankfürt --> Kassel 173km
travel Kassel --> München 502km
```

提案されているグラフアルゴリズムには、ダイクストラ/ベルマンフォード法、各種連結成分の抽出、関節点や推移平方の抽出のほか、`std::erase/std::erase_if`などがあります。

- [P1709 進行状況](https://github.com/cplusplus/papers/issues/476)

### [P1759R4 Native handles and file streams](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1759r4.html)
### [P1928R1 Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1928r1.pdf)

`std::simd<T>`をParallelism TS v2から標準ライブラリへ移す提案。

`std::simd<T>`を含むParallelism TS v2は2018年に発行されました。その後GCC9リリースの後、`std::simd<T>`の完全な実装（ただしGCC専用）が行われ、GCC11以降はlibstdc++の一部となっています。そして、Parallelism TS v2発行後`std::simd<T>`に対する十分なフィードバックが寄せられています。

この提案は、それらのフィードバックを`std::simd<T>`に適用しつつ、`std::simd<T>`をC++26を目指してワーキングドラフトにマージしようとするものです。

- [P2638R0 Intel's response to P1915R0 for std::simd parallelism in TS 2 - WG21月次提案文書を眺める（2022年09月）](https://onihusube.hatenablog.com/entry/2022/10/09/021557#P2638R0-Intels-response-to-P1915R0-for-stdsimd-parallelism-in-TS-2)
- [VcDevel/std-simd - Github](https://github.com/VcDevel/std-simd)
- [jfalcou/eve EVE - the Expressive Vector Engine](https://github.com/jfalcou/eve)
- [libstdc++ : simd.h](https://gcc.gnu.org/onlinedocs/gcc-12.1.0/libstdc++/api/a01088_source.html)
- [P1928 進行状況](https://github.com/cplusplus/papers/issues/670)

### [P1967R9 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1967r9.html)
### [P2000R4 Direction for ISO C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2000r4.pdf)

C++26に向けて、C++の標準化の方向性を示す文書。

この文書の内容を念頭に、各種提案の優先順位づけや新しい機能についての議論が行われることになります。

このリビジョンでの大きな変更は、中期目標（3~10年）としてより安全なC++に向けてのセクションが追加されたことです。

### [P2019R2 Usability improvements for std::thread](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2019r2.pdf)
### [P2047R4 An allocator-aware optional type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2047r4.html)
### [P2164R7 views::enumerate](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2164r7.pdf)
### [P2248R6 Enabling list-initialization for algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2248r6.html)
### [P2263R1 A call for a WG21 managed chat service](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2263r1.html)
### [P2392R2 Pattern matching using is and as](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2392r2.pdf)
### [P2505R5 Monadic Functions for std::expected](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2505r5.html)
### [P2527R1 std::variant_alternative_index and std::tuple_element_index](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2527r1.html)
### [P2530R1 Why Hazard Pointers should be in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2530r1.pdf)
### [P2539R2 Should the output of std::print to a terminal be synchronized with the underlying stream?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2539r2.html)
### [P2539R3 Should the output of std::print to a terminal be synchronized with the underlying stream?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2539r3.html)
### [P2545R1 Why RCU Should be in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2545r1.pdf)
### [P2546R2 Debugging Support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2546r2.html)
### [P2548R1 copyable_function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2548r1.pdf)
### [P2561R1 An error propagation operator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2561r1.html)
### [P2581R2 Specifying the Interoperability of Built Module Interface Files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2581r2.pdf)
### [P2592R2 Hashing support for std::chrono value classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2592r2.html)
### [P2614R1 Deprecate numeric_limits::has_denorm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2614r1.pdf)
### [P2630R1 Submdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2630r1.html)
### [P2632R0 A plan for better template meta programming facilities in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2632r0.pdf)
### [P2636R1 References to ranges should always be viewable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2636r1.html)
### [P2637R1 Member visit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2637r1.html)
### [P2640R1 Modules: Inner-scope Namespace Entities: Exported or Not?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2640r1.pdf)
### [P2641R1 Checking if a union alternative is active](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2641r1.html)
### [P2642R1 Padded mdspan layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2642r1.html)
### [P2644R0 Get Fix of Broken Range-based for Loop Finally Done](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2644r0.pdf)
### [P2646R0 Explicit Assumption Syntax Can Reduce Run Time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2646r0.pdf)
### [P2647R0 Permitting static constexpr variables in constexpr functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2647r0.html)
### [P2648R0 2022-10 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2648r0.html)
### [P2652R0 Disallow user specialization of allocator_traits](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2652r0.html)
### [P2653R0 Update Annex E based on Unicode 15.0 UAX 31](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2653r0.pdf)
### [P2655R0 common_reference_t of reference_wrapper Should Be a Reference Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2655r0.html)
### [P2656R0 C++ Ecosystem International Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2656r0.html)
### [P2657R0 C++ is the next C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2657r0.html)
### [P2658R0 temporary storage class specifiers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2658r0.html)
### [P2659R0 A Proposal to Publish a Technical Specification for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2659r0.pdf)
### [P2660R0 Proposed Contracts TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2660r0.pdf)
### [P2661R0 Miscellaneous amendments to the Contracts TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2661r0.pdf)
### [P2662R0 Pack Indexing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2662r0.pdf)
### [P2663R0 Proposal to support interleaved complex values in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2663r0.pdf)
### [P2665R0 Allow calling overload sets containing T, constT&](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2665r0.pdf)
### [P2666R0 Last use optimization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2666r0.pdf)
### [P2667R0 Support for static and SBO vectors by allocators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2667r0.pdf)
### [P2668R0 Role based parameter passing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2668r0.pdf)
### [P2669R0 Deprecate changing kind of names in class template specializations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2669r0.pdf)
### [P2670R0 Non-transient constexpr allocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2670r0.html)
### [P2671R0 Syntax choices for generalized pack declaration and usage](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2671r0.html)
### [P2672R0 Exploring the Design Space for a Pipeline Operator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2672r0.html)
### [P2673R0 Common Description Format for C++ Libraries and Packages](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2673r0.pdf)
### [P2674R0 A trait for implicit lifetime types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2674r0.pdf)
### [P2675R0 LWG3780: The Paper (format's width estimation is too approximate and not forward compatible)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2675r0.pdf)
### [P2676R0 The Val Object Model](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2676r0.pdf)
### [P2677R0 Reconsidering concepts in-place syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2677r0.pdf)
### [P2678R0 SG16: Unicode meeting summaries 2022-06-22 through 2022-09-28](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2678r0.html)
### [P2679R0 Fixing std::start_lifetime_as for arrays](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2679r0.pdf)
### [P2680R0 Contracts for C++: Prioritizing Safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2680r0.pdf)
### [P2682R0 Transactional Memory TS2 Editor's Report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2682r0.pdf)

N4923のEditor's Report。

N4906からN4923への変更点が記載されています。

設計上の変更はなく、typoなどの軽微な修正のみです。

### [P2683R0 SG14: Low Latency/Games/Embedded/Finance/Simulation virtual meeting minutes 2022/02/09-2022/10/12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2683r0.pdf)
### [P2684R0 SG19: Machine Learning Virtual Meeting Minutes 2022/02/10-2022/10/13](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2684r0.pdf)
### [P2685R0 Language Support For Scoped Allocators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2685r0.html)
### [P2686R0 Updated wording and implementation experience for P1481 (constexpr structured bindings)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2686r0.pdf)
### [P2687R0 Design Alternatives for Type-and-Resource Safe C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2687r0.pdf)
### [P2688R0 Pattern Matching Discussion for Kona 2022](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2688r0.pdf)
### [P2689R0 atomic_accessor](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2689r0.html)
### [P2690R0 C++17 parallel algorithms and P2300](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2690r0.html)
### [P2691R0 Allow referencing inline functions with internal linkage from outside their defining header unit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2691r0.pdf)
