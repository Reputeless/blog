# ［C++］void_tとその周辺

#### std::void_t

`void_t`とは以下のようなエイリアステンプレートです。[tex:f:Ts... \to void]な感じのメタ関数になります。

```cpp
template<typename Ts...>
using void_t = void;
```

あらゆる型のベクトルを受け取りvoidへ写します。こんなもんが一体何の役に立つというのか？というと、detection idiomと呼ばれる手法に使われます（というかそれ以外の使い方を知らない）。

#### detection idiom

detection idiomとは、`void_t`を利用してある型が持つ特性や適用可能な操作をコンパイル時に検出する手法です。

```cpp
template<class, class = std::void_t>
struct is_equality_comparable : std::false_type {};

template<class T>
struct is_equality_comparable<T, std::void_t<decltype(std::declval<const T&>() == std::declval<const T&>())>
   : std::true_type {};
```

この例だと、同じ型を引数にとるoperator==を実装しているか（等値比較可能か）を検出しています。
このままだと、operator==のチェック部分と`void_t`による検出部分がくっついていて見づらいため、それらを分離してみます。

```cpp
template<class, template<class> class, class = std::void_t<>>
struct detect : std::false_type {};

template<class T, template<class> class Check>
struct detect<T, Check, std::void_t<Check<T>>> : std::true_type {};
```

```cpp
template<class T>
using is_equality_comparable_checker = decltype(std::declval<const T&>() == std::declval<const T&>());

template<class T>
using is_equality_comparable = detect<T, is_equality_comparable_checker>;
```

`detect`クラスが`void_t`を利用して特性の検出を行う部分、`is_equality_comparable_checker`エイリアステンプレートが型Tを受け取り、operator==の存在チェックを行う部分になります。

このdetectクラスにある型TとTを一つ引数にとるメタ関数（この場合は`is_equality_comparable_checker`）を渡すことで、そのメタ関数が実行可能かによって任意の性質をチェックします。

例えばある型について足し算が可能かをチェックするには以下のようなメタ関数を作ってやります。

```cpp
template<class T>
using is_addable_checker = decltype(std::declval<const T&>() + std::declval<const T&>());

template<class T>
using is_addable = detect<T, is_addable_checker>;
```
[[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ](https://wandbox.org/permlink/oNXGCk4JxjQrEM8O)

たったのこれだけ、検出のキモは`detect`クラスと`void_t`にあり、`detect`クラスではテンプレートの部分特殊化とSFINAEを利用してfalse_typeとtrue_typeの分岐を行っています。

`void_t`を主に利用しているのは`std::true_type`を継承する方の`detect`で、チェックするメタ関数（Check<T>）を実行しその戻り値型をvoidへ写しています。
```cpp
template<class T, template<class> class Check>
struct detect<T, Check, std::void_t<Check<T>>> : std::true_type {};
```
ここで、もしも`Check<T>`が失敗する（＝TがCheckで調べられている特性を持っていない）場合は`void_t`はエラーとなりSFINAEによってプライマリテンプレート（`std::false_type`を継承する方）が選択されます。

`Check<T>`が恙なく評価されれば、その戻り値型が何であれvoidへ写して終了。結果、プライマリテンプレートと部分特殊化のシグネチャが同じになり、部分特殊化が優先的に選択され、`std::true_type`を継承した`detect`が実体化されます。

このような感じで検出が行われます。`void_t`はその型引数が全てエラー無く評価出来たらvoidに、エラーが出たなら自身もエラーとなりSFINAEを起動する、そのための核となっているわけです。

#### int_tあるいは任意のT_t
ここで疑問に持たれた方もいるかもしれません。なぜ`void_t`なのか？`int_t`やその他の型ではダメなのか？と。

結論から言えば、`int_t`でもなんでも良いのです。必要なのは、あらゆる型をある一つの型に写すという性質と、与えられた型引数がエラーとなるときは自身もエラーとなる（SFINAEのトリガーとなる）、この2つの性質なのです。

`int_t`を試してみましょう。`detect`クラスを以下のように修正します。

```cpp
template<class...>
using int_t = int;

//template<class, template<class> class, class = int>
template<class, template<class> class, class = int_t<>>
struct detect : std::false_type {};

template<class T, template<class> class Check>
struct detect<T, Check, int_t<Check<T>>> : std::true_type {};
```
[[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ](https://wandbox.org/permlink/9U38NdewbPPi4Ep0)

`void_t`と同じ結果を得られています。`void_t`と同じように`int_t`を実装し、`void_t`を置き換えてやっただけです。

`T_t`にしてもおｋです。

[[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ](https://wandbox.org/permlink/bP3FsRZPJX46kcqE)

このようにしてみると、`void_t`の持つ性質こそが重要であることが分かるでしょう。`void`が選択されたのは`void`という型がこのような性質に最適であるからだと思われます（引数は捨てるし、写した結果も使用しない）。

ところで、`int_t`ではプライマリテンプレートの最後のデフォルトパラメータ以下のようにしても動きます。
```cpp
template<class, template<class> class, class = int>
struct detect : std::false_type {};
```
これは`void_t`の場合も同じ（`= void`にする）です。しかし、`int_t`なら`int`、`void_t`なら`void`、`T_t`なら`T`にしないといけません。それ以外の型を指定しておくと、必ずプライマリテンプレートが選択されるようになります。なぜでしょうね・・・

#### クラステンプレートの部分特殊化とオーバーロード解決


#### 参考文献
- [std::void_t - cpprefjp](https://cpprefjp.github.io/reference/type_traits/void_t.html)
- [Detection Idiom - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20151103/p1)
- [Proposing Standard Library Support for the C++ Detection Idiom, v2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf)