# ［C++］WG21月次提案文書を眺める（2020年5月）

文書の一覧
[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-05:embed:cite]

提案文書で採択されたものはありません。全部で29本あります。

[:contents]

### [P0493R1 : Atomic maximum/minimum](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0493r1.pdf)

`std::atomic`に対して、指定した値と現在の値の大小関係によって値を書き換えるmaximum/minimum操作である`fetch_max()/fetch_min()`を追加する提案。

アトミックな数値演算は既に標準化されていますがmaximum/minimum操作はそうではなく、他フレームワークやハードウェアには既に実装があり、いくつかのマルチスレッドアプリケーションで有用であるため追加しようというものです。

```cpp
#include <atomic>

std::atomic<int> a = 10;

int r1 = a.fetch_max(20);
// r1 == 10, a == 20

int r2 = a.fetch_min(5);
// r2 == 20, a == 5
```

これらの操作はread-modify-writeです。すなわち、現在の値と指定された値の大小関係に関わらず、値は常に更新されます。

```cpp
std::atomic<int> a = 10;

int r = a.fetch_max(5);  // 値の入れ替えは起こらないが、書き込みは行われている

// 例えば、次のように実行される
int v = a.load();
int max = std::max(v, 5);
a.store(max);

int r = v;
```

この提案では今の所、`std::atomic<T>`の整数型とポインタ型の特殊化に対してだけ`fetch_max()/fetch_min()`メンバ関数を追加しています。「[P0020 : Floating Point Atomic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0020r6.html)」が採択されれば浮動小数点型の特殊化についても追加すると書かれていて、これはC++20に対して既に採択されているので、次のリビジョンくらいで浮動小数点型の`std::atomic<T>`特殊化についても同様のものが追加されるかもしれません。

また、他の`atomic`操作に準ずる形で非メンバ関数版も用意されています。ただし、これらも整数型とポインタ型でのみ利用可能です。

```cpp
namespace std {
  template<class T>
  T atomic_fetch_max(atomic<T>*, typename atomic<T>::value_type) noexcept;

  template<class T>
  T atomic_fetch_max_explicit(atomic<T>*, typename atomic<T>::value_type, memory_order) noexcept;

  // それぞれvolatileオーバーロードがある
  // fetch_min()も同様
}
```

### [P0870R3 : A proposal for a type trait to detect narrowing conversions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0870r3.html)

型`T`が別の型`U`へ縮小変換（*narrowing conversion*）によって変換可能かを調べるメタ関数`is_narrowing_convertible<T, U>`を追加する提案。

前回の記事を参照
[https://onihusube.hatenablog.com/entry/2020/05/01/194425#P0870R2--A-proposal-for-a-type-trait-to-detect-narrowing-conversions:embed:cite]

このリビジョンでの主な変更は、機能テストマクロが追加された事と、配列を用いた実装が`void`や参照型、配列型など一部の型で機能しない事が明記された事です。

- [P0870 進行状況](https://github.com/cplusplus/papers/issues/724)

### [P1679R2 : String Contains function](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1679r2.html)

`std::string, std::string_view`に、指定された文字列が含まれているかを調べる`contains()`メンバ関数を追加する提案。

同じことは既にある`find()`を使えばできますが、`find()`関数を使用する方法には少し問題があります。

```cpp
if (str.find(substr) != std::string::npos)
  std::cout << "found!\n";
```

- 含まれているかを調べているのに`!=`を使用する（書きづらい）
- 調べているのは文字の位置なのか、含まれているかどうかなのか、含まれていないかどうかなのか、一見して分かりづらい（読みづらい）

対して、`contains()`というメンバ関数は意図が明確で書くときも読むときもこれらの問題は起こらず、初学者に対しても教えやすく使いやすいものです。また、他の言語の文字列型および、標準外のライブラリには既に対応する関数の実装があるため、標準ライブラリにも追加しよう、と言うのが要旨です。

```cpp
if (str.contains(substr))
  std::cout << "found!\n";
```

オーバーロードは`starts_with/ends_with`を参考に以下の3つが提供されます。

```cpp
constexpr bool contains(basic_string_view x) const noexcept;
constexpr bool contains(charT x) const noexcept;
constexpr bool contains(const charT* x) const;
```

- [P1679 進行状況](https://github.com/cplusplus/papers/issues/457)

### [P1841R1 : Wording for Individually Specializable Numeric Traits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1841r1.pdf)

`std::numeric_limits`に代わる新たな数値特性（*numeric traits*）取得方法を導入する提案。

例えば数値型の最大値や最小値等、数値型の満たしている各種特性を取得するのに現在は`std::numeric_limits`が用意されています。これは少なくとも`<type_traits>`ヘッダにあるような型特性が見出されるよりも以前から存在しており、その設計は古くなっています。

ユーザー定義型に対する特殊化を追加する場合、ジェネリックな利用のために本来必要のない数値特性についてもそれっぽい値を返すように実装する必要があります。あるいは、ある数値特性を提供しているのかどうかを知る方法が提供されていません。  
このことは、新たな数値特性を追加した場合には既存のユーザー定義型に対する特殊化を破壊する事を意味しており、そのために`std::numeric_limits`は拡張可能ではなくなっています。

そこで、`std::numeric_limits`にある各数値特性関数をそれぞれ個別のクラステンプレートと対応する変数テンプレートのペアに分解します。また同時に、一部の数値特性の名前と内容を調整します。

```cpp
// 型Tの有限値のうちの最大値（numeric_limits<T>::max()相当
template <class T>
struct finite_max;

// 型Tの有限値のうちの最小値（numeric_limits<T>::min()相当
template <class T>
struct finite_min;

template <class T>
inline constexpr auto finite_max_v = finite_max<T>::value;

template <class T>
inline constexpr auto finite_min_v = finite_min<T>::value; 
```

ある型について任意の数値特性が定義されているかを調べるものも提供されます。

```cpp
// 任意のTについて、数値特性Traitが定義されているかを調べる
template <template <class> class Trait, class T>
inline constexpr bool value_exists;

// 任意のTについて、数値特性が提供されていればその値を、いなければdefにフォールバックする
template <template <class> class Trait, class T, class R = T>
inline constexpr R value_or(R def = R()) noexcept;
```

これは例えば、次のように実装されます

```cpp
template <template <class> class Trait, class T>
constexpr bool value_exists = requires { Trait<T>::value; };

template <template <class> class Trait, class T, class R = T>
constexpr R value_or( R def = R() ) noexcept {
  if constexpr(value_exists<Trait, T>s)
    return Trait<T>::value;
  else
    return def;
} 
```

これらのものは`<numbers>`ヘッダと`std::numbers`名前空間に追加されます。

このように、数値型に対する数値特性が個別に分かれていることによって新しい数値特性を追加する際に既存のユーザー定義特殊化を壊してしまう事もありません。ユーザーが特殊化を追加する際も必要な数値特性についてだけ特殊化を行えばよくなります。

- [P1370R1 Generic numerical algorithm development with(out) numeric_limits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1370r1.html)
- [P0437R1 Numeric Traits for the Standard Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0437r1.pdf)
- [P1841 進行状況](https://github.com/cplusplus/papers/issues/594)

### [P1861R1 : Secure Networking in C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1861r1.html)

Networking TS（簡単に言えば、ソケット通信ライブラリ）に対して、TLS/DTLSのサポートをデフォルトにする提案。

今日、ネットワークに接続すると言うことは悪意を持った攻撃に曝されることを意味します。それに対処するために、インターネットにおける通信はHTTPS(TLS)等を用いてセキュアにする事がデフォルトとなりつつあります。特に、WEBサーバの中にはHTTPを拒否しHTTPSでしか通信をしないものも増えてきています。  
C++のネットワークライブラリがそれらの現代のWEBシステムと対話するために、また、ネットワークセキュリティの知識のない開発者がそれを意識せずとも一定のセキュリティを確保する事ができるように、そして、C++のネットワークライブラリを用いたプログラムが将来的にもセキュアなインターネットと連携していくために、Networking TSにおいてTLS/DTLSをデフォルトで使用するようにする、と言う提案です。

セキュリテイを確保するために追加のややこしい設定が必要になったりコードとその理解が複雑になることはセキュアなプログラムを書くことを妨げ、安全でない通信の利用を促進しかねないため、この提案では現在のNetworking TSのAPIを変更し、WEBアクセスなども意識した使いやすいAPIセットを提案しています。

コルーチンと[`std::lazy<T>`](https://wg21.link/p1056r1)を用いたHTTPSクライアントのサンプル

```cpp
#include <iostream>
#include <net>

std::lazy<void> run()
{
  net::workqueue queue(net::workqueue::main_queue());
  net::endpoint::host host("www.apple.com", 80);

  // ここの第二引数でTLS/DTLSを使用するかを制御する
  net::connection connection(host, net::parameters::tls(), queue);
  connection.start();

  std::cout << "Sending request" << std::endl;
  net::message message(net::buffer("GET / HTTP/1.1\r\nHost: www.apple.com\r\n\r\n"));
  auto sendResult = co_await connection.send(message);
  if (!sendResult) {
    std::cerr << "failed to send request" << std::endl;
    co_return;
  }

  std::cout << "Sent request, waiting for response" << std::endl;
  auto message = co_await connection.receive();
  if (!message) {
    std::cerr << "failed to receive response" << std::endl;
    co_return;
  }

  std::cout << "Received response" << std::endl;
  message->data().get([](const uint8_t *bytes, std::size_t size) {
    std::cout << std::string(reinterpret_cast<const char *>(bytes), size);
  });
  std::cout << std::endl;
  co_return;
}

int main(int, char**)
{
  auto lazy = run();
  net::workqueue::main();
}
```

この提案は将来的にQUIC等のプロトコルをサポートするための下準備も兼ねています。

- [P1860R0 C++ Networking Must Be Secure By Default.](https://wg21.link/p1860r0)
- [P1861R0 Secure Connections in Networking TS](https://wg21.link/p1861r0)
- [P1861R1 Secure Networking in C++ - reddit](https://www.reddit.com/r/cpp/comments/gm40j0/p1861r1_secure_networking_in_c/)
- [P1861 進行状況](https://github.com/cplusplus/papers/issues/615)

### [P1897R3 : Towards C++23 executors: A proposal for an initial set of algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1897r3.html)

Executorのための実行アルゴリズムを追加する提案。

現在のExecutor提案に含まれている実行アルゴリズムは`bulk_execute`と言うバルク実行のためのものだけで、Executorを実用的にするにためにはもう少し多くの実行アルゴリズムサポートが必要という主張です。

アルゴリズムといっても`<algorithm>`ヘッダにあるようなものではなくて、ある処理の連鎖実行や複数の処理の一括実行などを簡単に書けるようにするためのものがメインです。そのため、この提案は既存の並列アルゴリズムをExcutor実行可能にすることは含んでいません。

また、今後さらに多くの実行アルゴリズムを追加していくにあたって、より洗練された設計や文言を選択するために、個別に議論可能な（相互依存していない）最小のアルゴリズムのセットから提案を始めています。

提案文書より、簡単なサンプル。

```cpp
auto just_sender = just(3); // sender_to<int>

auto transform_sender = transform(
  std::move(just_sender),
  [](int a){return a+0.5f;}
); // sender_to<float>

// ここで処理をExecutorに投げ、結果を待機する
float result = sync_wait(std::move(transform_sender));
// result == 3.5

// パイプライン演算子を用いて中間オブジェクトを隠蔽することもできます
float f = sync_wait(
  just(3) | transform([](int a){return a+0.5f;})
);
```

複数のタスク（*sender*）とその結果を受けてそれらを直列化する`when_all`のサンプル。

```cpp
auto just_sender = just(std::vector<int>{3, 4, 5}, 10); // sender_to<int>
auto just_float_sender = just(20.0f); // sender_to<float>

auto when_all_sender = when_all(
  std::move(just_sender),
  std::move(just_float_sender)
);

auto transform_sender(
  std::move(when_all_sender),
  [](std::vector<int> vec, int /*i*/, float /*f*/) {
    return vec;
  }
);

vector<int> result = sync_wait(std::move(transform_sender));
// result = {3, 4, 5}

// パイプライン演算子の利用
vector<int> result_vec = sync_wait(
  when_all(
    just(std::vector<int>{3, 4, 5}, 10),
    just(20.0f)
  ) |
  transform([](vector<int> vec, int /*i*/, float /*f*/){return vec;})
);
```

ここで出現している`just, transform, sync_wait`を始め用意されるアルゴリズムは全てカスタマイぜーションポイントオブジェクトになっています。

- [P0443R13 : A Unified Executors Proposal for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r13.html)
- [P1897 進行状況](https://github.com/cplusplus/papers/issues/645)

### [P1898R1 : Forward progress delegation for executors](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1898r1.html)

Executorでのタスクの前方進行に当たって、そのリソースを同時に伝播するためのコンセプトとカスタマイぜーションポイントを追加する提案。

### [P1974R0 : Non-transient constexpr allocation using propconst](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1974r0.pdf)

コンパイル時に確保したメモリを実行時にも安全に参照するための要件と、そのためのより深い`const`性を指定する`propconst`の提案。

C++20からは`constexpr`な動的メモリ確保が可能になっていますが、Non-transientなメモリ確保（コンパイル時に確保したメモリを実行時にも参照すること）は許可されませんでした。

```cpp
constexpr void f(std::initilizer_list<int> il) {
  std::vector<int> vec = il;  // これはok
}

int main() {
  constexpr std::vector<int> vec = {1, 2, 3, 4, 5}; // これはできない
}
```

Non-transientなメモリ確保が許可されていた以前の仕様の下では、クラス内部で確保されるメモリで条件を満たした場合にコンパイル時に解放されなかったメモリは実行時に静的ストレージに昇格されて参照可能でした。その際は通常の`constexpr`変数と同様に実行時`const`変数になります。その条件とは以下のようなものでした。

- `T`は非トリビアルconstexprデストラクタを持つ
- そのデストラクタはコンパイル時実行可能
- そのデストラクタ内で、`T`の初期化時に確保されたメモリ領域（Non-transient allocation）を解放する

すなわち、そのクラスの`constexpr`デストラクタによってコンパイル時に確保されたメモリがコンパイル時に解放可能であることです。これはコンパイラによるテスト要件であって、実際に解放が行われるわけではありません。

そして、その仕様の下では次のような問題が発生します。

```cpp
// これはok（だった
constexpr std::unique_ptr<std::unique_ptr<int>> uui 
  = std::make_unique<std::unique_ptr<int>>(std::make_unique<int>());

int main() {
  std::unique_ptr<int>& ui = *uui; // これができてしまう
  ui.reset(); // 静的ストレージの領域をdeleteする？
}
```

このように、デストラクタを実行時に呼び出せてしまいますが、前述のテスト要件だけではこれを検出し防ぐことはできません。そのため、Non-transientなメモリ確保は最終的にリジェクトされました。

これが何故起こるかというと、`std::unique_ptr`は*deep const*な型ではないからです。すなわち、外側の`std::unique_ptr`の`const`性が内部の`std::unique_ptr`まで伝播していません。

そこで、以前のコンパイラによるデストラクタのテスト要件に次の条件を加えます。

- デストラクタ呼び出し中に現れる全ての（メンバ）変数は`const`であり、かつ
- そのデストラクタは実行時に破棄されうるオブジェクトに対して呼び出されていない

これによって、上記の`std::unique_ptr<std::unique_ptr<int>>`のような例をコンパイル時に正しくエラーにすることができます。ただこれにも問題がまだあります。

```cpp
constexpr vector<vector<int>> vvi = {{1}};

int main() {
  vector<int>& vi = vi[0]; // 非const参照への変換になるのでng
  vi = vector<int>{}
}
```

このコードは以前の要件の下でも新たな要件の下でもエラーになります。`std::vector`は`const`修飾されたメンバ関数からその要素への非`const`な参照を取れないように巧妙に設計されているためです。これによって`std::vector`は多重ネストしても`std::unique_ptr`のように内部要素を解放されてしまうことは起こりえません。すなわち、`std::vector`は*deep const*な型です。

しかし、新たな要件によるデストラクタのテストはネストした`std::vector`を許可しません。`const`メンバ関数の慎重な設計によって*deep const*となっているだけでそのメンバは非`const`のままであり、コンパイラはネストした`std::vector`が*deep const*であることを認識できません。

そこで、ユーザーに追加の作業を必要とせずにコンパイラが正しく型の*deep const*性を認識するために、C++の型システムを拡張し新しいCV修飾子である`propconst`を導入することを提案しています。

`propconst`はポインタ型と参照型にのみ適用可能で、ポインタが不変である場合に`const`に変換され、それ以外の場合は何もしません。参照型はポインタ型に置き換えた上で同様です。

非メンバのオブジェクトポインタ型に対して`propconst`修飾している場合、その不変性は`const`修飾の有無で決まります。メンバ変数に対して`propconst`修飾している場合は呼び出すメンバ関数の`const`修飾によってその不変性が決定されます。

```cpp
int propconst* ip1;       // int* ip1;
int propconst* const ip2; // int const * const ip2;

struct S {
  int propconst *ppi;

  void f() const {
    // ここでは、ppiの型はint const * const
    // int const* ppi;と宣言されているように見える
  }

  void f() {
    //ここでは、ppiの型はint *
    // int * ppi;と宣言されているように見える
  }
};
```

最終的には、この`propconst`と以下の条件でもってNon-transientなメモリ確保を許可することが提案されています。

- `constexpr`なデストラクタの呼び出し（テスト）中に現れた全ての変数は、他の*mutable*な（実行時）文脈から到達可能ではない


```cpp
// 共にok
constexpr vector<vector<int>> vvi = {{1}};
constexpr vector<unique_ptr<int>> vui = {std::make_unique<int>()};
```

`propconst`はどこに現れるのかというと、`std::vector`の実装に現れています。`std::vector`の領域管理用のメンバ変数が全て`propconst`修飾されていれば、その要素を外部から変更可能でないことが保証可能であるため、コンパイラは`std::vector`が*deep const*であることを認識可能です。つまり、普通のユーザーは`propconst`を意識せずともNon-transientなメモリ確保を利用できるようになります。

- [［C++］ constexprなメモリの確保と解放のために（C++20） - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2019/03/03/113722)
- [N4388 A Proposal to Add a Const-Propagating Wrapper to the Standard
Library](https://wg21.link/n4388)
- [`std::experimental::propagate_const` - cppreference](https://en.cppreference.com/w/cpp/experimental/propagate_const)

### [P1985R1 : Universal template parameters](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1985r1.pdf)

任意の型、テンプレートテンプレート...、非型テンプレートパラメータなど、テンプレートの文脈で使用可能なものを統一的に受けることのできるテンプレートパラメータ（*Universal template parameter*）の提案。

例えば高階メタ関数を書くときなど、引数として任意のものを受け取りたいことがよくあります。現状ではこれをするためにはそれぞれのテンプレートパラメータの種類毎の特殊化を行う必要があります。

```cpp
// メタ関数Fに引数Argsを適用する
template <template <typename...> typename F, typename... Args>
using apply = F<Args...>;

template<typename X>
struct {using type = X;};

using OK = apply<G, int>;  // ok、G<int>

// 部分適用する
template <template <typename> typename F>
using H = F<int>;

using NG = apply<H, G>; // ng
// applyの引数パラメータArgs...はテンプレートテンプレートパラメータではないため
```

これはまた、`apply`の2番目以降の引数として非型テンプレートパラメータを渡そうとしても同じことが起きます。このような場合に、そのパラメータの種類を指定せずにテンプレートパラメータを宣言できるととても便利です。

提案では、2種類の文法を提案しています。

```cpp
// 簡単かつ使いやすい、template auto
template <template <template auto...> typename F, template auto... Args>
using apply = F<Args...>;

// 数学的に正しい、__ （+template auto）
template <template <__...> typename F, template auto... Args>
using apply = F<Args...>;
```

2番目の方法では同時に1つ目の方法も導入することになります。`__`はパターンマッチにおける制約のないパラメータのようなものであり（`switch`文の`default`ラベルのようなもの）、そのパラメータに名前をつけることが出来ません。  
`template auto`はちょうど、C++17で導入された`auto`によるユニーバーサル非型テンプレートパラメータの宣言と同じようなことをします。

また、この*Universal template parameter*を取るクラステンプレートをプライマリテンプレートとして、テンプレートパラメータの種類毎に特殊化を行えるようにすることも提案されています。

```cpp
// プライマリテンプレート
template <template auto>
struct X;

// 普通の型に対する特殊化
template <typename T>
struct X<T> {
  // T is a type
  using type = T;
};

// 非型テンプレートパラメータに対する特殊化
template <auto val>
struct X<val> : std::integral_constant<decltype(val), val> {
  // val is an NTTP
};

// テンプレートテンプレート（1引数メタ関数）に対する特殊化
template <template <typename> F>
struct X<F> {
  // F is a unary metafunction
  template <typename T>
  using func = F<T>;
};
```

- [C++17 非型テンプレートパラメータのauto宣言 - cpprefjp](https://cpprefjp.github.io/lang/cpp17/declaring_non-type_template_arguments_with_auto.html)
- [P1985 進行状況](https://github.com/cplusplus/papers/issues/735)

### [P2066R2 : Suggested draft TS for C++ Extensions for Transaction Memory Light](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2066r2.html)

現在のトランザクショナルメモリTS仕様の一部だけを、軽量トランザクショナルメモリとしてC++へ導入する提案。

トランザクショナルメモリはDBにおけるトランザクション処理の概念をDBをメモリに対応させ一般化したもので、トランザクション間においてメモリの一貫性を保証し、並行処理を容易に書くことができるようにするためのものです。

あるメモリ領域に対する1連の処理を1つのトランザクションとすると、そのトランザクションは成功するか失敗するかのどちらかであり、成功した場合にだけ結果がアトミックに書き込まれます。失敗した場合は進行中の処理は全てキャンセルされなされた変更はロールバックされるため、メモリ領域は一切変更されません。

このようなトランザクションはそれぞれがプログラム全体で1つの全順序に従うかのように実行され、あるトランザクションの実行中に外から処理中の状態を観測出来ず、1つのトランザクションは不可分の操作であるように実行されます。それによって、ユーザーはトランザクション間のデッドロックや同期などの心配を一切しないで並行処理を書くことが出来ます。

これらを標準機能として提供するために、トランザクショナルメモリTS仕様では2種類のトランザクション処理を定義するためのキーワード（`transaction_relaxed/transaction_atomic`）とトランザクションキャンセル時の挙動を指定する2種類の指定子やある関数がトランザクション中で安全に扱えるかを指定する2種類の関数指定子（`commit_on_escape/cancel_on_escape/transaction_safe/transaction_unsafe`）を定義していました。

2015年に現在のTS仕様が策定されていましたが実装もユーザー経験も少なく、機能がカバーする領域が広すぎると言う指摘もあり、標準への導入は見送られていました。そこでこの提案では、`atomic`トランザクション（以前の`transaction_atomic`相当）とそのために必要な最低限の仕様変更だけをC++に導入することを提案しています。最終的にはTS仕様の全てを含めることを目指すために、まずは実装の負担にならない小さな変更から初めて行くつもりのようです。

導入されるキーワードは`atomic`だけで、上記4つの指定子は全てありません。プログラムの実行に当たって発生するトランザクションはプログラム中で一貫した全順序によって実行され、同じ式を評価する2つのトランザクションは、先に評価が開始されたトランザクションの終了にもう一つのトランザクションの開始が同期します。

```cpp
int f()
{
  static int i = 0;

  // atomicステートメント、atomicトランザクションを定義
  // このブロックは全てのスレッドの間で1つづつ実行される
  atomic {
    ++i;
    return i;
  }
}

int main() {
  std::array<std::thread, 100> threads{};

  // 関数f()の呼び出し毎に一意の値が取得される
  // 同じ値を読んだり、更新中の値を読むことはない
  for (auto& th : threads) {
    th = std::thread([](){
      int n = f();
    });
  }

  for (auto& th : threads) {
    th.join();
  }
}
```

ただし、次のようにスレッド外部から観測可能な操作の`atomic`ステートメント内部での実行は未定義動作とされています。

- I/O操作
- `volatile`領域へのアクセス
- *atomic*操作
    - `std::atomic`など

そして、`atomic`ステートメントの中では次の行いは実装定義です。

- `asm`宣言
- 非`inline`関数以外の関数の呼び出し
- 仮想関数呼び出し
- 関数名を指定しない後置式
    - `a[], a++, a->b()`など
- `throw`式
- コルーチン関連
    - `co_await, co_return`など
- スレッドローカルストレージ及び静的変数の動的初期化

トランザクションのキャンセルはどうやらサポートされず、例外送出=キャンセルと考えればそれは実装定義のようです。また、その実装がハードウェアによるのかソフトウェアによるのかも規定していません。ほとんど実装定義です・・・

- [P1875R0 Transactional Memory Lite Support in C++](http://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p1875r0.pdf)
- [N4514 Technical Specification for C++ Extensions forTransactional Memory](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4514.pdf)
- [トランザクション処理 - wikipedia](https://ja.wikipedia.org/wiki/トランザクション処理)
- [ACID - wikipedia](https://ja.wikipedia.org/wiki/ACID_(コンピュータ科学))
- [コンピュータアーキテクチャの話(201) トランザクションメモリ](https://news.mynavi.jp/article/architecture-201/)
- [Boost.勉強会 #10 に参加しました - yohhoyの日記（別館）](https://yohhoy.hatenablog.jp/entry/2012/07/29/002928)
- [C++トランザクショナルメモリ拡張まとめ（ドラフト仕様v1.1） - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20120414/p1)
- [C++トランザクショナルメモリ拡張まとめ（N3718） - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20131005/p1)
- [2013-09 pre-Chicago mailingの簡易レビュー - 本の虫](https://cpplover.blogspot.com/2013/09/2013-09-pre-chicago-mailing.html)
- [P2066 進行状況](https://github.com/cplusplus/papers/issues/793)

### [P2128R1 : Multidimensional subscript operator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2128r1.pdf)

多次元コンテナサポートのために添字演算子（`[]`）が複数の引数を取れるようにする提案。

行列や画像、位置情報など多次元のデータの1要素にアクセスするためには、ぞの次元に応じたインデックスが必要です。現状の添字演算子は1引数しか取ることができず、`mdspan`や`mdarray`などの多次元データ型でその要素にアクセスするためには関数呼び出し演算子（`()`）を使用する必要があります。しかし、添字演算子と比べると明解ではなく少し混乱します。

そこで、添字演算子をオーバーロードする際に1つ以上の任意の数の引数を取れるように変更しよう、と言うのが提案です。この場合、関数呼び出し演算子との差異は引数なしオーバーロードが可能かどうかだけになります。

```cpp
template<class ElementType, class Extents>
class mdpan {

  // 多引数添字演算子オーバーロード
  template<class... IndexType>
  constexpr reference operator[](IndexType...);

  // 他実装略
};

int main() {
  int buffer[2*3*4] = { };
  auto s = mdspan<int, extents<2, 3, 4>> (buffer);

  // 添字演算子による多次元アクセス
  s[1, 1, 1] = 42;
  // 現在は関数呼び出し演算子を使用する必要がある
  s(1, 1, 1) = 42;
}
```

C++20では添字アクセスの際に`[]`の中にカンマを書くことが非推奨とされましたが、この提案の下では配列型の場合はC++17までのようなカンマによる式と常に認識し、クラス型の場合は添字演算子オーバーロードは見つからない場合にカンマによる式にフォールバックすると言う選択を取ることができ、C++17までの振る舞いをサポートし続けることが可能になります。

- [P1161R3 Deprecate uses of the comma operator in subscripting expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1161r3.html)
- [P2128 進行状況](https://github.com/cplusplus/papers/issues/845)


### [P2136R1 : invoke_r](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2136r1.html)

### [P2142R1 : Allow '.' operator to work on pointers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2142r1.pdf)

### [P2145R0 : Evolving C++ Remotely](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2145r0.html)

### [P2159R0 : An Unbounded Decimal Floating-Point Type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2159r0.html)

### [P2160R0 : Locks lock lockables (wording for LWG 2363)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2160r0.html)

### [P2161R0 : Remove Default Candidate Executor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2161r0.pdf)

### [P2162R0 : Inheriting from std::variant (resolving LWG3052)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2162r0.html)

### [P2163R0 : Native tuples in C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2163r0.pdf)

### [P2164R0 : views::enumerate](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2164r0.pdf)

### [P2165R0 : Comparing pair and tuples](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2165r0.pdf)

### [P2167R0 : Improved Proposed Wording for LWG 2114](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2167r0.html)

### [P2168R0 : generator: A Synchronous Coroutine Generator Compatible With Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2168r0.pdf)

### [P2169R0 : A Nice Placeholder With No Name](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2169r0.pdf)

### [P2170R0 : Feedback on implementing the proposed std::error type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2170r0.html)

### [P2171R0 : Rebasing the Networking TS on C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2171r0.pdf)

### [P2172R0 : What do we want from a modularized Standard Library?](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2172r0.pdf)

### [P2173R0 : Attributes on Lambda-Expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2173r0.pdf)

### [P2174R0 : Compound Literals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2174r0.html)

### 謝辞

この記事の6割は以下の方々によるご指摘によって成り立っています。
