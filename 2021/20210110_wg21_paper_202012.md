# ［C++］WG21月次提案文書を眺める（2020年12月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2020 mailing2020-12](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/#mailing2020-12)

採択されたものはありません、全部で32本あります。

[:contents]

### [N4878 Working Draft, Standard for Programming Language C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4878.pdf)

C++23ワーキングドラフト第3弾。

### [N4879 Editors' Report - Programming Languages - C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4879.html)

↑の変更点をまとめた文書。

前回会議で採択された提案文書とコア言語/ライブラリのIssue解決が適用されているようです。

### [P0401R5 Providing size feedback in the Allocator interface](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0401r5.html)
### [P0561R5 An RAII Interface for Deferred Reclamation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0561r5.html)

*deferred reclamation*を実現するためのより高レベルAPIを標準ライブラリに追加する提案。

*deferred reclamation*は並行処理における複数スレッド間のデータ共有におけるパターンで、この提案では次のように説明されています。

ある1つのデータ（変数）に対して*reader*と*updater*の2種類のコンポーネントを考えます。*reader*も*updater*も複数存在し、各々別々のスレッドからデータにアクセスします。  
*reader*は読み取りロックを取得してデータを読み取ります。ここでは、そのロックが保持されている間そのデータの生存が保証されます。一方、*updater*はデータを新しく確保された値によって置き換えることでデータを更新します。更新以降にデータを読みだした*reader*は新しい値を読み取りますが、置換前の古いデータを読み取った全ての*reader*がロックを解除するまでは古いデータは破棄されずに生存します。  
*reader*の読み取り操作は他の*reader*や*updater*をブロックせず、*updater*も*reader*をブロックしません。データの更新はメモリ確保を必要とするため高コストですが、読み取りと比較すると非常に稀であることが想定されます。

この*deferred reclamation*の実装には参照カウントやread-copy update(RCU)、ハザードポインタなどの方法があり、そのうちのいくつかは過去にC++に対して提案されています。しかし、それらはより実装そのものに近い低レベルなAPIを提供するものであり、それらの利用例の一つとして*deferred reclamation*が実現できるものでしかありませんでした。

この提案は、そのような低レベルなプリミティブによるものよりも安全性と使いやすさを重視し、かつ効率的な実装を可能とする*deferred reclamation*だけのための高レベルなAPIを提供するものです。

```cpp
#include <snapshot> // 新ヘッダ

// Configクラスによる設定を用いてリクエストを処理するServerクラス
class Server {
public:

  // 設定は随時変更可能
  // 設定変更を調べる別のスレッドから更新される
  void SetConfig(Config new_config) {
    config_.update(std::make_unique<const Config>(std::move(new_config)));
  }

  // リクエストはその時点の設定を使用して処理する
  // 設定の更新タイミングを考慮する必要はない
  void HandleRequest() {
    // リクエスト処理開始時点での設定データの取得
    std::snapshot_ptr<const Config> config = config_.get_snapshot();
    // configはunique_ptr<const Config>のように使用可能
    // configの生存期間内に設定データが更新されたとしても、configが参照するデータに影響はない
  }

private:
  // 共有される設定データ
  // 読み取り、更新、いずれに際しても同期を必要としない（ロックフリー）
  std::snapshot_source<Config> config_;
};
```

この提案のAPIはGoogle社内で実装され使用されているものをベースにしており、そこでは高レベルAPIとRCUによる実装の低レベルなAPIの両方が提供されているようですが、高レベルAPIの利用者が低レベルAPIに比べて多く、その経験こそが*deferred reclamation*のための高レベルAPIを提供する価値を実証していると主張しています。

- [ABA problem - Wikipedia](https://en.wikipedia.org/wiki/ABA_problem)
- [ABA問題 - Wikipedia](https://ja.wikipedia.org/wiki/ABA%E5%95%8F%E9%A1%8C)
- [CON09-C. ロックフリープログラミングの手法を使うときは ABA 問題を避ける - JPCERT/CC](https://www.jpcert.or.jp/sc-rules/c-con09-c.html)
- [P0233R3 Hazard Pointers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0233r3.pdf)
- [P0279R1 Read-Copy Update (RCU) for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0279r1.pdf)
- [P0461R1 Proposed RCU C++ API](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0461r1.pdf)
- [P0561 進行状況](https://github.com/cplusplus/papers/issues/268)

### [P0849R6 auto(x): decay-copy in the language](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0849r6.html)
### [P0901R8 Size feedback in operator new](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0901r8.html)
### [P1030R4 std::filesystem::path_view](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1030r4.pdf)

パス文字列を所有せず参照する`std::filesystem::path_view`の提案。

`std::filesystem::path`クラスはパスを表現するクラスですが、その実態はパス文字列であり、`std::string`と同様にパス文字列を所有しています。したがって、構築や連結などの操作において動的メモリ確保が発生します。  
`std::filesystem::path`に対する操作のいくつかは新しい`path`オブジェクトを返します。そこではメモリ確保と文字列のコピーが発生します。

例えば、ディレクトリを列挙する様な場合には1つのディレクトリの列挙毎に`path`オブジェクトの構築コストがかかる事になり、ディレクトリの数が多い場合にはボトルネックとなります。また、`path`オブジェクトの構築に伴う新規メモリ確保と文字列のコピーはCPUのキャッシュにも優しくありません。Windowsのパス文字列制限260文字に遭遇したことのある人が多くいる様に、パス文字列は数百バイトに達することもあり、パス文字列のコピーの度にキャッシュから有用なデータを削除する事になります。

`std::filesystem::path_view`は`std::filesystem::path`を参照する軽量な*View*です。`std::filesystem::path`と同様のインターフェースを提供し、ローカルプラットフォームのパス文字列に対して`const`/`constexpr`な参照であり、`std::filesystem::path`とほぼ同様に振舞います。これによって、現在`std::filesystem::path`を受け入れている所をリファクタリングをほぼ必要とせずに`std::filesystem::path_view`を受け入れられる様にすることができます。

また、`std::filesystem::path_view`に対するイテレーションで`path_view`を返さない様にするために、`std::filesystem::path_view_component`も追加されます。これは`path_view`とほぼ同じものですが、パス要素のイテレーションや抽出のための一部のメンバ関数を提供していません。  
`path_view`に対するイテレーションで得られた各パス要素をさらにパスとして扱う事は意味がなく、またそれを行う事はバグの可能性が高いため、パス要素である事を表現するための別の型が必要とされたのだと思われます。

この提案はC++23入りを念頭に作業が進められているようです。

- [P1030R4 std::filesystem::path_view](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1030r3.pdf)
- [`std::filesystem::path` - cpprefjp](https://cpprefjp.github.io/reference/filesystem/path.html)
- [P1030 進行状況](https://github.com/cplusplus/papers/issues/406)

### [P1072R6 basic_string::resize_and_overwrite](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1072r6.html)

`std:string`に領域（文字長）を拡張しつつその部分を利用可能にする為のメンバ関数`resize_and_overwrite()`を追加する提案。

例えばパフォーマンスに敏感なところで、`std::string`に文字を流し込んでいく処理を書くとき、おおよそ次の3つのいずれかを選択することになります。

1. 追加の初期化のコストを捧げる : `resize()` ゼロ初期化してから元の文字列をコピー
2. 追加のコピーコストを捧げる : 一時バッファに文字列をためておき、最後にまとめてコピー
3. 追加の簿記コストを捧げる : `reserve()` その後文字列が追加されるたびに、残りの長さが調べられ、null終端される

ここでやりたいことは、断続的に取得される文字列を随時追記していき最後にまとめて1つの文字列として扱う事です。しかし、いずれの方法も何かしら余分なコストがかかってしまい、最適な方法はありませんでした。

問題なのは、この様な場合に`std::string`をバッファとして使おうとしても、その領域をある程度の長さで確保しつつそのままアクセス可能にする、という操作が欠けていることです。

`resize_and_overwrite()`はまさにそのためのもので、指定された長さに領域を拡張しつつ、増やした領域はデフォルト初期化するだけに留める関数です。

```cpp
namespace std {

  template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
  class string {

    template<typename Operation>
    void resize_and_overwrite(size_type n, Operation op);

  };
}
```

`resize_and_overwrite()`は1つ目の引数に変更したい長さをとり、現在の長さがそれよりも短い場合は追加された領域はデフォルト初期化されています。また、2つ目の引数に変更後の領域に対する初期化処理を書く事ができ、変更後の領域の先頭ポインタと1つ目の引数`n`を取る任意の関数を指定できます。`op`は`erase(begin() + op(data(), n), end())`の様に呼び出されるため、`op`は処理後に残しておきたい領域のサイズを返す必要があります。

- [P1072 進行状況](https://github.com/cplusplus/papers/issues/31)

### [P1102R2 Down with ()!](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1102r2.html)
### [P1315R6 secure_clear (update to N2599)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1315r6.html)
### [P1478R6 Byte-wise atomic memcpy](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1478r6.html)
### [P1642R5 Freestanding Library: Easy [utilities], [ranges], and [iterators]](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1642r5.html)
### [P1689R3 Format for describing dependencies of source files](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1689r3.html)

C++ソースコードを読み解きその依存関係をスキャンするツールが出力する依存関係情報のフォーマットを定める提案。

モジュール導入以前は、各翻訳単位のコンパイルは独立して行うことができ、翻訳単位の依存関係はビルドしながら把握すれば十分でした。しかしモジュールを使用すると、ある翻訳単位をコンパイルするためにはそこでインポートされているモジュールのコンパイル（少なくともインターフェースの抽出）が必要となります。  
すなわち、モジュールを利用したプログラムでは各翻訳単位のコンパイルに順序付けが必要となります。

このために、ビルドツールはコンパイルする前にこの順序関係を（C++コードとしてではなく）ソースコードから抽出できる必要があります。

このフォーマットは次のような情報を含みます。

- 依存関係スキャンツールそのものの依存関係
- スキャンされた翻訳単位がコンパイルされる時に必要となるリソース
- スキャンされた翻訳単位がコンパイルされた時に提供されるリソース

このフォーマットはその表現としてJSONを使用しその規格を参照しています。そのエンコーディングはユニコードであり、特にファイルパスはUTF-8の有効な文字列であることがさらに要求されます。

例えば次のようなソースコードに対しては

```cpp
export module my.module;

import other.module;
import <header>;

#include "config.h"
```

次のようになります。

```json
{
  "version": 1,
  "revision": 0,
  "rules": [
    "work-directory": "/scanner/working/dir",
    "inputs": [
      "my.module.cpp"
    ],
    "outputs": [
      "depinfo.json"
    ],
    "depends": [
      "/system/include/path/header",
      "include/path/config.h"
    ],
    "future-compile": {
      "outputs": [
        "my.module.cpp.o",
        "my_module.bmi"
      ],
      "provides": [
        {
          "logical-name": "my.module",
          "source-path": "my.module.cpp",
          "compiled-module-path": "my_module.bmi"
        }
      ],
      "requires": [
        {
          "logical-name": "other.module"
        }
        {
          "logical-name": "<header>",
          "source-path": "/system/include/path/header",
        }
      ]
    }
  ]
}
```

なお、この動機となったモジュールのコンパイル順の問題はFortranのモジュールが長年抱えている問題と同じものであり、このフォーマットはC++だけではなくFortranでも使用することを想定しているようです。

- [P1689 進行状況](https://github.com/cplusplus/papers/issues/466)

### [P2077R2 Heterogeneous erasure overloads for associative containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2077r2.html)
### [P2136R2 invoke_r](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2136r2.html)
### [P2175R0 Composable cancellation for sender-based async operations](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2175r0.html)

Executor提案（[P0443R14](https://wg21.link/p0443r14)）に対して、非同期処理のキャンセル操作を追加する提案。

現在のExecutor提案には、実行コンテキストに投入した非同期処理がキャンセルされたときに処理が空らの結果で完了しそれを通知する機能を提供していますが、非同期処理を呼び出し元がキャンセルするための機能は提供されていません。

非同期処理のキャンセルという操作は並行プログラムにおける基礎的なプリミティブであり、それによって並行処理を構造的に記述できるようにするために、非同期処理のキャンセル操作と、それを伝達するためのメカニズムをExecutorに導入しようとする提案です。

このためには、個々の非同期処理でアドホックなメカニズムによって呼び出し元がキャンセル要求を伝達できるようにする必要があります。例えば、`std::chrono::duration`を渡すことでタイムアウトによるキャンセルを行う、`std::stop_token`を非同期関数/コルーチンに渡す、又は非同期処理を表現する呼び出し可能な型のメンバとして`.cancel()`を実装する、などです。

キャンセルを適切に処理するためには、全てのレイヤーがキャンセルをサポートし、そのキャンセル要求は全てのレイヤーに適切に伝播しなければなりません。例えば、タイマーやI/O、ループなど、高レベルの処理の完了が依存しているより低レベルな処理に要求を伝達しなければなりません。

しかし、アドホックメカニズムを使用すると、キャンセル可能な処理を構成してそのキャンセル要求を中間層を介して伝播することが困難になります。これは特に`when_all()`アルゴリズムなど、構築済みの`sender`によって構成されるアルゴリズムに当てはまり、入力となる元の`sender`を作成した非同期処理に渡されるパラメータを制御する方法がありません。

この様な事を考慮したうえで、この提案の目指すキャンセル操作は次のような設計に基づきます。

- 汎用的に構成可能なキャンセルのためのメカニズムを用意する。これによって、キャンセルに対して透過的であるか、新しいキャンセルスコープを導入して、キャンセル操作を処理のチェーンに挿入できるアルゴリズムを構築できる。
    - たとえば、指定された時間が経過した場合にキャンセル要求を行う、ジェネリックな`timeout()`アルゴリズムを定義できるようにする。
- キャンセル要求が行われないことがコンパイル時に分かる場合、キャンセルのためのオーバーヘッドがかからないようにする。
- 非同期処理の呼び出し元と呼び出された側のいずれに対しても、キャンセルのサポートを強制しない。
    - キャンセルのサポートはオプトイン（デフォルトは非サポート）
    - 呼び出し元がキャンセルを要求しない場合は、キャンセルをオプトアウトするために何もする必要が無い

そして、このために次のような変更を提案しています。

- `std::stop_token`と同様に扱えるクラスを表すための、`std::stoppable_token`コンセプトを追加する
    - 特定のユースケースにおいてより効率的な`stop_token-like`な同期プリミティブを`std::stop_token`の代わりに使用できるようにする
- `std::stoppable_token`を改善版である2つのコンセプトを追加する。
    - `std::stoppable_token_for<CB, Initializer>` : `stoppable_token`であることに加えて、`stop_token`のインスタンスと`Initializer`の値から`T::callback_type<CB>`が構築可能であることを表す。
    - `std::unstoppable_token` : [`stop_possible()`](https://cpprefjp.github.io/reference/stop_token/stop_token/stop_possible.html)メンバ関数が`constexpr`であり常に`false`を返す`stop_token`を表す。
- その操作に使用する`stop_token`を`connect`された`reciever`が取得できるようにするために`get_stop_token()`CPOを追加する。
- `reciever`に関連付けられた`stop_token`の型を求めるための型特性を追加する。
    - `std::stop_token_type_t<T>`は、型`T`を引数として呼び出された`get_stop_token()`の戻り値型をdecayして取得する
- `std::stoppable_token`コンセプトを満たす2つの新しい`stop_token`を追加する
    - `std::never_stop_token` : キャンセルが不要な場合に使用される`stop_token`。
    - `std::in_place_stop_token` : [`stop_source`](https://cpprefjp.github.io/reference/stop_token/stop_source.html)が`movable/copyable`である必要が無く、`stop_token`の生存期間が対応する`stop_source`の生存期間内に厳密に収まっている場合に使用できる`stop_token`。
- `std::stop_token`にメンバ型`::callback_type`を追加する（`std::stoppable_token`コンセプトのために必要）

提案されているものは、facebookによるC++ Executorの実装である[libunifex](https://github.com/facebookexperimental/libunifex)にて既に実装されているようです。

- [std::stop_token - cpprefjp](https://cpprefjp.github.io/reference/stop_token/stop_token.html)
- [The need for cancellation - facebookexperimental/libunifex - Github](https://github.com/facebookexperimental/libunifex/blob/master/doc/cancellation.md)
- [P2175 進行状況](https://github.com/cplusplus/papers/issues/953)

### [P2186R1 Removing Garbage Collection Support](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2186r1.html)
### [P2195R1 Electronic Straw Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2195r1.html)
### [P2213R1 Executors Naming](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2213r1.pdf)
### [P2216R1 std::format improvements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2216r1.html)
### [P2233R3 2020 Fall Library Evolution Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2233r3.html)
### [P2238R0 Core Language Working Group "tentatively ready" issues for the November, 2020 meeting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2238r0.html)

11月に行われた全体会議で採択された、6つのコア言語のIssue報告とその解決の一覧。

概要だけを記載しておくと

1. 構造体（集成体）に対する構造化束縛が`mutable`メンバを考慮するようになった
2. 制約によるオーバーロード候補からの除外を、テンプレートパラメータの置換よりも先に行うようにする
    - [Concept-basedオーバーロードとSFINAE-unfriendlyメタ関数の落とし穴 - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20200906/p1)
3. “flowing off the end of a coroutine”という用語の意味を明確にする
4. 展開されていないパラメータパックが、その外側の関数型に依存しないようにする
5. C言語リンケージを持ち、制約されている`friend`関数の複数の宣言が、同じ関数を参照するようにする
6. `requires`節に`bool`にならない（*atomic constraint*ではない）有効な式を指定することがill-formedである事を規定

### [P2247R1 2020 Library Evolution Report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2247r1.html)
### [P2248R1 Enabling list-initialization for algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2248r1.html)
### [P2262R0 2020 Fall Library Evolution Poll Outcomes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2262r0.html)

2020年11月に行われた全体会議におけるLEWGでの投票の結果。

投票にかけられる提案の一覧は[P2233R3 2020 Fall Library Evolution Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2233r3.html)にあります。

ここでは、投票の結果及び投票者のコメントが記載されています。

### [P2263R0 A call for a WG21 managed chat service](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2263r0.html)

WG21が管理するチャットサービスを確立するための提案。

現在WG21は、freenodeのIRCチャネルとSlackの[cpplang](https://cpplang.slack.com/)ワークスペースの2つのチャットサービスを利用しているようですが、これらはWG21のメンバによって維持・管理されているものではなく、WG21行動規範やISO行動規範に従って管理されているものでもありません。

WG21の慣行及び手順に基づいて管理されるWG21が後援・維持するチャットサービスが必要とされたため、この提案はその検討と議論のためのものです。主に、チャットサービスに求める要件が列挙されています。

### [P2264R0 Make assert() macro user friendly for C and C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2264r0.html)
### [P2265R0 Renaming any_invocable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2265r0.pdf)

提案中の[`any_invocable`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0228r6.html)の名前を変更する提案。

`any_invocable`は`std::function`の制約付きのサブセットであり、最大の特徴はムーブオンリーであることです。しかし、その名前はその特徴を表しておらず、一般的なC++開発者はムーブオンリー`std::function`の名前として`any_invocable`を期待することは無いといっても過言ではありません。

また、`any_invocable`は進行中の[`function_ref`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html)（*Callable*オブジェクトを所有せず参照するだけの軽量な`std::function`）及び`std::function`の補完を行い標準ライブラリの関数ラッパ機能をより完全にするためのものです。しかし、それらとの名前の一貫性が無く、`function_ref`に比べると何をするものなのか分からない命名になっています。

これらの理由により、`any_invocable`という名前は適切ではないため、変更を推奨する提案です。

この提案ではエンティティの名前に求めるもの、求められるものを6項目上げて説明したうえで、それに従った名前として、名前に`function`を含めたうえで`movable`や`move_only`などのプリフィックスを付けることが望ましいと述べています（筆者の方は`movable_function`を推しています）。

- [P0288R6 : any_invocable - ［C++］WG21月次提案文書を眺める（2020年8月）](https://onihusube.hatenablog.com/entry/2020/09/18/222444#P0288R6--any_invocable)
- [[C++] C++ proposalとして提案中のfunction_refを実装してみた](https://qiita.com/Kogia_sima/items/1c0f93fd1350d64e529a)

### [P2268R0 Freestanding Roadmap](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2268r0.html)
### [P2272R0 Safety & Security Review Board](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2272r0.pdf)
### [P2273R0 Making std::unique_ptr constexpr](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2273r0.pdf)
### [P2274R0 C and C++ Compatibility Study Group](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2274r0.pdf)