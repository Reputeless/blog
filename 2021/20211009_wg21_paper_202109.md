# ［C++］WG21月次提案文書を眺める（2021年09月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2021 mailing2021-09](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/#mailing2021-09)

全部で42本あり、SG22（C/C++相互互換性に関する研究グループ）のCの提案を除くと41本になります。

[:contents]

### [P0288R9 `move_only_function` (was `any_invocable`)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0288r9.html)
### [P0447R16 Introduction of `std::hive` to the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0447r16.html)
### [P0627R5 Function to mark unreachable code](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0627r5.pdf)

到達不可能なコード領域であることを示す、`std::unreachable()`の提案。

あるコードブロックについて、プログラマはそこが実行されないことを知っていたとしても、コンパイラにとってはそうではありません。そのような場合に、コンパイラにそれを通知する方法があるとより効率的なプログラムを作成できる可能性があります。例えば、`switch`文でよく見る事ができます。

```cpp
void do_something(int number_that_is_only_0_1_2_or_3) {
  switch (number_that_is_only_0_1_2_or_3) {
  case 0:
  case 2:
    handle_0_or_2();
    break;
  case 1:
    handle_1();
    break;
  case 3:
    handle_3();
    break;
  }
}
```

このような場合、コンパイラは4以上の入力に対して処理をスキップするコードを生成します。この時、4以上の入力が決して来ないことがわかっていて、それをコンパイラに伝える事ができればそのような余分なコードの生成を抑止する事ができます。

他にも有用な場合が多々あるため、C++の処理系でもそのような機能を持っているものがあります。

- GCC,clang,ICC : `__builtin_unreachable()`
- MSVC : `__assume(false)`

このようなサポートのない実装でも意図的にゼロ除算を行い未定義動作を挿入する事で到達不能性を表現できますが、それは直感的ではなく推奨されません。この提案は、標準的な方法によって到達不可能であることを表現できるようにしようとするものです。

この提案では、`std::unreachable()`という関数によってそれを行います。

```cpp
namespace std {
  [[noreturn]] void unreachable();
}
```

この関数は呼び出されると未定義動作であると規定されており（正確には、事前条件が常に満たされないように規定されている）、呼び出されているコンテキストは未定義動作であることからコンパイラはその場所が実行されないと仮定する事ができ、それによって到達不能性を表現します。

先ほどの`switch`文では次のように使用できます。

```cpp
void do_something(int number_that_is_only_0_1_2_or_3) {
  switch (number_that_is_only_0_1_2_or_3) {
  case 0:
  case 2:
    handle_0_or_2();
    break;
  case 1:
    handle_1();
    break;
  case 3:
    handle_3();
    break;
  default:
    std::unreachable();
  }
}
```

`std::unreachable()`の振る舞いが未定義動作であることを選択したのは次のような理由によります

- 呼び出された時の特定のアクションを規定しないことで、実装は自由な振る舞いを選択できる
    - 例えば、デバッグビルドにおいてトラップを発動するなど
- clangは`__builtin_unreachable()`の呼び出しを未定義動作であると規定している
- 動作が未定義であることで定数式では実行できず、必然的に`constexpr`コンテキストで呼ばれた場合の振る舞いが規定される

また、`[[unreachable]]`のような属性ではなく関数が好まれた一つの理由として、その実装を後から変更する事が可能となるためというのが挙げられています。

- [P0627 進行状況](https://github.com/cplusplus/papers/issues/275)

### [P0849R8 `auto(x)`: decay-copy in the language](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0849r8.html)
### [P1018R13 C++ Language Evolution status - pandemic edition – 2021/06-2021/08](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1018r13.html)
### [P1072R10 `basic_string::resize_and_overwrite`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1072r10.html)
### [P1885R7 Naming Text Encodings to Demystify Them](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1885r7.pdf)
### [P2012R1 Fix the range-based for loop, Rev1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2012r1.pdf)
### [P2036R3 Changing scope for lambda trailing-return-type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2036r3.html)
### [P2066R9 Suggested draft TS for C++ Extensions for Minimal Transactional Memory](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2066r9.html)
### [P2093R9 Formatted output](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2093r9.html)
### [P2128R6 Multidimensional subscript operator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2128r6.pdf)
### [P2214R1 A Plan for C++23 Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2214r1.html)
### [P2266R2 Simpler implicit move](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2266r2.html)
### [P2276R1 Fix cbegin](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2276r1.pdf)
### [P2278R1 cbegin should always return a constant iterator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2278r1.html)
### [P2314R3 Character sets and encodings](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2314r3.html)
### [P2316R2 Consistent character literal encoding](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2316r2.pdf)
### [P2322R4 `ranges::fold`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2322r4.html)
### [P2348R1 Whitespaces Wording Revamp](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2348r1.pdf)
### [P2362R3 Remove non-encodable wide character literals and multicharacter wide character literals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2362r3.pdf)
### [P2363R1 Extending associative containers with the remaining heterogeneous overloads](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2363r1.html)
### [P2372R3 Fixing locale handling in chrono formatters](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2372r3.html)
### [P2388R2 Minimum Contract Support: either Ignore or Check_and_abort](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2388r2.html)
### [P2408R1 Ranges views as inputs to non-Ranges algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2408r1.html)
### [P2418R1 Add support for std::generator-like types to `std::format`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2418r1.html)
### [P2419R1 Clarify handling of encodings in localized formatting of chrono types](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2419r1.html)
### [P2430R0 Slides: Partial success scenarios with P2300](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2430r0.pdf)
### [P2431R0 Presentation: Plans for P2300 Revision 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2431r0.pdf)
### [P2432R0 Fixing istream_view](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2432r0.pdf)

`std::views::istream_view<T>()`の他の`view`との非一貫性を正す提案。

`std::views::istream_view<T>()`は関数であり、型名ではありません。したがって、次のようなことはできません。

```cpp
int main() {
  std::istringstream mystream{"0 1 2 3 4"}; 

  std::ranges::istream_view<int> v{mystream}; // 型名ではないので、このような初期化はできない
  std::ranges::basic_istream_view<int, char> v{mystream}; // これはok
}
```

`istream_view`は、`std::ranges::basic_istream_view`という`view`の実体の型に対して`std::views::istream_view`というヘルパ関数が用意されています。一方で`<ranges>`の他の`view`は、`std::ranges::xxx_view`という実体の型に対して`std::views::xxx`という関数オブジェクト（CPO）が用意されており、`istream_view`だけがこれらの命名規則の外にあります。

そのため、上に書いたようなコードは他の`view`との一貫性のある自然な発想によって書かれますが、コンパイルエラーとなります。特に、`for`ループと共に書かれた場合に理解不能なエラーメッセージを見る事ができるでしょう・・・

```cpp
int main() {
  std::istringstream mystream{"0 1 2 3 4"}; 

  for (int v : std::ranges::istream_view<int>{mystream}) {
    ...
  }
}
```

この提案はこれらの問題を解決するべく、`istream_view`の命名規則を他の`view`と一貫させようとするものです。

この提案の後では、`istream_view`周りは次のようになります。

```cpp
namespace std::ranges {

  // basic_istream_viewクラスはそのまま
  template<movable Val, class CharT, class Traits>
    requires default_initializable<Val> && stream-extractable<Val, CharT, Traits>
  class basic_istream_view : public view_interface<basic_istream_view<Val, CharT, Traits>>;

  // charとwchar_tを予め嵌めた型エイリアスを追加
  template<class Val> 
  using istream_view = basic_istream_view<Val, char>;

  template<class Val> 
  using wistream_view = basic_istream_view<Val, wchar_t>; 

  namespace views {

    // 現在のviews::istream_view<T>()を削除し、views::istream<T> CPOを追加
    template<typename T>
    inline constexpr /*unspecified*/ istream = /*unspecified*/;
  }
}
```

これによって、`std::ranges::istream_view<T>`は型名を示すようになり`std::views::istream<T>`はそれを生成する関数オブジェクト（CPO）となり、その他の`view`との一貫性が保たれるようになります。

これらの解決はC++20へのDRとすることを提案しており、LEWGでのレビューでは合意が取れているようです。

- [P2432 進行状況](https://github.com/cplusplus/papers/issues/1098)

### [P2435R0 2021 Summer Library Evolution Poll Outcomes](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2435r0.html)

2021年の夏（7月から9月にかけて）に行われた、LEWGの全体投票の結果。

以下の5つの提案が投票にかけられ、P2138R4以外はLWGに転送されることが可決されています。また、その際に寄せられたコメントが記載されています。

- [P2138R4 Rules of Design <=> Wording Engagement](https://wg21.link/p2138r4)
- [P2372R1 Fixing Locale Handling In Chrono Formatters](https://wg21.link/p2372r1)
- [P1206R6 `ranges::to`](https://wg21.link/p1206r6)
- [P0533R8 constexpr For `<cmath>` And `<cstdlib>`](https://wg21.link/p0533r8)
- [P2273R2 Making `unique_ptr` constexpr](https://wg21.link/p2273r2)

### [P2436R0 2021 September Library Evolution Polls](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2436r0.html)

2021年の秋（10月から12月にかけて）に予定されている、LEWGでの全体投票の予定表。

以下の5つの提案が投票にかけられる予定です。

- [P2418R0 Add Support For `std::generator`-like Types To `std::format`](https://wg21.link/)
- [P2415R1 What Is A view?](https://wg21.link/)
- [P2432R0 Fix istream_view](https://wg21.link/)
- [P2351R0 Mark All Library Static Cast Wrappers As `[[nodiscard]]`](https://wg21.link/)
- [P2291R2 Add Constexpr Modifiers To Functions `to_chars` And `from_chars` For Integral Types In `<charconv>` Header](https://wg21.link/)

LEWGでの作業を完了してLWG（CWG）へ転送することを確認するための投票です。上の3つの提案はC++20へ逆適用することを目指しています。

### [P2437R0 Support for #warning](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2437r0.pdf)

警告を表示するための`#warning`プリプロセッシングディレクティブを追加する提案。

`#warning`ディレクティブは`#error`と同様にコンパイル時にプログラマに対してメッセージを発行する事ができますが、`#error`とは異なりコンパイルを停止しません。これは、ライブラリ開発者などが利用者に向けて致命的ではない警告を表示するのに役立ちます。

主要なC/C++コンパイラのほとんどが既にこれを実装しておりデファクトスタンダードとなっています。加えて、C言語ではC23に向けてすでに`#warning`ディレクティブが承認されているため、C++でも同じ機能をサポートする事でコンパイラ実装は2つの言語間で実装を共有でき、CとC++の相互運用性を高める事ができます。

```cpp
// マルチスレッド対応していないライブラリのヘッダにおいて、それを警告するのに使用する
// シングルスレッドで使用する分には問題ないのでコンパイルを止めたくない
#warning This library currently has no thread support.

...

```

- [P2437 進行状況](https://github.com/cplusplus/papers/issues/1103)

### [P2438R0 `std::string::substr() &&`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2438r0.html)

右辺値`std::string`からの`substr()`を効率化する提案。

`std::string::substr()`関数は、元の文字列の一部を切り出した部分文字列を返す関数です。その際、切り出した部分文字列は新しい`std::string`オブジェクトにコピーされて返されます。

```cpp
// コマンドライン引数の一部を取り出す
benchmark = std::string(argv[i]).substr(12);

// prvalueなstringの一部を切り出す
name_ = obs.stringValue().substr(0,32);
```

このように、元の`std::string`オブジェクトが右辺値である場合、`substr()`の処理では元の文字列の保持する領域を再利用してやることで余計なコピーとアロケーションを回避できます。これは、メンバ関数の`&&`修飾を利用すれば可能であり、似たような最適化は`std::optional`などに見ることができます。

現在、`std::string::substr()`には`const`修飾されたものだけが提供されており、この提案ではそれを`&&, const &`の2つに変更することを提案しています。

```cpp
// 現在のsubstr()
constexpr basic_string substr(size_type pos = 0, size_type n = npos) const;

// この提案後のsubstr()
constexpr basic_string substr(size_type pos = 0, size_type n = npos) const &;
constexpr basic_string substr(size_type pos = 0, size_type n = npos) &&;
```

提案より、振る舞いの変化例

```cpp
// aから部分文字列のstringをコピーして作成、aは変更されない（この振る舞いは変わらない）
auto a = std::string(/* */);
auto b = a.substr(/*  */);


auto foo() -> std::string;
// 現在 : 一時オブジェクトのstringから部分文字列のstringをコピーして作成
// 提案 : 一時オブジェクトのstringのリソースを再利用して部分文字列を保持するstringオブジェクトを作成
auto b = foo().substr(/* */);

// 現在 : 一時オブジェクトのstringから部分文字列のstringをコピーして作成
// 提案 : 一時オブジェクトのstringのリソースを再利用して部分文字列を保持するstringオブジェクトを作成
auto a = std::string(/* */).substr(/* */);

// 現在 : aから部分文字列のstringをコピーして作成、aは変更されない
// 提案 : aのリソースを再利用して部分文字列を保持するstringオブジェクトを作成、aは有効だが未規定な状態となる
auto a = std::string(/* */);
auto b = std::move(a).substr(/* */);
```

最後のケースだけはこの提案の変更によって破壊的変更となります。とはいえ現在このように記述するメリットはないためこう書くことはなく、書いたとしても明示的に`move`しているため`a`の値にはもはや関心が無いことを理解した上でコンパイラにそれを伝えているはずなので、この提案の変更によってその意図した振る舞いが得られることになります。

また、この変更は既存の`substr() const`を`cosnt &`と`&&`に置き換えるものなのでABiの破壊も伴います。しかし、ライブラリ実装は古い実装を同時に提供し続けておくことができるため、ABIの後方互換を保ちながらこの変更を適用可能であるようです。

また、`std::string`はコンストラクタによっても`substr()`を使用したのと同じことを行うことができるようになっているため、この提案では同時に右辺値`substr()`オーバーロードに対応したコンストラクタを追加することも提案しています。

```cpp
// 右辺値stringから部分文字列を切り出すコンストラクタ
constexpr basic_string( basic_string&& other, size_type pos, const Allocator& alloc = Allocator() );
constexpr basic_string( basic_string&& other, size_type pos, size_type count, const Allocator& alloc = Allocator() );
```

この提案のオーバーロードは、元の`std::string`オブジェクトのリソースを再利用することから、アロケータを適切に伝播しなければなりません。

```cpp
std::pmr::string s1 = ....;
std::pmr::string s2 = std::move(s1).substr();
```

この場合、`s1.get_allocator() == s2.get_allocator()`とならないと、再利用したリソースを適切に開放することができません。これは、`std::allocator_traits<A>::is_always_equal::value == true`となる場合は常に再利用することができます。そうならない状態を持つアロケータでもそれを再利用（`move`）することで効率的なアロケータ伝播を達成できます。それ以外の場合（アロケータのムーブができないなど）は既存の`substr()`と同じ振る舞いとなるため、効率性はなくなりますが追加のオーバーヘッドはありません。

この提案はこれらの最適化を実装に強制するものではなくこのような最適化を実装が選択できるようにし、またそれを推奨するものであり、実装はどのように最適化するかを自由に選択することができます。従って、このアロケータの伝播をどのようにするかは実装定義とすることを提案しています。

- [`std::basic_string::substr` - cpprefjp](https://cpprefjp.github.io/reference/string/basic_string/substr.html)
- [P2438 進行状況](https://github.com/cplusplus/papers/issues/1104)

### [P2439R0 Slides for P2415R1, what is a view?](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2439r0.pdf)
### [P2440R0 ranges::iota, ranges::shift_left, and ranges::shift_right](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2440r0.html)

新しいRangeアルゴリズムである、`ranges::iota, ranges::shift_left, ranges::shift_right`の提案。

これらのアルゴリズムは新しいものではなく、標準ライブラリに古いタイプのものが既にあります。`shift_left/shift_right`はC++20で追加されたため議論が間に合わず、`iota`は`<numeric>`にあったため後回しにされていました（`<numeric>`のアルゴリズムはより慎重な議論が必要であるとしてC++20に無理に間に合わそうとはしていなかったようです）。

#### `ranges::iota`

`ranges::iota`は効果が単純であるためすぐに追加できたのですが、`<ranges>`にはすでに`views::iota`が存在していたため、その有用性が不明であったためC++20には追加されませんでした。

`ranges::iota`は出力範囲の要素数に基づいて書き込む値の数が決定されますが、`view::iota`はそうではなくその数を事前に決定する必要があるため、`ranges::iota`は出力範囲があらかじめ得られている場合に効率的です。

追加されるのは次の二つの形式のオーバーロードです。

```cpp
// in <numeric>

namespace std::ranges {
  // iotaの戻り値型
  template<class O, class T>
    using iota_result = out_value_result<O, T>;
  
  // イテレータペアを受け取る
  template<input_or_output_iterator O, sentinel_for<O> S, weakly_incrementable T>
    requires indirectly_writable<O, const T&>
  constexpr iota_result<O, T> iota(O first, S last, T value);

  // Rangeオブジェクトを受け取る
  template<weakly_incrementable T, output_range<const T&> R>
  constexpr iota_result<borrowed_iterator_t<R>, T> iota(R&& r, T value);
}
```

戻り値型である`iota_result`は範囲の終了位置を指すイテレータと計算値の最終値のペアとなる集成体です。

cpprefjpのサンプルを改変したコード例

```cpp
#include <numeric>
#include <iostream>
#include <array>

int main() {

  // 0から始まる10要素のシーケンスを作成する。
  std::array<int, 10> ar;
  const auto [it, v] = std::ranges::iota(ar, 0);

  for (int x : ar) {
    std::cout << x << std::endl;  // 0123456789
  }

  std::cout << (it == ar.end()) << std::endl; // true
  std::cout << v; // 10
}
```

#### `ranges::shift_left, ranges::shift_right`

`shift_left/shift_right`もC++20を目指していたのですが、`ranges::shift_left`の戻り値型（シフト後範囲を示す`ranges::subrange`）が元の範囲の終端についての情報を失っていることが懸念から議論が長引き、C++20に間に合いませんでした。特に、番兵によって範囲の終端が示される場合、シフト後範囲の終端と番兵によって示される元の範囲の終端との間の要素はムーブされているため、元の範囲の終端を復元するのが難しいという懸念があったようです。

結局、次のような結論が得られたようです。

- 戻り値の`subrange`が空でない場合、その`end()`からシフト量`n`だけ進めることで終端を回復できる。
- 戻り値の`subrange`が空の時（元の範囲のサイズよりシフト量の方が大きい時）、アルゴリズムは必ずしも元の範囲の終端を計算していない可能性がある。
    - この時必要なのはサイズのみ。それは`last - first`(引数のイテレータペアが`sized_sentinel_for`のモデルとなる場合)か`ranges::size()`(引数の`range`型が`sized_range`のモデルとなる場合)によって計算できる。
    - そしてその場合、元の範囲は変更されないことが保証できる。

そして、ユーザーが自分で分解する必要のある複雑な型を返すよりも処理結果の部分範囲を示す`subrange`を返した方が使いやすく、範囲終端を計算する可能性があるがそれを返さないタイプのアルゴリズムには前例があります（`ranges::cout, ranges::min/max`など）。そして、問題が発生しない`ranges::shift_rgiht`と戻り値型を一貫させることができます。

これらの理由からこの提案では、`ranges::shift_left, ranges::shift_right`の戻り値型は[当初の提案](https://wg21.link/p1243r3)通りにシフト後の部分範囲を示す`subrange`とすることを提案しています。

提案では`ranges::iota`と同様にそれぞれ2種のオーバーロードを追加します

```cpp
namespace std::ranges {
  // イテレータペアを受け取るshift_left
  template<permutable I, sentinel_for<I> S>
  constexpr subrange<I> shift_left(I first, S last, iter_difference_t<I> n);

  // rangeオブジェクトを受け取るshift_left
  template<forward_range R>
    requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R> shift_left(R&& r, range_difference_t<R> n);

  // イテレータペアを受け取るshift_right
  template<permutable I, sentinel_for<I> S>
  constexpr subrange<I> shift_right(I first, S last, iter_difference_t<I> n);

  // rangeオブジェクトを受け取るshift_right
  template<forward_range R>
    requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R> shift_right(R&& r, range_difference_t<R> n);
}
```

前述の議論の通り、戻り値型はシフト後の`subrange`です（`borrowed_subrange_t`とは引数の`range`オブジェクトが右辺値であるなどダングリングイテレータの危険があるときに代わりのタグ型を返すものです）。

cpprefjpのサンプルを改変したコード例

```cpp
#include <iostream>
#include <ranges>
#include <vector>
#include <algorithm>

int main() {
  // shift_left
  {
    std::vector<int> v = {1, 2, 3, 4, 5};

    std::ranges::range auto shifted_range = std::ranges::shift_left(v, 2);

    for (int x : shifted_range) {
      std::cout << x << ',';  // 3,4,5,
    }
    std::cout << std::endl;
  }

  // shift_right
  {
    std::vector<int> v = {1, 2, 3, 4, 5};

    std::ranges::range auto shifted_range = std::ranges::shift_right(v, 2);

    for (int x : shifted_range) {
      std::cout << x << ',';  // 1,2,3,
    }
    std::cout << std::endl;
  }
}
```

- [`std::shift_left` - cpprefjp](https://cpprefjp.github.io/reference/algorithm/shift_left.html)
- [`std::shift_right` - cpprefjp](https://cpprefjp.github.io/reference/algorithm/shift_right.html)
- [`std::iota` - cpprefjp](https://cpprefjp.github.io/reference/numeric/iota.html)
- [P2440 進行状況](https://github.com/cplusplus/papers/issues/1106)

### [P2441R0 `views::join_with`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2441r0.html)

パターンによって`range`の`range`となっているような範囲を接合して平坦化するRangeアダプタ、`views::join_with`の提案。

`views::join`が`range`の`range`を単にそのまま平坦化（内側`range`の各要素からなる`range`に変換）するのに対して、`join_with`は指定されたパターンを挿入しながら平坦化します。

```cpp
std::vector<std::string> vs = {"the", "quick", "brown", "fox"};

for (char c : vs | std::views::join_with(' ')) {
    cout << c;  
}
// "the quick brown fox"という文字列が出力される

for (char c : vs | std::views::join) {
    cout << c;  
}
// "thequickbrownfox"という文字列が出力される
```

この例では入力の`vs`は`std::string`の`std::vector`という`range`の`range`であり、内側の`range`は`std::striing`です。`views::join`による平坦化は内側`range`の各`std::string`をそのまま繋げた`range`に変換するものですが、`views::join_with`は内側の各`range`の末尾に指定されたパターン（ここではスペース1つ）を挿入して1本の`range`に変換します。

また、これは`views::split`の逆変換となっており、パターン`p`による`str | views::split(p) | views::join_with(p)`の様な変換は、もとの`str`と同じシーケンスとなります（型は異なりますが）。

この様な平坦化は、`views::join`が追加の引数を取るようにすることによっても実装できますが、`range`の`range`を`views::join`Rangeアダプタオブジェクトに渡したときの曖昧さを回避するために別の名前の`view`として導入しています（`views::join(rr)`が`rr`を平坦化したいのか`rr`で`join_with`したのか不明瞭になる）。

上記例では単に文字（`single_view`に変換されている）を渡していましたが`join_with`のパターンには任意の`range`を渡すことができ、その`value_type/reference`は入力`range`の内側`range`の`value_type/reference`と`common_type`を有している必要があり、その`common_type`が`join_with`の`value_type/reference`となります。

`join_with`は`join`と同様に入力として*prvalue*の非`view`な`range`をキャッシュすることで処理することができます。その場合の`join_with`は`input_range`となり、そうでない場合は入力`range`とその内側`range`及びパターンの`range`の共通部分となるカテゴリになります。

- [P2440 進行状況](https://github.com/cplusplus/papers/issues/1107)

### [P2442R0 Windowing range adaptors: views::chunk and views::slide](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2442r0.html)
### [P2443R0 views::chunk_by](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2443r0.html)
### [P2444R0 The Asio asynchronous model](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2444r0.pdf)
### [P2446R0 views::move](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2446r0.html)