# ［C++］WG21月次提案文書を眺める（2023年01月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-02](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-02)

SG22のWG14からのものを除いて、全部で102本あります。

[:contents]

### [P0290R3 `apply()` for `synchronized_value`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0290r3.html)

↓

### [P0290R4 `apply()` for `synchronized_value`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0290r4.html)

ミューテックスを用いた値への同期アクセスをラップするユーティリティの提案。

この提案の`synchronized_value<T>`は`T`の値とミューテックスをペアで保持する型で、保持する`T`の値へのアクセスを保持するミューテックスによって同期化するものです。

```cpp
// synchronized_valueの宣言例
namespace std::experimental::inline concurrency_v2 {

  template<class T>
  class synchronized_value {
  public:
      synchronized_value(synchronized_value const&) = delete;
      synchronized_value& operator=(synchronized_value const&) = delete;

      template<class ... Args>
      synchronized_value(Args&& ... args);

  private:
      T value;   // exposition only
      mutex mut; // exposition only
  };

  template<class T>
  synchronized_value(T) -> synchronized_value<T>;
}
```

読み出しと書き込みを直接サポートしていませんが、それがあったとしてもそれだけなら`std::atomic`で十分であり、存在理由がありません。

ミューテックスを用いた値アクセスの同期化がアトミックアクセスと異なるところは、ミューテックスのロックと解放によって1度のアクセスを超えた範囲のクリティカルセクションを確保できることにあります。`synchronized_value<T>`はそのために`apply()`非メンバ関数を提供します。

```cpp
// apply()の宣言例
namespace std::experimental::inline concurrency_v2 {

  template<class F,class ... ValueTypes>
  invoke_result_t<F, ValueTypes&...> apply(F&& f, synchronized_value<ValueTypes>&... values);
}
```

`apply()`は、1つ以上の`synchronized_value<T>`とそれと同じ数の`T...`の値から呼び出し可能な`f`を受けて、`f(T...)`の呼び出し前後で`values`の全てのミューテックスのロックと解放を自動でかつ適切に行うことで`T...`の値に対するクリティカルセクション内で`f`を実行します。

```cpp
synchronized_value<std::string> s;

// 単純な読み出しの例
std::string read_value() {
  // apply()に渡した関数はsのmutexによるクリティカルセクション内で実行される
  return apply([](auto& x){ return x; }, s);
}

// 単純な書き込みの例
void set_value(const std::string& new_val) {
  // apply()に渡した関数はsのmutexによるクリティカルセクション内で実行される
  apply([&](auto& x){x=new_val;}, s);
}
```

`synchronized_value<T>`の保持する値へのアクセスはこの`apply()`を通してのみ行うことができ、使用間違いを防ぐために構築以外の操作は提供されていません。

ミューテックスを用いたアクセスの同期化においては同期対象の値とミューテックスオブジェクトがセットで扱われることになることが多いですが、コード上での記述はどうしても複数の変数宣言に分かれてしまうためセットは意味的なものとしてしか表現できません。また、実際のクリティカルセクションの作成においても、`std::lock_guard`などである程度自動化できるとはいえ、少なくともロックは手動で行う必要があり、その際に使用するミューテックスも明示的に指定しなければなりません。

`synchronized_value<T>`と`apply()`を用いると、同期対象の値とそのためのミューテックスのペアを型によって表現することができ、クリティカルセクションの作成においても手動でミューテックスを触る必要がなくなります。これによって、コードの可読性向上や記述ミスの防止などを図ることができます。

提案文書よりサンプルコード

より複雑な処理の例

```cpp
// 何かメッセージのキューを同期化する
synchronized_value<std::queue<message_type>> queue;

void process_message(){
  std::optional<message_type> local_message;

  // グローバルなキューからメッセージを1つ読み出してくる
  apply([&](std::queue<message_type>& q) {
      if(!q.empty()) {
        // 先頭メッセージ取り出し（クリティカルセクション）
        local_message.emplace(std::move(q.front()));
        q.pop_front();
      }
  }, queue);
  
  // 読み出しに成功していたら、それを使って何かする
  if(local_message) {
    do_processing(local_message.value());
  }
}
```

複数の値を処理する例

```cpp
// 口座間でお金を転送する例
void transfer_money(synchronized_value<account>& from_, // 転送元
                    synchronized_value<account>& to_,   // 転送先
                    money_value amount)                 // お金オブジェクト
{
  apply([=](auto& from, auto& to) {
    // 引き出して
    from.withdraw(amount);
    // 預け入れ
    to.deposit(amount);
  }, from_, to_);
}
```

このような複数の`synchronized_value<T>`に対する操作では特に、複数のミューテックスを用いたアクセスにおけるデッドロックを回避できるというメリットもあります。

このように、複数の`synchronized_value<T>`に対して何か関数を適用するという形は、`std::tuple`に対する`std::apply()`とよく似たものなので、名前もそこから取っています。

この提案はConcurrency TS v2向けに提案されており、2月のIssaquah会議でConcurrency TS v2に採択されています。

- [P0290 進行状況](https://github.com/cplusplus/papers/issues/255)

### [P0447R21 Introduction of `std::hive` to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0447r21.html)

要素が削除されない限りそのメモリ位置が安定なコンテナである`std::hive`（旧名`std::colony`）の提案。

以前の記事を参照

- [P0447R11 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2020年12月）](https://onihusube.hatenablog.com/entry/2020/12/06/015108#P0447R11-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R12 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2021年01月）](https://onihusube.hatenablog.com/entry/2021/02/11/153333#P0447R12-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R13 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P0447R13-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R14 Introduction of std::colony to the standard library - ［C++］WG21月次提案文書を眺める（2021年05月）](https://onihusube.hatenablog.com/entry/2021/06/13/165215#P0447R14-Introduction-of-stdcolony-to-the-standard-library)
- [P0447R15 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/07/12/182757#P0447R15-Introduction-of-stdhive-to-the-standard-library)
- [P0447R16 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2021年09月）](https://onihusube.hatenablog.com/entry/2021/10/03/193523#P0447R16-Introduction-of-stdhive-to-the-standard-library)
- [P0447R17 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P0447R17-Introduction-of-stdhive-to-the-standard-library)
- [P0447R18 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P0447R18-Introduction-of-stdhive-to-the-standard-library)
- [P0447R19 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2022年02月）](https://onihusube.hatenablog.com/entry/2022/03/19/224729#P0447R19-Introduction-of-stdhive-to-the-standard-library)
- [P0447R20 Introduction of std::hive to the standard library - ［C++］WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P0447R20-Introduction-of-stdhive-to-the-standard-library)

このリビジョンでの変更は、ブロック容量の制限が`std::hive`オブジェクト間でコピーされる条件について*Design Decisions*セクションに追記し提案する文言に正式に記載した、Appendix Fの修正、*Design Decisions*セクションのタイトルを修正、などです。

などです。

- [P0447 進行状況](https://github.com/cplusplus/papers/issues/328)

### [P0493R4 Atomic maximum/minimum](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0493r4.pdf)

`std::atomic`に対して、指定した値と現在の値の大小関係によって値を書き換えるmaximum/minimum操作である`fetch_max()/fetch_min()`を追加する提案。

以前の記事を参照

- [P0493R1 Atomic maximum/minimum - ［C++］WG21月次提案文書を眺める（2020年5月）](https://onihusube.hatenablog.com/entry/2020/06/01/001003#P0493R1--Atomic-maximumminimum)
- [P0493R2 Atomic maximum/minimum - ［C++］WG21月次提案文書を眺める（2021年5月）](https://onihusube.hatenablog.com/entry/2021/06/13/165215#P0493R2-Atomic-maximumminimum)
- [P0493R3 Atomic maximum/minimum - ［C++］WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P0493R3-Atomic-maximumminimum)

このリビジョンでの変更は

- 使用していなかったベンチマークの削除
- 非メンバ関数についてフリースタンディングであることを明記
- `fetch_max(), fetch_min()`に*remark*を追加
- ポインタの比較について*note*を追加
- ポインタの操作について説明を追記

などです。

この提案はC++26をターゲットして、LWGによるレビューを終えています。次の全体会議で投票にかけられる予定です。

- [P0493 進行状況](https://github.com/cplusplus/papers/issues/866)

### [P0792R13 function_ref: a non-owning reference to a Callable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0792r13.html)

↓

### [P0792R14 function_ref: a non-owning reference to a Callable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0792r14.html)

*Callable*を所有しない`std::function`である`std::function_ref`の提案。

以前の記事を参照

- [P0792R6 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P0792R6-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R8 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年02月）](https://onihusube.hatenablog.com/entry/2022/03/19/224729#P0792R8-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R9 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P0792R9-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R10 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P0792R10-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R11 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年09月）](https://onihusube.hatenablog.com/entry/2022/10/09/021557#P0792R11-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R12 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P0792R12-function_ref-a-non-owning-reference-to-a-Callable)

このリビジョンおよびR13での変更は、LWGのフィードバックによる文言の調整と、フリースタンディング指定の修正などです。

この提案はすでにLWGのレビューをパスして、次の全体会議にかけられることが決まっています（C++26ターゲットです）。

- [P0792 進行状況](https://github.com/cplusplus/papers/issues/256)

### [P0870R5 A proposal for a type trait to detect narrowing conversions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0870r5.html)

型`T`が別の型`U`へ縮小変換（*narrowing conversion*）を起こさずに変換可能かを調べるメタ関数`is_convertible_without_narrowing<T, U>`を追加する提案。

以前の記事を参照

- [P0870R1 A proposal for a type trait to detect narrowing conversions - ［C++］WG21月次提案文書を眺める（2020年04月）](https://onihusube.hatenablog.com/entry/2020/05/01/194425#P0870R2--A-proposal-for-a-type-trait-to-detect-narrowing-conversions)
- [P0870R3 A proposal for a type trait to detect narrowing conversions - ［C++］WG21月次提案文書を眺める（2020年05月）](https://onihusube.hatenablog.com/entry/2020/06/01/001003#P0870R3--A-proposal-for-a-type-trait-to-detect-narrowing-conversions)
- [P0870R4 A proposal for a type trait to detect narrowing conversions - ［C++］WG21月次提案文書を眺める（2020年10月）](https://onihusube.hatenablog.com/entry/2020/11/02/221657#P0870R4-A-proposal-for-a-type-trait-to-detect-narrowing-conversions)
- 
このリビジョンでの変更は、LWGのフィードバックの反映、変換元が定数式であることを考慮しないという意図的な選択についての解説を追記したことなどです。

この提案はLEWGのレビューをパスしたLWGに転送されています。

- [P0870 進行状況](https://github.com/cplusplus/papers/issues/724)

### [P0876R12 `fiber_context` - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0876r12.pdf)

スタックフルコルーチンのためのコンテキストスイッチを担うクラス、`fiber_context`の提案。

以前の記事を参照

- [P0876R11 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P0876R11-fiber_context---fibers-without-scheduler)

このリビジョンでの変更は、`fiber_context`から`stop_token`サポートを取り除いたこと、呼び出し側の提供する未初期化メモリ領域をファイバーのコールスタックとして使用するためのコンストラクタを追加したことです。

`stop_token`サポートが取り除かれたのはそれについて実装の懸念が生じたためのようです。各ファイバー（そのコールスタック）自体は`fiber_context`の寿命とは無関係ない永続的なエンティティですが、`fiber_context`はそうではありません。`fiber_context`の新しいオブジェクトは常に中断状態で生成され、これによってファイバーを一時停止するコードは関連する`stop_source`共有状態を見つけられなくなります。

`stop_token`を使用したいユーザーは、自身で`stop_source`を管理した上でそこから取得した`stop_token`を`fiber_context`に渡すラムダ式に渡しておけばよく、`fiber_context`で直接サポートする必要はない、とのことです。

```cpp
// fiber_contextの宣言例
namespace std::experimental::inline concurrency_v2 {
  class fiber_context {
  public:
    fiber_context() noexcept;

    template<typename F>
    explicit fiber_context(F&& entry);

    // コールスタック配置に使用するメモリ領域を受け取るコンストラクタ
    template<typename F, size_t N>
    explicit fiber_context(F&& entry, span<byte, N> stack);

    ~fiber_context();

    fiber_context(fiber_context&& other) noexcept;
    fiber_context& operator=(fiber_context&& other) noexcept;
    fiber_context(const fiber_context& other) noexcept = delete;
    fiber_context& operator=(const fiber_context& other) noexcept = delete;

    fiber_context resume() &&;

    template<typename Fn>
    fiber_context resume_with(Fn&& fn) &&;

    bool can_resume() noexcept;
    explicit operator bool() const noexcept;
    bool empty() const noexcept;

    void swap(fiber_context& other) noexcept;
  };
}
```

- [P0876 進行状況](https://github.com/cplusplus/papers/issues/117)

### [P1061R4 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1061r4.html)

構造化束縛可能なオブジェクトをパラメータパックに変換可能にする提案。

以前の記事を参照

- [P1061R2 Structured Bindings can introduce a Pack - WG21月次提案文書を眺める（2022年04月）](https://onihusube.hatenablog.com/entry/2022/05/08/195618#P1061R2-Structured-Bindings-can-introduce-a-Pack)
- [P1061R3 Structured Bindings can introduce a Pack - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P1061R3-Structured-Bindings-can-introduce-a-Pack)

このリビジョンでの変更は、CWGのレビューに伴うフィードバックを反映したことです。

- [P1061R2 進行状況](https://github.com/cplusplus/papers/issues/294)

### [P1708R7 Basic Statistics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1708r7.pdf)

標準ライブラリにいくつかの統計関数を追加する提案。

以前の記事を参照

- [P1708R3 Simple Statistical Functions - ［C++］WG21月次提案文書を眺める（2021年01月）](https://onihusube.hatenablog.com/entry/2021/02/11/153333#P1708R3-Simple-Statistical-Functions)
- [P1708R4 Simple Statistical Functions - ［C++］WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P1708R4-Simple-Statistical-Functions)
- [P1708R5 Simple Statistical Functions - ［C++］WG21月次提案文書を眺める（2021年06月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P1708R4-Simple-Statistical-Functions)
- [P1708R6 Simple Statistical Functions - ［C++］WG21月次提案文書を眺める（2022年03月）](https://onihusube.hatenablog.com/entry/2022/04/02/175835#P1708R6-Simple-Statistical-Functions)

このリビジョンでの変更は

- オーバーロードを活用して、重み付きと重みなしの関数を呼び分けるようにした
- 導出の表示を簡略化
- 歪度と尖度の導出を追加
- 文言の調整

などです。

- [P1708 進行状況](https://github.com/cplusplus/papers/issues/475)

### [P1715R1 Loosen restrictions on "_t" typedefs and "_v" values.](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1715r1.html)

[`std::conditional_t`](https://cpprefjp.github.io/reference/type_traits/conditional.html)の定義を修正する提案。

C++14で導入された`conditional_t`は、`std::conditional<B, T, F>::type`に簡易にアクセスするためのものです。それは次のような実装になるように指定されています

```cpp
namespace std {
  template <bool B, class T, class F>
  struct conditional {
    using type = …;
  };

  template <bool B, class T, class F>
  using conditional_t = typename conditional<B, T, F>::type; // C++14
}
```

`conditional_t`は`conditional<B, T, F>::type`のエイリアスでなくてはならないわけですが、このように指定していることが`conditional_t`のより効率的な実装を妨げています。

`conditional_t<B, T, F>`の現在の実装では、テンプレートパラメータ`B, T, F`毎に`std::conditional`のインスタンス化が必要となります。3つのパラメータのうちいずれか1つが異なっているだけで、`std::conditional`の新しいインスタンス化が必要となります。これは、`conditional_t`を多用する環境において、コンパイル時間の増大やデバッグ情報の肥大化を招きます。

例えば、`conditional_t`の実装を次のように変更したとすると

```cpp
template<bool _Bp>
struct __select;

template<>
struct __select<true>  {
  template<typename _TrueT, typename _FalseT>
  using type = _TrueT;
};

template<>
struct __select<false> {
  template<typename _TrueT, typename _FalseT>
  using type = _FalseT;
};

template <bool _Bp, class _TrueT, class _FalseT>
using conditional_t = typename __select<_Bp>::template type<_TrueT, _FalseT>;
```

この実装では、`conditional_t<B, T, F>`が異なるパラメータの組み合わせで何度使用されても、インスタンス化されるのは`__select<true>`と`__select<false>`の2つのクラステンプレートだけです（エイリアステンプレートはインスタンス化されないため）。`conditional_t`がどれだけ多用されようともこの2つのクラステンプレートがインスタンス化された後はその定義を使いまわすことができ、最終的な型の決定においてはエイリアステンプレートの実引数による置換だけしか発生しません。これによって、コンパイラのメモリ使用量を抑えるだけでなく、デバッグのために出力するデバッグ情報に記録される型情報も削減することができます。

筆者の方の（Googleにおける）調査では、特にTMPが多用されているファイルに対してclangが出力するデバッグ情報の1部として記録されているクラス名の約1/6が`std::conditional`のインスタンス化で占められていたそうです。

この提案は、これらの理由から、`conditional_t`の実装を`std::conditional`から切り離し、より効率的な実装を選択可能にするものです。

ただし、Google社内でこのような変更を行ったところ、この変更は観測可能であることが判明しています。

```cpp
// 最初にこのように宣言され
template<bool B>
long to_long(conditional_t<B, int, long> param);

...

// その後でこのように定義されている（おそらく記述ミス）
template<bool B>
long to_long(typename conditional<B, int, long>::type param) {
  return param;
}
```

この時、`conditional_t`が`std::conditional`によって定義されていない場合、この2つの関数宣言は異なるシグネチャを持つことになり、`to_long()`の呼び出しは2つのオーバーロードの間で曖昧となりコンパイルエラーを起こします。

ただし、この例が記述ミスを含むものであるように、このような例はかなり稀であるため実際の影響は非常に小さいと思われます。

- [P1715 進行状況](https://github.com/cplusplus/papers/issues/481)

### [P1759R5 Native handles and file streams](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1759r5.html)

標準ファイルストリームに、OSやプラットフォームネイティブのファイルを示すものを取得する方法およびその型エイリアスを追加する提案。

以前の記事を参照

- [P1759R3 Native handles and file streams - WG21月次提案文書を眺める（2020年10月）](https://onihusube.hatenablog.com/entry/2020/11/02/221657#P1759R3-Native-handles-and-file-streams)
- [P1759R4 Native handles and file streams - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P1759R4-Native-handles-and-file-streams)

このリビジョンでの変更は、ほぼ設計と提案する文言のみに文書を絞ったこと、対象の型（`.native_handle())`を持つ型）として`std::stacktrace_entry`を考慮し、それを他のものと比較する記述を追記した事です。

C++23で追加されたスタックトレースの1行を表す型である[`std::stacktrace_entry`](https://cpprefjp.github.io/reference/stacktrace/stacktrace_entry.html)もまた、その実装のハンドルを取得するために`.native_handle()`を持っています。ここから得られるネイティブハンドル型と`std::thread`のそれとを比較して、ネイティブハンドル型について次のような要求を追加することを提案しています

- `native_handle_type`は`semiregular`でありトリビアルコピー可能かつ`standard_layout`型
- ファイルのネイティブハンドルが何を意味しどのように動作するかを定義する

このことは、この提案の対象のファイルハンドルの`native_handle_type`に対してのみ要求されています。

- [P1759 進行状況](https://github.com/cplusplus/papers/issues/516)

### [P1854R4 Making non-encodable string literals ill-formed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1854r4.pdf)

文字列リテラルのエンコーディングを実行時エンコーディングに変換する際、文字表現が失われる場合をコンパイルエラーとする提案。

以前の記事を参照

- [P1854R1 Conversion to literal encoding should not lead to loss of meaning - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P1854R1-Conversion-to-literal-encoding-should-not-lead-to-loss-of-meaning)
- [P1854R2 Conversion to literal encoding should not lead to loss of meaning - ［C++］WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P1854R2-Conversion-to-literal-encoding-should-not-lead-to-loss-of-meaning)
- [P1854R3 Conversion to literal encoding should not lead to loss of meaning - ［C++］WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P1854R3-Conversion-to-literal-encoding-should-not-lead-to-loss-of-meaning)

このリビジョンでの変更は、CWGのフィードバックを適用した事です。

この提案は、CWGのレビューを終えて次の全体会議で投票にかけられる予定です。

- [P1854 進行状況](https://github.com/cplusplus/papers/issues/608)

### [P1928R3 Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r3.pdf)

`std::simd<T>`をParallelism TS v2から標準ライブラリへ移す提案。

以前の記事を参照

- [P1928R1 Merge data-parallel types from the Parallelism TS 2 - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2020/11/02/221657#P1759R3-Native-handles-and-file-streams)
- [P1928R2 Merge data-parallel types from the Parallelism TS 2 - WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P1928R2-Merge-data-parallel-types-from-the-Parallelism-TS-2)

このリビジョンでの変更は

- `hmin()/hmax()`の代替案を提案
- `<bit>`との一貫性のために、`simd_mask`の削減を議論。曖昧さを避けるためによりよい名前を募集
- `some_of`を削除
- `simd_mask`に単項`~`を追加
- マスク付きオーバーロードの名前と引数順序について議論と回答を追加
- `fixed_size`/`resize_simd`のNTTPを`int`から`size_t`へ変更
- ロード/ストアの変換について議論を追加
- P2509R0を関連提案として追加
- ロード/ストアをポインタから`contiguous_iterator`へと一般化
- `element_reference`の過剰な制約について*Open questions*に移動

などです。

この提案は、LEWGのレビューを通過し、LWGに転送するための投票待ちをしています。

- [P1759 進行状況](https://github.com/cplusplus/papers/issues/516)

### [P2022R0 Rangified version of `lexicographical_compare_three_way`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2022r0.pdf)

[`std::lexicographical_compare_three_way`](https://cpprefjp.github.io/reference/algorithm/lexicographical_compare_three_way.html)のRange版を追加する提案。

`std::lexicographical_compare_three_way`は、与えられた2つのイテレータ範囲を辞書式順序で三方比較するイテレータアルゴリズムです。この関数はC++20で[一貫比較](https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html)とともに導入されたこともあり、対応するRangeアルゴリズムは用意されていませんでした。

この提案は、それを追加するものです。

```cpp
// Rangeを受け取るものの宣言例
namespace std::ranges {

  template<
    ranges::input_range R1,
    ranges::input_range R2,
    class Comp = compare_three_way,
    class Proj1 = identity,
    class Proj2 = identity
  >
    requires is-lexicographical-compare-three-way-result-ordering<
               iterator_t<R1>, iterator_t<R2>, Comp, Proj1, Proj2
             >
  constexpr auto ranges::lexicographical_compare_three_way(
    R1&& r1,
    R2&& r2,
    Comp comp = {},
    Proj1 proj1 = {},
    Proj2 proj2 = {}
  ) -> common_comparison_category_t<
         decltype(
         comp(proj1(ranges::begin(r1)), proj2( ranges::begin(r2)))
         ),
         strong_ordering
       >;

}
```

他のRangeアルゴリズムと同様に、イテレータ範囲を受け取るものとそれを`range`で受け取るものの2種類が用意され、射影操作をサポートしています。`is-lexicographical-compare-three-way-result-ordering`というのは説明専用の`bool`定数の変数テンプレートで、それぞれの範囲の要素と比較関数オブジェクト`comp`による比較結果が比較カテゴリ型を返すことを調べるものです。

- [P2022 進行状況](https://github.com/cplusplus/papers/issues/1468)

### [P2047R6 An allocator-aware optional type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2047r6.html)

*Allocator Aware*な`std::optional`である、`std::pmr::optional`を追加する提案。

以前の記事を参照

- [P2047R1 An allocator-aware optional type - ［C++］WG21月次提案文書を眺める（2021年02月）](https://onihusube.hatenablog.com/entry/2021/03/12/225547#P2047R1-An-allocator-aware-optional-type)
- [P2047R2 An allocator-aware optional type - ［C++］WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2047R2-An-allocator-aware-optional-type)
- [P2047R3 An allocator-aware optional type - ［C++］WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/08/11/193828#P2047R3-An-allocator-aware-optional-type)
- [P2047R4 An allocator-aware optional type - ［C++］WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2047R4-An-allocator-aware-optional-type)
- [P2047R5 An allocator-aware optional type - ［C++］WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2047R5-An-allocator-aware-optional-type)

このリビジョンでの変更は、提案する文言やHTMLの調整です。

この提案はこれ以上議論されません。

- [P2047 進行状況](https://github.com/cplusplus/papers/issues/777)

### [P2159R1 A Big Decimal Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2159r1.html)

[Numbers TS (P1889R1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1889r1.pdf)に対して、10進多倍長浮動小数点型`std::decimal`を追加する提案。

以前の記事を参照

- [P2159R0 : An Unbounded Decimal Floating-Point Type - ［C++］WG21月次提案文書を眺める（2020年05月）](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2159r1.html)

このリビジョンでの変更はよくわかりませんが、SG6のレビューではこの提案の主張するユースケースに関心がないとして、これ以上議論しないことになったようです。

- [P2159 進行状況](https://github.com/cplusplus/papers/issues/870)

### [P2300R6 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2300r6.html)
### [P2308R0 Template parameter initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2308r0.html)

非型テンプレートパラメータの初期化に関しての規定を充実させる提案。

現在に至るまで、非型テンプレートパラメータ（NTTP）の初期化に関しての規定は、指定された初期化子がNTTPの型に変換可能であること、及び、その変換は定数式であること、くらいしか指定されていませんでした。それでも、C++17まではNTTPに取れるのは一部の組み込み型の値に限られていたたためあまり問題にはならなかったようです。

しかし、C++20から非型テンプレートパラメータとしてクラス型のオブジェクトを扱うことができるようになりました。NTTPとして扱えるクラス型には制限があるものの、コンストラクタを持つことができる他ポインタ型のメンバを持つこともできます。すると、左辺値NTTPをとるクラステンプレートの初期化時にそのアドレスを調べることができ、それによってある種のパラドックスが発生します。

```cpp
template<auto n>
struct B { /* ... */ };

struct J1 {
  J1* self = this;
};

B<J1{}> j1; // ??
```

このJ1自体はNTTPで使用可能なクラス型で、その初期化も問題なさそうに思えます。しかし、`J1::self`は`this`によってデフォルト初期化されており、`J1{}`とすると初期化にあたって自身のアドレスを要求します。普通の変数としておいた場合などではこれは問題にはならないのですが、ことNTTPだとこれが深刻な問題となります。これは簡単に言えば、`J1`の`this`を決めるためにはまずそのNTTPを持っているテンプレートがインスタンス化されなければならず、テンプレートがインスタンス化するためには全てのNTTPの初期化が完了しなければなりません。

これは、テンプレートはインスタンス化に際して（そのオーバーロードの適切な処理、あるいはODRのために）テンプレートパラメータ毎の同一性を判定する必要があり、NTTPの場合はその値の同一性によって判定され、クラス型のNTTPの場合その型名及び全てのメンバの値によって同一性が判定され、ポインタ型の同一性はそのアドレスによって判定されるためです。

現在の（C++20時点の）規定はこのようなことを考慮しておらず、このNTTP初期化に伴う矛盾を解決することができません。

この提案は、この問題を含むNTTPの初期化に関する規定を適切に書き直すことで、いくつかのコア言語Issueを解決するものです。上記問題の他にも、`{}`初期化がクラス型NTTPで使えるのかどうか不透明な問題も解決を図っています。

この提案によるアプローチではまず、テンプレート実引数で使用可能な構文（*template-argument*）として`{}`初期化子（*braced-init-list*）を許可します。

その上で、プレースホルダ型（`auto`）あるいはテンプレートパラメータを推論する必要のある形で宣言（[C++17 CTAD](https://cpprefjp.github.io/lang/cpp17/type_deduction_for_class_templates.html)）されているNTTPの型の推定について次のように変更します。そのような推論を必要とする型名/プレースホルダ（`auto`）を仮に`D`とすると

```cpp
// 現在
D x = template-argument;

// この提案
D x = E;
```

ここで、`E`は*template-argument*かデフォルト引数に指定されている`{}`初期化子のいずれかの式です。このような仮の`x`の初期化式を構成し、この時に`x`の型として推論される型をそのNTTPの型（仮に`T`とする）として推定します。

このようにすることで、NTTPのデフォルト引数も含めてNTTPの実引数として`{}`初期化子が使用できることを明示的にしています。

次に、NTTPの初期化においては、まず模範（*exemplar*）となる値をその初期化式（NTTPの実引数`A`）から決定します。模範となる値の型`U`を`T`もしくは`T`が参照型ならその参照される型として

- `U`がクラス型ではなく、`A`が波括弧初期化ではない場合
    - 模範となる値は、定数式で`A`を`T`へ変換した値
- それ以外の場合
    - `const U v = A;`と初期化される一時変数`v`を導入して
    - 模範となる値は、`v`

そして、NTTPは模範となる値からコピー初期化（*copy-initialization*）されます。

`U`がクラス型の場合、NTTPの同一性は模範となる値`v`によって決定されます。

このように、NTTPの初期化のための一時変数（模範となる値）を初期化して、それを用いてNTTPの同一性を判定し、またNTTPの値はそこからコピーして初期化することで、まずテンプレートの同一性が判定されてから初期化が起こるようにするとともに、上記`J1`メンバ`self`のような例では一時オブジェクトのアドレスを保持してしまうためエラーとなるようになります。

提案より、サンプルコード

```cpp
template<int i>
struct C { /* ... */ };

C<{ 42 }> c1;  // OK、波括弧初期化の許可

struct J1 {
  J1* self = this;
};

B<J1{}> j1;  // error: J1::selfが一時オブジェクトのアドレスを取っている

struct J2 {
  J2* self=this;
  constexpr J2() {}
  constexpr J2(const J2&) {}
};

B<J2{}> j2;  // error: NTTPの初期化後に模範となる値と異なる値が生成される（コピーコンストラクタの呼び出しによる）
```

- [C++20 非型テンプレートパラメータとしてクラス型を許可する](https://cpprefjp.github.io/lang/cpp20/class_types_in_non-type_template_parameters.html)
- [CWG Issue 2459. Template parameter initialization](https://cplusplus.github.io/CWG/issues/2459.html)
- [CWG Issue 2049. List initializer in non-type template default argument](https://cplusplus.github.io/CWG/issues/2049.html)
- [CWG Issue 2450. braced-init-list as a template-argument](https://cplusplus.github.io/CWG/issues/2450.html)
- [P2022 進行状況](https://github.com/cplusplus/papers/issues/1469)

### [P2338R4 Freestanding Library: Character primitives and the C library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2338r4.html)

`<charconv>`と`std::char_traits`をはじめとするいくつかのヘッダをフリースタンディングライブラリ指定する提案。

以前の記事を参照

- [P2338R0 Freestanding Library: Character primitives and the C library - WG21月次提案文書を眺める（2021年03月）](https://onihusube.hatenablog.com/entry/2021/04/10/222356#P2338R0-Freestanding-Library-Character-primitives-and-the-C-library)
- [P2338R1 Freestanding Library: Character primitives and the C library - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2338R1-Freestanding-Library-Character-primitives-and-the-C-library)
- [P2338R2 Freestanding Library: Character primitives and the C library - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P2338R2-Freestanding-Library-Character-primitives-and-the-C-library)
- [P2338R3 Freestanding Library: Character primitives and the C library - WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2338R3-Freestanding-Library-Character-primitives-and-the-C-library)

このリビジョンでの変更は、非推奨とされた`errc/errno`を取り除いたことです。

この提案は既にLWGでのレビューを終えており、次の全体会議で投票にかけられる予定です。

- [LWG Issue 3869. Deprecate `std::errc` constants related to UNIX STREAMS](https://cplusplus.github.io/LWG/issue3869)
- [P2338 進行状況](https://github.com/cplusplus/papers/issues/1017)

### [P2355R1 Postfix fold expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2355r1.html)
### [P2361R6 Unevaluated strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2361r6.pdf)
### [P2363R5 Extending associative containers with the remaining heterogeneous overloads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
### [P2406R3 Add lazy_counted_iterator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2406r3.html)

↓

### [P2406R4 Add lazy_counted_iterator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2406r4.html)

↓

### [P2406R5 Add lazy_counted_iterator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2406r5.html)
### [P2495R2 Interfacing stringstreams with string_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2495r2.pdf)
### [P2497R0 Testing for success or failure of `charconv` functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2497r0.html)

`std::to_chars_result`/`std::from_chars_result`に成否を簡単に問い合わせるための`bool`インターフェースを追加する提案。

[`std::to_chars_result`](https://cpprefjp.github.io/reference/charconv/to_chars_result.html)/[`std::from_chars_result`](https://cpprefjp.github.io/reference/charconv/from_chars_result.html)は`std::to_chars()`/`std::from_chars()`の結果型で、`std::errc`とポインタの2つのメンバを持っています。

多くの場合、それらの結果を構造化束縛で受けて、メンバの`errc`オブジェクトを`std::errc{}`（デフォルト値、成功を表す）と比較することで処理の成否を判断するコードが書かれます。

```cpp
// 42を文字列へ変換し範囲[p, last)へ書き込む
auto [ptr, ec] = std::to_chars(p, last, 42);

if (ec == std::errc{}) {
  // 成功時の処理
  ...
}
```

`std::errc`は単なるスコープ付き列挙型（`enum class`）でしかなく、これ以上に良い書き方は現状ありません。しかし、この比較は少し冗長かつ煩雑で、より読みやすい成功判定方法が求められました。

この提案はそのために、両結果型に`operator bool()`を追加して改善を図るものです。

```cpp
// 42を文字列へ変換し範囲[p, last)へ書き込む
auto [ptr, ec] = std::to_chars(p, last, 42);

if (ec) {
  // 成功時の処理
  ...
}

// あるいは
if (std::to_chars(p, last, 42)) {
  // 成功時の処理
  ...
}

// form_chars()も同様
if (int v;　std::from_chars(p, last, v)) {
  // 成功時の処理
  ...
}
```

```cpp
namespace std {
  struct to_chars_result {
    char* ptr;
    errc ec;
    
    friend bool operator==(const to_chars_result&, const to_chars_result&) = default;
    
    // 追加
    constexpr explicit operator bool() const noexcept { return ec == errc{}; }
  };

  struct from_chars_result {
    const char* ptr;
    errc ec;

    friend bool operator==(const from_chars_result&, const from_chars_result&) = default;
    
    // 追加
    constexpr explicit operator bool() const noexcept { return ec == errc{}; }
  };
}
```

この提案はすでにLWGのレビューを終えており、C++26ターゲットとして次の全体会議で投票にかけられる予定です（事務手続きのミスによりC++23にまにあわなかったとのこと・・・）

- [GB-083 19.5 [syserr] Add operator!(errc)](https://github.com/cplusplus/nbballot/issues/455)
- [P2497 進行状況](https://github.com/cplusplus/papers/issues/1454)

### [P2521R3 Contract support -- Record of SG21 consensus](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2521r3.html)
### [P2527R2 std::variant_alternative_index and std::tuple_element_index](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2527r2.html)
### [P2545R3 Why RCU Should be in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r3.pdf)
### [P2558R2 Add @, $, and ` to the basic character set](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2558r2.html)
### [P2572R1 std::format() fill character allowances](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2572r1.html)
### [P2588R3 Relax std::barrier phase completion step guarantees](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2588r3.html)
### [P2591R3 Concatenation of strings and string views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2591r3.html)
### [P2592R3 Hashing support for std::chrono value classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2592r3.html)
### [P2593R1 Allowing static_assert(false)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2593r1.html)
### [P2594R1 Slides: Allow programmer to control coroutine elision (P2477R3 Presentation))](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2594r1.pdf)
### [P2609R2 Relaxing Ranges Just A Smidge](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2609r2.html)

↓

### [P2609R3 Relaxing Ranges Just A Smidge](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2609r3.html)
### [P2616R4 Making std::atomic notification/wait operations usable in more situations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2616r4.html)
### [P2621R2 UB? In my Lexer?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2621r2.pdf)
### [P2641R2 Checking if a union alternative is active](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2641r2.html)
### [P2652R2 Disallow user specialization of allocator_traits](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2652r2.html)
### [P2655R2 common_reference_t of reference_wrapper Should Be a Reference Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2655r2.html)

↓

### [P2655R3 common_reference_t of reference_wrapper Should Be a Reference Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2655r3.html)
### [P2656R2 C++ Ecosystem International Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2656r2.html)
### [P2663R1 Proposal to support interleaved complex values in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2663r1.pdf)
### [P2664R1 Proposal to extend std::simd with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2664r1.pdf)
### [P2670R1 Non-transient constexpr allocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2670r1.html)
### [P2679R2 Fixing std::start_lifetime_as and std::start_lifetime_as_array](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2679r2.pdf)
### [P2681R1 More Basic Statistics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2681r1.pdf)
### [P2693R1 Formatting thread::id and stacktrace](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2693r1.pdf)
### [P2695R1 A proposed plan for contracts in C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2695r1.pdf)
### [P2724R1 constant dangling](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2724r1.html)
### [P2727R1 std::iterator_interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2727r1.html)
### [P2730R1 variable scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2730r1.html)
### [P2733R1 Fix handling of empty specifiers in std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2733r1.html)

↓

### [P2733R2 Fix handling of empty specifiers in std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2733r2.html)

↓

### [P2733R3 Fix handling of empty specifiers in std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2733r3.html)
### [P2736R2 Referencing the Unicode Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2736r2.pdf)
### [P2738R1 constexpr cast from void*: towards constexpr type-erasure](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r1.pdf)
### [P2740R1 Simpler implicit dangling resolution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2740r1.html)

↓

### [P2740R2 Simpler implicit dangling resolution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2740r2.html)
### [P2741R1 user-generated static_assert messages](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2741r1.pdf)
### [P2742R1 indirect dangling identification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2742r1.html)

↓

### [P2742R2 indirect dangling identification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2742r2.html)
### [P2749R0 Down with "character"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2749r0.pdf)

規格署中で使用される*character*という言葉を正しく使用しなおす提案。

規格署中で使用される*character*という言葉は多くの場所で不正確かつ曖昧な用法となっており、また、*translation set*というC++の規格署でしか使用されない言葉の使用にも問題があります。この提案は、適切な技術用語を使用してそれらを置き換えることで、表現を明確にするとともに解釈を容易にし、誤った意味にとられないようにするものです。

この提案では主に、単体あるいは近い型で使われている*character*という言葉をUnicodeの用語（*Unicode scalar value*/*Unicode code point*）によって置き換えようとしています。一方、文字リテラルや文字型などのC++の要素を指す言葉や、改行文字など既に明確なものは変更しようとはしていません。

この変更は言葉遣いの正確さを向上させるためのもので、何か動作の変更を意図したものではありません。そのため、ほとんどのプログラマには影響はないでしょう。

- [FR-020-014 5.3 [lex.charset] Replace "translation character set" by "Unicode" P2749](https://github.com/cplusplus/nbballot/issues/422)
- [P2749 進行状況](https://github.com/cplusplus/papers/issues/1470)

### [P2750R1 C Dangling Reduction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2750r1.html)

↓

### [P2750R1 C Dangling Reduction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2750r1.html)
### [P2751R1 Evaluation of Checked Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2751r1.pdf)
### [P2754R0 Deconstructing Avoiding Uninitialized Reads of Auto Variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2754r0.html)

未初期化自動変数のゼロ初期化に関するいくつかのソリューションをまとめ、比較する提案。

この提案は、[P2723R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2723r0.html)の提出をうけて寄せられたいくつものフィードバックから特にその代替手段について調査し、それらの特徴や利点を比べることで、P2723とその問題の議論を促進しようとするものです。

P2723R0については以前の記事を参照

- [P2723R0 Zero-initialize objects of automatic storage duration - WG21月次提案文書を眺める（2022年11月）](https://onihusube.hatenablog.com/entry/2022/12/25/175304#P2723R0-Zero-initialize-objects-of-automatic-storage-duration)

P2723R0の目標は、非クラス型の自動変数を初期化する前に不定の値を読み取ることによるセキュリティリスクを排除することです。P2723でもこの提案でも対象は未初期化の自動変数のみであり、その他のもの（動的確保したメモリや構造体のパディングなど）については考慮していません。

提案では、問題を理解するために、ごく簡単な未初期化変数読み取りの例を記載しています

```cpp
// 無条件でUB
void f1() {
  int p;
  int q = p + 1;  // UB
}

// 条件次第でUB
void f2() {
  int y;
  int z = b ? y + 1 : 0;
}

// 未初期化変数を別の関数に渡す
void g3(int);

void f3() {
  int x;
  g3(x);  // likely a bug
}

// 未初期化である可能性のある変数を別の関数に渡す
void g4(int);
void f4() {
  int s;
  if (c) s = 0;

  g4(s);  // likely a bug
}

// 未初期化である可能性のある変数を別の関数に参照渡しする
void g5(int*);
void f5() {
  int t;

  g5(&t);  // possibly a bug
           // g5()がtに出力のみを行うならUBではない
}

// 意図的な初期化の遅延
void f6() {
  // スタック領域を使用するアロケータ
  char buffer[1000];
  BufferAllocator a(buffer, sizeof buffer);
  // vectorで使用されることで初期化される
  std::vector v(&a);

  // すぐに別の値を書き込むことが分かっているため初期化しない
  char buffer2[1000];
  snprintf(buffer2, sizeof buffer2, "cstring");
}

// テンプレートパラメータ型の変数宣言
template <typename T>
void f7() {
  
  T t;  // クラス型の場合は初期化され、組み込み型の場合は未初期化

  cout << t;  // 組み込み型の場合UB
}
```

この提案で挙げられているこのような問題の解決策の候補は次の7つです

1. 常にゼロ初期化
    - 非クラス型の自動変数が初期化されない場合、常にゼロ初期化される
2. ゼロ初期化もしくは診断
    - 無条件に不定値を読む場合は診断（コンパイルエラー）
    - 条件次第で不定値を読む可能性がある場合はゼロ初期化
3. ソースでの初期化を強制
    - 非クラス型の未初期化変数はill-formed
4. 後から初期化されることを考慮しつっつ、ソースでの初期化を強制
    - 注釈なしの非クラス型の未初期化変数はill-formed
    - 未初期化変数は明示する
5. 実装定義の値で初期化するものの、書き込み前の読み取りは未定義動作
6. 実装定義の値で初期化するものの、書き込み前の読み取りは誤った動作
    - 書き込み前の値の読み取りは誤っているものの、UBではない
    - コンパイラフラグなどによって、テストのために検出しやすい値で初期化したり、実運用のために安全な値で初期化したりする
    - あるいは、誤った動作を未定義動作として扱うこともできる
7. 値初期化に一本化
    - 仕様からデフォルト初期化を削除する
    - これによって初期化は常に値初期化となり、仕様が単純化され、未初期化を含む初期化周りの問題が解決される

この提案では、これらを実現可能性、下位互換性、表現可能性の3つの観点から比較しています

- 実現可能性 : そのソリューションが既存のC++標準に対して一貫しているかどうか。つまりは、C++標準に適用可能であるかどうか
    - 実現可能
    - 実現不可能
    - 不透明 : 現時点では判断できない
- 下位互換性 : そのソリューションが採用された場合に、既存のコードを壊すことが無いかどうか。
    - 互換性がある : 以前にコンパイル可能なコードは引き続きコンパイル可能であり、UBの場合のみ動作が変更される
    - 正しいコードと互換性がある : 以前にコンパイル可能でUBを含まないものは引き続きコンパイル可能だが、UBを含むコードはコンパイルエラーとなる場合がある
    - 互換性がない : 以前に正しいコードもコンパイルが通らなくなる
    - 不透明 : 現時点では判断できない
- 表現可能性 : そのソリューションが採用された場合に、既存コードの意味が変更されるかどうか。
    - 良い : 初期化を遅らせる意図を明示、あるいはロジックエラー（初期化忘れ）を修正するためにコードを更新する必要がある
    - 悪い : 意図的な初期化遅延とロジックエラー以外の可能性が発生することで、現在よりも状況が悪くなる
    - 変わらない : 意図的な初期化遅延もしくはロジックエラーを含むような（未初期化変数を含む）既存コードが曖昧ではなくなる
    - 不透明 : 現時点では判断できない

次の表は、先程の7つのソリューションに対してこれを比較したものです

|ソリューション|実現可能性|下位互換性|表現可能性|
|---|---|---|---|
|1. 常にゼロ初期化|実現可能|互換性がある|悪い|
|2. ゼロ初期化/診断|不透明|正しいコードと互換性がある|変わらない|
|3. 初期化の強制|実現可能|互換性がない|良い|
|4. 遅延初期化を考慮した初期化の強制|実現可能|互換性がない|良い|
|5. 実装定義の値で初期化+その読み取りは未定義動作|実現不可能|互換性がある|変わらない|
|6. 実装定義の値で初期化+その読み取りは誤った動作|実現可能|互換性がある|変わらない|
|7. 値初期化に一本化|不透明|不透明|不透明|

この表から、次のようなことが分かります

1. 未初期化変数にまつわるセキュリティホールを塞ぐのに有効であるが、表現可能性が悪くなる 
      - 現在の初期化されていないローカル変数は、初期化忘れ（ロジックエラー）か意図的な未初期化（遅延初期化のため）のどちらかですが、このソリューションの後での初期化されていない変数は、初期化忘れと意図的なゼロ初期化の区別がつかなくなるため
2. ゼロ初期化とコンパイルエラーを組み合わせることは、コンパイラ間で拒否されるコードが変化しうることにつながる
3. 意図的な遅延初期化のための注釈（ソリューション4）の有無にかかわらず、既存のコードを修正する多大な努力を強いることになる
    - ともすれば、未初期化変数を初期化するようにするスクリプトの安易な使用を招き、それによって元のコードの意図を見失う恐れがある
    - 既存のコードベースが抵抗する可能性がある
4. 同上
5. UBに定義された意味と動作を要求することは不可能
6. 欠点が無く最も利得が高いが、誤った動作（*erroneous behavior*）という新しい概念を標準に導入する必要がある
    - 未初期化変数読み出しをEBとして指定することで、ソリューション7のような将来の変更をさたまげない
7. より詳細な調査が必要


この提案は、あくまで代替案を含めたソリューションをまとめ比較するもので、どれを推しているわけでもありません。提案というよりも、議論を促すための文書です。

- [P2754 進行状況](https://github.com/cplusplus/papers/issues/1461)

### [P2759R1 DG Opinion on Safety for ISO C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2759r1.pdf)
### [P2763R1 `layout_stride` static extents default constructor fix](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2763r1.html)
### [P2770R0 Stashing stashing iterators for proper flattening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2770r0.html)

*stashing iterator*というイテレータカテゴリに属している標準ライブラリ内イテレータについて、そのカテゴリや振る舞いを修正する提案。

*stashing iterator*とは、その間接参照がイテレータ自身の内部にあるもの（そのイテレータの生存期間と関連付けられているもの）を返すイテレータのことです。*stashing iterator*は`input_iterator`にしかならず、`forward_iterator`では*stashing*は認められません。

*stashing iterator*である標準ライブラリのイテレータには[`std::regex_iterator`](https://cpprefjp.github.io/reference/regex/regex_iterator.html)と[`std::regex_token_iterator`](https://cpprefjp.github.io/reference/regex/regex_token_iterator.html)がありますが、これらイテレータのカテゴリは現在*Forward Iterator*になっており、カテゴリ指定が間違っています。

このイテレータカテゴリの間違いは、C++20のRangeアダプタで使用したときに深刻な問題を起こすことがあります。

```cpp
#include <ranges>
#include <regex>
#include <iostream>

int main() {
  char const text[] = "Hello";
  std::regex regex{"[a-z]"};  // 小文字アルファベット1文字にマッチング

  // 範囲（sub_match）の範囲（match_results）
  std::ranges::subrange regex_range(std::cregex_iterator(
            std::ranges::begin(text),
            std::ranges::end(text),
            regex),
        std::cregex_iterator{}
      );

  // string_viewの範囲
  auto lower = regex_range
    | std::views::join  // sub_matchの範囲へと平坦化
    | std::views::transform([](auto const& sm) {
        // sub_matchオブジェクトが参照する文字列範囲をstring_viewへ変換
        return std::string_view(sm.first, sm.second);
    });

  // elloを1文字づつ改行して出力する（はず
  for (auto const& sv : lower) {
    std::cout << sv << '\n';
  }
}
```

このコードは一見すると問題なさそうに見えますが、実際にはダングリングイテレータが静かに生成されており、アドレスサニタイザーを使用していると`transform_view`のイテレータの最初の間接参照でheap-use-after-freeが発生します。

`std::regex_iterator`はそのメンバとして`std::match_results`というサブマッチオブジェクトの範囲（`std::vector<std::submatch>`のようなもの）を所有しており、間接参照はそのメンバへの参照を返し、イテレータのインクリメントのたびにそのメンバは次のマッチ結果で上書きされます。

`std::match_results`自体も範囲であり、これは`std::submatch`の配列のようなものです。そのため、上記の`ragex_range`は範囲の範囲となっており、それを`views::join`に通すと平坦化によって直接`std::submatch`の範囲を得ることができます。

`join_view`のイテレータは、入力`view`の外側イテレータ（`std::regex_iterator`）と内側イテレータ（`std::match_results`のイテレータ）をコピーして保持しています。

```cpp
// join_view::iteratorの概略
class iterator {
  // 入力範囲の外側範囲のイテレータ
  iterator_t<R> outer;

  // 入力範囲の内側範囲（*outer）のイテレータ
  iterator_t<range_reference_t<R>> inner;
};

// この場合、次のようになる
class iterator {
  // std::match_resultsオブジェクトを保持している
  std::regex_iterator outer;

  // std::match_results::iterator、例えばsubmatchのポインタ
  std::submatch* inner;
};
```

このようになっている時に`join_view`のイテレータをコピーすると、`outer`（及び内部のmatch_resultsオブジェクト）もコピーされますが、`inner`はコピー元の`outer`の要素を参照し続けます。コピー元イテレータのインクリメントや破棄によってそれが寿命を終えると、コピー後の`join_view`のイテレータはダングリングイテレータとなります。

コピーが起きなければ問題にならないのですが、残念ながら上記例では`transform_view`のイテレータ構築時にコピーが起きるとともにコピー元イテレータが即座に破棄されており、それによってダングリングイテレータが生成されてしまっています（とのことですが、正直どこでコピーが起きているのかわかりませんでした・・・）。

この問題は`regex_iterator`がカテゴリについて嘘をついてるだけではなく、`join_view`が*stashing iterator*を正しく扱えないことから起こっています。

この提案はこの問題の解決のために、それらに次のような変更を行います

- `regex_iterator`と`regex_token_iterator`の`iterator_concept`の変更
    - `iterator_category`の変更は破壊的かつ影響が大きいので行わない
- `join_view`と`join_with_view`が`input_itetaror`（`input_range`）に対して外側イテレータをその`view`オブジェクト内部にキャッシュするように変更
    - *stashing iterator*を判定する方法が無いため、全ての`input_iterator`に対して適用

同時に、LWG Issue 3700（`begin()`が内側範囲に対して`const`を考慮していない）とLWG Issue 3791（`--`内部で内側範囲が右辺値で得られる場合のハンドリング）の2つの`join_view`/`join_with_view`にまつわる小さなイシューも解決しています。

この提案は既に2月のIssaquah会議で全体投票をパスしてC++23に採択されています。

- [LWG Issue 3698. `regex_iterator` and `join_view` don't work together very well](https://cplusplus.github.io/LWG/issue3698)
- [LWG Issue 3700. The const begin of the `join_view` family does not require InnerRng to be a range](https://cplusplus.github.io/LWG/issue3700)
- [LWG Issue 3791. `join_view::iterator::operator--` may be ill-formed](https://cplusplus.github.io/LWG/issue3791)
- [Combining regex and ranges causes memory issues - stackoverflow](https://stackoverflow.com/questions/72201979/combining-regex-and-ranges-causes-memory-issues)
- [［C++］ <ranges>のviewを見る12 - join_view - Zenn](https://zenn.dev/onihusube/articles/42b5465e778cee595f76)
- [P2770 進行状況](https://github.com/cplusplus/papers/issues/1471)

### [P2771R0 Towards memory safety in C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2771r0.html)

依存関係を追跡することによる時間的なメモリ安全性保証を言語に導入する提案。

時間的なメモリ安全性保証とは、破棄済みのオブジェクトへのアクセスや無効な参照の使用などのことで、例えば次のようなものです

```cpp
int main() {
  std::string s1 = "abcdefg";
  std::string_view s2 = s1;

  std::cout << s2.length() << " " << s2 << std::endl;
  
  // 参照元を変更
  s1.erase(2,2);

  // s2の使用は危険
  std::cout << s2.length() << " " << s2 << std::endl;
}
```

対して、バッファオーバーランなど有効ではないメモリ領域へのアクセスは空間的なメモリ安全性の問題と言えます。空間的なメモリ安全性はランタイムのチェックや危険な機能（生ポインタや`reinterpret_cast`など）の使用禁止などの措置によって比較的簡単に防止することができます。

この提案の目的は、Rustの*borrow checker*の導入（C++の現在のプログラミングモデルにそぐわない）やライフタイム注釈のような不十分なものの導入をしなくても、C++をメモリ安全にすることが可能であり、その議論を促すことです。

この提案のアプローチは、オブジェクトの依存関係を追跡することにより時間的なメモリ安全性を保証するものです。例えば、オブジェクトA（`reference_wrapper`など）がオブジェクトBに依存するとき、Bが破棄された後にAを使用してはならないこと、あるいは、オブジェクトA（`string_view`など）がオブジェクトBのコンテンツに依存している時、Bの変更後にAを使用してはならないこと、を追跡し、それを静的に解析することで時間的なメモリ安全性を保証します。

この提案による安全性保証メカニズムは、何かしらの注釈によってスコープ単位で有効にするオプトインなもので、たとえば次のような構文によります

```cpp
namespace oldcode {
  // 既存のC++コード
}

namespace newcode {
  [[memorysafety]];
  // このスコープのコードはメモリ安全性を強制する
}

namespace newcode {
  // 注釈がないので、メモリ安全性はチェックされない
  // newcodeとoldcodeから任意のものを参照できる
}
```

この`memorysafety`な領域内では、同じく`memorysafety`なコードを呼び出す限り、コンパイラは時間的なメモリ安全性を保証します。ただし非メモリ安全なコードを呼び出すとそのチェックは無効化されます。

`memorysafety`な領域ではまず、メモリ安全性のために参照（ポインタ含む）のエイリアシングに制約を加えます。例えば次のような普通なコードはエイリアシングを考慮すると安全ではありません

```cpp
void foo(vector<int>& a, const vector<int>& b) {
  if (!b.empty()) {
     // aとbが同じオブジェクトを指している場合危険（foo(x, x)のように
     a.push_back(b.front());
  }
}
```

`memorysafety`な領域内ではデフォルトで安全にするために、あるオブジェクトの非`const`参照を関数に渡す際には他の参照はそのオブジェクトをエイリアスできなくします。この違反はコンパイラによってチェックされます。

```cpp
// memorysafety内にあるとして
void bar(int x, int y) {
  std::vector<int> a, b;
  std::array<std::vector<int>, 2> c;

  foo(a,b); // ok
  foo(a,a); // error
  foo(c[x], c[y]); // error, x != yを証明できない

  auto& r1 = c[x];
  auto& r2 = c[y];
  if (&r1 != &r2) {
    foo(r1, r2); // safe now
  }
}
```

エイリアシングを許可したい場合は明示的にコンパイラに表明します。例えば

```cpp
void swap(auto& a, [[mayalias(a)]] auto& b) { ... }
```

この`swap()`はオブジェクトに対して呼び出されても安全であるとみなされます。

多くのコードは引数がこのようなエイリアシングを起こしていると安全ではないため、エイリアシングを許可するのはオプトインである必要があります。

ただし、この制約は直接のエイリアスにのみ作用し、間接的なエイリアスの問題は依存関係の追跡によって対処されます。

```cpp
void foo(vector<string>& a, const string& b) {
  a.push_back(b);
}

void bar(vector<string>& a) {
  // 直接のエイリアスではないものの、依存関係が発生している
  foo(a, a.front());
}
```

オブジェクトが破棄された後にその参照からのアクセスが発生してはなりません。参照がローカル変数のスコープの外側にある場合などはすべての用途について安全であると確信が持てない場合は参照はオブジェクトよりも長く存在してはならない。このチェックのために、オブジェクトと参照の生存期間を追跡する必要がる。

生存期間は依存関係としてモデル化され、グローバルなオブジェクトは（とりあえず）無限の寿命を持ち、ローカルなオブジェクトはそのスコープに応じた寿命を持ちます。ローカルオブジェクトが破棄された時、それに依存する全てのオブジェクトは

1. トリビアルデストラクタを持つ
2. そのオブジェクトを用いてメンバ関数呼び出しがなされない

必要があります。

```cpp
void foo() {
  int* a;
  {
     int d = 2;
     a = &d; // aはdに依存
     *a = 3; // ok, dは生存期間内
  }
  // aはダングリング参照となるが、アクセスされなければ存在は許される

  // これはエラー、dは破棄済
  *a = 5;
}
```

関数呼び出し時に何かを渡す時、明示的な生存期間に関するアノテーションが必要になる場合があります。

```cpp
void bar(int* x),

void foo(int& x, int* y) {
  int* a = &x;  // ok, aはxに依存
  bar(a);       // ok, xは生存期間内

  // error: yはxよりも長く生存しうる
  y = a;
}
```

ここでは、`x`が破棄された後で`y`が使用されないことを証明できないため、`y`への参照の代入は禁止しなければなりません。許可するためには、依存関係を伝播するために注釈が必要になります

```cpp
void foo(int& x, [[maycapture(x)]] int* y) {
  // ok, 呼び出し側はxとyの寿命をチェックできる
  y = &x;
}
```

メンバ関数の場合、`this`に参照を保存する場合は同様の注釈を関数そのものに行います。また、戻り値で参照を返す場合も関数そのものに注釈が必要です。

```cpp
[[maycapture(x)]] void Foo::bar(int* x) {
  this->y = x;
}

[[dependson(x,y)]] char* foo(char* x, char* y) {
  return x < y ? x : y;
}
```

これらの注釈によって破棄後のオブジェクトにアクセスしている場合を検出することができますが、最初の`string_view`の例のようにコンテンツの変更を検出することはできません。

このために、オブジェクトのコンテンツのキャプチャを明示する注釈を行います

```cpp
[[dependson(*x)]] std::string_view foo(std::string& x) {
  return x;
}
```

これによって、次のようなルールを確立することができます

- オブジェクトAがオブジェクトBのコンテンツに依存する場合、Bの非`const`関数が呼び出された後でAを使用してはならない

これは、オブジェクトの状態を変更するのは非`const`関数のみであり、あるオブジェクトの非`const`関数が呼ばれたらそのオブジェクトに依存する全てのオブジェクトは無効になる、という単純なルールです。しかし実際には、非`const`でありながらオブジェクトの状態を変更しない関数が存在してるためこのルールは少し厳しいものです。例えば、コンテナの`begin()/end()`などがあり、明らかに`begin()/end()`の呼び出しでその時点で取得されているイテレータを無効にしたくはありません。

そのため、ここでもそれらの関数が*non-mutating*であることをマークする注釈が必要になります。これによって、コンテンツに依存するオブジェクトはそのような非`const`関数の呼び出しの後でも有効なままでいることができるようになり、コンパイラはそのような関数が他の注釈なしの非`const`関数を呼び出さないように強制する必要があります。

```cpp
template <class T>
[[dependson(*this), nonmutating]] myvec<T>::iterator myvec<T>::begin() {
  return iterator(this->ptr);
}
```

この上で、次のルールを確立することで、`a.push_back(a.front())`のような例を検出することができます

- あるオブジェクトによる関数呼び出しの引数は、そのオブジェクトに対する他の非`const`関数引数に依存してはならない

`a.front()`は`a`のコンテンツに依存しているので、`a.push_back()`に渡すことはできません。

ここまでの形式はほとんどのユースケースに対応していますが、標準ライブラリでも使用されている用例で禁止されているものが1つあります。例えば`std::vector::insert()`の次の様な呼び出しです

```cpp
a.insert(a.end(), b.begin(), b.end());
```

ここまでのルールによって、`b.begin()`と`b.end()`が`a`に依存してはならないことが要求され、それは正当なものです。しかし、`isnert()`の最初の引数は異なり、依存関係を受け入れる必要があるほかイテレータが同じコンテナのものであることを要求しています。

多くの場合、これを静的に証明することはできず、`insert()`に伴うイテレータ無効化によって実装自体も厄介です。ここでは、`insert()`の実装には安全ではないコード（およびイテレータがそのコンテナのものであることを検証するアサート）が必要になることを受け入れ、依存関係を許可するためのアノテーションを導入するにとどめています。

```cpp
template<class InputIt>
[[dependson(*this)]] iterator insert([[maydependon(this)]] const_iterator pos, InputIt first, InputIt last);
```

ここまでのルールによって、多くの時間的なメモリ安全性を壊すコードを検出することができるようになります。しかし、コンパイル時にすべてのバグを検出するには十分ではありません。エイリアスによって、まだ時間的な安全性を損ねる可能性が残されています

```cpp
void f1() {
  A a;
  B b;
  C c;
  a.push_back(123);
  f2(a, b, c);

  f3(b);  // b.iがaから取得される
  f4(c);  // b.iが無効化される
  f5(b);  // b.iが使用される
}
void f2(A& a, [[maycapture(a)]] B& b, [[maycapture(a)]] C& c) {
  b.a=&a;
  c.a=&a;
}
void f3(B& b) {
  b.i = b.a->begin(); // bにaのイテレータを保存
}
void f4(C& c) {
  c.a->clear(); // c経由でaのイテレータを無効化
}
void f5(B& b) {
  b.e = *b.i; // aのイテレータの使用
}
```

生存期間の制約は満たされていますが、`a`のエイリアスとそれを介した操作によってダングリングイテレータが発生しています。これらの関数が別々の翻訳単位に定義されている場合、これを検出することはできません。この挙動を検出するために非常に精巧なアノテーションを導入することもできるかもしれませんが、それはあまり現実的ではないようです。

その代わりに、この問題は実行時のチェック（サニタイザーのようなもの）によって検出することにしており、このチェックは例えばデバッグ時のみとすることができるようにすることを想定しています。

これらのようにして、コンパイル時になるべく多くの問題を発見しつつ、それが難しい部分は実行時チェックに任せることで、時間的なメモリ安全性を保証します。

- [P2771 進行状況](https://github.com/cplusplus/papers/issues/1472)

### [P2772R0 `std::integral_constant` literals do not suffice - `constexpr_t`?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2772r0.pdf)

コンパイル時定数オブジェクトを生成するクラスとリテラルの提案。

この提案は、P2725の[`std::integral_constant`](https://cpprefjp.github.io/reference/type_traits/integral_constant.html)リテラルの提案を受けてのもので、P2725のソリューションではカバーしきれないユーズケースに対応可能なようにP2725の提案を拡張するものです。P2725に関しては以前の記事を参照

- [P2725R0 `std::integral_constant` Literals - WG21月次提案文書を眺める（2022年11月）](https://onihusube.hatenablog.com/entry/2022/12/25/175304#P2725R0-stdintegral_constant-Literals)

P2725がカバーできていないユーズケースとは、次のように、非整数のNTTPを`constexpr`引数として関数に渡したい場合です

```cpp
// P2725のintegral_constantリテラルに対応する変数テンプレート
template<auto N>
inline constexpr std::integral_constant<decltype(N), N> Const = {};

template<typename T>
struct my_complex {
  T re , im;
};

template<typename T>
struct X {
  void f(auto c) {
    // cからNTTP値を引き出して定数式で使用可能
  }
};

inline constexpr short foo = 2;

template<typename T>
void g(X<T> x) {
  x.f(Const<1>);
  x.f(Const<2uz>);
  x.f(Const<3.0>);
  x.f(Const<4.f>);

  // P2725の提案ではこれらができない
  x.f(Const<foo>);
  x.f(Const<my_complex(1.f,1.f)>);
}
```

この例の最後の関数`g()`内部での最初の4つの`x.f()`呼び出しはP2725の`std::integral_constant`リテラル（`1ic`など）でも可能ですが、最後の2つの呼び出しはサポートされていません。P2725はあくまで整数定数のNTTPを同様の形で渡すためのリテラルを提案しているだけで、より一般的なNTTP（特に、C++20で許可されたクラス型）を渡すことができません。

関数に`cosntexpr`引数を渡したいケースは多くC++20以降は特にそれは整数型に限りません。従って、P2725が解決を目指している問題空間はより広いものであり、P2725の内容だけでは不完全です。また、このようなNTTP渡しにおいてはより簡単に行えることが望ましく、`1ic`（P2725のリテラル）と`std::cnst<1>`（上記例の`Const`）の両方が必要です。

また、上記例では整数以外のものも`std::integral_constant`に渡していますが、これは現在の定義でも行うことができます。その場合、このソリューションのために`integral_constant`を引き続き使用すべきではなく、そのための新しい型が必要になります。提案では、次のような型を例示しています

```cpp
template<auto Value>
struct constexpr_t {
  using value_type = decltype(Value);
  using type = constexpr_t;

  static inline constexpr value_type value = Value;
  
  constexpr operator value_type() const noexcept { return Value; }
  static constexpr value_type operator()() noexcept { return Value; }
};
```

新しい型を追加すれば、P2725で問題となっている単項`-`を`std::integral_constant`に追加する破壊的変更についても解決され、また一貫性のために他の演算子も追加することができます。

この提案ではさらに、これらの機能によって可能となるAPIについて記載しています。たとえば

- `std::array`や固定サイズ`std::span`（及び提案中の`std::simd`）などの`size()`メンバ関数をこの定数型（`std::integral_constant`/`constexpr_t`）に置き換える
    - これらの型が`operator()`を持つことによって、APIレベルでは破壊的変更にならない
    - メンバポインタを取られている場合のみ破壊的となるが、それは禁止されている
- 非メンバ`operator[]`によって、`contiguous`な範囲からスライスを取得するAPI

この提案はまだ問題提起に留まっていますが、LEWGのレビューではこの提案の方向性が支持されているようで、この提案を勘案しながらP2725のソリューションを検討していくようです。

- [C++20 非型テンプレートパラメータとしてクラス型を許可する - cpprefjp](https://cpprefjp.github.io/lang/cpp20/class_types_in_non-type_template_parameters.html)
- [P2772 進行状況](https://github.com/cplusplus/papers/issues/1453)

### [P2773R0 Considerations for Unicode algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2773r0.pdf)

P2728/P2729で提案されているユニコードアルゴリズム（変換・正規化）について、推奨事項等のフィードバックの提案。

P2728/P2729については以前の記事を参照

- [P2728R0 Unicode in the Library, Part 1: UTF Transcoding](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2728R0-Unicode-in-the-Library-Part-1-UTF-Transcoding)
- [P2729R0 Unicode in the Library, Part 2: Normalization](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2729R0-Unicode-in-the-Library-Part-2-Normalization)

この提案は、P2728/P2729の提案するユニコードアルゴリズム（文字列範囲に対するアルゴリズム）について、筆者の方の実装経験や考えをもとに推奨事項を記述するものです。

この提案の推奨事項の要旨は次のようなものです

- ほとんどのユニコードアルゴリズムは`view`として公開する必要がある
    - `<ranges>`の要件を満たす
- ユニコードアルゴリズムは、標準の他の`view`やアルゴリズムとうまく構成できる必要がある
- 正規化・クラスタ化・ケーシング（大文字小文字変換）を最初の作業の焦点とするべき
    - UTF相互変換を前提とする（それがなければ何もできない）
- ユニコードアルゴリズムはコードポイント（ユニコード空間上の32bit整数値）で動作する
- 調整済と未調整(Tailored and non-tailored)のアルゴリズムではそれぞれ異なる要件と実装上の課題があるため、類似しつつも別々のインターフェースで公開されるべき
- 調整済アルゴリズムに取り組む前に、ロケール表現についてよく理解しておく必要がある
- Rangeアダプタオブジェクト（`|`構文）は暗黙的なUTFデコード/エンコード手順を導入するのに最も適した場所。このような暗黙の手順はユーザビリティのために必要
- `char32_t`はコードポイントを表現するのに適切な型である
- `char`や`std::byte`の消費も可能だが、明示的であるべき
- コードユニット（UTFエンコーディングの1単位の整数値）のシーケンスはデフォルトで検証すべき
- ICUを使用した実装を可能とするために、未調整アルゴリズムを制約すべきではない
- ICU4xは調整済アルゴリズムに対する長期的な最善の答えである
- 将来のユニコードバージョンで変更されうる仮定を公開するのは避けるべき
- プロパティルックアップを最適化し非`sized_range`のメモリを巧妙に確保することで、既存のフレームワークと遜色ないパフォーマンスを実現できる
- ユニコードアルゴリズムは、インプレースの変換や文字列コンテナの恩恵を受けられない
- UTFのデコード/エンコードを回避しても、明確にパフォーマンスが向上するとは限らない

この提案はP2728/P2729の内容を否定したり批判したりするものではなく、ユーザビリティやユニコード固有事情などの面からC++の標準ライブラリとして望ましい方向性を示すものです。

- [P2773 進行状況](https://github.com/cplusplus/papers/issues/1473)

### [P2779R0 Make `basic_string_view`'s range construction conditionally `explicit`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2779r0.html)

`std::string_view`の`range`コンストラクタの`explicit`を条件付きに緩和する提案。

`std::string_view`（`std::basic_string_view`）に対する文字の範囲から構築する`range`コンストラクタは、C++23で追加されており、そのコンストラクタは`explicit`指定されています。その目的は、文字の範囲を常に文字列として変換することには問題があるためで、文字の範囲からの構築時にその意図を確認するために明示的なものとするためです。

なお、`std:string`は`std::string_view`への暗黙変換演算子を備えているため、このコンストラクタと関係なく`std::string_view`へ暗黙変換できます。

しかしこのことによって、独自定義された文字列型を`std::string_view`へ暗黙変換することも禁止されています。

```cpp
void use(std::string_view v);

std::string str1;
use(str1);  // OK

// 自分で作成したものだったり、どこかのライブラリのものだったり
my::string str2;
use(str2);  // ERROR
```

このような在野の`string`（あるいは同様の`string_view`）型は必ずしも自分が定義したものではなく、別のライブラリに属するものかもしれません。その場合、自分で暗黙変換を提供することもできません。また、この問題は逆に、独自定義の`string_view`をライブラリのインターフェースとしているようなライブラリにおいて、`std::string`で問題になる可能性もあります。

```cpp
void lib::very_useful_algorithm(lib::string_view v);

std::string str;
lib::very_useful_algorithm(str);  // ERROR
```

これらのコードのコンパイルが妨げられる理由はなく、この提案は、現在の`range`コンストラクタの`explicit`にこれらの文字列型を検出する条件を指定することでこの問題を解決しようとするものです。

その際問題となるのは、どのようにしてそれら在野の文字列型を識別するかという点です。

しかし残念なことに、`std::string`と`std::vector<char>`が名前以外ほとんど同じクラスであるように、在野の文字列型を識別することは困難です。そのため、必然的に何かしらの方法でオプトインする手段が必要となります。そのために、次の2つが提案されています

1. `std::ranges::enable_view<T>`または`std::ranges::view_base`のように、特殊化/継承して有効化する特性の導入
2. 文字列型に共通する、何かしらのユニークな特性を利用する
    - 入れ子型`traits_type`を活用する（P2499で以前に提案されていたが採用されなかった）

どちらにも

- どちらのオプションでも既存コードからのオプトインのための作業が必要となる。
    - ただし、オプション1を実装するコードは存在していないが、オプション2は既に実装しているものが存在する
- `traits_type`は必ずしも文字列型に固有のものではなく、全く異なる意味で同じ名前を使用している可能性がある
- オプション1は、それが適用され利用可能になるまでに時間がかかり過ぎる
    - それが採択され、実装されて利用できるようになるまでに1つのC++リリースサイクルの間問題が解決しない

オプション2の欠点については、`std::string_view`の`range`コンストラクタは現在でも制約によって厳密に文字の範囲を判定しており、その判定をパスしたうえで`traits_type`を持つようなクラスというのは実際にはほぼ存在しえないと思われます。この提案では在野のライブラリを調査することで、`traits_type`を持たない文字列型はあっても、`traits_type`持ちながら（`std::string_view`の`range`コンストラクタの制約をパスして）文字列型であると認識される型は見つからなかったようです。

この提案はオプション2を推しており、それをC++23へのDRとすることを提案しています。

- [P2499R0 string_view range constructor should be explicit - WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2499R0-string_view-range-constructor-should-be-explicit)
- [P2779 進行状況](https://github.com/cplusplus/papers/issues/1474)

### [P2782R0 A proposal for a type trait to detect if value initialization can be achieved by zero-filling](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2782r0.html)
### [P2784R0 Not halting the program after detected contract violation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2784r0.html)
### [P2786R0 Trivial relocatability options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2786r0.pdf)
### [P2787R0 `pmr::generator` - Promise Types are not Values](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2787r0.pdf)

↓

### [P2787R1 `pmr::generator` - Promise Types are not Values](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2787r1.pdf)

`std::generator`の`polymorphic_allocator`を使用するエイリアス、`pmr::generator`を追加する提案。

`std::generator`は他のアロケータ対応（*allocator aware*）なコンテナ型等と異なり、生成する要素のためにアロケータを使用するのではなく、コルーチンフレームを保存しておく領域をコルーチンの初期化時に確保するためにアロケータを使用します。そのため、`std::generator`は生成要素へのアロケータ伝播を行わず、それは`std::generator`の役割ではありません。

しかし、アロケータのカスタマイズは標準ライブラリの他の型と同じようにテンプレートパラメータで行い、使用可能なアロケータに関しても差異はありません（アロケータオブジェクトの渡し方はコルーチンの事情により少し異なりますが）。したがって、`polymorphic_allocator`と`memory_resource`によってアロケータをカスタマイズすることもでき、`std::generator`に対してそうしようとするのは自然な発想です。

しかし、`std::generator`には3つのテンプレートパラメータがありアロケータは一番最後のパラメータによってカスタマイズしますが、その場合は3つのテンプレートパラメータを全て明示的に指定しなければならず、使いにくくなります。

```cpp
std::pmr::monotonic_buffer_resource mbr;
std::pmr::polymorphic_allocator<> pa{&mbr};

// 型名が長くなる
std::generator<int, void, std::pmr::polymorphic_allocator<>> g = pmr_requiring_coroutine(std::allocator_arg, pa);

template<typename T>
using pmr_genterator = std::generator<T, void, std::pmr::polymorphic_allocator<>>;

// エイリアスがあれば使用感がかなり良くなる
pmr_genterator<int> g2 = pmr_requiring_coroutine(std::allocator_arg, pa);
```

`std::pmr`名前空間の意図は、アロケータをカスタマイズ可能な型について`polymorphic_allocator`をデフォルトとした型名を提供するもので、これまではそういう型しかなかったとはいえコンテナ型などのアロケータ対応型のためだけのものではないはずです。また、`std::generator`で`polymorphic_allocator`を使用する場合は上記のようなエイリアスを作成することになるはずです。

この提案は、本来不必要な作業を強いることを回避するために、標準で`std::pmr::generator`エイリアスを用意しておくべきという提案です。

```cpp
// 追加する宣言例
namespace std {

  // std::generator本体
  template<class Ref, class V = void, class Allocator = void>
  class generator;

  namespace pmr {
    // pmr::generatorエイリアス
    template<class R, class V = void>
    using generator = std::generator<R, V, polymorphic_allocator<>>;
  }
}
```

これによって、`std::generator`とほぼ同じ使用感によって、`polymorphic_allocator`を使用した`generator`を使用できるようになります

```cpp
std::pmr::monotonic_buffer_resource mbr;
std::pmr::polymorphic_allocator<> pa{&mbr};

// この提案後
std::pmr::generator<int> g = pmr_requiring_coroutine(std::allocator_arg, pa);
```

この提案は、すでに2月のIssaquah会議でC++23向けに採択されています。

- [`std::generator` - cpprefjp](https://cpprefjp.github.io/reference/generator/generator.html)
- [`std::pmr::polymorphic_allocator` - cpprefjp](https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator.html)
- [P2787 進行状況](https://github.com/cplusplus/papers/issues/1457)

### [P2788R0 Linkage for modular constants](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2788r0.html)
### [P2789R0 C++ Standard Library Ready Issues to be moved in Issaquah, Feb. 2023](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2789r0.html)
### [P2790R0 C++ Standard Library Immediate Issues to be moved in Issaquah, Feb. 2023](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2790r0.html)
### [P2791R0 mandate concepts for new features](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2791r0.pdf)
### [P2796R0 Core Language Working Group "ready" Issues for the February, 2023 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2796r0.html)
### [P2797R0 Proposed resolution for CWG2692 Static and explicit object member functions with the same par](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2797r0.html)
### [P2798R0 Fix layout mappings all static extent default constructor](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2798r0.html)
### [P2799R0 Closed ranges may be a problem; breaking counted_iterator is not the solution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2799r0.html)
### [P2802R0 Presentation of P1385R7 to LEWG at Issaquah 2023](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2802r0.pdf)
### [P2803R0 std::simd Intro slides](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2803r0.pdf)
### [P2805R0 fiber_context: fibers without scheduler - LEWG slides](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2805r0.pdf)
### [P2806R0 do expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2806r0.html)
### [P2807R0 Issaquah Slides for Intel response to std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2807r0.pdf)
### [P2808R0 Internal linkage in the global module](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2808r0.html)
### [P2810R0 is_debugger_present is_replaceable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2810r0.html)
### [P2812R0 P1673R11 LEWG presentation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2812r0.html)
### [P2815R0 Slides for presentation on P2188R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2815r0.pdf)
### [P2816R0 Safety Profiles: Type-and-resource Safe programming in ISO Standard C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2816r0.pdf)
