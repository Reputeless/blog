# ［C++］WG21月次提案文書を眺める（2023年01月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-01](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-01)

SG22のWG14からのものを除いて、全部で84本あります（R0が36本、R1以上で見てないのが4本）

[:contents]

### [N4928 Working Draft, Standard for Programming Language C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4928.pdf)

C++23のワーキングドラフト第8弾。

### [N4929 Editors' Report - Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4929.html)

↑の変更点をまとめた文書。

11月のKona会議で採択された提案とコア言語/ライブラリのIssue解決が適用されています。

### [N4933 WG21 November 2022 Kona Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4933.pdf)

2022年11月7-12日にハワイのKonaで行われた、WG21全体会議の議事録。

開催期間中の各グループの活動報告や、CWG/LWG/LEWGの投票の様子などが記載されています。

### [N4934 2023 WG21 admin telecon meetings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4934.pdf)

2023年（今年）のWG21管理者ミーティングの予定表。

### [N4935 2023 Varna Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4935.pdf)

2023年6月にブルガリアのヴェルナで開催される予定のWG21全体会議のインフォーメーション。

主に開催場所やその注意点などが記載されています。

### [N4936 2023-11 Kona meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4936.pdf)

2023年11月にハワイのKonaで開催される予定のWG21全体会議のインフォーメーション。

同上。

### [N4937 Programming Languages — C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n4937.pdf)

次期標準ライブラリ機能候補の実装経験を得るためのTSである、Library Fundamental TS v3のFDIS。

### [N4939 Working Draft, C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4939.html)

次期標準ライブラリ機能候補の実装経験を得るためのTSである、Library Fundamental TS v3のドラフト文書。

おそらく内容はN4937と同一です。

### [N4938 Editor's Report: C++ Extensions for Library Fundamentals, Version 3](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4938.html)

↑の変更点を記した文書。

この版での変更は、typoの修正などです。

### [P0260R5 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0260r5.html)

標準ライブラリに並行キューを追加するための設計を練る提案。

キューはシステムコンポーネント間のデータのやり取りの方法を提供する基礎的なものです。現在のC++標準ライブラリにも`std::deque`などが用意されていますが、それらは全てシーケンシャルなデータ構造であり、その要素アクセスとキューの操作を並行に行うことができません。そのため、並行キューを導入するためには、それらとは別のものが必要となります。

さらに、並行性の要求はパフォーマンスとそのセマンティクスに新たな評価軸を追加し、並行キューにおいては競合しない操作のコスト、競合する操作のコスト、要素の順序保証をトレードオフにする必要があり、これによって既存のキューよりもセマンティクスが弱くなります。

そのような対立軸にはたとえば

- 固定長 vs 可変長
- ブロッキング vs 上書き
- シングルエンド vs マルチエンド
- 厳密なFIFOによる順序 vs 優先度による順序

などがあります。

この提案は今の所、そのような並行キューのインターフェースのベースとなる概念的なインターフェースの要件を定義しています。

**基本操作**

並行キューイングの問題に対する本質的な解決策は、参照ベースではなく値ベースの操作へ以降することです。そのために次の2種類の基本操作を定義しています

```cpp
// 要素をキューイングする
void queue::push(const Element&);
void queue::push(Element&&);

// 要素をキューから取り出す
// 要素はコピーではなくムーブされる
void queue::pop(Element&);
```

ここでの`queue`は特定のキューを示すものではなく、コンセプト的なプレースホルダです。

これらの操作はまたブロッキングを伴う操作でもあり、キューが満杯/空の場合に待機し、操作の競合を回避するためにブロックされる可能性があります。

**即時操作**

満杯/空のキューで待機すると操作が完了するまでにしばらく時間を要する可能性があり、機会費用がかかります。この待ち時間を回避することで、満杯/空のキューで操作の完了を待機する代わりに他の作業を行うことができます。そのために、次の2種類の即時操作（待機しない操作）を定義しています

```cpp
// キューが満杯/クローズ状態の場合はその状態を返し、そうではない場合にキューイングしqueue_op_status::successを返す
queue_op_status queue::try_push(const Element&);

// キューが満杯/クローズ状態の場合はその状態を返し、第一引数を第二引数へムーブする
// そうではない場合にキューイングしqueue_op_status::successを返す
queue_op_status queue::try_push(Element&&, Element&);

// キューが空ならqueue_op_status::emptyを返し
// そうではない場合に要素をキューから取り出し（コピーではなくムーブされる）、queue_op_status::successを返す
queue_op_status queue::try_pop(Element&);
```

`queue_op_status`は次のようなスコープ付き列挙型です

```cpp
enum class queue_op_status { 
  success, 
  empty,
  full,
  closed
};
```

これらの操作はキューが満杯/空の場合にブロックしませんが、操作の競合を回避するためにブロックされる可能性があります。

**キューのクローズ**

通信にキューを使用しているスレッドでは、キューが不要になった場合にそのキューを使用している他のスレッドにそのことを通知するメカニズムが必要になる場合があります。典型的には、それはキューとは別の条件変数やアトミック変数などの帯域外信号が使用されます。ただし、このアプローチでは、そのキューで待機している他のスレッドを起床しなければならない問題があり、そのためにキューの満杯/空のブロッキングに使用される条件変数にアクセスする必要が出てくるなど、インターフェースの複雑さと危険性を増大させます。また、ミューテックスやアトミック変数を使用することでパフォーマンスに影響が及ぶ可能性もあります。

そのため、この提案ではそのようなシグナルをキュー自体でサポートすることを選択しており、これによってコーディングがかなり簡素化されます。

このシグナルのために、キューはクローズ（`close()`）を行うことができます。あるスレッドでキューがクローズされると新しい要素をそのキューに挿入（`push`）することができなくなります。クローズ済キューに対する挿入操作は`queue_op_status::closed`を返すか例外としてスローします。キューに存在する要素は取り出し（`pop`）が可能ですが、キューが空でクローズされている場合、取り出し操作は`queue_op_status::closed`を返すか例外としてスローします。

```cpp
// キューを閉じる
void queue::close() noexcept;

// キューが閉じられていればtrueを返す
bool queue::is_closed() const noexcept;

// キューが閉じられていればqueue_op_status::closedを返す
// そうでないならば、要素をキューイングする
queue_op_status queue::wait_push(const Element&);
queue_op_status queue::wait_push(Element&&);

// キューが空で閉じられていればqueue_op_status::closedを返す
// そうではなく、キューが空ならばqueue_op_status::emptyを返す
// それ以外の場合、キューから要素を取り出しqueue_op_status::successを返す
queue_op_status queue::wait_pop(Element&);
```

`wait_`とある`push/pop`操作は、キューが閉じられている場合に例外を回避するためのインターフェースです。この操作はキューが閉じられておらず満杯/空の場合に待機し、操作の競合を回避するためにブロックされる可能性があります。

クローズ後のキューを再開したいユースケースがあり、この提案ではそのためのインターフェースも定義しています

```cpp
// キューをオープンする
void queue::open();
```

キューを再開する機能が困難になる実装は現在把握されてはいませんが、存在する可能性があります。また、キューの再開は通常キューが閉じていて空の場合にのみ呼び出すことができ、これによってクリーンな動機ポイントを提供することができます。ただし、空でないキューで`open()`を呼び出すことは可能です。

`is_closed()`が`false`を返す場合でも、他のスレッドがキューを同時にクローズする可能性があるため、後続の操作でキューが閉じられている保証はありません。

オープン操作が利用できない場合、キューが閉じられるとキューは閉じたままになるという保証があります。したがってその場合、プログラマが他のすべてのスレッドがキューを閉じないように細心の注意を払わない限りは、`is_closed()`の戻り値は`true`のみが意味を持ちます。

キューの再開にはこれらの問題があるため、この提案ではこのインターフェースを提案してはいません。

**要素型の要件**

上記の操作のためには、要素型にはコピー/ムーブコンストラクタ、コピー/ムーブ代入演算子、及びデストラクタが必要になります。

コンストラクタと代入演算子は例外を投げる可能性がありますが、後続の操作のためにはオブジェクトを有効な状態のままにしておく必要があります。

**例外ハンドリング**

基本操作の2つの操作（`push()/pop()`）はキューの状態によって例外を投げる可能性があります。その例外オブジェクトは`std::exception`の派生クラスであり、`queue_op_state`の値を含んでいる必要があります。

他のスレッドがキューの状態を監視している時に変更を透過的に元に戻すことができないため、並行キューは要素型がスローした例外の影響を完全に隠すことはできません。そのような例外は要素型のコピー/ムーブコンストラクタ及びコピー/ムーブ代入演算子から投げられる可能性があります。

それ以外の場合、キューは、メモリ確保、キューテックス、条件変数から例外を再スローする可能性があります。

要素のコピー/ムーブが例外を投げる可能性がある場合、一部のキュー操作には追加の動作が定義されています

- 構築時は例外を再スローし、構築しようとしていた要素を破棄する
- 挿入操作は再スローし、キューの状態は変化しない
- 取り出し操作は再スローし、取り出そうとしていた要素はキューから取り除かれる（要素は実質的に失われる）


この提案ではこれらの要件に沿った具体的なキューを提案してはいませんが、[P1958R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1958r0.html)でその一つである`buffer_queue`が提案されている他、[google-concurrency-library](https://github.com/alasdairmackintosh/google-concurrency-library)にこの提案の初期のインターフェースをベースとした実装があります。

この提案は、フィードバックを得るためにConcurrency TS v2入りを目指しています。

- [P0260 進行状況](https://github.com/cplusplus/papers/issues/99)

### [P0342R1 What does "current time" mean?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0342r1.pdf)

`<chrono>`の時計型の`now()`が最適化によって並べ替えられないようにする提案。

`<chrono>`の時計型（`steady_clock`など）はその静的メンバ関数`now()`によってその時計の示す現在の時刻（*current point in time*）を取得することができます。しかし、この現在の時刻が何を指すのか不明瞭であり、必ずしもコードに記述した実行地点での現在時刻を取得しないことがあります。

提案より、サンプルコード

```cpp
#include <chrono>
#include <atomic>
#include <iostream>

std::size_t fib(std::size_t n) {
  if (n == 0)
    return n;
  if (n == 1)
    return 1;
  return fib(n - 1) + fib(n - 2);
}
int const which{42};

int main() {
  // fib()の実行にかかる時間を計測する
  auto start = std::chrono::high_resolution_clock::now(); // #1
  auto result = fib(which);                               // #2
  auto end = std::chrono::high_resolution_clock::now();   // #3

  std::cout << "fib(" << which << ") is " << result << std::endl;
  std::cout << "Elapsed time is "
            << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()
            << "ms" << endl;

  return 0;
}
```

[godbolt](https://godbolt.org/z/ofvfd7WbK)

このようなコードはかなり基本的なものですが、少なくともMSVCは最適化を有効にすると`#2 #3`の順番を入れ替えて、`#1 -> #3 -> #2`のように実行してしまい、結果0msが出力されます。このような最適化は標準の範囲内で許可されているため、この最適化自体は合法です。

これはシングルスレッドプログラムにおける実行順序の並べ替えであるため、標準の範囲内で回避するのは難しいようです。ファイルを分割することで回避できるようですが、それもプログラム全体の最適化やリンク時最適化を考慮すると確実なものとは言えません。また、この問題はコンパイラによっては起こらないかもしれず、回避策を含めたこのようなコードの移植性を損ねています。

プログラム中で現在のタイムスタンプを取得するという単純な処理にすらこのような罠が潜んでいて回避が難しいというのは大きな問題であり、この提案はその改善のためのものです。

この提案ではこの問題の解決のためにいくつかの方法を挙げています

- 標準を変更はしないが、ガイダンスを充実させる
    - SG20で配布可能なガイダンスを作成するだけでも教育者には大きな助けになる
- 編集上の変更を加える
    - ↑のガイダンスを標準に記述する
- `now()`の並べ替えを禁止する
    - このアプローチはR0の議論において実装可能性について懸念があった
- シングルスレッドフェンスを導入する
    - この問題が発生するのは時刻取得に止まらないと考えられるため、このユースケースに応えるためにより一般的なソリューションを提供する
    - このアプローチはR0で提案していたものだったが、実装可能性について懸念があった

ただし、現在のところどれかを選択してはいません。

この提案のR0ではこの問題の解決のためのシングルスレッドフェンスを提案していましたが、2016年にレビューされた際にはその実装可能性の懸念などから受け入れられず、提案の追求はストップしていました。しかし、2022年のKona会議におけるSG1のミーティング中にこの問題が取り上げられ、この提案の改訂版が望まれたことで、とりあえず問題を整理したR1（このリビジョン）が再度提出されました。

著者の方やSG1のメンバは、現在の時刻の取得という単純なタスクでプログラマが直面するこの問題は、現状の改善をより広く検討するのに十分に深刻だと考えているようです。

- [C++標準化委員会の文書: P0340R0-P0349R0 - 本の虫](https://ezoeryou.github.io/blog/article/2016-08-09-cpp-P0340R0-P0349R0.html#:~:text=P0342R0%3A%20Timing%20barriers)
- [P0342 進行状況](https://github.com/cplusplus/papers/issues/1417)

### [P0792R12 function_ref: a non-owning reference to a Callable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0792r12.html)

*Callable*を所有しない`std::function`である`std::function_ref`の提案。

以前の記事を参照

- [P0792R6 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P0792R6-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R8 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年02月）](https://onihusube.hatenablog.com/entry/2022/03/19/224729#P0792R8-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R9 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P0792R9-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R10 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P0792R10-function_ref-a-non-owning-reference-to-a-Callable)
- [P0792R11 function_ref: a non-owning reference to a Callable - ［C++］WG21月次提案文書を眺める（2022年09月）](https://onihusube.hatenablog.com/entry/2022/10/09/021557#P0792R11-function_ref-a-non-owning-reference-to-a-Callable)

このリビジョンでの変更は、LWGのフィードバックによる文言の調整と、メンバ変数ポインタを誤って処理していた推論補助の修正です。

この提案は次のリビジョン（未公開）がLWGのレビューをパスして、次の全体会議にかけられることが決まっています（C++26ターゲットです）。

- [P0792 進行状況](https://github.com/cplusplus/papers/issues/256)

### [P1383R1 More constexpr for `<cmath>` and `<complex>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1383r1.pdf)

`<cmath>`と`<complex>`の数学関数を`constexpr`にする提案。

`<cmath>`の数学関数をはじめとする浮動小数点数を扱うものを`constexpr`対応させるにあたって問題となっているのは、同じ浮動小数点数値に対するある関数の結果がコンパイラの設定やプラットフォーム、実行タイミング等のコンテキストによって等しい必要があるのか？という点です。明らかにそうなって欲しいのですが、浮動小数点数の特性などの事情によってそれは実際には困難であり、そうするとそれら関数の実行結果についてどのように規定するのか、あるいはどのような保証を与えるのか？が問題となります。

C++23におけるP0533R9による`<cmath>`等の関数の`constexpr`対応にあたってもそのような問題の議論を回避するために、四則演算（`+ - * /`）よりも（その事情の下では）複雑でないとみなされる関数のみが`constexpr`対応されました。

この提案は次のような設計指針によって、`<cmath>`と`<complex>`にあるほぼすべての数学関数を`constexpr`対応させようとしています

1. 数学関数の実行結果が実行時とコンパイル時で異なることを許容する
2. 数学関数の定数実行が異なるプラットフォームで異なることを許容する
3. `<cmath>`内の既存関数に正確な動作を義務付けるのではなく、QoIの定量化を奨励することが望ましい

そもそも実行時における現在の`<cmath>`の数学関数や浮動小数点演算は、異なるコンパイラやプラットフォームの間、あるいは異なるコンパイラオプション（`-ffast-math`など）の間で結果が一致しないことはない間許容されています。また、定数式では数学関数を呼び出さない浮動小数点演算は可能であり、規格も利用者もその結果の実行時とコンパイル時の差異を許容してきています（実行時における丸めモードの変更やFMAの利用など）。

`costexpr`な数学関数にのみ過剰な正確性や結果の一貫性を要求することは、実装の困難さを高めるとともにそれそのものが実行時とコンパイル時の出力差の原因となります。そのためこの提案では、許容されている現在の実行時の振る舞いをベースとした設計指針によって数学関数を`constexpr`対応させる方針を押しています。

- [P1383 進行状況](https://github.com/cplusplus/papers/issues/168)

### [P1673R11 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r11.html)

標準ライブラリに、BLASをベースとした密行列のための線形代数ライブラリを追加する提案。

以前の記事を参照

- [P1673R3 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2021年04月）](https://onihusube.hatenablog.com/entry/2021/05/14/214016#P1673R3-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R4 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P1673R4-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R5 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P1673R5-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R6 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P1673R6-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R7 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2022年04月）](https://onihusube.hatenablog.com/entry/2022/05/08/195618#P1673R7-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R8 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P1673R8-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R9 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1673R9-A-free-function-linear-algebra-interface-based-on-the-BLAS)
- [P1673R10 A free function linear algebra interface based on the BLAS - ［C++］WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P1673R10-A-free-function-linear-algebra-interface-based-on-the-BLAS)

このリビジョンでの変更は

- `in_{vector,matrix,object}*_t`がユニークなレイアウトを持つという要件を削除
- `in_{vector,matrix,object}*_t`に対する名前付き要件を説明専用コンセプトに変更
- 対称なHermitian updateアルゴリズムを制約するために、説明専用コンセプト`possibly-packed-inout-matrix`を追加
- 新しい説明専用コンセプトと重複する制約を削除
- 全てのアルゴリズムの制約から、`mdspan`がユニークなレイアウトを持つという制約を削除
- ベクトル/行列オブジェクトのテンプレートパラメータが`mdspan`への`const`左辺値参照もしくは非`const`右辺値参照を推論する可能性があるという要件を削除
- 両方のベクタ型を含めるように`dot`の要件を修正
- `mdspan`の`element_type`エイリアスの代わりに`value_type`エイリアスを使用するように、いくつかの関数の規定を修正
- `matrix_vector_product`のテンプレートパラメータ順序と仮引数の順序を合わせた
- LEWGのガイダンスに従って、効果と制約を数学的に記述するようにした
- `matrix_one_norm`の事前条件（要素の`abs()`の結果が`T`に変換可能であること）を制約に変更
- `vector_abs_sum`の事前条件（`init + abs(v[i])`の結果が`T`に変換可能であること）を制約に変更
- Bikeshedの代わりにPandocを使用するようにした
- `conjugated-scalar`の`conjugatable<ReferenceValue>`を適格要件ではなく制約に変更
- “If an algorithm in [linalg.algs] accesses the elements of an out-vector, out-matrix, or out-object, it will do so in write-only fashion.”という文言を削除
- P2642の内容をR2にアップデート
- 全てのタグ型の`default`実装デフォルトコンストラクタに`explicit`を付加
- `givens_rotation_setup`を出力パラメータではなく新しい`givens_rotation_setup_result`構造体の値を返すように変更

などです。

- [P1673 進行状況](https://github.com/cplusplus/papers/issues/557)

### [P1684R4 mdarray: An Owning Multidimensional Array Analog of mdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1684r4.html)
### [P1883R2 `file_handle` and `mapped_file_handle`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1883r2.pdf)

ファイルI/Oライブラリの提案。

この提案のファイルI/Oライブラリは[llfio](https://github.com/ned14/llfio/)というライブラリをベースとしたもので、llfioは現代の高性能ストレージに対するI/Oで理論性能値に迫るパフォーマンスを引き出すことができることを謳っています。また、llfioはPOSIX（Linux/Mac等）とWindowsにおけるI/Oを抽象化して扱うクロスプラットフォームなライブラリでもあります。

この提案では、そのllfioから`file_handle`と`mapped_file_handle`を中心としたファイル毎のI/O機能を標準ライブラリへ導入しようとしています（llfio自体はネットワークI/Oやファイルシステム操作などより広い機能を持っています）。

llfioではファイルやファイルシステムの要素などをハンドルという次のような7階層の階層構造によって抽象化しています

1. `handle`
    - オープン/クローズ、パスの取得、クローン、追加のみのset/unset、キャッシュの変更、などの特性を提供する
2. `fs_handle`
    - inode番号を持つ`handle`
3. `path_handle`
    - ファイルシステムの一部分への競合の無いアンカー
4. `directory_handle`
    - ファイルシステムを列挙する
5. `io_handle`
    - 追加で、同期スキャッタ/ギャザーI/O、バイト範囲ロックを提供する
6. `file_handle`
    - 追加で、ファイルのオープン/クローズ、最大サイズの設定/取得を提供する
7. `mapped_file_handle `
    - 追加で、メモリマップされたファイルに対する低レインテンシのスキャッタ/ギャザーI/Oを提供する

この階層構造はこのままクラスの継承関係に対応しています。

`file_handle`と`mapped_file_handle`は6,7階層に位置するもので、ファイルという対象に対する実際のI/O操作を提供します。主役がこの2つであるだけで、下の5階層のクラスも一緒に導入されます。

提案文書より、スキャッタ書き込みのサンプルコード

```cpp
// 上記階層構造によって、file_handleでもmapped_file_handleでも使用可能
void write_and_close(file_handle &&fh) {
  // ファイルの最大サイズを設定
  // mapped_file_handleはファイルサイズが固定のために必要
  fh.truncate(12).value();

  // 書き込むデータのバッファ
  const char a[] = "hel";
  const char b[] = "l";
  const char c[] = "lo w";
  const char d[] = "orld";

  // ギャザー書き込み（バラバラのバッファからのスキャッタ書き込み）を行う
  // file_handleの場合 : max_buffers() >= 4ならばこの書き込みは並行する読み取りに対してアトミック
  //                    そのような読み取りは何も読まないか、完了した結果を読むかのどちらか（破損はない）
  // mapped_file_handleの場合 : 書き込みに伴う同期は行われず、読み書きは並行するリーダ/ライターに対して競合するため、追加の同期が必要になる
  fh.write(
    // ギャザーリストの指定
    { // 入力はstd::byteで行われるためキャストが必要
      { reinterpret_cast<const byte*>(a), sizeof(a) - 1 },
      { reinterpret_cast<const byte*>(b), sizeof(b) - 1 },
      { reinterpret_cast<const byte*>(c), sizeof(c) - 1 },
      { reinterpret_cast<const byte*>(d), sizeof(d) - 1 },
    }
    // デフォルトのタイムアウトは無限
  ).value(); // 失敗した場合、filesystem_error例外をスローする

  // ファイルのクローズに失敗する場合に備えて、明示的にファイルをクローズする
  fh.close().value();
}


// 書き込み用にファイルをオープン
// 必要に応じてファイルを作成、キャッシュをスルーして書き込み
write_and_close(file(
  {},                                       // 子要素（↓）を探索するベースディレクトリのpath_handle（この場合はカレントディレクトリを意味する）
  "hello",                                  // ベースディレクトリ（↑）からの相対的なパスフラグメントへのpath_view（ファイル名）
  file_handle::mode::write,                 // 書き込みアクセスを要求
  file_handle::creation::if_needed,         // 必要ならファイルを新規作成
  file_handle::caching::reads_and_metadata  // ストレージに到達するまで書き込み（デフォルトはnone
).value());                                 // 失敗した場合、filesystem_error例外をスローする


const path_handle& somewhere;

// メモリマップを使用して既存ファイルを更新する例
write_and_close(mapped_file(
  somewhere,                            // 子要素（↓）を探索するベースディレクトリのpath_handle
  "hello2",                             // ベースディレクトリ（↑）からの相対的なパスフラグメントへのpath_view（ファイル名）
  file_handle::mode::write,             // 書き込みアクセスを要求
  file_handle::creation::open_existing  // 既存ファイルを開くのみ、ファイルがない場合に失敗する
                                        // デフォルトは全てキャッシュを使用する
).value());                             // 失敗した場合、filesystem_error例外をスローする
```

`mapped_file_handle`はメモリにマップされたファイルの抽象であり、ファイル書き込みに伴ってファイルサイズの自動延長が行われないなどの制約があります。一方で、`file_handle`はもっと広いファイルの抽象であり、通常ファイルの自動延長機能を持ちます。

各I/O操作やハンドル作成の結果で`value()`を呼んでいるのは、それぞれの操作が`result<T>`型を返しており、その成功結果を取得するためです。`result<T>`はエラー型が`std::error`（[P1028R4](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1028r4.pdf)）に固定された`std::expected`のような型で、同じようなインターフェースを持っています。

`file_handle`と`mapped_file_handle`の`file`とはUNIXにおけるファイルという概念のようなもので、必ずしもファイルシステム上のファイルだけを意味するのではなく、ファイルとして扱えるもの全体を指しています。例えば、ASIOがソケットベースのI/Oライブラリであるとすると、このライブラリはファイルベースのI/Oライブラリです。

このライブラリは次のような設計原則を謳っています

1. デフォルトパラメータや設定はパフォーマンスよりもセキュリティを重視する。
    - これはいつでも明示的にアプトアウトできる
2. 実行されるI/Oの種別に関係なく、基礎となるシステムコールのラインタイムオーバーヘッドを超える（ライブラリの）統計的に計測可能なラインタイムオーバーヘッドはない
3. ホストOSの並行I/Oに関する保証を可能な限りそのまま提供する
4. POSIXのrace free filesystem path lookup拡張を中心として設計されている
5. システム内でのどこでも、C++I/Oと最終ストレージデバイスの間の全てのメモリコピーを常に回避可能である必要がある
6. カーネルI/Oキャッシュ制御および仮想メモリ制御機能を提供する
7. ファイルシステムの競合を検知して回避する機能を提供し、少なくともホストOSが許可する範囲で第三者によるファイルシステム同時変更によって導入される競合が完全にないコードを記述可能にする

筆者の方（llfio開発者の方）によれば、llfioの中で`file_handle`と`mapped_file_handle`周りのAPIおよびABIは2020年ごろから安定しており、市場取引のデータ処理において数年間の使用実績があり、現在も1TB/日のデータを処理している、とのことです。

この提案は現在のところ機能や設計についてのレビューを受けている段階であり、具体的な文言はありません。

- [ned14/llfio P1031 low level file i/o and filesystem library for the C++ standard](https://github.com/ned14/llfio/)
- [LLFIO: Mainpage](https://ned14.github.io/llfio/)
- [P1883 進行状況](https://github.com/cplusplus/papers/issues/633)

### [P1928R2 Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1928r2.pdf)
### [P1967R10 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1967r10.html)
### [P2013R5 Freestanding Language: Optional ::operator new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2013r5.html)
### [P2047R5 An allocator-aware optional type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2047r5.html)
### [P2075R2 Philox as an extension of the C++ RNG engines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2075r2.pdf)
### [P2164R9 views::enumerate](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2164r9.pdf)
### [P2169R3 A Nice Placeholder With No Name](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r3.pdf)
### [P2198R6 Freestanding Feature-Test Macros and Implementation-Defined Extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2198r6.html)
### [P2198R7 Freestanding Feature-Test Macros and Implementation-Defined Extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2198r7.html)
### [P2338R3 Freestanding Library: Character primitives and the C library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2338r3.html)
### [P2363R4 Extending associative containers with the remaining heterogeneous overloads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r4.html)
### [P2406R1 Fix counted_iterator interaction with input iterators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2406r1.html)
### [P2406R2 Add lazy_counted_iterator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2406r2.html)
### [P2407R2 Freestanding Library: Partial Classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2407r2.html)
### [P2508R2 Exposing std::basic-format-string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2508r2.html)
### [P2530R2 Why Hazard Pointers should be in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2530r2.pdf)
### [P2537R2 Relax va_start Requirements to Match C](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2537r2.html)
### [P2545R2 Why RCU Should be in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r2.pdf)
### [P2570R2 Contract predicates that are not predicates](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2570r2.html)
### [P2591R2 Concatenation of strings and string views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2591r2.html)
### [P2616R3 Making std::atomic notification/wait operations usable in more situations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2616r3.html)
### [P2630R2 Submdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r2.html)
### [P2636R2 References to ranges should always be viewable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2636r2.html)
### [P2642R2 Padded mdspan layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2642r2.html)
### [P2656R1 C++ Ecosystem International Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2656r1.html)
### [P2659R2 A Proposal to Publish a Technical Specification for Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2659r2.pdf)
### [P2675R1 LWG3780: The Paper (format's width estimation is too approximate and not forward compatible)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2675r1.pdf)
### [P2677R2 Reconsidering concepts in-place syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2677r2.pdf)
### [P2680R1 Contracts for C++: Prioritizing Safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2680r1.pdf)
### [P2689R1 atomic_accessor](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2689r1.html)
### [P2700R1 Questions on P2680 "Contracts for C++: Prioritizing Safety"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2700r1.pdf)
### [P2713R0 Escaping improvements in `std::format`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2713r0.html)

↓

### [P2713R1 Escaping improvements in `std::format`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2713r1.html)

`std::format`のエスケープ出力（`?`）時の出力方法を修正する提案。

`std::format`の`?`指定は、C++23で`range`出力サポート（[P2286R8](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2286r8.html)）と同時に、ロギングやデバッグ時の出力のために追加されたものです。

`?`による指定は特に文字/文字列の出力時に有効なもので、入力の文字列をそのまま（人間の視認性を優先して）出力します。出力はまず、出力文字列全体が`"`にくくられて出力され、入力された文字で対応するエスケープシーケンスがある文字（`\t \n \r " \`の5つ）は対応するエスケープシーケンスに置換されて出力されます。また、ユニコード文字の中でも出力できない（見えない）ものなどや、無効な文字となるものもエスケープされて（`\u{xxxx}`の形で）出力されます。

```cpp
int main() {
  std::cout << std::format("{:?}", "hello") << std::endl;
  // "hello"と出力
  std::cout << std::format("{:?}", R"("hello"\n)") << std::endl;
  // "\"hello\"\n"と出力
}
```

このフォーマット時のエスケープの振る舞いは、入力文字列を1文字づつ見ていって、文字が置換条件に合致した場合に対応する表現に置換（エスケープ）されて出力する、ような形で記述されています。

ただ、このフォーマット方法は、何を目的としてフォーマットするのかが不明瞭だったようです。つまり、このエスケープは、入力文字列を人間にとって読みやすい形で出力することを意図しているのか、元のエンコーディングにおける文字表現を視認可能な形で出力することを意図しているのか、が不透明で、それによって一部の文字の最適なエスケープが変化します。これはC++23 CDに対するアメリカ/フランスからのNBコメントによって指摘されました。

この提案は、`?`によってエスケープされた出力文字列の意図が、入力文字/文字列をC++コード上で文字/文字列リテラルとして記述した場合の文字列を再現することにあることを明確化するために、エスケープ方法を修正するものです。

この提案はこの問題に関するSG16の投票によって確認された事項に対して標準の文言を提供するもので、SG16では次のことが確認されました

1. `?`によってエスケープされた文字列はそのまま文字/文字列リテラルとして使用できる
    - エスケープされた出力文字列は、文字列リテラルとして使用されたときに入力文字列を再現することのできる文字列となる
2. エスケープされた文字列は視覚的に明確な（人間にとって読み取りやすい）文字列を生成しない
3. 区切り文字や表示できない文字は引き続きエスケープされる

これによる主な変更は、次のようになります

- ユニコードの結合文字は、出力文字列の直前に結合可能な文字が現れている場合にエスケープされない
    - 結合文字とは、`Grapheme_­Extend=Yes`というユニコードプロパティを持つ文字
    - 結合可能な文字とは、エスケープされない文字もしくは、それに結合している結合文字のこと

提案文書より、サンプルコード

```cpp
string s0 = format("[{}]", "h\tllo");               // s0の結果文字列は [h    llo] （非エスケープ出力）
string s1 = format("[{:?}]", "h\tllo");             // s1の結果文字列は ["h\tllo"] （タブ文字が\tにエスケープ）
string s3 = format("[{:?}, {:?}]", '\'', '"');      // s3の結果文字列は ['\'', '"'] （\ と " はエスケープされて出力される）

// 次の例ではUTF-8エンコーディングを仮定
string s4 = format("[{:?}]", string("\0 \n \t \x02 \x1b", 9));  // s4の結果文字列は ["\u{0} \n \t \u{2} \u{1b}"]
string s5 = format("[{:?}]", "\xc3\x28");           // s5の結果文字列は ["\x{c3}("] （不正なUTF-8文字列のケース）
string s6 = format("[{:?}]", "\u0301");             // s6の結果文字列は ["\u{301}"]
string s7 = format("[{:?}]", "\\\u0301");           // s7の結果文字列は ["\\\u{301}"]
string s8 = format("[{:?}]", "e\u0301\u0323");      // s8の結果文字列は ["ẹ́"]
```

この提案において振る舞いが明確化されたのは、下の3つの例（`s6, s7, s8`）です。まず、`\u0301`と`\u0323`はダイアクリティカルマークという結合文字（アルファベットの上下につく文字）です。

`s6`は、結合文字に非結合文字（結合対称）が先行していないため、エスケープされて出力されています。`s7`は、エスケープされた文字が先行しているため、エスケープされて出力されています。`s8`はエスケープされない文字（`e`）が先行しているため`\u0301`（上付きの`,`）が結合し、結合した結合文字が先行しているため`\u0323`（下付きの`.`）も結合して出力され、結果は見た目1文字になり、エスケープされる文字はありません。

- [FR 005-134 22.14.6.4 [format.string.escaped] Aggressive escaping](https://github.com/cplusplus/nbballot/issues/408)
- [US 38-098 22.14.6.4p1 [format.string.escaped] Escaping for debugging and logging](https://github.com/cplusplus/nbballot/issues/515)
- [`std::format` - cpprefjp](https://cpprefjp.github.io/reference/format/format.html)
- [P2286R8 Formatting Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2286r8.html)
- [P2713 進行状況](https://github.com/cplusplus/papers/issues/1418)

### [P2714R0 Bind front and back to NTTP callables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2714r0.html)
### [P2717R0 Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2717r0.html)
### [P2723R1 Zero-initialize objects of automatic storage duration](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2723r1.html)
### [P2724R0 constant dangling](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2724r0.html)
### [P2725R1 std::integral_constant Literals](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2725r1.html)
### [P2728R0 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2728r0.html)
### [P2729R0 Unicode in the Library, Part 2: Normalization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2729r0.html)
### [P2730R0 variable scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2730r0.html)
### [P2732R0 WG21 November 2022 Kona meeting Record of Discussion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2732r0.pdf)
### [P2733R0 Fix handling of empty specifiers in std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2733r0.html)
### [P2734R0 Adding the new 2022 SI prefixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2734r0.pdf)
### [P2736R0 Referencing the Unicode Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2736r0.pdf)
### [P2737R0 Proposal of Condition-centric Contracts Syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2737r0.pdf)
### [P2738R0 constexpr cast from void*: towards constexpr type-erasure](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r0.pdf)
### [P2739R0 A call to action: Think seriously about "safety" then do something sensible about it](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2739r0.pdf)
### [P2740R0 Simpler implicit dangling resolution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2740r0.html)
### [P2741R0 user-generated static_assert messages](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2741r0.pdf)
### [P2742R0 indirect dangling identification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2742r0.html)
### [P2743R0 Contracts for C++: Prioritizing Safety - Presentation slides of P2680R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2743r0.pdf)
### [P2746R0 Deprecate and Replace Fenv Rounding Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2746r0.pdf)
### [P2747R0 Limited support for constexpr void*](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2747r0.html)
### [P2748R0 Disallow Binding a Returned glvalue to a Temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2748r0.html)
### [P2750R0 C Dangling Reduction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2750r0.html)
### [P2751R0 Evaluation of Checked Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2751r0.pdf)
### [P2752R0 Static storage for braced initializers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2752r0.html)
### [P2756R0 Proposal of Simple Contract Side Effect Semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2756r0.pdf)
### [P2757R0 Type checking format args](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2757r0.html)
### [P2758R0 Emitting messages at compile time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2758r0.html)
### [P2759R0 DG Opinion on Safety for ISO C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2759r0.pdf)
### [P2762R0 Sender/Receiver Interface For Networking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2762r0.pdf)
### [P2763R0 `layout_stride` static extents default constructor fix](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2763r0.html)
### [P2764R0 SG14: Low Latency/Games/Embedded/Finance/Simulation virtual meeting minutes 2023/01/11](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2764r0.pdf)
### [P2765R0 SG19: Machine Learning Virtual Meeting Minutes 2022/12/08-2023/01/12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2765r0.pdf)
### [P2766R0 SG16: Unicode meeting summaries 2022-10-12 through 2022-12-14](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2766r0.html)
### [P2769R0 get_element customization point object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2769r0.html)
