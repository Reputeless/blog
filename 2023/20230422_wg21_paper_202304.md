# ［C++］WG21月次提案文書を眺める（2023年04月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2023-04](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-04)

SG22のWG14からのものを除いて、全部で41本あります。

[:contents]


### [N4940 WG21 2022-11 Kona Minutes of Meeting V2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4940.pdf)

2022年11月7-12日にハワイのKonaで行われた、WG21全体会議の議事録。

N4933の改訂版です。

### [N4941 INCITS C++/WG21 Agenda: 6-11 February 2023, Issaquah, WA USA](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4941.html)

2023年2月6-11日にアメリカのIssaquahで行われた、WG21全体会議の全体予定表。

### [N4942 WG21 2023-01 Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4942.pdf)

2023年1月に行われた、WG21管理者ミーティングの議事録

### [N4943 WG21 February 2023 Issaquah Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4943.pdf)

2023年2月6-11日にアメリカのIssaquahで行われた、WG21全体会議の議事録。

おそらく、初日と最終日に行われた全体の会議の議事録です。

### [N4944 Working Draft, Standard for Programming Language C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4944.pdf)

C++23のワーキングドラフト第9弾。

### [N4945 Editors' Report - Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4945.html)

↑の変更点をまとめた文書。

2月のIssaquah会議で採択された提案とコア言語/ライブラリのIssue解決が適用されています。

### [P0876R13 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0876r13.pdf)
### [P1144R7 std::is_trivially_relocatable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1144r7.html)
### [P1673R12 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r12.html)
### [P1885R11 Naming Text Encodings to Demystify Them](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1885r11.pdf)
### [P2022R1 Rangified version of lexicographical_compare_three_way](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2022r1.pdf)
### [P2287R2 Designated-initializers for base classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2287r2.html)
### [P2407R3 Freestanding Library: Partial Classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2407r3.html)
### [P2447R3 std::span over an initializer list](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2447r3.html)
### [P2530R3 Hazard Pointers for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2530r3.pdf)
### [P2545R4 Read-Copy Update (RCU)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
### [P2630R3 Submdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r3.html)
### [P2690R1 Presentation for C++17 parallel algorithms and P2300](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2690r1.pdf)
### [P2746R1 Deprecate and Replace Fenv Rounding Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2746r1.pdf)
### [P2752R1 Static storage for braced initializers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2752r1.html)
### [P2757R1 Type checking format args](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2757r1.html)
### [P2780R0 Caller-side precondition checking, and Eval_and_throw](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2780r0.html)

契約プログラミングのEval_and_throwモード実装のための動作（実装）モデルの提案。

P2698R0では、契約違反が起きた時に無条件終了するのではなく例外を投げて継続するモードであるEval_and_throwモードが提案されています。

このモードで問題となっているのは`noexcept`との兼ね合いで、Eval_and_throwモードでは契約がなされている関数は全て例外を投げる可能性があるため、その関数の（あるいはその関数に対する）`noexcept`がどうなるのかが問題となっています。

この提案は、契約条件（事前条件）のチェックが関数内部ではなく関数呼び出し側で行われるという動作モデルによって、この問題を解決しようとするものです。

Eval_and_throwモードと`noexcept`の問題は、契約条件の評価がその関数の内側にあるという実行モデルに基づいています。そこで、契約条件（事前条件）のチェックは関数の呼び出し側で、関数呼び出しの前で行われるようにして、契約条件の評価と関数呼び出しを分離します。これによって、`noexcept`の扱いはこれまで通りとなり、`noexcept`指定されている関数で契約指定を行うことができるようになります。

この動作モデルでは、呼び出される側の準備や協力がなくても、完全に呼び出し側の責任範囲で契約のチェックを行うことができます。すなわち、呼び出される側の関数実態が別の翻訳単位にある時でも、翻訳単位間で何かを共有する必要はなく、呼び出し側で契約評価の有効/無効を切り替える時でも同じバイナリを使用し続けることができ、契約機能の状態によるABIの変化はありません。これによって、プレビルドバイナリを配布するようなライブラリでは契約機能の状態に応じた数のバイナリを配布するのではなく従来通りに1つのバイナリだけを配布し、そのAPIにおける契約の有効/無効はライブラリ使用者の任意で切り替えることができるようになります。

このことは、単にEval_and_throwモードの実装という枠を超えて契約機能全体にとって有用である可能性があります。この提案が採用されないにしても、契約機能がABIに影響を与えないように実装されることは非常に重要だと筆者の方は述べています。

この提案の動作モードは、単純なコードで示すと次のようなものになります

```cpp
// 関数呼び出しは
f();

// このように書き換えられて実行される
((precond() ? nop() : violation()), f());
```

`precond()`とは事前条件チェックの全体であり、`nop()`は何もしないダミーの関数で、`violation()`は違反ハンドラの呼び出しです。`violation()`は評価されると、Eval_and_abortモードでは`std::terminate()`を呼び出し、Eval_and_throwモードでは例外を送出します。

このコードでは、`violation()`が呼び出されると`f()`の呼び出しには到達しないため、`violation()`が例外を投げるかどうかは`f()`の`noexcept`性に影響を与えません。そのため、`noexcept`関数でも契約指定を行うことができます。また、このような実装は、コンパイラのフロントエンドだけで実装することができます。

この提案は、MVPの一部あるいはEval_and_throwモードのためというわけではなく、契約機能そのものに対して次のことを提案しています

1. 呼び出される関数の事前条件チェックを、現在の翻訳単位内のコードによって可能とする
2. オーバーロード解決済の関数呼び出しのみチェックすることを可能とするために、対象となる関数を名前を指定する関数とメンバ関数に限定する
3. 現在の翻訳単位内での契約アサートのチェックを可能とする
4. 現在の翻訳単位内での事後条件評価を可能としない
5. 事前条件が何回評価されるかは保証されない

また、Eval_and_throwモードを採用する場合でも、それを有効にするとこれらのことが有効となり、これ以上の何かが有効にはならないことを提案しています。

- [P2698R0 Unconditional termination is a serious problem](https://onihusube.hatenablog.com/entry/2022/12/25/175304#P2698R0-Unconditional-termination-is-a-serious-problem)
- [P2780 進行状況](https://github.com/cplusplus/papers/issues/)

### [P2806R1 do expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2806r1.html)
### [P2809R0 Trivial infinite loops are not Undefined Behavior](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2809r0.html)
### [P2811R0 Contract Violation Handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r0.pdf)
### [P2811R1 Contract Violation Handlers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2811r1.pdf)
### [P2817R0 The idea behind the contracts MVP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2817r0.html)
### [P2818R0 Uniform Call Syntax for explicit-object member functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2818r0.html)
### [P2819R0 Add tuple protocol to complex](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2819r0.pdf)
### [P2821R0 span.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2821r0.html)
### [P2824R0 WG21 February 2023 Issaquah meeting Record of Discussion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2824r0.pdf)
### [P2825R0 calltarget(unevaluated-call-expression)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2825r0.html)
### [P2826R0 Replacement functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2826r0.html)
### [P2827R0 Floating-point overflow and underflow in from_chars (LWG 3081)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2827r0.html)
### [P2828R0 Copy elision for direct-initialization with a conversion function (Core issue 2327)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2828r0.html)
### [P2830R0 constexpr type comparison](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2830r0.html)
### [P2833R0 Freestanding Library: inout expected span](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2833r0.html)
### [P2836R0 std::const_iterator often produces an unexpected type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2836r0.html)
### [P2838R0 Unconditional contract violation handling of any kind is a serious problem](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2838r0.html)
