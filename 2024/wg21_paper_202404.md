# ［C++］WG21月次提案文書を眺める（2024年04月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-04](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-04)

全部で173本あります。

もくじ

[:contents]

### [N4974 Wroclaw meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4974.pdf)

2024年11月にポーランドのWroclaw（ブロツワウ）で行われる全体会議のインフォメーション。

予定（2024年11月18日～23日）と場所、ホテルの案内などが記載されています。

### [N4975 2024 WG21 admin telecon meetings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4975.pdf)

2024年に行われる、WG21管理者ミーティングの予定表。

今年の残りは6/10と11/04に予定されています。

### [N4976 WG21 agenda: 18-23 March 2024, Tokyo, Japan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4976.html)

2024年3月に東京で行われた会議のアジェンダ。

### [N4978 WG21 2024-03 Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4978.pdf)

2024年3月4日に行われた、WG21管理者ミーティングの議事録。

前回（kona会議の前）からどのような活動があったかや、東京会議で何をするかなどの報告がなされています。

### [N4979 Hagenberg Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4979.pdf)

2025年1月にオーストリアのHagenberg（ハーゲンベルグ）で行われる全体会議のインフォメーション。

予定（2025年1月10日～15日）と場所、生き方や現地の観光案内などが記載されています。

### [N4980 WG21 2024-03 Tokyo Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4980.pdf)

2024年3月に東京で行われた全体会議の議事録。

最終日に行われた全体会議での各グループの作業報告と、全体投票の様子が記録されています。

### [N4981 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4981.pdf)

C++26のワーキングドラフト第4弾

### [N4982 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4982.html)

↑の変更点をまとめた文書。

### [P0260R8 C+ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0260r8.html)
### [P0562R1 Initialization List Symmetry](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0562r1.pdf)

↓

### [P0562R2 Trailing Commas in Base-clauses and Ctor-initializers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0562r2.pdf)

コンストラクタ初期化子リストと基底クラスリストにおいて、末尾カンマを許容する提案。

カンマはC++の様々なところでエンティティの区切り文字として使用され、一部のコンテキストでは冗長な末尾のカンマが許容されます。

```cpp
enum class E {
  a,
  b,
  c,  // ok
};

int array[2] = { 
  0,
  1, // ok
};

std::vector<int> vec = {
  0,
  1, // ok
};

struct S {
  int a;
  int b;
};

S s = { 
  .a = 0,
  .b = 1,  // ok
};
```

このことは、単純なマクロの展開によってカンマ区切りリストを生成する際に便利であったり、単純なコード整形などによって見やすさや保守性の向上等のための助けとなります。

ただし、コンストラクタ初期化子リストでは末尾のカンマは許容されていません。

```cpp
class C {
  int a, b;
public:

  C(int n1, int n2)
    : a{n1},
      b{n2},  // ng
  {}
};
```

コンストラクタ初期化子リストの順番はクラスのメンバの宣言順と一致している必要があり、一致しない場合に時に微妙なバグを静かに埋め込むことになります。宣言順に一致させるために行の入れ替えをした後でカンマを消すというのはとても簡単な作業ではありますが、時に忘れがちで、コンパイルエラーを起こしてはじめて気づくこともあります。コンパイル時間が長い場合はその損失は大きなものになります。

また、そもそもその些細な作業の地味な面倒さから、並べ替えの必要性に気づいた人が作業をやらない誘因を与えています。

そのため、この提案ではコンストラクタ初期化子リストにおける末尾の不要なカンマを許容することを提案しています。

また、同様のメンテナンス性の問題と一貫性の向上のために、基底クラスリストにおいて同様に末尾カンマを許容するようにすることも提案しています。


<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
foo::foo(int x, int y, int z) :
  a(x),
  b(y),
  c(z)
{...}

class bar :
  public base,
  public mixin
{};
```

</td>
<td valign="top">

```cpp
foo::foo(int x, int y, int z) :
  a(x),
  b(y),
  c(z),
{...}

class bar :
  public base,
  public mixin,
{};
```

</td>
</tr>
</table>

この提案は内容が小さいこともありEWGのレビューをすでに終えてCWGでレビューされています。

- [P0562 進行状況](https://github.com/cplusplus/papers/issues/1818)

### [P0609R3 Attributes for Structured Bindings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0609r3.pdf)
### [P0843R11 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0843r11.html)
### [P0876R16 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0876r16.pdf)
### [P1061R8 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1061r8.html)
### [P1068R11 Vector API for random number generation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1068r11.pdf)
### [P1317R1 Remove return type deduction in `std::apply`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1317r1.pdf)

`std::apply`の戻り値型推論をやめる提案。

`std::apply`の宣言は次のようになっており、戻り値型は`decltype(auto)`によって推論されています。

```cpp
namespace std {
  template<class F, tuple-like Tuple>
  constexpr decltype(auto)
    apply(F&& f, Tuple&& t) noexcept(...);
}
```

これによって、`apply`の引数に呼び出し不可能なペアを渡すと`apply`内部においてエラーが起こることによって、SFINAEのような動作をしないという問題があります。

例えば次のようなコンセプトとその使用例において

```cpp
#include <tuple>

template<class Func, class Tuple>
concept applicable =
  requires(Func&& func, Tuple&& args) {
    std::apply(std::forward<Func>(func), std::forward<Tuple>(args));
  };

int main () {
  auto func = [](){};
  auto args = std::make_tuple(1);

  static_assert(!applicable<decltype(func), decltype(args)>); // static_assert()によらずにエラーが起こる
}
```

この`func`は引数無しのラムダ式なので`std::tuple<int>`では呼び出しできません。`applicable`コンセプトの意図としては制約を満たさずに`false`となることが期待されますが、実際には`apply`本体内でのハードエラーとなることによってコンセプトの定義内でのエラーとなってしまいます。

これは、`decltype(auto)`によって戻り型が推論されているためで、これによって関数のシグネチャの決定のために本体のインスタンス化が必要となり、呼び出しできない引数が渡っている場合にそのインスタンス化の途中でハードエラーを起こしています。

この問題を回避するため、この提案は`std::apply`の戻り値型を求めるために`decltype(auto)`ではなく別の型特性を使用することを提案しています。

この提案では、`std::apply`の戻り値型導出のために`std::apply_result_t`という型特性を使用することを提案しています。

```cpp
namespace std {
  template<class Fn, class Tuple>
  struct apply_result;

  template<class F, class Tuple>
  using apply_result_t = apply_result<F, Tuple>::type;

  // 新しいapplyの宣言
  template<class F, class Tuple>
  constexpr std::apply_result_t<F, Tuple> apply(F&& f, Tuple&& t);
}
```

この`std::apply_result_t`は呼び出し不可能な型のペアを受け取ると、巧妙な実装によってそれをハードエラーではなくSFINAE-friendlyなエラーとして報告するように実装されます（提案中に実装例があります）。

また特に触れられてはいないのですが、上記の`applicable`のようなコンセプトを同時に追加しようともしています。

- [c+ - decltype(auto) works with SFINAE in some cases? - Stack Overflow](https://stackoverflow.com/questions/51119523/decltypeauto-works-with-sfinae-in-some-cases)
- [P1317 進行状況](https://github.com/cplusplus/papers/issues/326)

### [P2034R3 Partially Mutable Lambda Captures](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2034r3.pdf)
### [P2075R5 Philox as an extension of the C+ RNG engines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2075r5.pdf)
### [P2127R0 Making C+  Software Allocator Aware](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2127r0.pdf)

Allocator AwareなC++コードのための解説書。

この文書は、Bloomberg社内の教育のために書かれた、C++コードでアロケータを受け取るクラスを記述するための知っておくべきことをまとめたものです。

LEWGにおけるポリシーの策定に当たってアロケータ関連のポリシーが提案されており、LEWGのメンバにとっても有用である可能性があるとして公開されたものです。

### [P2135R1 P2055R1: A Relaxed Guide to memory_order_relaxed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2135r1.pdf)
### [P2141R2 Aggregates are named tuples](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2141r2.html)
### [P2248R8 Enabling list-initialization for algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
### [P2300R8 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r8.html)
### [P2300R9 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r9.html)
### [P2355R2 Postfix fold expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2355r2.html)
### [P2389R1 `dextents` Index Type Parameter](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2389r1.html)
### [P2414R3 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2414r3.pdf)
### [P2542R8 views::concat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2542r8.html)
### [P2573R2 = delete("should have a reason");](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2573r2.html)
### [P2591R5 Concatenation of strings and string views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2591r5.html)
### [P2746R5 Deprecate and Replace Fenv Rounding Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2746r5.pdf)
### [P2747R2 constexpr placement new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2747r2.html)
### [P2748R5 Disallow Binding a Returned Glvalue to a Temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2748r5.html)
### [P2755R1 A Bold Plan for a Complete Contracts Facility](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2755r1.pdf)
### [P2786R5 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r5.pdf)
### [P2795R5 Erroneous behaviour for uninitialized reads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2795r5.html)
### [P2809R3 Trivial infinite loops are not Undefined Behavior](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2809r3.html)
### [P2810R4 is_debugger_present is_replaceable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2810r4.html)
### [P2825R1 Overload Resolution hook: declcall(unevaluated-postfix-expression)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2825r1.html)
### [P2825R2 Overload Resolution hook: declcall(unevaluated-postfix-expression)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2825r2.html)
### [P2826R2 Replacement functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2826r2.html)
### [P2830R2 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r2.html)
### [P2830R3 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r3.html)
### [P2841R2 Concept and variable-template template-parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2841r2.pdf)
### [P2845R7 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2845r7.html)
### [P2845R8 Formatting of std::filesystem::path](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2845r8.html)
### [P2855R1 Member customization points for Senders and Receivers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2855r1.html)
### [P2863R5 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2863r5.html)
### [P2866R2 Remove Deprecated Volatile Features From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2866r2.pdf)
### [P2867R2 Remove Deprecated strstreams From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2867r2.html)
### [P2869R4 Remove Deprecated `shared_ptr` Atomic Access APIs From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2869r4.pdf)
### [P2872R3 Remove `wstring_convert` From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2872r3.pdf)
### [P2873R1 Remove Deprecated locale category facets for Unicode from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2873r1.pdf)
### [P2875R4 Undeprecate `polymorphic_allocator::destroy` For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2875r4.pdf)
### [P2893R3 Variadic Friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2893r3.html)
### [P2900R6 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r6.pdf)
### [P2927R2 Observing exceptions stored in exception_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2927r2.html)
### [P2944R3 Comparisons for reference_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2944r3.html)
### [P2977R1 Build database files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2977r1.html)
### [P2988R4 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r4.pdf)
### [P2993R0 Constrained Numbers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2993r0.pdf)

制約付きの整数型を生成するライブラリ機能の提案。

2018年から2022年の5年間で整数オーバーフローに関連するCVEレコードが1515件あります。1996年6月4日のアリアン5G V88/501ロケットの打ち上げ失敗は整数オーバーフローのエラー処理のバグが原因となり、3億7000万ドルの以上の損害を出しました。2015年と2020年には、ボーイング787のシステム内の時間値の整数オーバフローに関連する2つの別々のバグにより、飛行システムがクラッシュしたり計器に誤った情報が表示されたりするインシデントがありました。

これらのような整数型のオーバフローとそれに伴う結果は、プログラムの機能やセキュリティ、安全性を損なう重大なバグの原因となります。実行時に整数オーバーフローを検出できた場合でも、エラー処理を正しく行わなければそれもバグの元となります。

整数型の実行時の演算に伴う問題としてはそのほかにも、アンダーフロー、ゼロ除算、少し毛色は異なりますが配列の範囲外アクセスなどがあります。

C++コアガイドラインをはじめとする、安全なC/C++プログラムのためのコーディングルールにおいても必ず整数型のオーバーフローに関する注意やルールが存在しています。しかし、そのようなルールが取り入れられている現場においても、整数型のオーバーフローをはじめとする数値演算におけるバグは依然として危険性の高い問題であり続けています。

数値を正しく扱うために、既存のC++言語標準及びライブラリ、ガイドライン、コーディングルールなどは十分ではありません。

この提案では、標準ライブラリに対して新しい制約付きの数値システムを提案するものです。このシステムは、基本的に制約をコンパイル時にチェックし、必要な場合にのみ実行時チェックを行うことで、実行時への影響を最小限に抑えつつ安全で使いやすい数値型を提供するものです。

この提案による機能は`constrained_number<C, T>`という型を中心にしています。テンプレートパラメータの`C`には制約を指定し、`T`には内部表現のための整数型を指定して使用します。

```cpp
// 64bit符号付整数型としての制約を満たす値でのみ初期化可能
constrained_integral<int64_t> foo = 42; // ok

// [0, 10]の区間の整数値のみ表現可能な整数型
// この場合、符号付き整数型の値で初期化できない
constrained_number<constrain_interval<0, 10>> bar = 4;  // ng
```

ここでの制約とはコンセプトとは関係ありません。詳細は後述しますが、これは構文的な制約だけではなく意味論的な制約も表現可能なDSLになっています。

整数定数によって`constrained_number`を初期化するには、`_cn`リテラルを使用します。

```cpp
// 定数値'4'は指定されている制約を満たす
constrained_number<constrain_interval<0, 10>> bar = 4_cn;   // ok

// 定数値'42'は制約を満たさない
bar = 42_cn;    // ng
```

このチェックはすべてコンパイル時に行われ、実行時のオーバーヘッドはありません。

異なる制約を持つ`constrained_number`値の間で代入や初期化は可能ですが、代入・初期化しようとしている値が制約を満たしているかどうかがコンパイル時にチェックされます

```cpp
// 制約を満たす値によって正しく初期化されているとして
constrained_number<constrain_interval<0, 100>> foo = ...;

// 'foo'には'bar'の制約を満たさない値が含まれうる
constrained_number<constrain_interval<0, 10>> bar = foo;    // ng

// 上記エラーが無く、制約を満たす値によって正しく初期化されているとして
bar = ...;

// `bar`の値は`foo`の制約を常に満たす
foo = bar;  // ok
```

とはいえ、実行時に決定される値によって初期化できなければ実用には耐えません。ただしその場合でも制約を満たすかどうかはチェックされなければなりません。`make_constrained()`を使用すると、実行時の値から実行時に制約を満たしているかをチェックして変換することができます。このとき、制約を満たさない場合は例外が送出されます。

```cpp
// 5の倍数であることを要求する制約
constexpr any_constraint auto multiple_of_five_c =
  constraint_of<int64_t> &&
  constrain_multiple<5>;

// 5の倍数値のみからなる整数型
using mult_of_five_t = constrained_number<multiple_of_five_c>;

// コンパイル時にチェックされ、実行時には何もしない
auto v1 = make_constrained<multiple_of_five_c>(1005_cn);    // ok

// 実行時にチェック、制約が満たされない場合は例外を投げる
mult_of_five_t v2 = make_constrained<multiple_of_five_c>(get_some_raw_int());   // ok

// コンパイルエラー
auto v3 = make_constrained<multiple_of_five_c>(12_cn);  // ng

// 実行時に例外が送出される
mult_of_five_t v4 = make_constrained<multiple_of_five_c>(12);   // ok
```

`make_constrained()`は引数値に対してコンパイル時の検証が行える場合（`_cn`リテラルの値など）はコンパイル時にチェックを完了しようとします。

`constrained_number`は他の整数型に暗黙変換されません。`constrained_number`の値から生の整数値を得るためには`static_cast`によって明示的にキャストします
```cpp
// 制約を満たす値によって正しく初期化されているとして
constrained_number<constrain_interval<0, 10>> foo = ...;

// 組み込み整数型に変換
auto raw_foo = static_cast<uint32_t>(foo);  // ok
```

`constrained_number<C, T>`に指定する制約`C`の指定は、簡易なDSLによって行います。ここまでに使用していますが、整数型のとり得る値を区間で制限するために`constrain_interval`が用意されています

```cpp
// [-100, 100]区間の値のみ保持可能
constrained_number<constrain_interval<-100, 100>> small_number{};

// ↑はこれと等価
constrained_number<constrain_interval<-100, 100>> small_number = 0_cn;

// 0を除きたい場合（[-100, 0) ∪ (0, 100]）
constrained_number<constrain_interval<-100, -1> || constrain_interval<1, 100>> small_nonzero_number = 1_cn;
```

これによって、このライブラリではゼロ除算をコンパイル時に防止することができます。

```cpp
// small_numberは0を保持しうる
auto result_1 = 10_cn / small_number;   // ng

// small_nonzero_numberは0を保持しない
auto result_2 = 10_cn / small_nonzero_number;   // ok
```

この制約の実体は変数テンプレートであり、`constrained_number`のテンプレートパラメータの外側で定義しておくこともできます。

```cpp
constexpr auto non_zero_req = constrain_interval<-100, -1> || constrain_interval<1, 100>;
constexpr auto small_num_req = constrain_interval<-100, 100>;

// <=演算子を⊆の意味で使用可能
static_assert(non_zero_req <= small_num_req);

constrained_number<non_zero_req> non_zero = 1_cn;

// この初期化が安全であることは、制約の<=によってコンパイル時にチェックされる
constrained_number<small_num_req> small_num = non_zero;
```

この制約は、演算によって更新されます。

```cpp
constexpr auto one_to_ten_req = constrain_interval<1, 10>;
constexpr auto non_zero_req = constrain_interval<-100, -1> || constrain_interval<1, 100>;

constrained_number<non_zero_req> a = 42_cn;
constrained_number<one_to_ten_req> b = 3_cn;

auto c = a * b; // ok

// 実行時の値は期待通りに更新される
assert(c == 126);

// 制約もまた、期待通りに更新される
static_assert(c.constraint == constrain_interval<-1000, -1> || constrain_interval<1, 1000>);
```

用意されている制約は次のものです

|名称|定義|API|備考|
|---|---|---|---|
|区間|`[a, b]`|`constrain_interval<a, b>`|閉区間|
|集合|`{a, b, ...}`|`constrain_set<a, b, ...>`|外延的な集合|
|マスク|`{x ∈ Z | 0 <= x <= 2^n && (x & ~V) == C}`|`constrain_mask<V, C>`|ビットマスクによる整数値の指定|
|剰余類|`{x ∈ Z | mod(x, a) == 0}`|`constrain_multiple<a>`|`a`の倍数からなる集合|
|Constraint of|`[min(T), max(T)]`|`constraint_of<T>`|整数表現の制約区間|
|空集合|∅|`constraint_empty `|表現可能な値なし|
|不正|⊥|`constraint_invalid`|他の方法では表現できない値が含まれていたであろう集合|

これらの制約は集合的に指定されており、集合の演算によって制約を合成したりすることができます。制約の定義のために使用可能な演算は、次のものです

![](./wg21_paper_202404/P2993R0_constraint_operation.png)

`constrained_number`を使用して、`[]`の引数値を制限する例

```cpp
template<class T, size_t Extent = dynamic_extent>
class span {
  ...

  constexpr reference at(constrained_number<constrain_interval<0, Extent - 1>> pos) noexcept const
    requires (Extent != dynamic_extent);

  constexpr reference operator[](constrained_number<constrain_interval<0, Extent - 1>> pos) noexcept const
    requires (Extent != dynamic_extent);
  
  ...
};
```

- [C+ における整数型の怪と "移植性のある" オーバーフローチェッカー (第1回 : 整数型の怪と対策の不足) - Qiita](https://qiita.com/a4lg/items/541c9d9dd5d874eeef2f)
- [P2993 進行状況](https://github.com/cplusplus/papers/issues/1817)

### [P2997R1 Removing the common reference requirement from the indirectly invocable concepts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2997r1.html)
### [P3008R2 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3008r2.html)
### [P3016R3 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3016r3.html)
### [P3019R7 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r7.html)
### [P3019R8 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r8.html)
### [P3029R1 Better mdspan's CTAD](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3029r1.html)
### [P3032R1 Less transient constexpr allocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3032r1.html)
### [P3032R2 Less transient constexpr allocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3032r2.html)
### [P3034R1 Module Declarations Shouldn't be Macros](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3034r1.html)
### [P3037R1 constexpr std::shared_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3037r1.pdf)
### [P3049R0 node-handles for lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3049r0.pdf)

リストに対してノードハンドルのサポートを追加する提案。

C++17では、連想コンテナに対してノードハンドルAPIが追加されました。ノードハンドルとはノードベースコンテナのある一要素の所有権を引き取るもので、ノードハンドルを介することで、互換性のあるコンテナ間でムーブすらすることなく要素を移動することができます。

```cpp
// cpprefjpのサンプルを微修正したもの

import std;

int main() {
  std::map<char, int> m1, m2;

  m1.insert(std::make_pair('a', 10));
  m1.insert(std::make_pair('b', 20));
  m1.insert(std::make_pair('c', 30));

  // m1の'c'をキーとするノードハンドルを取得
  std::map<char, int>::node_type node = m1.extract('c');

  // 取得したノードハンドルを別のmap'm2'へ挿入
  // この時、ノード（要素）はコピーもムーブもされていない
  m2.insert(std::move(node));

  std::println("{}\n{}", m1, m2);
}
```

出力例

```
{'a': 10, 'b': 20}
{'c': 30}
```

一方`std::list`及び`std::forward_list`もノードベースコンテナではありましたが、元々`splice`のAPIを備えていたこともあり、APIの一貫性以上の利点はないとしてリスト系コンテナに対してはノードハンドルAPIは追加されませんでした。

この提案は、APIの一貫性向上も含めてさらに追加の利点があるとして、`std::list`及び`std::forward_list`にノードハンドルAPIを追加することを提案するものです。

ここで提案されているAPIは、連想コンテナのAPI

```cpp
// ノードハンドルの型
using node_type = implementation defined specialization of node_handle;

// ノードハンドルの取り出しAPI
node_type extract(const_iterator pos);
node_type extract(const key_type& key);
template<typename Key> 
node_type extract(Key&& key);

// insert()の戻り値型
struct insert_return_type {
  iterator position; 
  bool inserted; 
  node_type node; 
};

// ノードハンドルの挿入API
insert_return_type insert(node_type && handle);
iterator insert(const_iterator pos, node_type && handle);
```

に対してこのサブセットとなるもので、次の2つの関数からなります

```cpp
// ノードハンドルの型
using node_type = implementation defined specialization of node_handle;

// ノードハンドルの取り出し
node_type extract(const_iterator pos);

// ノードハンドルの挿入
iterator insert(const_iterator pos, node_type && handle);

// forward_listのAPI
node_type extract_after(const_iterator pos); 
iterator insert_after(const_iterator pos, node_type && handle);
```

減った分のAPIは、連想コンテナに固有の事情に特化したものだけです。

リスト系コンテナへのノードハンドルAPI追加の利点として、この提案では`splice()`操作と比較してソースとターゲットをより適切に分離できる点を挙げています。

```cpp
// listでsplice()を使用する例

// valに指定した値に一致する値を持つリスト要素を移動する
template<typename T> 
void splice_if(list<T> & from, list<T> & to, T val) { 
  const auto it{ranges::find(from, val)};
 
  if (it != from.end()) {
    to.splice(to.begin(), from, it); 
  }
} 

// usage: 
list<int> l1 = …; // filled with random ints 

// splice()によって要素を移動させようとする場合
// 移動元と移動先コンテナがそろっている必要がある
list<int> l2 = …;

splice_if(l1, l2, 42);
```

```cpp
// この提案のノードハンドルAPIを使用する例

// valに指定した値に一致する値を持つリスト要素のノードハンドルを取得する
template<typename T> 
list<T>::node_type extract_if(list<T> & from, T val) { 
  const auto it{ranges::find(from, val)};

  if (it != from.end()) {
    return from.extract(it);
  }

  return {}; 
} 

//usage: 
list<int>& l1 = …; // filled with random ints 
auto nh{extract_if(l1, 42)};
// nh は転送先とは独立して取り廻すことができる

// これにより、要素取り出しと要素挿入が分離される
list<int>& l2 = …; 
if(nh) l2.insert(l2.end(), move(nh));
```

この提案の内容は既に、MSVC STLのフォークにて実装可能なことが確認されています。

- [`node_handle` - cpprefjp](https://cpprefjp.github.io/reference/node_handle/node_handle.html)
- [P3049 進行状況](https://github.com/cplusplus/papers/issues/1820)

### [P3050R1 Fix C++26 by optimizing linalg::conjugated for noncomplex value types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3050r1.html)
### [P3064R0 How to Avoid OOTA Without Really Trying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3064r0.pdf)
### [P3068R1 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r1.pdf)
### [P3072R2 Hassle-free thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3072r2.html)
### [P3074R3 trivial union (was std::uninitialized<T>)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3074r3.html)
### [P3085R1 `noexcept` policy for SD-9 (throws nothing)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3085r1.html)
### [P3086R1 Proxy: A Pointer-Semantics-Based Polymorphism Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3086r1.pdf)
### [P3086R2 Proxy: A Pointer-Semantics-Based Polymorphism Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3086r2.pdf)
### [P3091R1 Better lookups for `map` and `unordered_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3091r1.html)
### [P3094R1 std::basic_fixed_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3094r1.html)
### [P3097R0 Contracts for C++: Support for virtual functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3097r0.pdf)

契約プログラミング機能において、仮想関数に対する契約の指定をサポートする提案。

以前の契約プログラミング仕様においては仮想関数にも通常の関数と同様に契約注釈を行うことができました。ただし、派生先の契約注釈は派生元の契約を暗黙に継承し、明示的に指定する場合でも派生元の契約と同じにならなければならないとされていました。これは、Assertion Redeclaration ruleというルール（事前条件は同じかより弱いもの、事後条件は同じかより強いものでなければならない）に沿うものでしたが、派生先に明示的に指定された契約注釈が派生元と同じであることをどう表現するかや異なる場合にどうするかなどや、そのルールがC++の実際の仮想関数のユースケースを満たしていないということが問題となり、より議論を尽くすためにC++26に向けては仮想関数に対する契約注釈を目指さないことになりました。それを受けて、現在のContracts MVP仕様（P2900R5）では仮想関数に対する契約注釈の指定は禁止されています。

例えば、Assertion Redeclaration ruleに従わないような2つの呼び出し、事前条件をより強くする場合と事後条件をより弱くする場合の2つのケースにおいても、ユースケースが存在しています。

例えば次のような`Car`クラスを基底クラスとして

```cpp
struct Car {
  virtual void drive(float speedMph)
    pre (speedMph < 100) // don't go too fast!
};

void testCar(Car& car) {
  car.drive(90);  // OK
  car.drive(120); // bug: precondition violation
}
```

次のように`Car`クラスを派生させると、事前条件をより強くすることになります

```cpp
struct ElectricCar : Car {
  void drive(float speed_mph) override
    pre (is_charged);   // 事後条件が強くなっている

  void charge() { is_charged = true }

private:
  bool is_charged = false;
};


void testCar(Car& car);

int main() {
  ElectricCar myElectricCar;
  testCar(myElectricCar);
}

void testCar(Car& car) {
  car.drive(90); // 事前条件違反、charge()を呼んでいない
}
```

このように派生クラスで事前条件を強くしてしまうと、`ElectricCar`のインスタンスは一般的に`Car`のインスタンスとして使用することができなくなるため、正統的なオブジェクト指向設計に準拠していません。

それでもなあお、これが合理的である場合があります。使用準備が整った`ElectricCar`のインスタンスをより広いスコープで使用することで、より具体的な事前条件を非ローカルで保証することができます。

```cpp
int main() {
  ElectricCar myElectricCar;
  myElectricCar.charge();
  
  testCar(myElectricCar); // everything works now!
}
```

デフォルト構築された`ElectricCar`はそのまま`Car`の代わりに使用することはできませんが、`.charge()`を呼び出すことでその準備が整います。この場合、`ElectricCar::drive()`で強められている契約はこの追加のセットアップ手順を省略されないようにすることを表現するものとしてみることができます。このような設計は現実のC++アプリケーションで一般的です。

（提案には、他の3つの場合と多重継承の場合のユースケース例があります）

また、以前のMVP仕様（派生先に派生元と同じ契約を強制する）では、この例だけでなく、Assertion Redeclaration ruleに従うような継承を行っている場合を完全にサポートしきれてはいません。

この提案は、仮想関数に対する契約注釈は契約機能の普及のために必須であるとして、以前の問題を解決して仮想関数に対する契約注釈を個萎えるようにするための新しいソリューションを提案するものです。

この提案では仮想関数に対する契約注釈を許可しますが、派生先の関数は派生元の関数の契約を継承しません。派生元関数の契約は派生元の関数の契約から完全に独立しており、派生先の事前条件及び事後条件は拡大と縮小の両方が可能になります。

そして、仮想関数呼び出し時の契約チェックの評価は次のようになります

1. 派生元関数の事前条件が評価される
2. 派生先関数の事前条件が評価される
3. 派生先関数の本体が実行される
4. 派生先関数の事後条件が評価される
5. 派生元関数の事後条件が評価される

仮想関数が基底クラスのポインタ/参照を介して呼び出される場合、派生元の関数は静的に決定されておりその契約も呼び出す場所から見えています。一方、派生先の関数は動的に決定され動的にディスパッチされますが、ディスパッチされた先ではどの派生型の実装された関数が呼ばれているのか、およびその契約についてが分かっています。

そのため、仮想関数の呼び出しにおいては直接関与する2つの型（静的型と動的型）についての情報を利用することができ、それによって上記のような呼び出しシーケンスが可能になります。

例えば、静的型と動的型が一致する場合（派生クラスオブジェクトを派生クラスのポインタ/参照、あるいはオブジェクトから直接呼び出した場合）、その派生クラスにおいてなされている契約だけが評価されます。

提案より、深い継承の例

```cpp
struct X {
  virtual void f() pre(a) post(b);
};

struct Y : X {
  void f() override pre(c) post(d);
};

struct Z : Y {
  void f() override pre(e) post(f);
};

int main() {
  Z z;

  X& x = (X&)z;
  x.f(); // a -> eの順でチェックされ、z::f()が実行された後、f -> bの順でチェックされる
  
  Y& y = (Y&)z;
  y.f(); // c -> eの順でチェックされ、z::f()が実行された後、f -> dの順でチェックされる
}
```

多重継承の例

```cpp
struct X1 {
  virtual void f() pre(a1) post (b1);
};

struct X2 {
  virtual void f() pre(a2) post (b2);
};

struct Y : X1, X2 {
  void f() override pre(c) post (d);
};

int main() {
  Y y;

  X2& x2 = (X2&)y;
  x2.f(); // a2 -> cの順でチェックされ、Y::f()が実行された後、d -> b2の順でチェックされる
}
```

このように、仮想関数呼び出しにおいてはコード上から見えている直接の静的型における関数と実際に呼び出される動的型における関数だけが契約チェックに関与することになり、直感的になるとともに非常に教えやすくもなります。

この提案における仮想関数に対する契約注釈は、仮想関数が純粋であるかどうかによらず行うことができ、同じように動作します。

提案しているこの方法では、事前条件は派生先の物より強くすることができ、どちらの条件においても派生元の契約を無視するようにすることができます。そのため、Assertion Redeclaration ruleに従ったものではありません。これは、実際のC++における仮想関数の使用パターンとの互換性と一貫性を最大化しつつ、全体として最も幅広いユースケースを可能にしようとした結果です。この提案では、Assertion Redeclaration ruleに従わない契約と継承を許可する一方で、Assertion Redeclaration ruleに従った契約と継承も同時に許可しています。

この提案において重要なことは、呼び出し側（派生元）と呼び出し先（派生先）の関数の両方がその呼び出しに伴って契約をチェックする一方で、必要なところではその契約を変化させたり回避する柔軟性を提供している点です。

- [P3049 進行状況](https://github.com/cplusplus/papers/issues/1822)

### [P3103R1 More bitset operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3103r1.html)
### [P3104R1 Bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3104r1.html)
### [P3104R2 Bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3104r2.html)
### [P3105R1 constexpr std::uncaught_exceptions()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3105r1.html)
### [P3105R2 constexpr std::uncaught_exceptions()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3105r2.html)
### [P3106R1 Clarifying rules for brace elision in aggregate initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3106r1.html)
### [P3107R1 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r1.html)
### [P3107R2 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r2.html)
### [P3107R3 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r3.html)
### [P3107R4 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r4.html)
### [P3107R5 Permit an efficient implementation of std::print](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r5.html)
### [P3119R0 Tokyo Technical Fixes to Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3119r0.pdf)

現在のContarcts仕様の小さな問題を解決する提案。

2023年3月に東京で行われたWG21全体ミーティングの中で、Contracts MVP（P2900R6）がEWGに転送され、最初のレビューが行われました。この提案は、その際に寄せられたごく小さい問題について報告し、その解決策を提案するものです。

報告されているのは次の3つの問題です。

**配列引数と事後条件**

事後条件から関数引数を参照する場合、その引数は`const`指定されている必要があります。ところが、（参照ではない）配列引数の場合は`decay`されることによってポインタによって宣言した場合と同等になりますが、その際にそのポインタそのものに`const`を付加することができません。

例えば、次の2つの宣言は等価となります。

```cpp
void f(const int a[]);
void f(int * const a);
```

2つ目の宣言を見ればわかるように、これはポインタ自体が`const`なのではなく、ポインタの指す先が`const`となる宣言です。2つ目の宣言の場合は`const`を追加することは容易ですが、1つ目の配列引数に対してそのポインタに`const`を付加することはできません。

これによって、そもそも事後条件からの関数引数を参照することを禁止している理由が再燃します

```cpp
void f(const int a[]) post( a[0] == 5 ) {
  static int x[1];
  a = x;    // ローカル静的配列へのポインタを代入（ポインタそのものはローカル変数なので関数の外には漏れていない）
  a[0] = 5; // 関数本体では事後条件は満たされている
}

void g() {
  int b[5] = {0,1,2,3,4,5};
  f(b);
  contract_assert(b[0] == 5); // これは決して満たされない（常に失敗）
}
```

**Cの可変長関数引数と事前/事後条件**

現在のMVPの規定では、Cの可変長引数を持つ関数に対して事前条件及び事後条件を指定した場合、それらの中からその可変長引数をどのように使用可能なのかについての指定がありません。一般に、`va_start()`から`va_end()`までの一連の流れは1つの関数内で完結している必要があり、現在の契約においては次の2点が問題となります

1. `va_start()`から`va_end()`の使用はある1つの述語内で完結しなければならない
    - Cの可変長引数から見ると、異なる契約述語は異なる関数
2. Cの可変長引数を`const`にする方法が無いため、事後条件はそれを参照できない

少なくとも事前条件から可変長引数を参照するには1つ目の問題を解消しなければなりませんが、それは性的に検証できることではないので、破られた場合に未定義動作とするしかありません。

**契約条件の評価回数の制限**

現在のMVPの仕様では、ある契約述語は違反の検出のために0回以上、違反の処理のために1回以上評価されうるとしていますが、最大何回評価するかについては制限がありません。これについて2つの問題点が指摘されました

1. 契約述語の評価を何度も繰り返した末にUBになるとしたら、その契約は常にUBになるとみなせる。
2. 実行時の計算量について厳密な制限を必要とするリアルタイムシステムでは、標準で1回の述語評価から生じる評価回数が制限されていない場合、契約を使用できない
    - 実際に実装がこれについて制限を設けたとしても、使用が無制限を許可する以上契約を使用しないようにする人が居るかもしれない

一方で、無制限の評価を許可する合理的な理由もあります

1. 異なる翻訳単位で定義されている関数では、関数呼び出しの両側でチェックを行う必要がある場合があるかもしれない
    - これによって、契約のチェックが全く行われないことを回避できる
    - このことは、各契約述語は少なくとも2回評価されることを要求している
2. 何回評価されるかが不定であることは、副作用が発生する正確な回数への依存を困難にするため、契約述語に副作用があることが推奨されていないことを明確にする
3. 破壊的な契約述語をテストするための特に徹底的な方法は、テスト中に繰り返して契約述語を評価することで結果が変わるかを観察すること
    - 任意の繰り返し回数を要求する適合コンパイラオプションはこれを検証するための優れたメカニズム


これらの3つの問題について、この提案では次のような解決を提案しています

1. 配列引数と事後条件 : 事後条件からの配列引数の参照は禁止（コンパイルエラーとする）
    - それを行いたい場合、等価なポインタによる宣言に書き換える
2. Cの可変長関数引数と事前/事後条件 : 契約述語での`va_start`の使用は禁止（コンパイルエラーとする）
3. 契約条件の評価回数の制限 : 評価回数の上限は実装定義
    - 標準としては具体的な数の指定を避ける

とてもマイナーな問題ではありますが、この解決によってContracts仕様はよりロバストになるはずです。

- [P3119 進行状況](https://github.com/cplusplus/papers/issues/1823)

### [P3122R1 [[nodiscard]] should be Recommended Practice](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3122r1.html)
### [P3135R1 Hazard Pointer Extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3135r1.pdf)
### [P3146R1 Clarifying std::variant converting construction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3146r1.html)
### [P3147R1 A Direction for Vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3147r1.pdf)
### [P3149R1 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r1.pdf)
### [P3149R2 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r2.pdf)
### [P3159R0 C+ Range Adaptors and Parallel Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3159r0.html)

Rangeアダプタを並列実行する際に必要となる最適化とその方針についての提案。

この提案は、P3300で提案されている並列Rangeアルゴリズムの実装に伴って発生する設計の選択肢について説明し、その選択を提案するものです。以下、ほぼ提案の翻訳

Rangeアダプタ/ファクトリは範囲の各要素の変換をローカルに（グローバルメモリを更新することなく）行うことができ、またコード上でもその変換を分かりやすく表現することができます。

ただし、Rangeアダプタ/ファクトリが生成する`view`は遅延評価を行い、範囲の要素に対して1つづつその変換処理を適用していきますが、並列化のためにはその変換処理を抽出してベースとなる範囲に対して一括適用（複数の操作を順番にやるのではなく、1度にすべての操作を適用する）する必要があります。

範囲を消費する並列Rangeアルゴリズムを実装するには、入力の範囲を適用されているアダプタと一番基底にある元の範囲/Rangeファクトリに再帰的に分解する最適化カーネルビルダーを構築する必要があります。ただし、このカーネルビルダーはライブラリ内部に閉じているもので、公開されるAPIには含める必要はありません。

このカーネルビルダーは、必要に応じて各アダプタとファクトリを並列処理に適した代替実装に置き換えたり、前処理パスを挿入したりします。

```cpp
// 最適化カーネルビルダーの簡単な例
auto optimize_range(range auto&& rng) {
  if constexpr(has_base(rng)) {
    // このアダプタを最適化するロジックにディスパッチする
    return optimize_range(rng.base());
  } else {
    return rng;
  }
}
```

Rangeアダプタ/ファクトリを標準ライブラリ由来のものだけを考慮することにすると、この最適化カーネルビルダーは次の事を行います

- 入力の範囲がRangeアダプタなのか、Rangeファクトリなのかを判断する
- 入力の範囲がどのRangeアダプタ/ファクトリから来たのかを特定する
- 入力の範囲から、基底となる範囲を取得する
- 各アダプタを最適化するロジックにディスパッチする

Rangeアダプタの最適化が必要な場合として、例えば次の場合があります

1. 自明ではない要素の削除
2. 自明ではない要素のグループ化

**自明ではない要素の削除**

`filter`や`take_while`などのアダプタは、事前に自明に計算できない方法で範囲の要素を削除（フィルタ）します。

並列アルゴリズムの実装では、N個の実行エージェントがM個の要素を処理するように、入力をスレッド間で事前に分散することができます。この分散時に範囲内のどの要素が削除されるのかを計算することができないため、各実行エージェントはM個の初期要素を受け取ってから遅れて各自で条件を満たす要素を削除することになります。

これらの非自明な削除を行うアダプタを並行的に使用するためには、削除対象の要素をそれとマークされた特定の値（*tombstone* : 墓石）に置き換える必要があります。墓石要素は範囲から削除する必要がある事を示す`std::optional`とよく似た要素です。

並列アルゴリズムが範囲を消費する場合、この墓石を取り除く必要があります。このためのもっとも簡単な方法は`copy_if`前処理パスを挿入することです。ただしこの処理を適用した範囲がメモリ上で実体化するのを回避するために、インプレースで行う必要があります。このような処理パスはストリーム圧縮（*stream compaction*）と呼ばれます。

```cpp
// このような処理は
for_each(rng | filter(f), g);

// このように最適化する必要がある
void kernel(range auto&& rng0) {
  // フィルタ要素の墓石への置き換えと、ストリーム圧縮
  rng1 = compact(rng0 | filter_tombstone(f));
  for_each_collective(rng1);
}
```

ストリーム圧縮は多くの場合、`scan`によって実装されます

```cpp
auto copy_if(range auto&& in, output_iterator auto out, auto pred) {
  vector<uint8_t> flags(size(in));

  transform(par, in, begin(flags), pred);

  vector<size_t> indices(size(in));

  exclusive_scan(par, flags, begin(indices), 0);

  for_each(par, zip(in, flags, indices),
    apply([&in] (auto e, auto flag, auto index]) {
      if (flag) out[index] = e;
    }));

  return subrange(begin(out), next(out, indices.back()));
}
```

墓石要素を取り除く別の方法は、後続のアダプタ等をすべてラップして墓石要素を無視するようにすることです。全てを単純にラップできる場合、ストリーム圧縮パスを挿入する必要が無くなります。

```cpp
// このような処理は
for_each(rng | filter(f), g);

// このように最適化（ストリーム圧縮を使用しない）
for_each(rng | transform([f] (auto x) {
                  if (!f(x)) return tombstone(x); else return nullopt;
               }),
         [g] (auto x) { if (x) g(*x); });


// このような処理は
reduce(rng | filter(f), g);

// このように最適化（ストリーム圧縮を使用しない）
reduce(rng | transform([f] (auto x) {
               if (!f(x)) return tombstone(x); else return nullopt;
             }),
       [g] (auto l, auto r) {
         if (l && r) return g(l, r);
         else if (l) return l;
         else if (r) return r;
         else        return {};
       });
```

ただし、このようなラッピングを常に可能ではありません。`adjacent`や`enumrate`をはじめとする一部のアダプタは要素の位置を認識します。これは、隣接する要素のアクセスするなど範囲内の要素の位置を考慮することを意味しており、墓石要素の存在はその位置ロジックを混乱させます。これを回避するためには、そもそも回避しようとしている遅延フィルタリングが必要となってしまいます。

このようなラッピングによって遅延的に墓石要素を取り除こうとする場合、最適化カーネルビルダーが範囲を再構築する際に、墓石が必要な範囲を見つけたらそれとマークし、墓石要素を無視できない範囲を見つけたらストリーム圧縮パスを挿入し墓石スキップが不要であるとマークする必要があります。

```cpp
// 墓石要素の要必要が入り乱れる例
sort(rng | filter(f) | transform(g) | adjacent<2> | filter(h) | transform(i));
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   XXXXXXXXXXX   ^^^^^^^^^^^^^^^^^^^^^^^^
  //           Tombstoned             Untombstoned         Tombstoned

// ↑を正しく処理する例
void kernel(range auto&& rng0) {
  rng1 = compact(rng0 | filter_tombstone(f) | transform_tombstone(g));
  rng2 = compact(rng1 | adjacent<2> | filter_tombstone(h) | transform_tombstone(i));
  sort_collective(rng2);
}
```

ラッピングによる遅延的な墓石要素の除去は、最適化カーネルビルダーの複雑さを増大させる代わりに、処理コストの高いストリーム圧縮パスを回避できるためパフォーマンスで有利になります。

C++26（予定）の並列Rangeアルゴリズムに向けては、簡素化のために、現時点ではこのラッピングによる遅延的な墓石要素の除去を行わず、墓石要素が必要となる範囲を見つけた場合はストリーム圧縮パスを挿入するようにすることを提案しています。

**自明な要素のグループ化と削除**

`drop. stride`などのRangeアダプタは事前に自明に予測可能な方法で要素を削除し、`chunk, adjacent`等のアダプタは事前に自明に計算可能な方法で要素をグループ化もしくは結合します。そのため、これらのアダプタを並列実行する場合、エージェントに分割して作業の分配を行う際にそのグルーピングを考慮することができます。

```cpp
// この様な処理は
for_each(rng | drop(X), f);

// このように最適化
auto start = begin(rng)   X;
auto end = end(rng);
for_each(start, end, f);
```

しかしこれらの入力アダプタが非自明な要素の削除もしくは非自明な要素のグループ化（`chunk_by, split`）を行うアダプタの適用を含んでいる場合、そのアダプタも非自明な要素削除を伴うアダプタとなるため、ストリーム圧縮パスを挿入する必要があります。

これらの、自明な要素のグループ化と削除を行うアダプタを処理するには2つのアプローチがあります

1. 常にストリーム圧縮パスを挿入し、作業の分散中にそれらを処理しない
    - 実装が単純
2. 以前に非自明な要素削除/グループ化のパスを含んでいる場合にのみストリーム圧縮パスを挿入し、それ以外の場合は作業分散中に処理する
    - 実装が複雑化するが、より効率的

この提案では、1のアプローチを提案しています。

- [P3300R0 C+ Asynchronous Parallel Algorithms - WG21月次提案文書を眺める 2024年02月](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3300R0-C-Asynchronous-Parallel-Algorithms)
- [P3119 進行状況](https://github.com/cplusplus/papers/issues/1824)

### [P3160R1 An allocator-aware `inplace_vector`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3160r1.html)
### [P3161R0 Unified integer overflow arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3161r0.html)

↓

### [P3161R1 Unified integer overflow arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3161r1.html)

オーバーフローを処理可能な整数演算の提案。

一部のアプリケーションでは、標準でサポートされている（あるいは今後されるであろう）整数値の最大幅を大きく超える値を扱わなければならない場合があります。また、そのような拡張幅を必要としない場合でも、整数演算の結果が有効かどうか（オーバーフローしていないかどうか）を知ることが重要な場合があります。前者の場合は多倍長整数型を使用することになりますが、その実装においては同様に整数演算の桁上がりを検知する必要があります。

それに対処するアルゴリズムは非常に単純で、ほとんどのCPUはそれをハンドルする命令をサポートしているものの、標準C++の範囲内でそれらの機構を利用可能な抽象化は存在していません。C++だけで同等の機能を実装するのはかなり難しく、その結果非常に非効率なコードになってしまいます。

C++23では整数型の飽和演算ライブラリが追加されましたが、これらはオーバーフローに対処する別のアプローチであり、オーバーフローを検知したい場合には向きません。

また、オーバーフローを検知可能な操作を行う関数があり、それがCPU命令を用いて効率的に実装されているとします。CPUは命令の実行のためあるいは結果の退避やレジスタ値の復帰のために特定のレジスタにオペランドをmovのような命令によって読み込みますが、一部のCPU（x86-64）では入力と出力のレジスタが一致していることから連続して同じ命令を同じ結果に対して適用していくような場合（多倍長整数の実装でよく現れるパターン）にmov命令の数を削減することができます。独立した計算を並べ替えたり可換なオペランドを入れ替えたりするオプティマイザはさらにmov命令を抑制可能になります。

このような最適化は個別の関数を実装するだけのライブラリ側では不可能であり、よりコンパイラに近いところで作業した場合に可能となります。このことは、このような操作が標準化されていることが重要であることを示唆しています。

この提案は、オーバーフローを検知することのできる整数型に対する操作を行うライブラリ機能を提案するものです。

提案より、整数型の演算のグループの要約表

|操作|現在の標準|飽和演算|オーバーフロー安全|Wide arithmetic|
|---|:-:|:-:|:-:|:-:|
|足し算|`+`|`add_sat()`|N/A|`add_carry()`|
|引き算|`-`|`sub_sat()`|N/A|`sub_borrow()`|
|掛け算|`*`|`mul_sat()`|N/A|`mul_wide()`|
|割り算, 剰余|`/, %, div()`|`div_sat()`*|`is_div_defined`|`div_wide(), is_div_wide_defined`|
|キャスト|`static_cast`|`saturate_cast`|`would_cast_modify`|N/A|

ここで提案されているのは、Wide arithmeticの列の関数群および`would_cast_modify`です。

`add_carry()`はキャリーありの加算を行います。

```cpp
template<class T>
constexpr add_carry_result<T> add_carry(T v1, T v2, bool carry) noexcept;
```

`result = v1  v2   (carry ? 1 : 0);`のような計算を行い、`result`の`T`と同じ幅の部分のビットによる`T`の値とオーバーフローが起きたかどうかの`bool`値を返します。

`sub_borrow()`はキャリーあり減算を行います。

```cpp
template<class T>
constexpr sub_borrow_result<T> sub_borrow(T v1, T v2, bool borrow) noexcept;
```

`result = v1 - v2 - (borrow ? 1 : 0);`のような計算を行い、`result`の`T`と同じ幅の部分のビットによる`T`の値とオーバーフローが起きたかどうかの`bool`値を返します。

`mul_wide()`はオーバーフローなしの乗算を行います。

```cpp
template<class T>
constexpr mul_wide_result<T> mul_wide(T v1, T v2) noexcept;
```

`result = v1 * v2;`のような計算を精度の制限が無いかのように行い、`T`の幅を`N`として、`result`の下位`N`ビットと上位`N`ビットの値をまとめて返します。`N`ビットの値同士の乗算の結果は`2N`ビットを超えないので、オーバーフローすることなく乗算を行い結果を得ることができます。

`div_wide()`は商と剰余の計算を同時に行います。

```cpp
template<class T>
constexpr div_result<T> div_wide(T dividend_high, T dividend_low, T divisor) noexcept;
```

これは、次のような計算を精度の制限が無いかのように行います

```cpp
dividend = (dividend_high << sizeof(T)*8) | dividend_low;
result_quo = dividend / divisor;
result_rem = dividend % divisor;
```

結果として、`T`の幅に切り詰めた`result_quo`の値と`result_rem`の値を返します。

この関数では、`divisor == 0`もしくは商の値`result_quo`がオーバーフローしている場合は未定義動作となります。これは`is_div_wide_defined()`によって調べることができます。

```cpp
template<class T>
constexpr bool is_div_wide_defined(T dividend_high, T dividend_low, T divisor) noexcept;
```

引数は`div_wide()`と同じで、`div_wide()`の結果が未定義にならない場合に`true`を返します。

`would_cast_modify()`は、キャストによって値が変化するかを調べるものです。

```cpp
template<class T, class U>
constexpr bool would_cast_modify(U) noexcept;
```

型`U`の入力値が型`T`で表現可能かを調べ、できる場合に`true`を返します。

また提案にはしていないものの、`std::div_sat()`の削除と`std::div`のシグネチャ修正も解決すべき問題として挙げています。

- [P3161 進行状況](https://github.com/cplusplus/papers/issues/1825)

### [P3162R0 LEWG [[nodiscard]] policy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3162r0.html)

標準ライブラリの関数に対する`[[nodiscard]]`の付加についてのポリシーの提案。

基本的なモチベーションは前回の`[[nodiscard]]`関連の提案と共通しています

- [P2422R0 Remove nodiscard annotations from the standard library specification - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P2422R0-Remove-nodiscard-annotations-from-the-standard-library-specification)
- [P3122R0 [[nodiscard]] should be Recommended Practice - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P2422R0-Remove-nodiscard-annotations-from-the-standard-library-specification)

ただし、この提案では標準ライブラリの規定で`[[nodiscard]]`を付加するのをやめようとするのではなく、ポリシーに従ってある程度機械的に判断できるようにすることを目指しています。

この提案では次のようなポリシーを提案しています

1. 戻り値を無視するとリソースリークなどの重大な欠陥が避けられない関数には`[[nodiscard]]`を付加する
2. 関数名が誤解されやすいなど、戻り値を見落とすことがよくある間違いである関数には`[[nodiscard]]`を付加する
3. 関数の戻り値としてエラーを伝えるように設計された型には`[[nodiscard]]`を付加する

加えて、このポリシーを補強する3つの原則を提案しています

1. 複雑さを最小化する
    - C++の複雑さを最小限に抑えると、新規ユーザーにとって使いやすくなり、メンテナンス負荷が減少し、コードの寿命が延びる
    - この原則によって、`void`以外の戻り値型を持つ関数すべてに`[[nodiscard]]`を付加するのが禁止される
2. 90%の使用例に焦点を当てる
    - 全ての人の問題ではなくほとんどの人の問題に集中することで、一般的により良い結果が得られる
    - 最も一般的なバグの警告を生成するには`[[nodiscard]]`を数回付加するだけで済む
3. 結果に焦点を当てる
    - （委員会の）決定の現実の影響を考慮する。`[[nodiscard]]`ポリシーは次の2つの影響が考えられる
        1. 標準ライブラリ実装
            - 実装者は標準ライブラリの`[[nodiscard]]`ガイダンスに従う必要は無いため、ここでの影響は最小
            - listdc++/MSVC STLは独自の決定を下し、libc++は標準の規定に倣っている
        2. トレーニングコンテンツ
            -　C++の新規学習コンテンツ、本やcppreferenceをはじめとするwebサイトなどでは、標準ライブラリの関数シグネチャが頻繁に再掲している
            - これらのシグネチャは結果としてコーディングスタイルに大きな影響を与えている

ここでのポリシーと原則に従った`[[nodiscard]]`の付加例

```cpp
// 'empty'はよく新規学習者に'clear'と間違われる
[[nodiscard]]
bool map<T>::empty() const noexcept;

// Discarding the return value of 'new' is always a memory leak.
[[nodiscard]]
void* operator new(size_t);

// ==の戻り値を捨てるのは頻繁に発生するバグではなく
// [[nodiscard]]を正当化するほど壊滅的でもない
template<class T, size_t N>
constexpr bool operator==(const array<T, N>& x, const array<T, N>& y);

// `expected`戻り値の破棄はエラーの隠蔽につながる
// クラスに対する[[nodiscard]]は少しの構文オーバーヘッドで済む
template<class T, class E>
class [[nodiscard]] expected { ... };
```

- [P3162 進行状況](https://github.com/cplusplus/papers/issues/1826)

### [P3164R0 Improving diagnostics for sender expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3164r0.html)

提案中のExecutorライブラリにおいて、`sender`チェーンのエラーを早期に報告するようにする提案。

P2300にて`sender/receiver`ベースのExecutorライブラリの提案が進行中です。`sender`はなにかの処理を表現する型のことを指しており、`sender`同士は`|`でチェーンすることで非同期処理グラフを構成することことができ、その結果もまた何らかの`sender`型となります。

処理グラフを構成している`sender`の型チェックのためには通常、その完了シグネチャ（成功・失敗・完了の3つのチャネルが何を返すかなどの情報）を計算する必要があり、一般に完了シグネチャを計算するためには`receiver`のもつ実行環境（*execution environment*）の情報が必要であるため、`sender`が`receiver`に接続されるまでは`sender`の表現している処理グラフの型チェックを行うことができません。

例えば、`read(get_stop_token)`のような`sender`（`stop_token`を取得して次に渡す`sender`）は、`rcvr`というなにか`receiver`を接続し処理が開始されると、その内部で`rcvr`の環境から次のように`stop_token`を取得してそれを返そうとします

```cpp
auto st = get_stop_token(get_env(rcvr));  // stop_token取得
set_value(move(rcvr), move(st));          // このsenderの処理の結果としてそれを返す
```

`receiver`が与えられてその実行環境が存在している場合にのみ、この`sender`（`read(get_stop_token)`）はその完了方法を知ることができます。

`receiver`の実行環境の型は接続されて初めて分かり、これはその`sender`が構成された場所から遠く離れている場合があります。その`sender`がエラーとなりうる構成をされている場合、そのエラーはその`sender`が構成された場所から離れたところで起こることになります。

ところが、用意されている`sender`のほとんどは`receiver`の実行環境に依存せずにその処理を完了することができます。例えば次のような`sender`による処理があるとき

```cpp
just(42) | then([](int* p) { return *p; });
```

この`just(42)`は結果として`42`という整数値を生成しますが、その結果は他の何かに依存せずに決まります。そして、後続の`then`ではそこに指定されたラムダの引数型が前段の`just(42)`の結果を受けることができないことがすぐに（`receiver`の接続を待たずして）分かります。

このような依存なしの`sender`（non-dependent `sender`）の場合、その後続の`sender`においてはその結果と自身の入力の期待が一致するかをすぐにチェックすることができます。

P2300でもそのような依存なしの`sender`は区別されていますが、現在その特性を使用してはいません。

この提案は、依存なしの`sender`が接続された場合の型チェックを早期に（`receiver`接続前に）行うようにする提案です。ここで提案されているのは次のことです

- 依存なしの`sender`を実行環境無くても完了を知ることのできる`sender`として定義
- `awaitable`ヘルパコンセプトの定義を変更して、任意のコルーチンで（`promise`型を知らなくても）`awaitable`かどうかのを問い合わせられるようにする
    - 例えば、awaiterインターフェース(`await_ready`, `await_suspend`, `await_resume`)を定義していればどのコルーチンでも`awaitable`であり、依存なしの`sender`として機能するはず
- 環境引数なしで`get_completion_signatures()`を呼び出せるようにする
- `completion_signatures_of_t`エイリアステンプレートの定義を修正し、`sender`の非依存シグネチャを問い合わせられるようにする（存在する場合にのみ）
- `sender`アダプタアルゴリズムに対して、可能な限り依存なし`sender`の性質を維持するように要求する
- `sender`アダプタアルゴリズムの"Mandates"にて、依存なし`sender`が渡されて型チェックに失敗した場合にハードエラーを起こすように規定する

これによって、多くの`sender`に対して早期の型チェックが可能となり、P2300の提案するライブラリ機能のユーザーエクスペリエンスが向上します。

- [P3164 進行状況](https://github.com/cplusplus/papers/issues/1827)

### [P3165R0 Contracts on virtual functions for the Contracts MVP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3165r0.html)

契約プログラミング機能において、仮想関数に対する契約の指定をサポートする提案。

背景などは少し上のP3097R0の項を参照。この提案では、仮想関数はC++の主要なテクニックかつスタイルであり、仮想関数に対する契約注釈という重要な機能を最初のMVPの後に延期すべきではなく、最初のMVPに対してそのサポートを有効化することを提案しています。

提案している仮想関数に対する契約注釈のセマンティクスはP3097R0と同じものです。すなわち、仮想関数のオーバーライドにおいてはオーバライドした関数は基底の関数の契約を継承せず、仮想関数がポインタや参照を通して呼び出された場合は呼び出している参照の型（静的型）と実際に呼び出される型（動的型）の2つの型におけるその関数の契約条件だけがチェックされます。その順番は次のようになります

1. 派生元関数の事前条件が評価される
2. 派生先関数の事前条件が評価される
3. 派生先関数の本体が実行される
4. 派生先関数の事後条件が評価される
5. 派生元関数の事後条件が評価される

静的型と動的型が一致している場合はその直接の型の関数の契約のみがチェックされ、その型が仮に派生型だったとしても基底クラスの関数になされた契約条件はチェックされません。

提案文書より、ネストしているサンプルコード

```cpp
struct Vehicle {
  void drive(int speed) pre(speed_within_limit(speed)); // #1
};

struct WheeledVehicle : Vehicle {
  bool tiresSufficientlyInflated = false;
  void drive(int speed) pre(tiresSufficientlyInflated) override; // #2
};

struct MotorVehicle : WheeledVehicle {
  bool engineRunning = false;
  void drive(int speed) pre(engineRunning) override; // #3
};

void use1(Vehicle* veh) {
  veh->drive(80); // #4
}

void use2(WheeledVehicle* veh) {
  veh->drive(80); // #5
}

void use3() {
  MotorVehicle mv;

  use1(&mv);
  
  mv.drive(400); // #6

  use2(&mv);
}
```

この`use3()`の呼び出しに際して、まず`use1()`の中の`#4`では`#1`と`#3`の契約がチェックされます。次に`#6`の地点ではその動的型の契約`#3`だけがチェックされます。そして、`use2()`の呼び出しに伴う`#5`では、`#2`と`#3`の契約がチェックされます。

派生関数は基底関数の契約を継承せず独自の契約を持つことができる、というセマンティクスの根拠として、この提案でもステートフルな派生クラスを挙げています。派生クラスが独自の状態を持つ場合、構築直後は基底クラスの代替として使用できる準備ができていないということはよくあることであり、派生クラスにおける契約はその準備が整ったことを確認する事の出来るポイントとなります。

この提案では次のような設計原則を掲げています

- このアプローチはABIを破損しない
- 標準的な代替可能設計は比較的簡単に表現可能である必要があるが、強制する理由はない
- オーバライドする関数が基底の関数よりも狭い契約を持つなど、標準的ではない設計を許容する必要がある
- このアプローチでは、契約階層内での契約の包含の証明を要求しない
- このアプローチでは、呼び出し側での契約チェックを行う実装を可能な限り許可するように努める必要があるが、それ以上ではない

ここで提案されているアプローチは、これらを満たしながらルールはかなりシンプルなものになっています。

- [P3165 進行状況](https://github.com/cplusplus/papers/issues/1828)

### [P3166R0 Static Exception Specifications](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3166r0.html)
### [P3167R0 Attributes for the result name in a postcondition assertion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3167r0.html)

事後条件構文内の戻り値名に対して属性を指定できるようにする提案。

P3088R1がContaracts MVP仕様にマージされたことで、契約注釈そのものに対して属性指定を行うことができるようになりました。

```cpp
int f(int i, int j)
  pre [[foo]] (i > 0 && j > 0)
  post [[bar]] (r: r > 0)
{
  [[likely]] contract_assert [[baz]] (i   j < 10);
  return i  j;
}
```

ただし、そこでは事後条件の中の戻り値名（`post [[bar]] (r: r > 0)`の`r`）に対する属性指定は提案されておらず、これは可能になっていません。

既存のC++のエンティティ名に対しては、ごく一部の例外を除いて属性指定ができるようにされています（そのごく一部の例外も例外となっているのは意図的ではないようです）。そのため、この提案はその慣例通りに、事後条件における戻り値名に対しても属性指定を可能にする提案です。

この提案では次の2点の変更を提案しています

- 事後条件構文（`post(r : expr)`）の戻り値名`r`の後に*attribute-specifier-seq*を配置して、その属性はその直前にある戻り値名に作用することを規定
- `[[maybe_unused]]`属性が事後条件内の戻り値名に対しても作用するように規定

```cpp
int g()
  post (r [[maybe_unused]]: r > 0);
```

この提案はSG21にて採択され、すでにContracts MVP（P2900R6）に対してマージされています。

- [P3088R1 Attributes for contract assertions - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3088R1-Attributes-for-contract-assertions)
- [P3167 進行状況](https://github.com/cplusplus/papers/issues/1830)

### [P3168R0 Give `std::optional` Range Support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3168r0.html)

↓

### [P3168R1 Give `std::optional` Range Support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3168r1.html)

`std::optional`を`range`にする提案。

この提案は、P1255で提案中の`views::maybe/views::nullable`の代替案として、そもそも`std::optional`を`range`として扱えるようにしてしまおうとする提案です。

P1255については以前の記事を参照

- [P1255R6 : A view of 0 or 1 elements: `views::maybe` - WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2020/05/01/194425#P1255R6--A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R9 A view of 0 or 1 elements: `views::maybe` - WG21月次提案文書を眺める（2022年08月）](https://onihusube.hatenablog.com/entry/2020/05/01/194425#P1255R6--A-view-of-0-or-1-elements-viewsmaybe)

`maube_view`と`std::optional`の本質的な違いは`range`であるかどうかの一点のみで、その他の点でほぼ同じセマンティクスを持ち、互換性のあるインターフェースを備えています。一方で、インターフェースには相違点がありものによっては意図的でなかったりどこまで`std::optional`に合わせるべきかが不明瞭なものもあります。

結局、この2つのよく似た型が標準に存在しているとC++標準ライブラリのシンプルさと一貫性を損ね、どちらを使用するべきかについてユーザーに混乱が生じ教育コストも上昇します。

そのため、この提案では`std::optional`を直接`range`にしてしまうことで、1つの型でP1255のモチベーションを満たそうとしています。

この提案では、`std::optional`を`range`かつ`view`であり、また`contiguous`かつ`sized`となる範囲とすることを提案しています。

```cpp
namespace std {
  // optional本体
  template<class T>
    class optional;
  
  // viewへの対応
  template<class T>
    constexpr bool ranges::enable_view<optional<T>> = true;   

  // rangeとしてのformatを無効化
  template<class T>
    constexpr auto format_kind<optional<T>> = range_format::disabled;
}
```

そして、`optional`に対してイテレータインターフェースを追加します

```cpp
template<class T>
class optional {
public:
  ...
  
  // イテレータ型は独自のもの（ポインタではない）
  using iterator       = implementation-defined; // see [optional.iterators]
  using const_iterator = implementation-defined;

  ...
    
  // [optional.iterators], iterator support
  constexpr iterator begin() noexcept;
  constexpr const_iterator begin() const noexcept;

  constexpr iterator end() noexcept;
  constexpr const_iterator end() const noexcept;   

  ...
};
```

`optional`のイテレータ型はポインタ型を使用しないことを提案しています。これは、`optional`からポインタを取得できる経路が存在してしまうことで、それが誤用されたりすることを防止するためです

```cpp
void takes_pointer(T const*);
    
void f(optional<T> const& o) {
  // これはどういう意味？
  T const* p = o.begin();  
  
  // これを動作させたい？
  takes_pointer(o.begin());
  
  // もしくはこれも？
  if (o.begin()) { /* ... */ }
}
```

提案文書より、サンプルコード

```cpp
// A person's attributes (e.g., eye color). All attributes are optional.
class Person {                        
    /* ... */                               
public:                               
    optional<string> eye_color() const;   
};                                    
    
vector<Person> people = ...;
```


<table>
<tr>
<th>P1255R12</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
// Compute eye colors of 'people'.
vector<string> eye_colors = people
  | views::transform(&Person::eye_color)
  | views::transform(views::nullable)
  | views::join
  | ranges::to<set>()
  | ranges::to<vector>();
```

</td>
<td valign="top">

```cpp
// Compute eye colors of 'people'.
vector<string> eye_colors = people
  | views::transform(&Person::eye_color)
  // ラップが必要ない
  | views::join
  | ranges::to<set>()
  | ranges::to<vector>();
```

</td>
</tr>

<tr>
<td valign="top">

```cpp
for (auto&& opt : views::nullable(get_optional())) {
  ...

  use(opt); // optの利用は安全
}
```

</td>
<td valign="top">

```cpp
for (auto&& opt : get_optional()) {
  ...

  use(opt); // optの利用は安全
}
```

</td>
</tr>

<tr>
<td valign="top">

```cpp
auto opt_int = get_optional();
for (auto&& i : views::nullable(std::ref(opt_int))) {
  ...

  i = 123;
}
```

</td>
<td valign="top">

```cpp
auto opt_int = get_optional();
for (auto&& i : opt_int) {
  ...

  i = 123;
}
```

</td>
</tr>

</table>

この提案の方向性はLEWGのレビューにおいて弱いながらもコンセンサスを得ています。ただし、よりコンセンサスを高めるために実装と開発の経験が必要とされています。

- [P3168 進行状況](https://github.com/cplusplus/papers/issues/1831)

### [P3169R0 Inherited contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3169r0.pdf)

契約プログラミング機能において、仮想関数に対する契約の指定をサポートする提案。

この提案は、上の方のP3097R0やP3165R0と同様に、現在MVP仕様で無効化されている仮想関数に対する契約指定とチェックを有効化しようとするものです。動機については、下の方のP3173R0も参照されるといいかもしれません。

ここで提案している仮想関数の契約チェックの方法はP3097R0やP3165R0とは少し異なっています。この提案では仮想関数呼び出し時に次のような手順で契約をチェックします

1. 呼び出し側は、呼び出された関数の静的型についての事前条件をチェックする
2. 動的型の関数本体を実行する
3. 呼び出し先は、オーバーライドされたすべての関数の事後条件をチェックする

すなわちこの提案では、事前条件は基底クラスの関数及びそれをオーバーライドする全ての関数の事前条件の論理和となり、事後条件は呼び出されている全てのオーバーライド及び既定の関数の事後条件の論理積となります。これは、Assertion Redeclaration rule（事前条件は同じかより弱く、事後条件は同じかより強くなければならない）に沿うものです。

またこの提案では、オプティマイザが契約を見て、特に事後条件について同等かより狭くなっていることが分かる場合は1つの契約チェックのみを行い不要なチェックを省略できるようにすることも提案しています。

提案より、基底クラスの場合の例

```cpp
struct C1 {
  virtual R1 f1(A1)
    pre(c1())
    post(c2())
  {
    contract_assert(c1());  // 常に満たされる
    return ...;             // c2()が満たされていなければならない
    // 事後条件c2()のチェック
  }
};

auto g1(C1& c,A1& a) {
  // 事前条件c1()のチェック
  auto r = c.f1(a);
  contract_assert(c2); // 常に満たされる
}
```
単一継承の例

```cpp
struct C2 : C1 {
  R1 f1(A1) override
    pre (c3())
    post (c4())
  {
    contract_assert(c3() || c1);  // 常に満たされる
    return ...;                   // (c4() && c2())が満たされていなければならない
    // 事後条件(c4() && c2())のチェック
  }
};

auto g1(C2& c,A1& a) {
  // 事前条件c3()のチェック
  auto r = c.f1(a);
  contract_assert(c4()); // 常に満たされる
  return r;
}
```

多重継承の例

```cpp
struct C3 {
  virtual R1 f1(A1)
    pre (c5())
    post (c6());
};

struct C4 : C2, C3 {
  virtual R1 f1(A1)
    pre (c7())
    post (c8());
  {
    contract_assert(c7() || c3() || c1() || c5()); // 常に満たされる
    return ...; // (c8() && c4() && c2() && c6())が満たされていなければならない
    // 事後条件(c8() && c4() && c2() && c6())のチェック
  }
};

auto g1(C4& c,A1& a) {
  // 事前条件c7()のチェック
  auto r = c.f1(a);
  contract_assert(c8()); // 常に満たされる
  return r;
}
```

この提案では、より強い事前条件とより弱い事後条件を行いたい場合、`contract_assert()`によって関数内で記述すればよく、`pre()/post()`で行う必要は無いとしています。

提案によれば、この実装は難しくなくABIに影響を与えることもないとのことです。

- [P3169 進行状況](https://github.com/cplusplus/papers/issues/1832)

### [P3170R0 sinkable exception error message](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3170r0.html)

標準の例外クラスに対して、動的確保無しでエラーメッセージを設定可能にする提案。

`std::logic_error`と`std::runtime_error`をはじめとする標準の例外クラスは、構築時にエラーメッセージを指定することができます。しかし、このコンストラクタに`std::string`を渡す場合、それはコピーされて保持される可能性があります。

```cpp
std::string temp = to_string(pos, location);
// std::stringはコピーされる可能性がある
throw std::out_of_range(temp);
```

これは、これらの型のコンストラクタが`explicit T(const string& what_arg);`の様に宣言されているためです。

この提案は、右辺値の`std::string`を受け取るコンストラクタを追加することで、例外オブジェクト構築時の余計な`std::string`のコピー及び動的メモリ確保の発生を削減しようとするものです。

この提案では各例外クラスのコンストラクタに`T(string&& what_arg);`の様なコンストラクタを追加することで、エラーメッセージを指定する`std::string`をムーブできるようにするものです。

```cpp
std::string temp = to_string(pos, location);
throw std::out_of_range(std::move(temp));

// もしくは
throw std::out_of_range(to_string(pos, location));
```

これによって、例外を投げる処理がそれに伴って発生しうる動的メモリ確保をその制御下に置くことができるようになります。

この提案は、以前のP3056R0で提案されていたものの一部を分離したものです。

- [P3056R0 what ostream exception - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P3056R0-what-ostream-exception)
- [`<stdexcept>` - cpprefjp](https://cpprefjp.github.io/reference/stdexcept.html)
- [P3170 進行状況](https://github.com/cplusplus/papers/issues/1833)

### [P3171R0 Adding functionality to placeholder types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3171r0.html)

`std::bind`用のプレースホルダを活用した短縮ラムダ機能の提案。

標準ライブラリにはいくつかの演算子をラップした関数オブジェクト（`std::plus<>`など）があり、これらの関数オブジェクトはアルゴリズムのようなライブラリ機能に対して渡してその動作をカスタマイズするのに便利です。

ただし、標準ライブラリにある組み込み演算子に対応する関数オブジェクトは四則演算と比較及び論理演算くらいしか用意されておらず、添字演算子やシフト演算子など欠けているものが多くあります。

また、それらの関数オブジェクトはラムダ式を手書きするのと比較すると記述量を削減できるメリットがありますが、反面行うことが関数オブジェクト内部に隠蔽され対応する名前に置き換えられてしまうため、必ずしも可読性向上に繋がらず、直感的なものでもありません。

Boost.Lambda2というライブラリは、`std::bind`で使用されているプレースホルダに対して各種演算子のオーバーロードを提供しそれによって即席の関数オブジェクトを作成することで、やりたいことを直感的に記述しながらも記述量を削減するということを達成しています。

`views::zip`のイテレータの`operator*`および`operator++`の実装における各記述方法の比較

```cpp
// 手書きのラムダ式
auto operator*() const {
  return tuple_transform(current_,
    [](auto& it) -> decltype(auto) {
      return *it;
    });
}

auto operator++() -> iterator& {
  tuple_for_each(current_,
    [](auto& it) { ++it; });
  return *this;
}
```
```cpp
// 名前付き関数オブジェクト
auto operator*() const {
  return tuple_transform(current_,
    dereference{});
}

auto operator++() -> iterator& {
  tuple_for_each(current_,
    prefix_increment{});
  return *this;
}
```
```cpp
// Boost.Lambda2
auto operator*() const {
  return tuple_transform(current_, *_1);
}

auto operator++() -> iterator& {
  tuple_for_each(current_, ++_1);
  return *this;
}
```

Boost.Lambda2による記述は圧倒的に簡潔であり、行う作業を直接的に表現することができています。

Boost.Lambda2による記法は、対応する演算子の関数オブジェクトが既に存在する場合でも、一般的な述語を記述するために威力を発揮します。例えば、負の数を判定する述語を記述してみると

```cpp
// 手書きラムダ式 (28文字)
[](auto e) { return e < 0; }

// std::lessの使用 (19文字)
bind(less{}, _1, 0)

// Boost.Lambda2 (6文字)
_1 < 0
```

この提案は、Boost.Lambda2の機能を標準化することと、欠けている関数オブジェクトを追加することの2つを提案するものです。

とはいえ、標準ライブラリにはすでにプレースホルダと`std::bind`が存在しているので、追加で必要なのはプレースホルダに対して作用する演算子オーバーロードのみです。

追加する関数オブジェクトは次のものです

```cpp
namespace std {
  ...

  // [additional.operations], additional transparent operations
  struct subscript;                                                                 // freestanding
  struct left_shift;                                                                // freestanding
  struct right_shift;                                                               // freestanding
  struct unary_plus;                                                                // freestanding
  struct dereference;                                                               // freestanding
  struct increment;                                                                 // freestanding
  struct decrement;                                                                 // freestanding
  struct postfix_increment;                                                         // freestanding
  struct postfix_decrement;                                                         // freestanding

  // [compound.operations], compound assignment operations
  struct plus_equal;                                                                // freestanding
  struct minus_equal;                                                               // freestanding
  struct multiplies_equal;                                                          // freestanding
  struct divides_equal;                                                             // freestanding
  struct modulus_equal;                                                             // freestanding
  struct bit_and_equal;                                                             // freestanding
  struct bit_or_equal;                                                              // freestanding
  struct bit_xor_equal;                                                             // freestanding
  struct left_shift_equal;                                                          // freestanding
  struct right_shift_equal;                                                         // freestanding

  ...
}
```

どちらも、アドレス取得演算子（`&`）に対応するものは見送られています。

- [`std::placeholders` - cpprefjp](https://cpprefjp.github.io/reference/functional/placeholders.html)
- [Lambda2: A C++14 Lambda Library - master](https://www.boost.org/doc/libs/master/libs/lambda2/doc/html/lambda2.html)
- [P3171 進行状況](https://github.com/cplusplus/papers/issues/1834)

### [P3172R0 Using `this` in constructor preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3172r0.html)

コンストラクタにおける事前条件にて、`this`を使用した場合の動作を規定する提案。

現在のContarcts MVP仕様ではコンストラクタに事前条件を指定することができ、これは主にコンストラクタ引数についての事前条件を指定するものです。

```cpp
class X {
  std::string name;

public:

  explicit X(const char * n)
    pre(name != nullptr)  // まずこっちが評価され
    : name{n}             // 次にこっちが評価される
    {}
};
```

また、メンバ関数における契約条件として同じクラスのメンバ関数を使用することができます。

```cpp
T& container<T>::front()
  pre(!empty());
```

ただし、この2つの事を組み合わせてコンストラクタの事前条件でメンバ関数を呼び出してもそれは機能しません。デストラクタの事後条件でメンバ関数を呼び出すことも同様です。なぜなら、コンストラクタの呼び出し前はまだそのクラスのオブジェクトは初期化されておらず、デストラクタの実行後にはそのクラスのオブジェクトは既に破棄されているからです。

現在のMVP仕様ではこれについての規定がなく、暗黙的に未定義動作となります。

この提案は、コンストラクタの事前条件での`this`の使用とデストラクタの事後条件での`this`の使用の2つの場合について、どのような動作となるかを明確にしようとするものです。

この提案では次の2つの選択肢を挙げています

1. 明示的に未定義動作とする
    - 現在のコンストラクタにおける純粋仮想関数呼び出しと、コンストラクタの関数`try`ブロックにおける`this`の使用時と同じ挙動とする
    - ユーザーはそのような危険なコードを書かないものとして信頼する
2. ill-formedとする 
    - コンストラクタの事前条件とデストラクタの事後条件で暗黙的にでも`this`を使用している場合にコンパイルエラーにする
    - 一部の有用なアサーションが禁止されるかもしれない
    - Contractsの設計の精神に則った選択であるように思われる 
    - GCC13のContracts実験実装では、この動作を取っている

この提案では、このどちらを選択するかはSG21に委ねています。

- [P3172 進行状況](https://github.com/cplusplus/papers/issues/1835)

### [P3173R0 P2900R6 may be minimimal, but it is not viable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3173r0.pdf)

Microsoftによる、現在のContracts MVPのC++26への導入について反対する意見書。

次の3点について、懸念が解消されない限りP2900R6のContracts MVPをC++26に導入するのに反対する、としています

1. 契約条件で未定義動作が起こることを許容していること
    - P2680R1のような仕組みを導入し、ContractsをUBフリーにする
2. 仮想関数と関数ポインタ経由などの間接呼び出しにおける契約チェックが欠けている
    - 仮想関数呼び出しも関数ポインタなどを経由した間接呼び出しもC++における実装の定番であり、これをサポートしない機能はC++26に適しているとは言えない
3. C++26の段階で標準ライブラリに対して適用される予定が無い事
    - 標準ライブラリのような基本的なコンポーネントで使用しないことは機能が使用可能ではないことを示している
    - 標準ライブラリに対して適用することで、機能の実装・使用経験が得られる

P2900R6で確立されているContracts MVPの設計やその原則などに反対するものではありません（1を除いて）が、これらの懸念を解消しなければMicrosoftとしてはC++26への導入に反対する意向のようです。

この提案を受けて、P2680の方向性をSG23で再検討することにしたようです。

- [P2680R0 Contracts for C++: Prioritizing Safety - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2680R0-Contracts-for-C-Prioritizing-Safety)
- [P3173 進行状況](https://github.com/cplusplus/papers/issues/1836)

### [P3174R0 SG16: Unicode meeting summaries 2023-10-11 through 2024-02-21](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3174r0.html)

2023年10月から2024年2月に行われたSG16のミーティングの議事録。

全部で7回のミーティングが開催されており、どの提案をレビューしてだれがどういう発言をしたのかが詳しく記されています。

### [P3175R0 Reconsidering the `std::execution::on` algorithm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3175r0.html)

P2300の`std::execution::on`アルゴリズムの命名について再考する提案。

`sender`と`sender`アルゴリズムをあまり知らない人が次のコードを見て

```cpp
namespace ex = std::execution;

ex::sender auto work1 = ex::just()
                      | ex::transfer(scheduler_A);

ex::sender auto work2 = ex::on(scheduler_B, std::move(work1))
                      | ex::then([] { std::puts("hello world!"); });

ex::sender auto work3 = ex::on(scheduler_C, std::move(work2))

std::this_thread::sync_wait(std::move(work3));
```

最終的に`std::puts("hello world!")`はどこの`scheduler`で（`scheduler_A, scheduler_B, scheduler_C`のどれか）実行されるか？と問われたとします。次のような合理的な推論によって、`scheduler_C`だと答えるかもしれません

1. 明らかに最初に実行するのは`on(scheduler_C, work2)`
2. とすると、`work2`が`scheduler_C`で実行されるのは確実
3. `puts("hello world!")`は`work2`の一部なので、当然`scheduler_C`で実行される

しかし実際には、`scheduler_A`で`puts("hello world!")`が実行されます。

`work2`は`scheduler_B`で`work1`を実行し、`work1`はすぐに`ex::on()`によって`scheduler_A`に遷移して以降戻りません。そのため、`work1`の継続処理は`scheduler_A`で実行されることになり、`puts("hello world!")`も`scheduler_A`で実行されます。

`work3`に追加の作業が接続されている場合、それも`scheduler_A`で実行されます。

P2300の作者の1人は実際にこの混乱に遭遇し、何人かのプログラマの友人に聞いたところ全員が実際の動作とは異なる動作を期待することが分かりました。

この問題は一部のアルゴリズムの名前が悪さをしていると考えられるため、名前を変更すればその動作に誤った期待をしづらくなります

```cpp
namespace ex = std::execution;

ex::sender auto work1 = ex::just()
                      | ex::continue_on(scheduler_A);

ex::sender auto work2 = ex::start_on(scheduler_B, std::move(work1))
                      | ex::then([] { std::puts("hello world!"); });

ex::sender auto work3 = ex::start_on(scheduler_C, std::move(work2))

std::this_thread::sync_wait(std::move(work3));
```

`continue_on`と`start_on`という名前はどちらもその実際の動作と一致する一方向の実行コンテキスト遷移を表しています。

この提案はまず、これをメインに提案するものです。

元々の`std::execution::on`という名前は、人々に対してそこへ行ってからまた戻ってくるものだと思わせてしまい、それを修正するために`start_on`に変更しようとしていますが、一方でそこへ行ってから戻ってくるアルゴリズムの需要もありそうです。

非同期作業においては、開始時と同じ実行コンテキストで完了するとより適切にカプセル化されます。例えば、OSのスレッドプールからタスクを`co_await`して、作業完了後に再開したスレッドがOSのタイマースレッドだった場合、利用者はかなり驚くことになるでしょう。当然ながら暗黙的にそのようなことを行うのはひどい設計です。

`std::execution::on`という名前は行って戻るという処理の印象を抱かせるものでしたが実際にはそういう動作をしておらず、この提案でその名前が変更されたことによってそのための名前が解放されることになります。

そこでこの提案では、実行元のコンテキスト（`scheduler`）を記憶し指定された処理を指定されたコンテキストで実行した後で元のコンテキストに自動的に戻ってくる`std::execution::on`という新しいアルゴリズムを追加することを提案しています。

これは次のように既存の`sender`アルゴリズムによって構成できます

```cpp
template <ex::scheduler Sched, ex::sender Sndr>
sender auto on(Sched sched, Sndr sndr) {
  return ex::read(ex::get_scheduler)
       | ex::let_value([=](auto old_sched) {
           return ex::start_on(sched, sndr)
                | ex::continue_on(old_sched);
         });
}
```

`on`をそこへ行ってまた戻るアルゴリズムとして定義すると、別のタイプのそこへ行ってまた戻るアルゴリズムを考えることができます。例えば次のコードについて考えてみます

```cpp
ex::sender auto work = async_read_file()
                     | ex::on(cpu_pool, ex::then(crunch_numbers))
                     | ex::let_value([](auto numbers) {
                         return async_write_file(numbers);
                       });
```

`async_read_file()`と`async_write_file(numbers)`はともに`sender`を返す関数です。

このコードでは、まず非同期にファイルを読み込みそれを`on`-`sender`に転送します。ここ（2行目）の`on`は前の作業の`sender`と`scheduler`、そして継続を受け取る別の`on`オーバーロードです。

`sender`（`async_read_file()`）の結果を受け取って指定された`scheduler`（`cpu_pool`）に遷移し、受けた結果を継続に転送して`ex::then(crunch_numbers)`を実行します。その後元の実行コンテキストに戻り、`async_write_file(numbers)`-`sender`を実行します。

これを1つ前で提案した`on`で書くと次のようになります

```cpp
ex::sender auto work = async_read_file()
                     | ex::let_value([=](auto numbers) {
                         ex::sender auto work = ex::just(numbers)
                                              | ex::then(crunch_numbers);
                         return ex::on(cpu_pool, work)
                              | ex::let_value([=](auto numbers) {
                                  return async_write_file(numbers);
                                });
                       });
```

元の`on`は2引数であり、前の作業の`sender`を受け取ることができず、基本的に処理グラフ（パイプライン）の先頭で使用するものです。こちらのおーバロードの`on`は3引数で、1つ目の引数として前の作業の`sender`を受け取ることができ、それによってパイプラインの途中で別の実行コンテキストへ移って少し作業して、完了したら戻ってくるという処理を簡単に書けるようになります。

この提案ではこちらの形式の`on`を追加することも提案しています。

この提案では追加でいくつかの関連する変更も提案しています。ただし最初の2つ以外はオプショナルとしており、まとめると次の事を提案しています。

- 提案
  - `std::execution::on`を`std::execution::start_on`に変更
  - `std::execution::transfer`を`std::execution::continue_on`に変更
- オプションの提案
  - 指定された処理を指定されたコンテキストで実行した後で元のコンテキストに自動的に戻ってくる`std::execution::on`アルゴリズムを追加
  - `receiver`の実行環境に値を書き込むことのできる`write_env`を追加し、`read`を`read_env`に変更
    - 新しい`on`の実装に使用する
  - `write_env`の簡単な応用であるカスタマイズ不可な`unstoppable`アダプタを追加
    - 現在の`receiver`環境の`stop_token`を`never_stop_token`に変更するもの
    - これは`schedule_from`アルゴリズムの再指定（次の項目）に使用する
  - `schedule_from`を一般化して、`sender`と`scheduler`の代わりに2つの`sender`を受け取るようにして、`finally`という名前に変更し、カスタマイズ不可にする
    - `schedule_from(sch, snd)`のデフォルト実装を`finally(snd, unstoppable(schedule(sch)))`として指定
  - パイプラインの途中に挿入することのできる`on`オーバーロードを追加

これらのことは[`stdexec`](https://github.com/NVIDIA/stdexec)で1年前から実装されているようです（ただし、巧妙に名前空間が分けられているようです）。

- [P3175 進行状況](https://github.com/cplusplus/papers/issues/1838)

### [P3176R0 The Oxford variadic comma](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3176r0.html)

前にカンマが無い省略仮引数引数（`...`）の使用を非推奨にする提案。

この提案が対象にしているのは関数引数の宣言における`f(int...)`のような`...`の使用です。これは現在`f(int, ...)`と等価な宣言として扱われています。

```cpp
// OK, 関数テンプレートパラメータパック
template<class... Ts> void a(Ts...);

// OK, 略記関数テンプレートパラメータパック
void b(auto...);

// OK, 省略パラメータ, Cとの互換性あり
void c(int, ...); 
void d(...); 

// Deprecated, 省略パラメータ, Cではill-formed
void e(int...);   // 👈
void f(int x...); // 👈

// Ill-formed, but unambiguous
void g(int... args);
```

この`f(int...)`のような`...`の使用はCでは許可されておらずC++で導入されてしまったものです。そのため、これは可変長引数関数の宣言として解釈されるべきではなく、多くのユーザーもパラメータパックの一種だと認識するでしょう。

このような宣言（`(int...)`）が間違って使用されてしまっていることは将来の機能に対して悪影響を与えます。すでにP1219R2に影響を与えている他、将来的に出てくる提案にも影響を与えるでしょう。

また、可変長テンプレートに慣れていないユーザーは`class`の後に`...`を置くのを忘れがちです。さらに、`auto`による略記を行うとさらに間違いが分かりづらくなります

```cpp
// 略記可変長関数テンプレート
void g(auto ...args);

// 略記関数テンプレート（可変長ではない）
void g(auto args...); // おそらく書き間違い
```

可変長テンプレートのパラメータパックの宣言と展開の記述はややこしく、このような書き間違いはよく起こってしまうため、これが何かしら診断されることが望ましいです。

さらには、C++では`f(auto......)`や`f(T......)`のような宣言さえ許可されています（それぞれ、`f(auto ..., ...)`と`f(auto, ..., ...)`と同じ宣言となる）。

この提案は、これらの問題からこのようなタイプの宣言を非推奨とすることを提案するものです。

以前の提案ではこのような宣言を禁止しようとするものもありましたが、既存コードへの影響から頓挫しており、この提案では同じ轍を踏まないために単に非推奨にすることまでを提案しています。

提案より、その他の例

```cpp
void a(...);                // OK
void b(auto...);            // OK
void c(auto, ...);          // OK

void d_depr(auto......);    // deprecated
void d_okay(auto..., ...);  // OK

void e_depr(auto x...);     // deprecated
void d_okay(auto x, ...);   // OK

void f_depr(auto...x...);   // deprecated
void f_okay(auto...x, ...); // OK

void g_depr(int...);        // deprecated
void g_okay(int, ...);      // OK

void h_depr(int x...);      // deprecated
void h_okay(int x, ...);    // OK
```

- [P3176 進行状況](https://github.com/cplusplus/papers/issues/1839)

### [P3177R0 const prvalues in the conditional operator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3177r0.html)

条件演算子の型の決定において、スカラ型とクラス型で異なる結果のなるのを修正する提案。

次のようなコードにおいて

```cpp
// add_rvalue_referenceしないdeclval<T>()
template <class T>
auto make() -> T;

template <class T, class U>
using cond = decltype(true ? make<T>() : make<U>());

template <class T>
using cref = cond<T, T const&>; // この型は何になる？
```

`cref`の型は何になるでしょうか？

`T`に修飾が着いた型になるだろうということがまずわかります。片方が`const T&`なので`T&`や`T&&`ではないことが分かります（両辺を受けられないので）。したがって、`T`か`const T&`のどちらかになるであろうと予想できます。このコンテキストでprvalueな`T`が左辺値に昇格されるのは変なので、`T`になると考えることができます。

実際の結果は、スカラ型の場合は`T`になり、クラス型の場合は`const T`になります。

```cpp
cref<int> // int
cref<std::vector<int>> // const std::vector<int>
```

これは驚きの挙動であるだけでなく、有害な場合があります。

```cpp
auto get() -> T;
auto lookup() -> T const&;

T obj;
obj = flag ? get() : lookup();  // ここ
```

このコードの最後の行において、`flag`が何であれ`T`がスカラ型の場合は結局コピーなので問題はありません。クラス型の場合`flag`によって起こることが変化します。そして、この右辺の条件演算子の結果は`const T`になるわけですが、これが仮に`T`になるとした場合と比較すると非効率なことになります。

|`flag`|`const T`|`T`|
|---|---|---|
|`true`|コピー代入|ムーブ代入|
|`false`|コピー構築後コピー代入|コピー構築後ムーブ代入|

`=`の右辺の型に`const`が付いてしまうことによってこの違いが発生しています。また、これは`if (flag) { obj = get(); } else { obj = lookup(); }`のようなコードよりも効率が悪くなっています。

また、より出会いやすい所では`<ranges>`の`const_iterator`で出会うかもしれません。例えば次のようなイテレータ型があるとき

```cpp
// プロクシイテレータ型とする
template <class T>
struct Priterator {
  using value_type = T:
  auto operator*() const -> T;

  // other stuff
};
```

これを`const_iterator`に通すことを考えます。

```cpp
template<indirectly_readable It>
  using iter_const_reference_t =
    common_reference_t<const iter_value_t<It>&&, iter_reference_t<It>>;

template<class It>
  concept constant-iterator =                                                   // exposition only
    input_iterator<It> && same_as<iter_const_reference_t<It>, iter_reference_t<It>>;

template<input_iterator I>
  using const_iterator = see below;
```

[`const_iterator<I>`](https://cpprefjp.github.io/reference/iterator/const_iterator.html)は`constant-iterator`コンセプトによって`I`が既に定数イテレータであるかどうかを調べて、`std::basic_const_iterator`でラップするかどうかを決定します。そして、その決定には`common_reference_t`が使用されます。これも非常に複雑ですが、今回の場合は次のようなコードと結果が等しくなります

```cpp
template <class T>
using iter_const_reference_t = cond<iter_value_t<T> const&&, iter_reference_t<T>>;
```

`cond`は冒頭で見たものです。今回は`Priterator<T>`に対して`const<const T&&, T&>`のようになります。この場合でも結果は同じで、`T`がクラス型の場合この型は`const T`になります。

すると、`constant-iterator<Priterator<T>>`は`T`がクラス型の場合`false`になり、`const_iterator<Priterator<T>>`は`std::basic_const_iterator`でラップされます。そして、その間接参照結果型は`const T`になります。

本来間接参照結果型がprvalueな`T`の場合、`iter_const_reference_t`は単に`T`になるのが正しいふるまいです。しかし、この場合そうならず、余計な`const`がついてしまっています。

これは特殊な場合ではなく、`value_type`も`reference_type`もprvalueな`T`の場合に同じことになります。この場合に不要なラッピングが発生することも問題ですが、何より問題なのは本来ムーブできたものが出来なくなっていることが問題です。

まとめると、条件演算子の結果は`:`の左右のオペランドの組み合わせによって次のようになります

![](./wg21_paper_202404/P3177_table1.PNG)

`T | T const`となっているところは`T`がスカラ型（左）かクラス型（右）かによって結果が変わる事を表しています。これらのグループは`const T`が条件演算子の後ろ側のどちらかのオペランドにある場合（黄色）と無い場合（オレンジ）の2つのグループに分けることができます。

オレンジのグループはここで問題にしてきたもので、この場合に`const T`を生成するのは間違っています。

黄色のグループは少し質問が異なります。ここで`const T`を生成するのはユーザーの求めるものなのでしょうか？そうすることに全くメリットが無いわけではなく、ムーブセマンティクス以前は関数が`T`の代わりに`const T`を返すようにして`f() = x`のような代入を防止することが推奨されていた時代がありました。しかしこれは現在では推奨されず、代入演算子の左辺値修飾によって防止することができます。

とはいえ、`const T`という型が現れる場合が稀であるため、オレンジのグループの修正の重要度はあまり高くありません。オレンジのグループを修正することでさらに重要度が低下するでしょう。

この提案はこの問題を解決するためのものであり、そのために（主張の）弱い提案と強い提案の2つを挙げています。

弱い提案は、両方のオペランドに`const T`が現れていない場合にクラス型の`T`についての結果を`T`になるようにするものです。すなわち、先ほどのオレンジのグループだけを修正するものです。

![](./wg21_paper_202404/P3177_weak_proposal.PNG)

強い提案は、クラス型とスカラ型で結果が異ならないようにするものです。すなわち、弱い提案に加えて黄色のグループも修正するものです。

![](./wg21_paper_202404/P3177_strong_proposal.PNG)

ただし、この強い提案には一点だけ違和感があるかもしれない部分があり、`cond<const T, const T>`が`T`になる所です。スカラ型の場合は現在そうなっているのですが、これが`const T`になる方が自然な挙動かもしれません。その場合、この部分だけ現在の動作を維持するように強い提案を修正することもできます

![](./wg21_paper_202404/P3177_strong_proposal_fix.PNG)

この場合スカラ型とクラス型で異なる型を生成することになりますが、おそらく問題にはならないでしょう。

- [［C++］iter_iter_const_reference_tの型の決定について - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2023/04/30/181514)
- [P3177 進行状況](https://github.com/cplusplus/papers/issues/1840)

### [P3179R0 C+ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3179r0.html)

Rangeアルゴリズムを`ExecutionPolicy`に対応させる提案。

別の言い方をすると、並列アルゴリズムをRange化する提案です。

P2500R2では、既存の並列アルゴリズムをRange対応したうえで、さらに`scheduler`を受け取れるようにしようとするものでした。その後SG9ではこの2つの事（並列アルゴリズムをRange対応と並列アルゴリズムの`scheduler`対応）を分割して処理することになったようです。この提案は、前者の並列アルゴリズムのRange対応を担うものです。後者を担うのはおそらくP3300です。

この提案では、既存のRangeアルゴリズムに対して[標準の実行ポリシー](https://cpprefjp.github.io/reference/execution/execution/execution_policy.html)を受け取ることのできるオーバーロードを追加しようとしています。それらのものの事を、並列Rangeアルゴリズム（*parallel range algorithms*）と呼称しています。

設計の概要は次のものです

- 並列Rangeアルゴリズムは、最小限のコードの変更で使用できるようにするために、C++17の並列アルゴリズムに近いものにする
- 並列Rangeアルゴリズムは、対応するシリアル（非並列の）Rangeアルゴリズムの戻り値型と同じ戻り値型となる
- 並列Rangeアルゴリズムは、シリアルRangeアルゴリズムと同様にADLで発見されない関数である
- 並列Rangeアルゴリズムが要求する範囲及びイテレータのカテゴリは、`std::execution::seq`ポリシーの場合を除いて少なくともランダムアクセス可能である必要がある
- 並列Rangeアルゴリズムに呼び出し可能オブジェクト（述語や`for_each`の処理など）を渡す場合、`const`修飾された`operator()`が必要
- 提案しているAPIはカスタマイゼーションポイントではない
- ここで提案している並列Rangeアルゴリズムは`constexpr`ではない

この提案では特に、既存の並列アルゴリズムのRange移行、あるいは既存のRangeアルゴリズムの並列アルゴリズム移行において、コードの変更が最小になるように注意を払っています

```cpp
// 既存の並列アルゴリズムの使用
std::for_each(        std::execution::par, v.begin(), v.end(), [](auto& x) { ++x; });

// イテレータペアを使用したまま並列Rangeアルゴリズムへ移行
std::ranges::for_each(std::execution::par, v.begin(), v.end(), [](auto& x) { ++x; });

// さらに、範囲を直接渡す形に移行
std::ranges::for_each(std::execution::par, v, [](auto& x) { ++x; });
```
```cpp
// 既存のRangeアルゴリズムの利用
std::ranges::for_each(                     v, [](auto& x) { ++x; });

// 実行ポリシーを指定して並列Rangeアルゴリズムへ移行
std::ranges::for_each(std::execution::par, v, [](auto& x) { ++x; });
```

このように、並列Rangeアルゴリズムへの移行作業は名前空間名を追加するか、実行ポリシーを追加するだけで行うことができます。Rangeアルゴリズムからの移行の場合は戻り値型も同じままなので結果を利用するコードにも変更が必要ありません。

`for_each`で示すと、提案するAPIは次のようになります

```cpp
namespace std::ranges {
  // Policy-based API
  template <class ExecutionPolicy, policy-dependent-iterator I, sentinel_for<I> S,
            class Proj = identity, indirectly_unary_invocable<projected<I, Proj>> Fun>
    ranges::for_each_result<I, Fun>
      ranges::for_each(ExecutionPolicy&& policy, I first, S last, Fun f, Proj proj = {});

  template <class ExecutionPolicy, policy-dependent-range R, class Proj = identity,
           indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
    ranges::for_each_result<ranges::borrowed_iterator_t<R>, Fun>
      ranges::for_each(ExecutionPolicy&& policy, R&& r, Fun f, Proj proj = {});
}
```

- [P2500R1 C++ parallel algorithms and P2300 - ［C++］WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2500R1-C-parallel-algorithms-and-P2300)
- [P3300R0 C++ Asynchronous Parallel Algorithms - ［C++］WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3300R0-C-Asynchronous-Parallel-Algorithms)
- [P3179 進行状況](https://github.com/cplusplus/papers/issues/1815)

### [P3180R0 C+ Standard Library Ready Issues to be moved in Tokyo, Mar. 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3180r0.html)
### [P3181R0 Atomic stores and object lifetimes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3181r0.pdf)
### [P3182R0 Add pop_value methods to container adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3182r0.html)
### [P3183R0 Contract testing support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3183r0.pdf)
### [P3187R1 remove ensure_started and start_detached from P2300](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3187r1.pdf)
### [P3188R0 Proxy: A Pointer-Semantics-Based Polymorphism Library - Presentation slides for P3086R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3188r0.pdf)
### [P3189R0 Slides for LEWG presentation of P2900R6: Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3189r0.pdf)

LEWGのメンバーに向けて、P2900R6時点のContracts MVPの仕様について説明するスライド。

LEWGのメンバに向けてということで、言語機能の詳細には踏み込まずに主に標準ライブラリのAPIについての部分に詳しく触れています。

### [P3190R0 Slides for EWG presentation of D2900R7: Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3190r0.pdf)

EWGのメンバーに向けて、P2900R6時点のContracts MVPの仕様について説明するスライド。

↑のスライド資料（P3189）の完全版です。読めば現時点でのC++ Contaractsを知ることができます。

### [P3191R0 Feedback on the scalability of contract violation handlers in P2900](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3191r0.pdf)
### [P3192R0 LEWGI/SG18 Presentation of P3104R1 Bit Permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3192r0.pdf)

P3104R0で提案されている新しいビット操作ライブラリ機能の解説スライド。

おそらくLEWGのメンバに向けてプレゼンするためのものです。

- [P3104R0 Bit permutations - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3104R0-Bit-permutations)

### [P3194R0 LEWGI/SG18 Presentation of P3105R1 constexpr std::uncaught_exceptions()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3194r0.pdf)

P3105で提案されている`std::uncaught_exceptions()`の`constexpr`化について解説するスライド。

おそらくLEWGのメンバに向けてプレゼンするためのものです。

- [P3105R0 constexpr `std::uncaught_exceptions()` - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3105R0-constexpr-stduncaught_exceptions)

### [P3196R0 Core Language Working Group "ready" Issues for the March, 2024 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3196r0.html)
### [P3197R0 A response to the Tokyo EWG polls on the Contracts MVP (P2900R6)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3197r0.pdf)
### [P3198R0 A takeaway from the Tokyo LEWG meeting on Contracts MVP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3198r0.html)
### [P3199R0 Choices for make_optional and value()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3199r0.html)
### [P3201R0 LEWG [[nodiscard]] policy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3201r0.html)
### [P3201R1 LEWG [[nodiscard]] policy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3201r1.html)
### [P3203R0 Implementation defined coroutine extensions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3203r0.html)
### [P3205R0 Throwing from a `noexcept` function should be a contract violation.](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3205r0.pdf)
### [P3207R0 More & like](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3207r0.html)
### [P3208R0 import std; and stream macros](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3208r0.pdf)
### [P3210R0 A Postcondition *is* a Pattern Match](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3210r0.html)
### [P3211R0 views::transform_join](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3211r0.html)
### [P3213R0 2024-04 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3213r0.html)
### [P3215R0 Slides: Thread Attributes as Designators (P3072R2 presentation)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3215r0.pdf)
### [P3216R0 views::slice](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3216r0.html)
### [P3217R0 Adjoints to "Enabling list-initialization for algorithms": find_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3217r0.html)
### [P3218R0 const references to constexpr variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3218r0.html)
### [P3220R0 views::delimit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3220r0.html)
### [P3221R0 Disable pointers to contracted functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3221r0.pdf)
### [P3222R0 Fix C++26 by adding transposed special cases for P2642 layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3222r0.html)
### [P3223R0 Making std::basic_istream::ignore less surprising](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3223r0.html)
### [P3224R0 Slides for P3087 - Make direct-initialization for enumeration types at least as permissive as direct](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3224r0.pdf)
### [P3225R0 Slides for P3140 std::int_least128_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3225r0.pdf)
### [P3226R0 Contracts for C++: Naming the "Louis semantic"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3226r0.pdf)
### [P3228R0 Contracts for C++: Revisiting contract check elision and duplication](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3228r0.pdf)
### [P3230R0 views::(take|drop)_exactly](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3230r0.html)
### [P3232R0 User-defined erroneous behaviour](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3232r0.html)
### [P3233R0 Issues with P2786 (Trivial Relocatability For C++26)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3233r0.html)
### [P3234R0 Utility to check if a pointer is in a given range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3234r0.html)
### [P3236R0 Please reject P2786 and adopt P1144](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3236r0.html)
### [P3237R0 Matrix Representation of Contract Semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3237r0.pdf)
### [P3240R0 Slides for EWGI presentation on allocators, Tokyo 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3240r0.pdf)
### [P3241R0 Slides for LEWG presentation on trivial relocation, April 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3241r0.pdf)
### [P3242R0 Copy and fill for mdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3242r0.html)
### [P3243R0 Give std::optional Range Support - Presentation, Tokyo 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3243r0.pdf)
### [P3244R0 [[nodiscard]] Policy - Presentation, Tokyo 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3244r0.pdf)
### [P3245R0 Allow `[[nodiscard]]` in type alias declarations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3245r0.html)
### [P3247R0 Deprecate the notion of trivial types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3247r0.html)
